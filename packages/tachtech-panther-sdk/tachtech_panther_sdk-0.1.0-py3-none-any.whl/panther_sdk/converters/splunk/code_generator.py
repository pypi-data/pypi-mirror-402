"""Python Code Generator - Generates Panther detection rules from transformed SPL."""

from __future__ import annotations

import re
import textwrap
from dataclasses import dataclass, field
from typing import Any

from .analyzer import AnalysisResult, RecommendedDetectionType
from .transformer import TransformResult


@dataclass
class GeneratedRule:
    """Generated Panther rule output."""

    # The generated Python source code
    source_code: str

    # Rule metadata
    rule_id: str
    class_name: str
    log_types: list[str]
    severity: str

    # Whether this is a threshold rule
    is_threshold_rule: bool = False
    threshold: int | None = None

    # List of TODO items that need manual attention
    todos: list[str] = field(default_factory=list)

    # Unit test code (if generated)
    test_code: str | None = None

    # Detection type recommendation
    recommended_type: RecommendedDetectionType = RecommendedDetectionType.STREAMING
    recommendation_reasons: list[str] = field(default_factory=list)


class PantherCodeGenerator:
    """Generates Panther detection rule Python code."""

    def __init__(
        self, analysis: AnalysisResult, transform: TransformResult
    ) -> None:
        """
        Initialize the code generator.

        Args:
            analysis: Analysis result from SPLAnalyzer
            transform: Transform result from SPLToPythonTransformer
        """
        self.analysis = analysis
        self.transform = transform
        self.todos: list[str] = []

    def generate(
        self, rule_id: str, class_name: str | None = None
    ) -> GeneratedRule:
        """
        Generate a Panther detection rule.

        Args:
            rule_id: The rule ID (e.g., "Custom.AWS.SuspiciousActivity")
            class_name: Optional class name (derived from rule_id if not provided)

        Returns:
            GeneratedRule with source code and metadata
        """
        if not class_name:
            class_name = self._derive_class_name(rule_id)

        # Determine log types
        log_types = self._get_log_types()

        # Build the source code
        source_code = self._generate_source_code(rule_id, class_name, log_types)

        # Generate test code
        test_code = self._generate_test_code(rule_id, class_name, log_types)

        # Determine threshold
        threshold = None
        if self.analysis.threshold_pattern:
            threshold = self.analysis.threshold_pattern.threshold

        return GeneratedRule(
            source_code=source_code,
            rule_id=rule_id,
            class_name=class_name,
            log_types=log_types,
            severity=self.analysis.severity,
            is_threshold_rule=self.analysis.is_threshold_rule,
            threshold=threshold,
            todos=self.todos,
            test_code=test_code,
            recommended_type=self.analysis.recommended_type,
            recommendation_reasons=self.analysis.recommendation_reasons,
        )

    def _generate_source_code(
        self, rule_id: str, class_name: str, log_types: list[str]
    ) -> str:
        """Generate the complete Python source code."""
        parts = []

        # Module docstring with original SPL
        parts.append(self._generate_docstring())

        # Imports
        parts.append(self._generate_imports())

        # Class definition
        parts.append(self._generate_class(rule_id, class_name, log_types))

        return "\n".join(parts)

    def _generate_docstring(self) -> str:
        """Generate module docstring with original SPL."""
        spl = self.analysis.original_spl.strip()
        # Indent SPL for readability
        spl_lines = spl.split("\n")
        indented_spl = "\n    ".join(spl_lines)

        return f'''"""
Converted from Splunk SPL:
    {indented_spl}

Generated by SPL to Panther Converter.
"""
'''

    def _generate_imports(self) -> str:
        """Generate import statements."""
        imports = ["from panther_sdk.detections import Rule, Severity, LogType"]

        # Add helper imports
        helper_imports = []
        if "deep_get" in self.transform.required_imports:
            helper_imports.append("deep_get")
        if "pattern_match" in self.transform.required_imports:
            helper_imports.append("pattern_match")
        if "is_ip_in_network" in self.transform.required_imports:
            helper_imports.append("is_ip_in_network")

        if helper_imports:
            imports.append(
                f"from panther_sdk.detections import {', '.join(helper_imports)}"
            )

        # Add standard library imports
        if "re" in self.transform.required_imports:
            imports.append("import re")
        if "math" in self.transform.required_imports:
            imports.append("import math")
        if "time" in self.transform.required_imports:
            imports.append("import time")
        if "hashlib" in self.transform.required_imports:
            imports.append("import hashlib")

        return "\n".join(imports) + "\n"

    def _generate_class(
        self, rule_id: str, class_name: str, log_types: list[str]
    ) -> str:
        """Generate the rule class definition."""
        parts = []

        # Class declaration
        parts.append(f"\nclass {class_name}(Rule):")

        # Class attributes
        parts.append(f'    id = "{rule_id}"')

        # Log types
        log_type_strs = []
        for lt in log_types:
            # Try to use LogType enum if it's a known type
            enum_name = lt.replace(".", "_").upper()
            if hasattr(self, "_is_known_log_type") or lt in (
                "AWS.CloudTrail",
                "Okta.SystemLog",
                "CrowdStrike.FDREvent",
                "GitHub.Audit",
            ):
                log_type_strs.append(f'"{lt}"')
            else:
                log_type_strs.append(f'"{lt}"')

        parts.append(f"    log_types = [{', '.join(log_type_strs)}]")
        parts.append(f"    severity = Severity.{self.analysis.severity}")

        # Threshold attributes for threshold rules
        if self.analysis.threshold_pattern:
            parts.append(f"    threshold = {self.analysis.threshold_pattern.threshold}")
            parts.append(f"    dedup_period_minutes = {self.analysis.dedup_period_minutes}")

        # Add unsupported features as TODO comments
        if self.analysis.unsupported_features:
            parts.append("")
            parts.append("    # ===== TODO: Manual conversion required =====")
            for feature in self.analysis.unsupported_features:
                parts.append(f"    # {feature.feature_type.upper()}: {feature.description}")
                if feature.raw_text:
                    # Truncate long raw text
                    raw_text = feature.raw_text[:100]
                    if len(feature.raw_text) > 100:
                        raw_text += "..."
                    parts.append(f"    #   Original: {raw_text}")
                if feature.suggestion:
                    parts.append(f"    #   Suggestion: {feature.suggestion}")
                self.todos.append(f"{feature.feature_type}: {feature.description}")
            parts.append("    # =============================================")

        # Rule method
        parts.append("")
        parts.append(self._generate_rule_method())

        # Title method (if we have dedup fields or can generate a meaningful title)
        if self.transform.title_expression or self.analysis.dedup_fields:
            parts.append("")
            parts.append(self._generate_title_method())

        # Dedup method (if we have dedup fields)
        if self.transform.dedup_expression or self.analysis.dedup_fields:
            parts.append("")
            parts.append(self._generate_dedup_method())

        # Alert context method (if we have context fields)
        if self.transform.alert_context_fields:
            parts.append("")
            parts.append(self._generate_alert_context_method())

        return "\n".join(parts)

    def _generate_rule_method(self) -> str:
        """Generate the rule() method."""
        parts = ['    def rule(self, event: dict) -> bool:']

        # Add any rex extractions at the beginning
        if self.transform.rex_extractions:
            for field, pattern, var_name in self.transform.rex_extractions:
                parts.append(
                    f'        {var_name} = re.search(r"{pattern}", event.get("{field}", ""))'
                )
            parts.append("")

        # Add helper expressions (eval results)
        if self.transform.helper_expressions:
            for field_name, expr in self.transform.helper_expressions.items():
                parts.append(f"        {field_name} = {expr}")
            parts.append("")

        # Main condition
        condition = self.transform.rule_condition
        if condition == "True":
            parts.append("        # TODO: Add detection logic")
            parts.append("        return True")
        else:
            parts.append(f"        return {condition}")

        return "\n".join(parts)

    def _generate_title_method(self) -> str:
        """Generate the title() method."""
        parts = ['    def title(self, event: dict) -> str:']

        # Use the primary dedup field or title expression field
        field = self.transform.title_expression or (
            self.analysis.dedup_fields[0] if self.analysis.dedup_fields else None
        )

        if field:
            field_access = self._get_field_access_for_title(field)
            parts.append(f'        identifier = {field_access}')
            parts.append('        return f"Detection triggered for {identifier}"')
        else:
            parts.append('        return f"{self.id}"')

        return "\n".join(parts)

    def _generate_dedup_method(self) -> str:
        """Generate the dedup() method."""
        parts = ['    def dedup(self, event: dict) -> str:']

        if self.transform.dedup_expression:
            parts.append(f"        result = {self.transform.dedup_expression}")
            parts.append('        return str(result) if result else self.id')
        elif self.analysis.dedup_fields:
            # Generate dedup based on fields
            if len(self.analysis.dedup_fields) == 1:
                field = self.analysis.dedup_fields[0]
                field_access = self._get_field_access_simple(field)
                parts.append(f'        return str({field_access}) if {field_access} else self.id')
            else:
                field_parts = [
                    self._get_field_access_simple(f)
                    for f in self.analysis.dedup_fields
                ]
                parts.append(
                    f'        parts = [{", ".join(field_parts)}]'
                )
                parts.append('        return "-".join(str(p) for p in parts if p) or self.id')
        else:
            parts.append("        return self.id")

        return "\n".join(parts)

    def _generate_alert_context_method(self) -> str:
        """Generate the alert_context() method."""
        parts = ['    def alert_context(self, event: dict) -> dict:']
        parts.append("        return {")

        for field in self.transform.alert_context_fields:
            # Clean field name for dict key
            key = field.replace(".", "_")
            field_access = self._get_field_access_simple(field)
            parts.append(f'            "{key}": {field_access},')

        parts.append("        }")

        return "\n".join(parts)

    def _generate_test_code(
        self, rule_id: str, class_name: str, log_types: list[str]
    ) -> str:
        """Generate unit test code for the rule."""
        # Create a simple test template
        test_code = f'''"""Unit tests for {class_name}."""

import pytest
from .{self._to_snake_case(class_name)} import {class_name}


class Test{class_name}:
    """Test cases for {class_name}."""

    @pytest.fixture
    def rule(self):
        """Create rule instance."""
        return {class_name}()

    def test_rule_metadata(self, rule):
        """Test rule has required metadata."""
        assert rule.id == "{rule_id}"
        assert rule.log_types
        assert rule.severity

    def test_rule_matches_positive_event(self, rule):
        """Test rule matches expected event."""
        # TODO: Add a sample event that should trigger the rule
        event = {{
            # Add event fields here
        }}
        # assert rule.rule(event) is True

    def test_rule_ignores_negative_event(self, rule):
        """Test rule ignores non-matching event."""
        # TODO: Add a sample event that should NOT trigger the rule
        event = {{
            # Add event fields here
        }}
        # assert rule.rule(event) is False
'''

        return test_code

    def _get_log_types(self) -> list[str]:
        """Get the log types for the rule."""
        if self.analysis.log_type:
            return [self.analysis.log_type]

        # Default log type if none could be inferred
        self.todos.append("LOG_TYPE: Could not infer log type from SPL. Please set manually.")
        return ["Custom.Logs"]

    def _derive_class_name(self, rule_id: str) -> str:
        """Derive a class name from the rule ID."""
        # Remove prefix (e.g., "Custom.")
        parts = rule_id.split(".")
        if len(parts) > 1:
            name_parts = parts[1:]
        else:
            name_parts = parts

        # Convert to PascalCase while preserving existing camelCase
        result_parts = []
        for part in name_parts:
            # Split on - and _ but preserve existing casing
            subparts = part.replace("-", "_").split("_")
            for subpart in subparts:
                if subpart:
                    # Capitalize first letter, keep rest as-is
                    result_parts.append(subpart[0].upper() + subpart[1:])

        return "".join(result_parts)

    def _to_snake_case(self, name: str) -> str:
        """Convert PascalCase to snake_case."""
        # Insert underscore before uppercase letters
        s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
        return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()

    def _get_field_access_simple(self, field: str) -> str:
        """Get simple field access code."""
        if "." in field:
            return f'deep_get(event, "{field}")'
        return f'event.get("{field}")'

    def _get_field_access_for_title(self, field: str) -> str:
        """Get field access code with default for title."""
        if "." in field:
            return f'deep_get(event, "{field}", "Unknown")'
        return f'event.get("{field}", "Unknown")'
