"""Interactive TUI for building .gitignore files."""

from __future__ import annotations

import platform
import subprocess
from dataclasses import dataclass, field
from pathlib import Path

from prompt_toolkit import Application
from prompt_toolkit.data_structures import Point
from prompt_toolkit.filters import Condition
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.layout import Layout
from prompt_toolkit.layout.containers import (
    ConditionalContainer,
    HSplit,
    VSplit,
    Window,
    WindowAlign,
)
from prompt_toolkit.layout.controls import FormattedTextControl
from prompt_toolkit.layout.dimension import Dimension
from prompt_toolkit.styles import Style

from gno.templates import TemplateData, TemplateManager


@dataclass
class GnoApp:
    """Main TUI application state."""

    all_templates: list[TemplateData] = field(default_factory=list)
    filtered_templates: list[TemplateData] = field(default_factory=list)
    selected_templates: set[str] = field(default_factory=set)
    current_index: int = 0
    search_text: str = ""
    search_active: bool = False
    show_help: bool = False
    output_path: str = ".gitignore"
    message: str = ""
    preview_scroll: int = 0
    confirm_quit: bool = False
    focus_preview: bool = False
    _app: Application | None = None

    def load_templates(self) -> bool:
        """Load templates from the TemplateManager."""
        manager = TemplateManager()
        if not manager.ensure_templates():
            return False
        self.all_templates = manager.get_all_templates()
        self.filtered_templates = self.all_templates.copy()
        return True

    def toggle_selection(self) -> None:
        """Toggle selection of the current template."""
        self.confirm_quit = False
        if not self.filtered_templates:
            return
        name = self.filtered_templates[self.current_index]["name"]
        if name in self.selected_templates:
            self.selected_templates.discard(name)
        else:
            self.selected_templates.add(name)
        self.preview_scroll = 0

    def move_cursor(self, delta: int) -> None:
        """Move the cursor up or down."""
        self.confirm_quit = False
        if not self.filtered_templates:
            return
        self.current_index = max(
            0, min(len(self.filtered_templates) - 1, self.current_index + delta)
        )

    def filter_templates(self, query: str) -> None:
        """Filter templates by search query."""
        self.search_text = query
        q = query.lower()
        if not query:
            self.filtered_templates = self.all_templates.copy()
        else:
            self.filtered_templates = [
                t for t in self.all_templates if q in t["name"].lower()
            ]
        self.current_index = 0

    def _dedupe_content(self, content: str, seen: set[str]) -> str:
        """Remove duplicate patterns from content, tracking in seen set."""
        lines = []
        for line in content.strip().splitlines():
            stripped = line.strip()
            if not stripped or stripped.startswith("#") or stripped not in seen:
                if stripped and not stripped.startswith("#"):
                    seen.add(stripped)
                lines.append(line)
        return "\n".join(lines)

    def get_preview(self) -> str:
        """Get the combined .gitignore content for selected templates."""
        if not self.selected_templates:
            return "# No templates selected\n# Use Space to select templates"

        seen: set[str] = set()
        sections = []
        for t in self.all_templates:
            if t["name"] in self.selected_templates:
                content = self._dedupe_content(t["content"], seen)
                section = f"# {t['name']}\n# {t['description']}\n\n{content}"
                sections.append(section)

        header = "# Generated by gno (https://github.com/OseSem/gno)\n"
        header += f"# Templates: {', '.join(sorted(self.selected_templates))}\n\n"
        return header + "\n\n".join(sections)

    def save(self) -> bool:
        """Save the .gitignore file."""
        if not self.selected_templates:
            self.message = "No templates selected!"
            return False
        output = Path(self.output_path)
        output.parent.mkdir(parents=True, exist_ok=True)
        output.write_text(self.get_preview() + "\n", encoding="utf-8")
        self.message = f"Saved to {self.output_path}"
        return True

    def exit(self) -> None:
        """Exit the application."""
        if self._app:
            self._app.exit()

    def get_preview_line_count(self) -> int:
        """Get the number of lines in the preview content."""
        return len(self.get_preview().splitlines())


def create_kb(state: GnoApp) -> KeyBindings:
    """Create key bindings for the TUI."""
    kb = KeyBindings()

    normal = Condition(lambda: not state.search_active and not state.show_help)
    list_focus = Condition(lambda: normal() and not state.focus_preview)
    preview_focus = Condition(lambda: normal() and state.focus_preview)
    search = Condition(lambda: state.search_active)
    help_mode = Condition(lambda: state.show_help)

    @kb.add("tab", filter=normal)
    def _tab(e):
        state.focus_preview = not state.focus_preview
        state.confirm_quit = False

    @kb.add("up", filter=list_focus)
    @kb.add("k", filter=list_focus)
    def _up(e):
        state.move_cursor(-1)

    @kb.add("down", filter=list_focus)
    @kb.add("j", filter=list_focus)
    def _down(e):
        state.move_cursor(1)

    @kb.add("up", filter=preview_focus)
    @kb.add("k", filter=preview_focus)
    def _preview_up_arrow(e):
        state.preview_scroll = max(0, state.preview_scroll - 1)

    @kb.add("down", filter=preview_focus)
    @kb.add("j", filter=preview_focus)
    def _preview_down_arrow(e):
        max_scroll = max(0, state.get_preview_line_count() - 5)
        state.preview_scroll = min(state.preview_scroll + 1, max_scroll)

    @kb.add("pageup", filter=list_focus)
    def _pgup(e):
        state.move_cursor(-10)

    @kb.add("pagedown", filter=list_focus)
    def _pgdn(e):
        state.move_cursor(10)

    @kb.add("home", filter=normal)
    @kb.add("g", filter=normal)
    def _home(e):
        state.current_index = 0

    @kb.add("end", filter=normal)
    @kb.add("G", filter=normal)
    def _end(e):
        if state.filtered_templates:
            state.current_index = len(state.filtered_templates) - 1

    @kb.add("space", filter=normal)
    @kb.add("enter", filter=normal)
    def _toggle(e):
        state.toggle_selection()

    @kb.add("s", filter=normal)
    def _save(e):
        if state.save():
            state.exit()

    @kb.add("q", filter=normal)
    def _quit(e):
        if state.selected_templates and not state.confirm_quit:
            state.confirm_quit = True
            state.message = "Press q again to quit without saving"
        else:
            state.exit()

    @kb.add("c-c")
    def _force_quit(e):
        state.exit()

    @kb.add("escape")
    def _esc(e):
        if state.search_active:
            state.search_active = False
            state.filter_templates("")
        elif state.show_help:
            state.show_help = False
        else:
            state.exit()

    @kb.add("?", filter=normal)
    def _help(e):
        state.show_help = True

    @kb.add("<any>", filter=help_mode)
    def _close_help(e):
        state.show_help = False

    @kb.add("/", filter=normal)
    def _search(e):
        state.search_active = True
        state.search_text = ""
        state.message = ""

    @kb.add("enter", filter=search)
    def _confirm_search(e):
        state.search_active = False

    @kb.add("backspace", filter=search)
    def _backspace(e):
        if state.search_text:
            state.search_text = state.search_text[:-1]
            state.filter_templates(state.search_text)

    @kb.add("<any>", filter=search)
    def _char(e):
        if e.data.isprintable() and len(e.data) == 1:
            state.search_text += e.data
            state.filter_templates(state.search_text)

    @kb.add("c-d", filter=normal)
    def _preview_down(e):
        max_scroll = max(0, state.get_preview_line_count() - 5)
        state.preview_scroll = min(state.preview_scroll + 5, max_scroll)

    @kb.add("c-u", filter=normal)
    def _preview_up(e):
        state.preview_scroll = max(0, state.preview_scroll - 5)

    @kb.add("c-a", filter=normal)
    def _select_all(e):
        for t in state.filtered_templates:
            state.selected_templates.add(t["name"])
        state.preview_scroll = 0
        state.message = f"Selected {len(state.filtered_templates)} templates"

    @kb.add("c-x", filter=normal)
    def _clear_all(e):
        state.selected_templates.clear()
        state.preview_scroll = 0
        state.message = "Cleared all selections"

    @kb.add("c", filter=normal)
    def _copy_to_clipboard(e):
        if not state.selected_templates:
            state.message = "Nothing to copy"
            return
        content = state.get_preview()
        try:
            system = platform.system()
            if system == "Windows":
                subprocess.run(["clip.exe"], input=content.encode("utf-8"), check=True)
            elif system == "Darwin":
                subprocess.run(["pbcopy"], input=content.encode("utf-8"), check=True)
            else:
                subprocess.run(
                    ["xclip", "-selection", "clipboard"],
                    input=content.encode("utf-8"),
                    check=True,
                )
            state.message = "Copied to clipboard!"
        except (subprocess.SubprocessError, FileNotFoundError):
            state.message = "Failed to copy (clipboard tool not found)"

    return kb


def get_list_text(state: GnoApp) -> list[tuple[str, str]]:
    """Generate formatted text for the template list."""
    result: list[tuple[str, str]] = []

    # Header
    count = len(state.filtered_templates)
    total = len(state.all_templates)
    selected = len(state.selected_templates)

    header_style = "class:header" if state.focus_preview else "class:header-focused"
    result.append((header_style, " Templates"))
    if state.search_text:
        result.append(("class:search-info", f" ({count}/{total})"))
    else:
        result.append(("class:search-info", f" ({total})"))
    if selected:
        result.append(("class:selected-count", f" [{selected} selected]"))
    result.append(("", "\n"))

    # Search bar
    if state.search_active:
        result.append(("class:search-prompt", " / "))
        result.append(("class:search-text", state.search_text))
        result.append(("class:cursor-blink", "_"))
        result.append(("", "\n"))
    elif state.search_text:
        result.append(("class:search-filter", f" Filter: {state.search_text}\n"))

    result.append(("class:separator", " " + "-" * 35 + "\n"))

    # List
    for i, t in enumerate(state.filtered_templates):
        is_current = i == state.current_index
        is_selected = t["name"] in state.selected_templates

        result.append(("class:cursor", " > ") if is_current else ("", "   "))
        result.append(
            ("class:checkbox-selected", "[x] ")
            if is_selected
            else ("class:checkbox", "[ ] ")
        )
        result.append(
            ("class:template-selected", t["name"])
            if is_selected
            else ("class:template", t["name"])
        )
        result.append(("", "\n"))

    if not state.filtered_templates:
        result.append(("class:no-results", "   No templates found\n"))

    return result


def get_preview_text(state: GnoApp) -> list[tuple[str, str]]:
    """Generate formatted text for the preview pane."""
    result: list[tuple[str, str]] = []

    header_style = "class:header-focused" if state.focus_preview else "class:header"
    result.append((header_style, " Preview"))
    if state.selected_templates:
        num_templates = len(state.selected_templates)
        patterns = sum(
            1
            for t in state.all_templates
            if t["name"] in state.selected_templates
            for line in t["content"].splitlines()
            if line.strip() and not line.strip().startswith("#")
        )
        result.append(
            (
                "class:pattern-count",
                f" ({num_templates} templates, {patterns} patterns)",
            )
        )
    if state.preview_scroll > 0:
        result.append(("class:search-info", f" [scroll: {state.preview_scroll}]"))
    result.append(("", "\n"))
    result.append(("class:separator", " " + "-" * 35 + "\n"))

    lines = state.get_preview().splitlines()
    visible_lines = lines[state.preview_scroll :]
    for line in visible_lines:
        if line.startswith("# Generated") or line.startswith("# Templates:"):
            result.append(("class:preview-meta", f" {line}\n"))
        elif line.startswith("# "):
            result.append(("class:preview-header", f" {line}\n"))
        elif line.startswith("#"):
            result.append(("class:preview-comment", f" {line}\n"))
        elif line.strip():
            result.append(("class:preview-pattern", f" {line}\n"))
        else:
            result.append(("", " \n"))

    return result


def get_footer_text(state: GnoApp) -> list[tuple[str, str]]:
    """Generate formatted text for the footer."""
    result: list[tuple[str, str]] = []
    result.append(("class:separator", "-" * 80 + "\n"))

    if state.message:
        result.append(("class:message", f" {state.message}  "))

    if state.search_active:
        result.append(("class:help", " [Enter] Confirm  [Esc] Cancel"))
    elif state.show_help:
        result.append(("class:help", " Press any key to close help"))
    else:
        result.append(("class:output-path", f" {state.output_path} "))
        result.append(
            (
                "class:help",
                "| [/] Search  [Space] Toggle  [^A] All  "
                "[^X] Clear  [c] Copy  [s] Save  [q] Quit",
            )
        )

    return result


def get_help_text() -> list[tuple[str, str]]:
    """Generate formatted text for the help screen."""
    result: list[tuple[str, str]] = []

    result.append(("class:header", "\n  gno - Interactive .gitignore Builder\n\n"))
    result.append(("class:separator", "  " + "-" * 40 + "\n\n"))

    sections = [
        (
            "Navigation",
            [
                ("Up/Down, j/k", "Move cursor"),
                ("PgUp/PgDn", "Move 10"),
                ("g/G", "First/last"),
                ("Tab", "Switch pane focus"),
            ],
        ),
        (
            "Selection",
            [
                ("Space/Enter", "Toggle selection"),
                ("Ctrl+A", "Select all visible"),
                ("Ctrl+X", "Clear all"),
            ],
        ),
        ("Preview", [("Ctrl+D/U", "Scroll down/up"), ("j/k", "Scroll (when focused)")]),
        ("Search", [("/", "Search"), ("Enter", "Confirm"), ("Esc", "Cancel")]),
        (
            "Actions",
            [
                ("c", "Copy to clipboard"),
                ("s", "Save and exit"),
                ("q", "Quit"),
                ("?", "Help"),
            ],
        ),
    ]

    for name, items in sections:
        result.append(("class:help-section", f"  {name}\n"))
        for key, desc in items:
            result.append(("class:help-key", f"    {key:<12}"))
            result.append(("class:help-desc", f"{desc}\n"))
        result.append(("", "\n"))

    result.append(("class:separator", "  " + "-" * 40 + "\n"))
    result.append(("class:help-footer", "\n  Press any key to close\n"))

    return result


def run_tui(output: str = ".gitignore") -> bool:
    """Run the interactive TUI."""
    state = GnoApp(output_path=output)

    if not state.load_templates():
        import click

        click.secho(
            "Failed to load templates. Run 'gno update' first.", fg="red", err=True
        )
        return False

    kb = create_kb(state)

    style = Style.from_dict(
        {
            "header": "bold cyan",
            "search-info": "gray",
            "selected-count": "bold green",
            "separator": "gray",
            "cursor": "bold yellow",
            "checkbox": "gray",
            "checkbox-selected": "bold green",
            "template": "",
            "template-selected": "bold green",
            "message": "bold yellow",
            "help": "gray",
            "search-prompt": "bold cyan",
            "search-text": "bold",
            "search-filter": "cyan",
            "cursor-blink": "blink",
            "no-results": "italic gray",
            "pattern-count": "gray",
            "preview-header": "bold green",
            "preview-meta": "cyan",
            "preview-comment": "gray",
            "preview-pattern": "",
            "border": "gray",
            "help-section": "bold cyan",
            "help-key": "bold yellow",
            "help-desc": "",
            "help-footer": "italic gray",
            "output-path": "bold cyan",
            "header-focused": "bold yellow underline",
        }
    )

    def get_cursor_position():
        lines = 2
        if state.search_active or state.search_text:
            lines += 1
        return Point(x=0, y=lines + state.current_index)

    left = Window(
        FormattedTextControl(
            lambda: get_list_text(state),
            get_cursor_position=get_cursor_position,
            show_cursor=False,
        ),
        wrap_lines=False,
        width=Dimension(min=30, preferred=40, max=50),
    )

    border = Window(
        FormattedTextControl(lambda: [("class:border", " | \n" * 100)]),
        width=Dimension.exact(3),
    )

    right = Window(
        FormattedTextControl(lambda: get_preview_text(state)),
        wrap_lines=True,
    )

    footer = Window(
        FormattedTextControl(lambda: get_footer_text(state)),
        height=Dimension.exact(2),
        align=WindowAlign.LEFT,
    )

    help_pane = Window(FormattedTextControl(get_help_text), wrap_lines=False)

    show_main = Condition(lambda: not state.show_help)
    show_help = Condition(lambda: state.show_help)

    layout = Layout(
        HSplit(
            [
                ConditionalContainer(VSplit([left, border, right]), filter=show_main),
                ConditionalContainer(help_pane, filter=show_help),
                footer,
            ]
        )
    )

    app = Application(
        layout=layout,
        key_bindings=kb,
        style=style,
        full_screen=True,
        mouse_support=True,
    )
    state._app = app
    app.run()

    return bool(state.selected_templates) and Path(state.output_path).exists()
