from pathlib import Path
import os
import sys
import time
import click
import yaml
from dotenv import load_dotenv
from sqlalchemy import create_engine, inspect, text

MODELS_FILE = Path.cwd() / "bmdb" / "models" / "models.bmdb"  # Always use absolute path
OUT_DIR = Path.cwd() / "bmdb" / "models" / "generated"  # Always use absolute path

@click.group()
def main():
    """BMDB - minimal schema manager"""
    pass

def load_models():
    """Load models from models.bmdb file in current directory"""
    # Ensure the directory exists
    MODELS_FILE.parent.mkdir(parents=True, exist_ok=True)
    
    if not MODELS_FILE.exists():
        return {"models": {}}
    with open(MODELS_FILE, "r", encoding="utf-8") as f:
        return yaml.safe_load(f) or {"models": {}}

def save_models(data):
    """Save models to models.bmdb file in current directory"""
    # Ensure the directory exists
    MODELS_FILE.parent.mkdir(parents=True, exist_ok=True)
    
    with open(MODELS_FILE, "w", encoding="utf-8") as f:
        yaml.safe_dump(data, f, sort_keys=False, allow_unicode=True)

def generate_models():
    """Generate Python models from models.bmdb"""
    # First, try to find .env in current directory
    env_path = Path.cwd() / ".env"
    if env_path.exists():
        load_dotenv(dotenv_path=env_path)
    else:
        load_dotenv()  # Try default location
    
    db_url = os.getenv("DB_CONNECTION")
    if not db_url:
        print(f"Error: DB_CONNECTION missing in .env file at {env_path}")
        return

    data = load_models()
    if not data.get("models"):
        print("No models found in models.bmdb")
        return

    # Create output directory
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    click.echo(f"Generating models to: {OUT_DIR}")

    # Generate models with CRUD methods
    code = [
        "# -*- coding: utf-8 -*-",
        "# Generated by BMDB - DO NOT EDIT MANUALLY",
        "# " + "="*70,
        "",
        "from sqlalchemy import Column, Integer, String, Text, Float, Boolean, Date, DateTime, ForeignKey, create_engine",
        "from sqlalchemy.orm import declarative_base, sessionmaker, Session",
        "from sqlalchemy.orm import relationship",
        "import os",
        "from dotenv import load_dotenv",
        "from pathlib import Path",
        "",
        "Base = declarative_base()",
        "",
        "# Load DB connection from .env at runtime",
        "# Try to find .env in current directory first",
        "env_path = Path.cwd() / '.env'",
        "if env_path.exists():",
        "    load_dotenv(dotenv_path=env_path)",
        "else:",
        "    load_dotenv()",
        "",
        "DB_URL = os.getenv('DB_CONNECTION', '').strip('\"')",
        "engine = create_engine(DB_URL, echo=False) if DB_URL else None",
        "SessionLocal = sessionmaker(bind=engine) if engine else None",
        "",
        "class ModelMixin:",
        "    '''Mixin to add CRUD methods to models'''",
        "    ",
        "    def save(self):",
        "        '''Create or update this instance'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            session.add(self)",
        "            session.commit()",
        "            session.refresh(self)",
        "            return self",
        "        except Exception as e:",
        "            session.rollback()",
        "            raise e",
        "        finally:",
        "            session.close()",
        "    ",
        "    def delete(self):",
        "        '''Delete this instance'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            session.delete(self)",
        "            session.commit()",
        "            return True",
        "        except Exception as e:",
        "            session.rollback()",
        "            raise e",
        "        finally:",
        "            session.close()",
        "    ",
        "    @classmethod",
        "    def get(cls, id):",
        "        '''Get record by ID'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            return session.query(cls).filter(cls.id == id).first()",
        "        finally:",
        "            session.close()",
        "    ",
        "    @classmethod",
        "    def all(cls):",
        "        '''Get all records'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            return session.query(cls).all()",
        "        finally:",
        "            session.close()",
        "    ",
        "    @classmethod",
        "    def filter(cls, **kwargs):",
        "        '''Filter records by field values'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            query = session.query(cls)",
        "            for key, value in kwargs.items():",
        "                if hasattr(cls, key):",
        "                    query = query.filter(getattr(cls, key) == value)",
        "            return query.all()",
        "        finally:",
        "            session.close()",
        "    ",
        "    @classmethod",
        "    def first(cls, **kwargs):",
        "        '''Get first record matching filters'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            query = session.query(cls)",
        "            for key, value in kwargs.items():",
        "                if hasattr(cls, key):",
        "                    query = query.filter(getattr(cls, key) == value)",
        "            return query.first()",
        "        finally:",
        "            session.close()",
        "    ",
        "    @classmethod",
        "    def count(cls, **kwargs):",
        "        '''Count records matching filters'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            query = session.query(cls)",
        "            for key, value in kwargs.items():",
        "                if hasattr(cls, key):",
        "                    query = query.filter(getattr(cls, key) == value)",
        "            return query.count()",
        "        finally:",
        "            session.close()",
        "    ",
        "    def to_dict(self):",
        "        '''Convert model instance to dictionary'''",
        "        result = {}",
        "        for column in self.__table__.columns:",
        "            result[column.name] = getattr(self, column.name)",
        "        return result",
        "",
    ]

    type_map = {
        "String": "String",
        "Text": "Text",
        "Int": "Integer",
        "Integer": "Integer",
        "Float": "Float",
        "Boolean": "Boolean",
        "Date": "Date",
        "DateTime": "DateTime",
        "JSON": "JSON"
    }

    # Generate model classes
    for m_name, m_data in data["models"].items():
        code.append(f"class {m_name}(Base, ModelMixin):")
        code.append(f'    __tablename__ = "{m_name.lower()}s"')
        code.append("    id = Column(Integer, primary_key=True, autoincrement=True)")
        for f_name, f_type in m_data.get("fields", {}).items():
            base_type = f_type.split()[0].strip()
            col_type = type_map.get(base_type, "String")
            # Check for unique constraint
            if "@unique" in f_type:
                code.append(f"    {f_name} = Column({col_type}, unique=True)  # {f_type}")
            else:
                code.append(f"    {f_name} = Column({col_type})  # {f_type}")
        code.append("")

    # Write models.py
    models_py_path = OUT_DIR / "models.py"
    models_py_path.write_text("\n".join(code), encoding="utf-8")
    
    # Write __init__.py
    init_py_path = OUT_DIR / "__init__.py"
    init_py_content = '''"""
Generated models package.
"""
from .models import Base, ModelMixin
'''
    init_py_path.write_text(init_py_content, encoding="utf-8")

    # Write migrate.py
    migrate_code = [
        "# -*- coding: utf-8 -*-",
        "# migrate.py - run manually or use bmdb migrate",
        "from .models import Base, engine",
        "",
        "if engine:",
        "    Base.metadata.create_all(engine)",
        "    print('Tables created')",
        "else:",
        "    print('Error: DB_CONNECTION not set')"
    ]
    (OUT_DIR / "migrate.py").write_text("\n".join(migrate_code), encoding="utf-8")

    click.echo(f"‚úì Generated models to: {OUT_DIR}")
    click.echo(f"‚úì Main models file: {models_py_path}")

@main.command("create-model")
@click.argument("name")
def create_model(name):
    """Create a new model"""
    data = load_models()
    if name in data["models"]:
        click.echo(f"‚úó Model '{name}' already exists")
        return
    data["models"][name] = {"fields": {}}
    save_models(data)
    click.echo(f"‚úì Model '{name}' created in {MODELS_FILE}")

@main.command("add-fields")
@click.argument("model")
@click.argument("fields", nargs=-1)
@click.option("--unique", multiple=True)
def add_fields(model, fields, unique):
    """Add fields to a model"""
    if len(fields) % 2 != 0:
        click.echo("‚úó Fields must come in name-type pairs (e.g., 'name String age Integer')")
        return
    data = load_models()
    if model not in data["models"]:
        click.echo(f"‚úó Model '{model}' not found. Create it first with 'bmdb create-model {model}'")
        return
    uniques = set(unique)
    for i in range(0, len(fields), 2):
        fname = fields[i]
        ftype = fields[i+1]
        defn = ftype + (" @unique" if fname in uniques else "")
        data["models"][model]["fields"][fname] = defn
    save_models(data)
    click.echo(f"‚úì Fields added to model '{model}'")
    click.echo(f"  Updated {MODELS_FILE}")

@main.command("generate")
def generate():
    """Generate Python models from models.bmdb"""
    click.echo(f"Current directory: {Path.cwd()}")
    click.echo(f"Looking for models.bmdb at: {MODELS_FILE}")
    generate_models()

@main.command("migrate")
@click.option("--safe", is_flag=True, help="Safe mode (won't drop columns)")
@click.option("--dry-run", is_flag=True, help="Show what would change without applying")
def migrate_schema(safe, dry_run):
    """Update existing database schema to match models (add/modify columns)"""
    try:
        load_dotenv()
        db_url = os.getenv("DB_CONNECTION", "").strip('"')
        if not db_url:
            click.echo("‚úó Error: DB_CONNECTION not found in .env")
            return
        
        # Import models
        models_path = OUT_DIR / "models.py"
        if not models_path.exists():
            click.echo("‚úó Generated models not found. Run 'bmdb generate' first.")
            return
        
        import importlib.util
        spec = importlib.util.spec_from_file_location("generated_models", str(models_path))
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        Base = module.Base
        
        engine = create_engine(db_url)
        inspector = inspect(engine)
        
        click.echo("üîç Analyzing database schema...")
        
        changes = []
        
        for table_name, table in Base.metadata.tables.items():
            if table_name not in inspector.get_table_names():
                changes.append(f"‚ûï CREATE TABLE {table_name}")
                continue
            
            existing_columns = {col['name']: col for col in inspector.get_columns(table_name)}
            model_columns = {col.name: col for col in table.columns}
            
            # Check for new columns
            for col_name, model_col in model_columns.items():
                if col_name not in existing_columns:
                    col_type = str(model_col.type)
                    changes.append(f"  ‚ûï ADD COLUMN {table_name}.{col_name} ({col_type})")
            
            # Check for type changes
            for col_name, model_col in model_columns.items():
                if col_name in existing_columns:
                    existing_type = str(existing_columns[col_name]['type'])
                    model_type = str(model_col.type)
                    if existing_type != model_type:
                        changes.append(f"  üîÑ MODIFY {table_name}.{col_name} ({existing_type} ‚Üí {model_type})")
            
            # Check for columns to drop
            if not safe:
                for col_name in existing_columns.keys():
                    if col_name not in model_columns:
                        changes.append(f"  üóëÔ∏è  DROP COLUMN {table_name}.{col_name}")
        
        if not changes:
            click.echo("‚úÖ Database schema is already up to date!")
            return
        
        click.echo("\nüìã Proposed changes:")
        for change in changes:
            click.echo(f"  {change}")
        
        if dry_run:
            click.echo("\n‚úÖ Dry run complete - no changes were made.")
            return
        
        if changes and click.confirm("\nApply these changes to the database?"):
            # Apply changes
            with engine.begin() as conn:
                for table_name, table in Base.metadata.tables.items():
                    if table_name not in inspector.get_table_names():
                        table.create(conn)
                        click.echo(f"‚úÖ Created table: {table_name}")
                        continue
                    
                    # Handle column changes
                    existing_columns = {col['name']: col for col in inspector.get_columns(table_name)}
                    model_columns = {col.name: col for col in table.columns}
                    
                    # Add new columns
                    for col_name, model_col in model_columns.items():
                        if col_name not in existing_columns:
                            col_type = model_col.type.compile(engine.dialect)
                            sql = f"ALTER TABLE {table_name} ADD COLUMN {col_name} {col_type}"
                            conn.execute(text(sql))
                            click.echo(f"‚úÖ Added column: {table_name}.{col_name}")

                    for col_name in existing_columns:
                        if col_name not in model_columns and not safe:
                            sql = f"ALTER TABLE {table_name} DROP COLUMN {col_name}"
                            conn.execute(text(sql))
                            click.echo(f"‚úÖ Dropped column: {table_name}.{col_name}")

                    # For type changes (very basic ‚Äì only works for some databases)
                    for col_name, model_col in model_columns.items():
                        if col_name in existing_columns:
                            existing_type = str(existing_columns[col_name]['type'])
                            model_type = str(model_col.type.compile(engine.dialect))
                            if existing_type != model_type:
                                if "postgresql" in db_url.lower():
                                    sql = f"ALTER TABLE {table_name} ALTER COLUMN {col_name} TYPE {model_type}"
                                    conn.execute(text(sql))

                                elif "mysql" in db_url.lower() or "mariadb" in db_url.lower():
                                    sql = f"ALTER TABLE {table_name} MODIFY COLUMN {col_name} {model_type}"
                                    conn.execute(text(sql))

                                elif "sqlite" in db_url.lower():
                                    click.echo(f"SQLite: recreating table {table_name} to change {col_name} type")

                                    temp_table = f"{table_name}_temp_{int(time.time())}"

                                    # Create temp table with new schema
                                    temp_table_obj = Base.metadata.tables[table_name].to_metadata(
                                        Base.metadata, name=temp_table
                                    )
                                    temp_table_obj.create(conn)

                                    # Copy data
                                    columns = ", ".join(c.name for c in Base.metadata.tables[table_name].columns)
                                    conn.execute(text(
                                        f"INSERT INTO {temp_table} ({columns}) SELECT {columns} FROM {table_name}"
                                    ))

                                    # Drop old ‚Üí rename new
                                    conn.execute(text(f"DROP TABLE {table_name}"))
                                    conn.execute(text(f"ALTER TABLE {temp_table} RENAME TO {table_name}"))

                                else:
                                    click.echo("‚úó Type change not supported for this database")
                                    continue

                                click.echo(f"‚úÖ Modified column: {table_name}.{col_name}")
        
        click.echo("\n‚úÖ Schema migration completed!")
        
    except Exception as e:
        click.echo(f"‚úó Migration failed: {e}")
        import traceback
        traceback.print_exc()

@main.command("list-models")
def list_models():
    """List all defined models"""
    data = load_models()
    if not data.get("models"):
        click.echo("No models defined in models.bmdb")
        return
    
    click.echo(f"Models defined in {MODELS_FILE}:")
    click.echo("=" * 50)
    for model_name, model_data in data["models"].items():
        click.echo(f"\nüìã {model_name}:")
        fields = model_data.get("fields", {})
        if fields:
            for field_name, field_type in fields.items():
                click.echo(f"  ‚îú‚îÄ {field_name}: {field_type}")
        else:
            click.echo("  ‚îî‚îÄ (no fields defined yet)")

@main.command("init")
def init():
    """Initialize a new BMDB project"""
    current_dir = Path.cwd()
    click.echo(f"Initializing BMDB project in: {current_dir}")
    
    # Create project structure FIRST
    project_structure = [
        current_dir / "bmdb",
        current_dir / "bmdb" / "models",
        current_dir / "bmdb" / "models" / "generated",
    ]
    
    for folder in project_structure:
        folder.mkdir(parents=True, exist_ok=True)
        click.echo(f"‚úì Created directory: {folder}")
    
    # NOW create models.bmdb if not exists
    if MODELS_FILE.exists():
        click.echo(f"‚úì {MODELS_FILE} already exists")
    else:
        save_models({"models": {}})
        click.echo(f"‚úì Created {MODELS_FILE}")
    
    # Create .env.example if not exists
    env_example = current_dir / ".env.example"
    if not env_example.exists():
        with open(env_example, "w") as f:
            f.write("# Database connection\n")
            f.write("# Copy this file to .env and edit with your credentials\n")
            f.write("DB_CONNECTION=postgresql://username:password@localhost:5432/database_name\n")
            f.write("\n# SQLite example:\n")
            f.write("# DB_CONNECTION=sqlite:///database.db\n")
        click.echo(f"‚úì Created {env_example}")
    
    click.echo("\n" + "="*50)
    click.echo("‚úÖ Project initialized successfully!")
    click.echo("\nNext steps:")
    click.echo("1. Copy .env.example to .env and edit with your database details")
    click.echo("2. Create your first model: bmdb create-model User")
    click.echo("3. Add fields: bmdb add-fields User name String email String --unique email")
    click.echo("4. Generate models: bmdb generate")
    click.echo("5. Migrate database: bmdb migrate-schema")
    click.echo("\nFor help: bmdb --help")

@main.command("where")
def where():
    """Show current paths and locations"""
    click.echo("üìÅ Current paths:")
    click.echo(f"  Current directory: {Path.cwd()}")
    click.echo(f"  MODELS_FILE: {MODELS_FILE}")
    click.echo(f"  OUT_DIR: {OUT_DIR}")
    click.echo(f"  Python executable: {sys.executable}")
    click.echo(f"  Python path: {sys.path[:3]}")

if __name__ == "__main__":
    main()