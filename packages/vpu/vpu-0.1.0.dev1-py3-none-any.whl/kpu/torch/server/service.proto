syntax = "proto3";

package kpu.torch;

// Tensor management service for KPU PyTorch backend
service Service {
  // Tensor lifecycle management
  rpc CreateTensor(CreateTensorRequest) returns (CreateTensorResponse);
  rpc UpdateTensor(stream TensorChunk) returns (TensorResponse);
  rpc GetStorageData(GetStorageDataRequest) returns (stream TensorChunk);
  rpc CopyTensor(CopyTensorRequest) returns (TensorResponse);

  // ATen operation execution
  rpc ExecuteAtenOperation(ExecuteAtenRequest) returns (ExecuteAtenResponse);
}

// Represents a chunk of serialized tensor data
message TensorChunk {
  // Unique identifier for the tensor (used to group chunks)
  int64 tensor_id = 1;

  // Chunk sequence number (for ordering)
  uint32 chunk_number = 2;

  // Binary data chunk
  bytes data = 3;

  // Total number of chunks for this tensor (set in first chunk)
  uint32 total_chunks = 4;

  // Indicates if this is the last chunk
  bool is_last = 5;

  // Optional metadata (shape, dtype, etc.) - included in first chunk
  map<string, string> metadata = 6;
}

// Response after receiving tensors
message TensorResponse {
  bool success = 1;
  string message = 2;
  repeated string received_tensor_ids = 3;
}

// Request to create a tensor on the server
message CreateTensorRequest {
  int64 tensor_id = 1;
  repeated int64 shape = 2;
  string dtype = 3;
  int64 nbytes = 4;
  string device_type = 5;
  repeated int64 stride = 6;
  int64 storage_offset = 7;
  int32 device_index = 8;
}

// Response after creating a tensor
message CreateTensorResponse {
  bool success = 1;
  string message = 2;
  int64 tensor_id = 3;
}

// Request to get tensor data from storage
message GetStorageDataRequest {
  int64 tensor_id = 1;
  repeated int64 shape = 2;
  string dtype = 3;
  repeated int64 stride = 4;
  int64 storage_offset = 5;
}

// Request to copy tensor data on the server
message CopyTensorRequest {
  int64 src_tensor_id = 1;
  int64 dst_tensor_id = 2;
  int64 src_offset = 3;
  int64 dst_offset = 4;
  int64 num_bytes = 5;
}

// Reference to a tensor on the server
message TensorReference {
  int64 tensor_id = 1;
  repeated int64 shape = 2;
  string dtype = 3;
  int64 nbytes = 4;
  string device_type = 5;
  repeated int64 stride = 6;
  int64 storage_offset = 7;
  int32 device_index = 8;
}

// Argument for ATen operations (can be tensor, scalar, or nested structure)
message AtenArgument {
  oneof value {
    TensorReference tensor = 1;
    double scalar_float = 2;
    int64 scalar_int = 3;
    bool scalar_bool = 4;
    string scalar_string = 5;
    AtenArgumentList list_value = 6;
    bool none_value = 7;  // Represents Python None
  }
}

// List of AtenArguments (for nested lists/tuples)
message AtenArgumentList {
  repeated AtenArgument values = 1;
  bool is_tuple = 2;  // Preserve tuple vs list distinction
}

// Request to execute an ATen operation
message ExecuteAtenRequest {
  string op_name = 1;
  repeated AtenArgument args = 2;  // Positional arguments (preserves order)
  repeated TensorReference outputs = 3;
  map<string, AtenArgument> kwargs = 4;
}

// Response after executing an ATen operation
message ExecuteAtenResponse {
  bool success = 1;
  string message = 2;
  repeated TensorReference output_tensors = 3;
}
