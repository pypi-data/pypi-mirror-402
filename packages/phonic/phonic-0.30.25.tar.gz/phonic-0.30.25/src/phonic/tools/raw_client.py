# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..errors.bad_request_error import BadRequestError
from ..errors.conflict_error import ConflictError
from ..errors.forbidden_error import ForbiddenError
from ..errors.not_found_error import NotFoundError
from ..requests.tool_parameter import ToolParameterParams
from .types.create_tool_request_endpoint_method import CreateToolRequestEndpointMethod
from .types.create_tool_request_execution_mode import CreateToolRequestExecutionMode
from .types.create_tool_request_type import CreateToolRequestType
from .types.tools_create_response import ToolsCreateResponse
from .types.tools_delete_response import ToolsDeleteResponse
from .types.tools_get_response import ToolsGetResponse
from .types.tools_list_response import ToolsListResponse
from .types.tools_update_response import ToolsUpdateResponse
from .types.update_tool_request_endpoint_method import UpdateToolRequestEndpointMethod
from .types.update_tool_request_execution_mode import UpdateToolRequestExecutionMode
from .types.update_tool_request_type import UpdateToolRequestType

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawToolsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self, *, project: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ToolsListResponse]:
        """
        Returns all custom tools for the organization.

        Parameters
        ----------
        project : typing.Optional[str]
            The name of the project to list tools for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ToolsListResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "tools",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsListResponse,
                    construct_type(
                        type_=ToolsListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create(
        self,
        *,
        name: str,
        description: str,
        type: CreateToolRequestType,
        execution_mode: CreateToolRequestExecutionMode,
        project: typing.Optional[str] = None,
        parameters: typing.Optional[typing.Sequence[ToolParameterParams]] = OMIT,
        endpoint_method: typing.Optional[CreateToolRequestEndpointMethod] = OMIT,
        endpoint_url: typing.Optional[str] = OMIT,
        endpoint_headers: typing.Optional[typing.Dict[str, str]] = OMIT,
        endpoint_timeout_ms: typing.Optional[int] = OMIT,
        tool_call_output_timeout_ms: typing.Optional[int] = OMIT,
        phone_number: typing.Optional[str] = OMIT,
        dtmf: typing.Optional[str] = OMIT,
        use_agent_phone_number: typing.Optional[bool] = OMIT,
        detect_voicemail: typing.Optional[bool] = OMIT,
        agents_to_transfer_to: typing.Optional[typing.Sequence[str]] = OMIT,
        require_speech_before_tool_call: typing.Optional[bool] = OMIT,
        wait_for_speech_before_tool_call: typing.Optional[bool] = OMIT,
        forbid_speech_after_tool_call: typing.Optional[bool] = OMIT,
        allow_tool_chaining: typing.Optional[bool] = OMIT,
        wait_for_response: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ToolsCreateResponse]:
        """
        Creates a new tool in a project.

        Parameters
        ----------
        name : str
            The name of the tool. Must be snake_case and unique within the organization.

        description : str
            A description of what the tool does.

        type : CreateToolRequestType
            The type of tool.

        execution_mode : CreateToolRequestExecutionMode
            Mode of operation.

        project : typing.Optional[str]
            The name of the project to create the tool in.

        parameters : typing.Optional[typing.Sequence[ToolParameterParams]]
            Array of parameter definitions.
            For `custom_webhook` tools with POST method, each parameter must include a `location` field.
            For `custom_webhook` tools with GET method, `location` defaults to `"query_string"` if not specified.
            For `custom_websocket`, `built_in_transfer_to_phone_number`, and `built_in_transfer_to_agent` tools, `location` must not be specified.

        endpoint_method : typing.Optional[CreateToolRequestEndpointMethod]
            Required for webhook tools. HTTP method for the webhook endpoint.

        endpoint_url : typing.Optional[str]
            Required for webhook tools.

        endpoint_headers : typing.Optional[typing.Dict[str, str]]
            Optional headers for webhook tools.

        endpoint_timeout_ms : typing.Optional[int]
            Timeout for webhook tools.

        tool_call_output_timeout_ms : typing.Optional[int]
            Timeout for WebSocket tool responses.

        phone_number : typing.Optional[str]
            The E.164 formatted phone number to transfer calls to. Set to null if the agent should determine the phone number.

        dtmf : typing.Optional[str]
            DTMF digits to send after the transfer connects (e.g., "1234"). Defaults to null.

        use_agent_phone_number : typing.Optional[bool]
            When true, Phonic will transfer the call using the agent's phone number. When false, Phonic will transfer the call using the phone number of the party to whom the agent is connected. This is only available for built_in_transfer_to_phone_number tools.

        detect_voicemail : typing.Optional[bool]
            When true, Phonic will listen in and tell the user if the transfer hits voicemail. This is only available for built_in_transfer_to_phone_number tools when use_agent_phone_number is true.

        agents_to_transfer_to : typing.Optional[typing.Sequence[str]]
            Array of agent names that the LLM can choose from when transferring. Required for built_in_transfer_to_agent tools. All agents must exist in the same project as the tool.

        require_speech_before_tool_call : typing.Optional[bool]
            When true, forces the agent to speak before executing the tool.

        wait_for_speech_before_tool_call : typing.Optional[bool]
            If true, the agent will wait to finish speaking before executing the tool. This is only available for custom_webhook and custom_websocket tools.

        forbid_speech_after_tool_call : typing.Optional[bool]
            When true, forbids the agent from speaking after executing the tool. Available for custom_context, custom_webhook and custom_websocket tools.

        allow_tool_chaining : typing.Optional[bool]
            When true, allows the agent to chain and execute other tools after executing the tool. Available for custom_context, custom_webhook and custom_websocket tools.

        wait_for_response : typing.Optional[bool]
            The agent doesn't typically wait for the response of async custom_websocket tools. When true, makes the agent wait for a response, not call other tools and inform the user of the result. Only available for async custom_websocket tools.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ToolsCreateResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            "tools",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            params={
                "project": project,
            },
            json={
                "name": name,
                "description": description,
                "type": type,
                "execution_mode": execution_mode,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=typing.Sequence[ToolParameterParams], direction="write"
                ),
                "endpoint_method": endpoint_method,
                "endpoint_url": endpoint_url,
                "endpoint_headers": endpoint_headers,
                "endpoint_timeout_ms": endpoint_timeout_ms,
                "tool_call_output_timeout_ms": tool_call_output_timeout_ms,
                "phone_number": phone_number,
                "dtmf": dtmf,
                "use_agent_phone_number": use_agent_phone_number,
                "detect_voicemail": detect_voicemail,
                "agents_to_transfer_to": agents_to_transfer_to,
                "require_speech_before_tool_call": require_speech_before_tool_call,
                "wait_for_speech_before_tool_call": wait_for_speech_before_tool_call,
                "forbid_speech_after_tool_call": forbid_speech_after_tool_call,
                "allow_tool_chaining": allow_tool_chaining,
                "wait_for_response": wait_for_response,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsCreateResponse,
                    construct_type(
                        type_=ToolsCreateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ToolsGetResponse]:
        """
        Returns a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to get.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ToolsGetResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsGetResponse,
                    construct_type(
                        type_=ToolsGetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ToolsDeleteResponse]:
        """
        Deletes a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to delete.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ToolsDeleteResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="DELETE",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsDeleteResponse,
                    construct_type(
                        type_=ToolsDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        type: typing.Optional[UpdateToolRequestType] = OMIT,
        execution_mode: typing.Optional[UpdateToolRequestExecutionMode] = OMIT,
        parameters: typing.Optional[typing.Sequence[ToolParameterParams]] = OMIT,
        endpoint_method: typing.Optional[UpdateToolRequestEndpointMethod] = OMIT,
        endpoint_url: typing.Optional[str] = OMIT,
        endpoint_headers: typing.Optional[typing.Dict[str, str]] = OMIT,
        endpoint_timeout_ms: typing.Optional[int] = OMIT,
        tool_call_output_timeout_ms: typing.Optional[int] = OMIT,
        phone_number: typing.Optional[str] = OMIT,
        dtmf: typing.Optional[str] = OMIT,
        use_agent_phone_number: typing.Optional[bool] = OMIT,
        detect_voicemail: typing.Optional[bool] = OMIT,
        agents_to_transfer_to: typing.Optional[typing.Sequence[str]] = OMIT,
        require_speech_before_tool_call: typing.Optional[bool] = OMIT,
        wait_for_speech_before_tool_call: typing.Optional[bool] = OMIT,
        forbid_speech_after_tool_call: typing.Optional[bool] = OMIT,
        allow_tool_chaining: typing.Optional[bool] = OMIT,
        wait_for_response: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ToolsUpdateResponse]:
        """
        Updates a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to update.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        name : typing.Optional[str]
            The name of the tool. Must be snake_case and unique within the organization.

        description : typing.Optional[str]
            A description of what the tool does.

        type : typing.Optional[UpdateToolRequestType]
            The type of tool.

        execution_mode : typing.Optional[UpdateToolRequestExecutionMode]
            Mode of operation.

        parameters : typing.Optional[typing.Sequence[ToolParameterParams]]
            Array of parameter definitions.
            When updating `type` or `endpoint_method`, all parameters must include explicit `location` values.
            For `custom_webhook` tools: `location` is required for POST, defaults to `"query_string"` for GET.
            For `custom_websocket`, `built_in_transfer_to_phone_number`, and `built_in_transfer_to_agent` tools: `location` must not be specified.

        endpoint_method : typing.Optional[UpdateToolRequestEndpointMethod]
            HTTP method for webhook tools. When changing this value, all parameters must include explicit `location` values.

        endpoint_url : typing.Optional[str]

        endpoint_headers : typing.Optional[typing.Dict[str, str]]

        endpoint_timeout_ms : typing.Optional[int]

        tool_call_output_timeout_ms : typing.Optional[int]

        phone_number : typing.Optional[str]
            The E.164 formatted phone number to transfer calls to. Set to null if the agent should determine the phone number.

        dtmf : typing.Optional[str]
            DTMF digits to send after the transfer connects (e.g., "1234"). Can be set to null to remove DTMF.

        use_agent_phone_number : typing.Optional[bool]
            When true, Phonic will transfer the call using the agent's phone number. When false, Phonic will transfer the call using the phone number of the party to whom the agent is connected. This is only available for built_in_transfer_to_phone_number tools.

        detect_voicemail : typing.Optional[bool]
            When true, Phonic will listen in and tell the user if the transfer hits voicemail. This is only available for built_in_transfer_to_phone_number tools when use_agent_phone_number is true.

        agents_to_transfer_to : typing.Optional[typing.Sequence[str]]
            Array of agent names that the LLM can choose from when transferring. All agents must exist in the same project as the tool.

        require_speech_before_tool_call : typing.Optional[bool]
            When true, forces the agent to speak before executing the tool.

        wait_for_speech_before_tool_call : typing.Optional[bool]
            If true, the agent will wait to finish speaking before executing the tool. This is only available for custom_webhook and custom_websocket tools.

        forbid_speech_after_tool_call : typing.Optional[bool]
            When true, forbids the agent from speaking after executing the tool. Available for custom_context, custom_webhook and custom_websocket tools.

        allow_tool_chaining : typing.Optional[bool]
            When true, allows the agent to chain and execute other tools after executing the tool. Available for custom_context, custom_webhook and custom_websocket tools.

        wait_for_response : typing.Optional[bool]
            The agent doesn't typically wait for the response of async custom_websocket tools. When true, makes the agent wait for a response, not call other tools and inform the user of the result. Only available for async custom_websocket tools.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ToolsUpdateResponse]
            Success response
        """
        _response = self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="PATCH",
            params={
                "project": project,
            },
            json={
                "name": name,
                "description": description,
                "type": type,
                "execution_mode": execution_mode,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=typing.Sequence[ToolParameterParams], direction="write"
                ),
                "endpoint_method": endpoint_method,
                "endpoint_url": endpoint_url,
                "endpoint_headers": endpoint_headers,
                "endpoint_timeout_ms": endpoint_timeout_ms,
                "tool_call_output_timeout_ms": tool_call_output_timeout_ms,
                "phone_number": phone_number,
                "dtmf": dtmf,
                "use_agent_phone_number": use_agent_phone_number,
                "detect_voicemail": detect_voicemail,
                "agents_to_transfer_to": agents_to_transfer_to,
                "require_speech_before_tool_call": require_speech_before_tool_call,
                "wait_for_speech_before_tool_call": wait_for_speech_before_tool_call,
                "forbid_speech_after_tool_call": forbid_speech_after_tool_call,
                "allow_tool_chaining": allow_tool_chaining,
                "wait_for_response": wait_for_response,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsUpdateResponse,
                    construct_type(
                        type_=ToolsUpdateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawToolsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self, *, project: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ToolsListResponse]:
        """
        Returns all custom tools for the organization.

        Parameters
        ----------
        project : typing.Optional[str]
            The name of the project to list tools for.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ToolsListResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tools",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsListResponse,
                    construct_type(
                        type_=ToolsListResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create(
        self,
        *,
        name: str,
        description: str,
        type: CreateToolRequestType,
        execution_mode: CreateToolRequestExecutionMode,
        project: typing.Optional[str] = None,
        parameters: typing.Optional[typing.Sequence[ToolParameterParams]] = OMIT,
        endpoint_method: typing.Optional[CreateToolRequestEndpointMethod] = OMIT,
        endpoint_url: typing.Optional[str] = OMIT,
        endpoint_headers: typing.Optional[typing.Dict[str, str]] = OMIT,
        endpoint_timeout_ms: typing.Optional[int] = OMIT,
        tool_call_output_timeout_ms: typing.Optional[int] = OMIT,
        phone_number: typing.Optional[str] = OMIT,
        dtmf: typing.Optional[str] = OMIT,
        use_agent_phone_number: typing.Optional[bool] = OMIT,
        detect_voicemail: typing.Optional[bool] = OMIT,
        agents_to_transfer_to: typing.Optional[typing.Sequence[str]] = OMIT,
        require_speech_before_tool_call: typing.Optional[bool] = OMIT,
        wait_for_speech_before_tool_call: typing.Optional[bool] = OMIT,
        forbid_speech_after_tool_call: typing.Optional[bool] = OMIT,
        allow_tool_chaining: typing.Optional[bool] = OMIT,
        wait_for_response: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ToolsCreateResponse]:
        """
        Creates a new tool in a project.

        Parameters
        ----------
        name : str
            The name of the tool. Must be snake_case and unique within the organization.

        description : str
            A description of what the tool does.

        type : CreateToolRequestType
            The type of tool.

        execution_mode : CreateToolRequestExecutionMode
            Mode of operation.

        project : typing.Optional[str]
            The name of the project to create the tool in.

        parameters : typing.Optional[typing.Sequence[ToolParameterParams]]
            Array of parameter definitions.
            For `custom_webhook` tools with POST method, each parameter must include a `location` field.
            For `custom_webhook` tools with GET method, `location` defaults to `"query_string"` if not specified.
            For `custom_websocket`, `built_in_transfer_to_phone_number`, and `built_in_transfer_to_agent` tools, `location` must not be specified.

        endpoint_method : typing.Optional[CreateToolRequestEndpointMethod]
            Required for webhook tools. HTTP method for the webhook endpoint.

        endpoint_url : typing.Optional[str]
            Required for webhook tools.

        endpoint_headers : typing.Optional[typing.Dict[str, str]]
            Optional headers for webhook tools.

        endpoint_timeout_ms : typing.Optional[int]
            Timeout for webhook tools.

        tool_call_output_timeout_ms : typing.Optional[int]
            Timeout for WebSocket tool responses.

        phone_number : typing.Optional[str]
            The E.164 formatted phone number to transfer calls to. Set to null if the agent should determine the phone number.

        dtmf : typing.Optional[str]
            DTMF digits to send after the transfer connects (e.g., "1234"). Defaults to null.

        use_agent_phone_number : typing.Optional[bool]
            When true, Phonic will transfer the call using the agent's phone number. When false, Phonic will transfer the call using the phone number of the party to whom the agent is connected. This is only available for built_in_transfer_to_phone_number tools.

        detect_voicemail : typing.Optional[bool]
            When true, Phonic will listen in and tell the user if the transfer hits voicemail. This is only available for built_in_transfer_to_phone_number tools when use_agent_phone_number is true.

        agents_to_transfer_to : typing.Optional[typing.Sequence[str]]
            Array of agent names that the LLM can choose from when transferring. Required for built_in_transfer_to_agent tools. All agents must exist in the same project as the tool.

        require_speech_before_tool_call : typing.Optional[bool]
            When true, forces the agent to speak before executing the tool.

        wait_for_speech_before_tool_call : typing.Optional[bool]
            If true, the agent will wait to finish speaking before executing the tool. This is only available for custom_webhook and custom_websocket tools.

        forbid_speech_after_tool_call : typing.Optional[bool]
            When true, forbids the agent from speaking after executing the tool. Available for custom_context, custom_webhook and custom_websocket tools.

        allow_tool_chaining : typing.Optional[bool]
            When true, allows the agent to chain and execute other tools after executing the tool. Available for custom_context, custom_webhook and custom_websocket tools.

        wait_for_response : typing.Optional[bool]
            The agent doesn't typically wait for the response of async custom_websocket tools. When true, makes the agent wait for a response, not call other tools and inform the user of the result. Only available for async custom_websocket tools.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ToolsCreateResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "tools",
            base_url=self._client_wrapper.get_environment().base,
            method="POST",
            params={
                "project": project,
            },
            json={
                "name": name,
                "description": description,
                "type": type,
                "execution_mode": execution_mode,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=typing.Sequence[ToolParameterParams], direction="write"
                ),
                "endpoint_method": endpoint_method,
                "endpoint_url": endpoint_url,
                "endpoint_headers": endpoint_headers,
                "endpoint_timeout_ms": endpoint_timeout_ms,
                "tool_call_output_timeout_ms": tool_call_output_timeout_ms,
                "phone_number": phone_number,
                "dtmf": dtmf,
                "use_agent_phone_number": use_agent_phone_number,
                "detect_voicemail": detect_voicemail,
                "agents_to_transfer_to": agents_to_transfer_to,
                "require_speech_before_tool_call": require_speech_before_tool_call,
                "wait_for_speech_before_tool_call": wait_for_speech_before_tool_call,
                "forbid_speech_after_tool_call": forbid_speech_after_tool_call,
                "allow_tool_chaining": allow_tool_chaining,
                "wait_for_response": wait_for_response,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsCreateResponse,
                    construct_type(
                        type_=ToolsCreateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ToolsGetResponse]:
        """
        Returns a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to get.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ToolsGetResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="GET",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsGetResponse,
                    construct_type(
                        type_=ToolsGetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ToolsDeleteResponse]:
        """
        Deletes a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to delete.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ToolsDeleteResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="DELETE",
            params={
                "project": project,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsDeleteResponse,
                    construct_type(
                        type_=ToolsDeleteResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update(
        self,
        name_or_id: str,
        *,
        project: typing.Optional[str] = None,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        type: typing.Optional[UpdateToolRequestType] = OMIT,
        execution_mode: typing.Optional[UpdateToolRequestExecutionMode] = OMIT,
        parameters: typing.Optional[typing.Sequence[ToolParameterParams]] = OMIT,
        endpoint_method: typing.Optional[UpdateToolRequestEndpointMethod] = OMIT,
        endpoint_url: typing.Optional[str] = OMIT,
        endpoint_headers: typing.Optional[typing.Dict[str, str]] = OMIT,
        endpoint_timeout_ms: typing.Optional[int] = OMIT,
        tool_call_output_timeout_ms: typing.Optional[int] = OMIT,
        phone_number: typing.Optional[str] = OMIT,
        dtmf: typing.Optional[str] = OMIT,
        use_agent_phone_number: typing.Optional[bool] = OMIT,
        detect_voicemail: typing.Optional[bool] = OMIT,
        agents_to_transfer_to: typing.Optional[typing.Sequence[str]] = OMIT,
        require_speech_before_tool_call: typing.Optional[bool] = OMIT,
        wait_for_speech_before_tool_call: typing.Optional[bool] = OMIT,
        forbid_speech_after_tool_call: typing.Optional[bool] = OMIT,
        allow_tool_chaining: typing.Optional[bool] = OMIT,
        wait_for_response: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ToolsUpdateResponse]:
        """
        Updates a tool by name or ID.

        Parameters
        ----------
        name_or_id : str
            The name or the ID of the tool to update.

        project : typing.Optional[str]
            The name of the project containing the tool. Only used when `nameOrId` is a name.

        name : typing.Optional[str]
            The name of the tool. Must be snake_case and unique within the organization.

        description : typing.Optional[str]
            A description of what the tool does.

        type : typing.Optional[UpdateToolRequestType]
            The type of tool.

        execution_mode : typing.Optional[UpdateToolRequestExecutionMode]
            Mode of operation.

        parameters : typing.Optional[typing.Sequence[ToolParameterParams]]
            Array of parameter definitions.
            When updating `type` or `endpoint_method`, all parameters must include explicit `location` values.
            For `custom_webhook` tools: `location` is required for POST, defaults to `"query_string"` for GET.
            For `custom_websocket`, `built_in_transfer_to_phone_number`, and `built_in_transfer_to_agent` tools: `location` must not be specified.

        endpoint_method : typing.Optional[UpdateToolRequestEndpointMethod]
            HTTP method for webhook tools. When changing this value, all parameters must include explicit `location` values.

        endpoint_url : typing.Optional[str]

        endpoint_headers : typing.Optional[typing.Dict[str, str]]

        endpoint_timeout_ms : typing.Optional[int]

        tool_call_output_timeout_ms : typing.Optional[int]

        phone_number : typing.Optional[str]
            The E.164 formatted phone number to transfer calls to. Set to null if the agent should determine the phone number.

        dtmf : typing.Optional[str]
            DTMF digits to send after the transfer connects (e.g., "1234"). Can be set to null to remove DTMF.

        use_agent_phone_number : typing.Optional[bool]
            When true, Phonic will transfer the call using the agent's phone number. When false, Phonic will transfer the call using the phone number of the party to whom the agent is connected. This is only available for built_in_transfer_to_phone_number tools.

        detect_voicemail : typing.Optional[bool]
            When true, Phonic will listen in and tell the user if the transfer hits voicemail. This is only available for built_in_transfer_to_phone_number tools when use_agent_phone_number is true.

        agents_to_transfer_to : typing.Optional[typing.Sequence[str]]
            Array of agent names that the LLM can choose from when transferring. All agents must exist in the same project as the tool.

        require_speech_before_tool_call : typing.Optional[bool]
            When true, forces the agent to speak before executing the tool.

        wait_for_speech_before_tool_call : typing.Optional[bool]
            If true, the agent will wait to finish speaking before executing the tool. This is only available for custom_webhook and custom_websocket tools.

        forbid_speech_after_tool_call : typing.Optional[bool]
            When true, forbids the agent from speaking after executing the tool. Available for custom_context, custom_webhook and custom_websocket tools.

        allow_tool_chaining : typing.Optional[bool]
            When true, allows the agent to chain and execute other tools after executing the tool. Available for custom_context, custom_webhook and custom_websocket tools.

        wait_for_response : typing.Optional[bool]
            The agent doesn't typically wait for the response of async custom_websocket tools. When true, makes the agent wait for a response, not call other tools and inform the user of the result. Only available for async custom_websocket tools.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ToolsUpdateResponse]
            Success response
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"tools/{jsonable_encoder(name_or_id)}",
            base_url=self._client_wrapper.get_environment().base,
            method="PATCH",
            params={
                "project": project,
            },
            json={
                "name": name,
                "description": description,
                "type": type,
                "execution_mode": execution_mode,
                "parameters": convert_and_respect_annotation_metadata(
                    object_=parameters, annotation=typing.Sequence[ToolParameterParams], direction="write"
                ),
                "endpoint_method": endpoint_method,
                "endpoint_url": endpoint_url,
                "endpoint_headers": endpoint_headers,
                "endpoint_timeout_ms": endpoint_timeout_ms,
                "tool_call_output_timeout_ms": tool_call_output_timeout_ms,
                "phone_number": phone_number,
                "dtmf": dtmf,
                "use_agent_phone_number": use_agent_phone_number,
                "detect_voicemail": detect_voicemail,
                "agents_to_transfer_to": agents_to_transfer_to,
                "require_speech_before_tool_call": require_speech_before_tool_call,
                "wait_for_speech_before_tool_call": wait_for_speech_before_tool_call,
                "forbid_speech_after_tool_call": forbid_speech_after_tool_call,
                "allow_tool_chaining": allow_tool_chaining,
                "wait_for_response": wait_for_response,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ToolsUpdateResponse,
                    construct_type(
                        type_=ToolsUpdateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 409:
                raise ConflictError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        construct_type(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
