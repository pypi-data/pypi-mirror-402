"""Cleaning report generation."""

from datetime import datetime, timezone
from pathlib import Path


def generate_report(
    file_path: str,
    total_chunks: int,
    functions: list[dict],
    latency_stats: dict | None = None,
    quality_before: dict | None = None,
    quality_after: dict | None = None,
) -> str:
    """
    Generate markdown cleaning report.

    Args:
        file_path: Path to the file that was cleaned
        total_chunks: Number of chunks processed
        functions: List of generated function dicts with 'name', 'docstring' keys
        latency_stats: Optional dict with call_count, total_ms, avg_ms, etc.
        quality_before: Optional dict with null_count, empty_string_count, etc.
        quality_after: Optional dict with quality metrics after cleaning

    Returns:
        Markdown-formatted report string
    """
    lines = ["# Data Cleaning Report", ""]

    # Summary section
    lines.append("## Summary")
    lines.append("")
    lines.append(f"- **File**: `{file_path}`")
    lines.append(f"- **Chunks processed**: {total_chunks}")
    lines.append(f"- **Functions generated**: {len(functions)}")

    if latency_stats and latency_stats.get("call_count", 0) > 0:
        total_ms = latency_stats.get("total_ms", 0)
        lines.append(f"- **Total LLM time**: {total_ms:.0f}ms")
        lines.append(f"- **LLM calls**: {latency_stats.get('call_count', 0)}")

    lines.append("")

    # Functions section
    if functions:
        lines.append("## Functions Generated")
        lines.append("")
        lines.append("| # | Name | Description |")
        lines.append("|---|------|-------------|")

        for i, func in enumerate(functions, 1):
            name = func.get("name", "unknown")
            docstring = func.get("docstring", "")
            # Get first line of docstring
            first_line = docstring.split("\n")[0].strip() if docstring else ""
            # Escape pipe characters for markdown table
            first_line = first_line.replace("|", "\\|")
            lines.append(f"| {i} | `{name}` | {first_line} |")

        lines.append("")

    # Quality metrics section
    if quality_before:
        lines.append("## Quality Metrics")
        lines.append("")
        lines.append("| Metric | Before | After | Change |")
        lines.append("|--------|--------|-------|--------|")

        before_nulls = quality_before.get("null_count", 0)
        after_nulls = quality_after.get("null_count", 0) if quality_after else before_nulls
        null_change = _format_change(before_nulls, after_nulls)
        lines.append(f"| Null values | {before_nulls} | {after_nulls} | {null_change} |")

        before_empty = quality_before.get("empty_string_count", 0)
        after_empty = quality_after.get("empty_string_count", 0) if quality_after else before_empty
        empty_change = _format_change(before_empty, after_empty)
        lines.append(f"| Empty strings | {before_empty} | {after_empty} | {empty_change} |")

        lines.append("")

    # Footer
    lines.append("---")
    lines.append("")
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
    lines.append(f"*Generated by Recursive Data Cleaner at {timestamp}*")

    return "\n".join(lines)


def _format_change(before: int, after: int) -> str:
    """Format the change between before and after values."""
    if before == 0:
        if after == 0:
            return "-"
        return f"+{after}"

    diff = after - before
    pct = (diff / before) * 100

    if diff == 0:
        return "0%"
    elif diff < 0:
        return f"{pct:.0f}%"
    else:
        return f"+{pct:.0f}%"


def write_report(
    report_path: str,
    file_path: str,
    total_chunks: int,
    functions: list[dict],
    latency_stats: dict | None = None,
    quality_before: dict | None = None,
    quality_after: dict | None = None,
) -> None:
    """
    Generate and write cleaning report to file.

    Args:
        report_path: Path to write the report
        file_path: Path to the file that was cleaned
        total_chunks: Number of chunks processed
        functions: List of generated function dicts
        latency_stats: Optional latency statistics
        quality_before: Optional quality metrics before cleaning
        quality_after: Optional quality metrics after cleaning
    """
    content = generate_report(
        file_path=file_path,
        total_chunks=total_chunks,
        functions=functions,
        latency_stats=latency_stats,
        quality_before=quality_before,
        quality_after=quality_after,
    )
    Path(report_path).write_text(content)
