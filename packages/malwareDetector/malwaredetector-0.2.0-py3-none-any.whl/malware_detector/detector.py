"""Base detector class for malware detection pipelines.

This module provides the base class for all malware detectors.
Subclasses should implement stage methods matching the names in
default_stages.

Typical usage:
    from malware_detector import BaseDetector, BaseDetectorConfig

    class MyDetector(BaseDetector):
        def stage_extract(self) -> Any:
            # Extract features from dataset
            ...

        def stage_vectorize(self) -> Any:
            # Convert features to vectors
            ...

        def stage_train(self) -> Any:
            # Train the model
            ...

        def stage_predict(self) -> Any:
            # Run predictions
            ...

    detector = MyDetector()
    detector.setup()
    results = detector.run()
"""

from typing import Any

import structlog

from .config import BaseDetectorConfig


class BaseDetector:
    """Base class for malware detectors.

    This class defines the interface and common functionality for all
    malware detectors. Subclasses should implement stage methods matching
    the names in default_stages (e.g., stage_extract for "extract").

    For standard detectors, implement: stage_extract, stage_vectorize,
    stage_train, and stage_predict.

    For custom pipelines, override default_stages and implement matching
    stage methods.

    Attributes:
        default_stages: List of stage names to run by default.
        config_class: Configuration class to use for this detector.
        config: The loaded configuration instance.
        log: Structured logger bound to this detector.

    Example:
        class MyDetector(BaseDetector):
            config_class = MyConfig

            def stage_extract(self) -> Path:
                self.log.info("extracting_features")
                # Implementation...
                return self.config.folder.feature

            def stage_vectorize(self) -> Any:
                ...

            def stage_train(self) -> Any:
                ...

            def stage_predict(self) -> Any:
                ...
    """

    default_stages: list[str] = ["extract", "vectorize", "train", "predict"]
    config_class: type[BaseDetectorConfig] = BaseDetectorConfig

    def __init__(self, config: BaseDetectorConfig | None = None) -> None:
        """Initialize the detector with configuration.

        Args:
            config: Configuration instance. If None, creates default config
                using config_class.
        """
        self.config = config or self.config_class()
        self.log = structlog.get_logger().bind(
            detector=self.__class__.__name__,
        )

    def setup(self) -> None:
        """Create all required directories from folder configuration."""
        for folder in self.config.folder.all_folders:
            folder.mkdir(parents=True, exist_ok=True)
            self.log.debug("folder_created", path=str(folder))

    def run(self, stages: list[str] | None = None) -> dict[str, Any]:
        """Execute the detection pipeline.

        Args:
            stages: List of stage names to run. If None, runs all
                default_stages.

        Returns:
            Dictionary mapping stage names to their return values.

        Raises:
            NotImplementedError: If a requested stage method doesn't exist.
        """
        stages = stages or self.default_stages
        results: dict[str, Any] = {}

        self.log.info("pipeline_started", stages=stages)

        for stage in stages:
            method = getattr(self, f"stage_{stage}", None)
            if method is None:
                self.log.error("stage_not_found", stage=stage)
                raise NotImplementedError(f"Stage '{stage}' not implemented")

            self.log.info("stage_started", stage=stage)
            result = method()
            results[stage] = result
            self.log.info("stage_completed", stage=stage)

        self.log.info("pipeline_completed", stages=stages)
        return results
