"""CLI factory using Typer for extensible command-line interfaces.

This module provides a factory function to create CLI applications for
any BaseDetector subclass. The generated CLI includes common commands
like `run` and `init`, and can be extended with custom commands.

Typical usage:
    from malware_detector import create_cli
    from my_detector import MyDetector

    app = create_cli(MyDetector)

    # Add custom commands
    @app.command()
    def evaluate():
        ...

    if __name__ == "__main__":
        app()
"""

from pathlib import Path
from typing import Annotated, Literal

import typer

from .config import BaseDetectorConfig
from .detector import BaseDetector
from .logging import configure_logging


def config_to_toml(config: BaseDetectorConfig) -> str:
    """Convert configuration to TOML format string.

    Args:
        config: Configuration instance to serialize.

    Returns:
        TOML-formatted configuration string.
    """
    lines: list[str] = []

    # Path section
    lines.append("[path]")
    for name, value in config.path.model_dump().items():
        lines.append(f'{name} = "{value}"')
    lines.append("")

    # Folder section
    lines.append("[folder]")
    for name, value in config.folder.model_dump().items():
        lines.append(f'{name} = "{value}"')
    lines.append("")

    # Top-level fields
    lines.append(f"classify = {str(config.classify).lower()}")

    return "\n".join(lines)


def create_cli(
    detector_class: type[BaseDetector],
    config_class: type[BaseDetectorConfig] | None = None,
) -> typer.Typer:
    """Create a CLI application for a detector class.

    This factory function generates a Typer CLI with standard commands
    for running the detector pipeline and initializing configuration.

    Args:
        detector_class: The detector class to create CLI for.
        config_class: Optional configuration class. If None, uses
            detector_class.config_class.

    Returns:
        Configured Typer application.

    Example:
        app = create_cli(MyDetector)

        @app.command()
        def custom_command():
            '''Add custom commands to the CLI.'''
            ...

        if __name__ == "__main__":
            app()
    """
    app = typer.Typer(
        name=detector_class.__name__,
        help=detector_class.__doc__ or f"CLI for {detector_class.__name__}",
    )
    resolved_config_class = config_class or detector_class.config_class

    @app.callback()
    def main(
        log_level: Annotated[
            str,
            typer.Option("--log-level", "-l", help="Log level"),
        ] = "INFO",
        log_format: Annotated[
            Literal["console", "json"],
            typer.Option("--log-format", help="Log format: console or json"),
        ] = "console",
    ) -> None:
        """Configure global options for the CLI."""
        configure_logging(level=log_level, format=log_format)

    @app.command()
    def run(
        config_path: Annotated[
            Path | None,
            typer.Option("--config", "-c", help="Config file path"),
        ] = None,
        stages: Annotated[
            str | None,
            typer.Option("--stages", "-s", help="Comma-separated stages to run"),
        ] = None,
    ) -> None:
        """Run the detector pipeline."""
        if config_path and config_path.exists():
            config = resolved_config_class.model_validate_json(
                config_path.read_text()
            )
        else:
            config = resolved_config_class()

        stage_list = stages.split(",") if stages else None

        detector = detector_class(config)
        detector.setup()
        detector.run(stage_list)

    @app.command()
    def init(
        output: Annotated[
            Path,
            typer.Option("--output", "-o", help="Output config file path"),
        ] = Path("config.toml"),
    ) -> None:
        """Generate default configuration file."""
        config = resolved_config_class()
        output.write_text(config_to_toml(config))
        typer.echo(f"Config written to {output}")

    return app
