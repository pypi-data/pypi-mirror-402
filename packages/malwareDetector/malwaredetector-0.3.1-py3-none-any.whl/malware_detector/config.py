"""Configuration system using Pydantic v2 and pydantic-settings.

This module provides a hierarchical configuration system that supports:
- Default values
- JSON and TOML configuration files
- Environment variables
- Programmatic overrides

Configuration priority (later overrides earlier):
    1. Default values (defined in models)
    2. Config file (JSON or TOML)
    3. Environment variables (MALWARE_DETECTOR_*)
    4. Direct assignment

Typical usage:
    from malware_detector.config import BaseDetectorConfig

    # Load with defaults
    config = BaseDetectorConfig()

    # Load from file
    config = BaseDetectorConfig.from_file(Path("config.json"))

    # Load from environment
    config = BaseDetectorConfig.from_env()

    # Subclass for custom configs
    class MyConfig(BaseDetectorConfig):
        batch_size: int = 32
"""

from pathlib import Path
from typing import Literal, Self

from pydantic import BaseModel, ConfigDict, model_validator
from pydantic_settings import BaseSettings, SettingsConfigDict

from .constants import (
    CONFIG_VERSION,
    DEFAULT_DATA_PATH_PREDICT,
    DEFAULT_DATA_PATH_TEST,
    DEFAULT_DATA_PATH_TRAIN,
    DEFAULT_LOG_FORMAT,
    DEFAULT_LOG_LEVEL,
    DEFAULT_OUTPUT_PATH_FEATURE,
    DEFAULT_OUTPUT_PATH_LOG,
    DEFAULT_OUTPUT_PATH_MODEL,
    DEFAULT_OUTPUT_PATH_PREDICTION,
    ENV_NESTED_DELIMITER,
    ENV_PREFIX,
)


class DataConfig(BaseModel):
    """Data path configuration.

    Attributes:
        train: Path to training dataset.
        test: Path to test dataset.
        predict: Path to samples for prediction.
    """

    model_config = ConfigDict(extra="allow", frozen=True)

    train: Path = DEFAULT_DATA_PATH_TRAIN
    test: Path = DEFAULT_DATA_PATH_TEST
    predict: Path = DEFAULT_DATA_PATH_PREDICT


class OutputConfig(BaseModel):
    """Output path configuration.

    Attributes:
        model: Path to save/load trained model.
        feature: Path to save extracted features.
        prediction: Path to save prediction results.
        log: Path to save log files.
    """

    model_config = ConfigDict(extra="allow", frozen=True)

    model: Path = DEFAULT_OUTPUT_PATH_MODEL
    feature: Path = DEFAULT_OUTPUT_PATH_FEATURE
    prediction: Path = DEFAULT_OUTPUT_PATH_PREDICTION
    log: Path = DEFAULT_OUTPUT_PATH_LOG


class LogConfig(BaseModel):
    """Logging configuration.

    Attributes:
        level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).
        format: Output format ('console' or 'json').
    """

    model_config = ConfigDict(extra="allow", frozen=True)

    level: str = DEFAULT_LOG_LEVEL
    format: Literal["console", "json"] = DEFAULT_LOG_FORMAT


class BaseDetectorConfig(BaseSettings):
    """Base configuration for malware detectors.

    This class is designed for inheritance. Subclasses can add custom
    configuration fields while inheriting all base functionality.

    Configuration is immutable after creation (frozen=True).

    Attributes:
        config_version: Configuration schema version for compatibility.
        data: Data path configuration.
        output: Output path configuration.
        log: Logging configuration.
    """

    model_config = SettingsConfigDict(
        env_prefix=ENV_PREFIX,
        env_nested_delimiter=ENV_NESTED_DELIMITER,
        extra="allow",
        frozen=True,
    )

    config_version: str = CONFIG_VERSION
    data: DataConfig = DataConfig()
    output: OutputConfig = OutputConfig()
    log: LogConfig = LogConfig()

    @model_validator(mode="after")
    def validate_version(self) -> Self:
        """Validate configuration version compatibility."""
        supported_versions = ["1.0"]
        if self.config_version not in supported_versions:
            raise ValueError(
                f"Unsupported config version: {self.config_version}. "
                f"Supported versions: {supported_versions}"
            )
        return self

    @classmethod
    def from_file(cls, path: Path) -> Self:
        """Load configuration from a JSON or TOML file.

        Args:
            path: Path to configuration file (.json or .toml).

        Returns:
            Loaded configuration instance.

        Raises:
            ValueError: If file format is not supported.
        """
        suffix = path.suffix.lower()
        content = path.read_text()

        if suffix == ".json":
            return cls.model_validate_json(content)
        elif suffix == ".toml":
            import tomllib

            data = tomllib.loads(content)
            return cls.model_validate(data)
        else:
            raise ValueError(
                f"Unsupported config format: '{suffix}'. "
                f"Supported formats: .json, .toml"
            )

    @classmethod
    def from_env(cls) -> Self:
        """Load configuration from environment variables only.

        Returns:
            Configuration instance with values from environment variables.
        """
        return cls()

    @classmethod
    def from_dict(cls, data: dict) -> Self:
        """Load configuration from a dictionary.

        Args:
            data: Configuration dictionary.

        Returns:
            Loaded configuration instance.
        """
        return cls.model_validate(data)

    def save(self, path: Path) -> None:
        """Save configuration to a JSON file.

        Args:
            path: Output file path.
        """
        path.write_text(self.model_dump_json(indent=2))
