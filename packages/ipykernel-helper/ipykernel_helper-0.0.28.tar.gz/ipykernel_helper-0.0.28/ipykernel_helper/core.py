"""API for ipykernel-helper"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto #0
__all__ = ['transient', 'run_cmd', 'get_md', 'scrape_url', 'gh_blob_to_raw', 'read_gh_repo', 'read_url', 'fix_editable_priority',
           'load_ipython_extension']

# %% ../nbs/00_core.ipynb #9470a755
from fastcore.meta import delegates
from fastcore.utils import patch,dict2obj
from fastcore.docments import sig_source,DocmentText
from fastcore.net import HTTP404NotFoundError
from types import ModuleType, FunctionType, MethodType, BuiltinFunctionType
from inspect import signature, currentframe
from functools import cmp_to_key,partial
from collections.abc import Mapping
from textwrap import dedent
from cloudscraper import create_scraper
from toolslm.funccall import *
from toolslm.xml import *
from ast import literal_eval
from urllib.parse import urlparse, urljoin
from ghapi.all import GhApi

import typing,warnings,re,os,html2text,base64

from IPython.core.interactiveshell import InteractiveShell
from IPython.core.completer import ProvisionalCompleterWarning
from jedi import Interpreter, Script as jscript

from IPython.core.display import DisplayObject
from IPython.display import display,Markdown,HTML
from IPython.core.oinspect import Inspector

# %% ../nbs/00_core.ipynb #06cb0934
warnings.filterwarnings('ignore', category=ProvisionalCompleterWarning)

# %% ../nbs/00_core.ipynb #2fc8512a
def _safe_repr(obj, max_len=200):
    "Safely get the repr() of an object, truncating if it exceeds max_len."
    try:
        s = str(obj)
        return s[:max_len] + ("‚Ä¶" if len(s)>max_len else "")
    except Exception as e: return f"<repr error: {str(e)}>"

# %% ../nbs/00_core.ipynb #1e600ee2
@patch
def user_items(self:InteractiveShell, max_len=200, xtra_skip=()):
    "Get user-defined vars & funcs from namespace."
    ns,nsh = self.user_ns,self.user_ns_hidden
    ignore = {'nbmeta', 'receive_nbmeta'}
    ignore.add(xtra_skip)
    rm_types = (
        type, FunctionType, ModuleType, MethodType, BuiltinFunctionType,
        getattr(typing, '_SpecialGenericAlias', ()),
        getattr(typing, '_GenericAlias', ()),
        getattr(typing, '_SpecialForm', ())
    )
    user_items = {k:v for k, v in ns.items()
                  if not k in ignore and k not in nsh}
    user_vars = {k:_safe_repr(v, max_len=max_len)
                 for k, v in user_items.items() if not k.startswith('_') and not isinstance(v, rm_types)}
    user_fns = {k:str(signature(v)) for k, v in user_items.items()
                if isinstance(v, FunctionType) and v.__module__ == '__main__' and not k.startswith('__')}
    return user_vars,user_fns

# %% ../nbs/00_core.ipynb #3c9a4ad3
def _rank(c, s):
    "Rank a completion `c` for text `s` with namespace `ns`."
    parts = s.split('.')
    is_public = not c.text.startswith('_')
    if c.type=='param': r=1
    elif c.mod=='__main__': r=2 # local
    elif len(parts)>1 and parts[0]==c.mod: r=3 # module
    elif c.mod=='builtins': r=4
    else: r=5
    return r if is_public else r+0.1

# %% ../nbs/00_core.ipynb #047a202b
@patch
def ranked_complete(self:InteractiveShell, code, line_no=None, col_no=None):
    ns = self.user_ns
    lines = code.splitlines(True)
    if line_no: offset = sum(len(lines[i]) for i in range(line_no-1)) + col_no -1
    else: offset = len(code)
    cs = self.Completer.completions(code, offset)
    def _c(a):
        res = dict2obj({attr: getattr(a, attr) for attr in dir(a) if attr[0]!='_'})
        res['mod']= getattr(ns.get(a.text, None), '__module__', None)
        res['rank'] = _rank(res, s=code)
        return res
    # Remove dunder vars, unless the user seems to be looking for them explicitly
    return [_c(c) for c in cs if not c.text.startswith('__') or '__' in code]

# %% ../nbs/00_core.ipynb #afad2cb1
def _signatures(ns, s, line, col):
    ctx = Interpreter(s, [ns]).get_signatures(line, col)
    if not ctx: ctx = jscript(s).get_signatures(line, col)
    return ctx

@patch
def sig_help(self:InteractiveShell, code, line_no=None, col_no=None):
    ns = self.user_ns
    ctx = _signatures(ns, code, line=line_no, col=col_no)
    def _s(s): return {'label':s.description,'typ':s.type, 'mod':s.module_name, 'doc':s.docstring(),
                       'idx':s.index, 'params':[{'name':p.name, 'desc':p.description} for p in s.params]}
    return [_s(opt) for opt in ctx]

# %% ../nbs/00_core.ipynb #808cd4c5
def _maybe_eval(o):
    try: literal_eval(repr(o)); return o
    except: return str(o)

# %% ../nbs/00_core.ipynb #eccab5a6
@patch
def get_vars(self:InteractiveShell, vs:list, literal=True):
    "Get variables from namespace."
    ns = self.user_ns
    return {v:_maybe_eval(ns[v]) if literal else str(ns[v]) for v in vs if v in ns}

# %% ../nbs/00_core.ipynb #ca702fed
@patch
def eval_exprs(self:InteractiveShell, vs:list, literal=True):
    "Evaluate expressions in namespace."
    ns,res = self.user_ns,{}
    for v in vs:
        try: res[v] = _maybe_eval(eval(v, ns)) if literal else str(eval(v, ns))
        except Exception as e: res[v] = f'<error: {e}>'
    return res

# %% ../nbs/00_core.ipynb #68476272
def _get_schema(ns: dict, t):
    "Check if tool `t` has errors."
    if t not in ns: return f"`{t}` not found. Did you run it?"
    try: return {'type':'function', 'function':get_schema(ns[t], pname='parameters', evalable=True, skip_hidden=True)}
    except Exception as e: return f"`{t}`: {e}."

@patch
def get_schemas(self:InteractiveShell, fs:list):
    "Get schemas from namespace."
    ns = self.user_ns
    return {f:_get_schema(ns,f) for f in fs}

# %% ../nbs/00_core.ipynb #9e026fa5
@patch
def xpush(self:InteractiveShell, interactive=False, **kw):
    "Like `push`, but with kwargs"
    self.push(kw, interactive=interactive)

# %% ../nbs/00_core.ipynb #d4a073da
@patch
def publish(self:InteractiveShell, data='', subtype='plain', mimetype='text', meta=None, update=False, **kw):
    if isinstance(data, DisplayObject): data,_ = self.display_formatter.format(data)
    elif not isinstance(data, Mapping): data = {f'{mimetype}/{subtype}': data}
    self.display_pub.publish(data, metadata=meta, transient=kw, update=update)

# %% ../nbs/00_core.ipynb #bb1ed4d6
def transient(data='', subtype='plain', mimetype='text', meta=None, update=False, **kw):
    display({f'{mimetype}/{subtype}': data}, raw=True, metadata=meta, transient=kw, update=update)

# %% ../nbs/00_core.ipynb #0e32b2c6
def run_cmd(cmd, data='', meta=None, update=False, **kw):
    transient(data, meta=meta, update=update, cmd=cmd, **kw)

# %% ../nbs/00_core.ipynb #0f2092d8
def _absolutify_imgs(md, base_url):
    def fix(m):
        alt,img_url = m.group(1),m.group(2)
        if not img_url.startswith('http'): img_url = urljoin(base_url, img_url)
        alt = alt.replace('\\','')
        return f'![{alt}]({img_url})'
    return re.sub(r'!\[(.*?)\]\((.*?)\)', fix, md)

# %% ../nbs/00_core.ipynb #b148c51d
def get_md(html, url='', mmode=None, ignore_links=False, ignore_images=False, mark_code=True):
    "Convert HTML to markdown with absolute image URLs and optional math mode"
    h = html2text.HTML2Text()
    h.body_width = 0
    h.ignore_links, h.ignore_images, h.mark_code = ignore_links, ignore_images, mark_code
    res = _absolutify_imgs(h.handle(str(html)), url)
    if mmode == 'safe': res = res.replace(r'\\(',r'\(').replace(r'\\)',r'\)')
    return re.sub(r'\[code]\s*\n(.*?)\n\[/code]', lambda m: f'```\n{dedent(m.group(1))}\n```', res, flags=re.DOTALL).strip()

# %% ../nbs/00_core.ipynb #18980edf
def scrape_url(url): 
    o = create_scraper().get(url)
    if not o.encoding or o.encoding == 'ISO-8859-1': o.encoding = 'utf-8'
    return o

# %% ../nbs/00_core.ipynb #cc5804a5
def _get_math_mode():
    v = os.getenv('USE_KATEX', '')
    if v.lower() in {'0', 'false', 'none', ''}: return None
    return 'dollar' if v.lower().startswith('d') else 'safe'

# %% ../nbs/00_core.ipynb #619fe2a4
def _aify_imgs(md): return re.sub(r'!\[(.*?)\]\((.*?)\)', r'![\1](\2#ai)', md)

# %% ../nbs/00_core.ipynb #1d1188a7
def gh_blob_to_raw(url):
    "Convert github.com/user/repo/blob/... URL to raw.githubusercontent.com URL"
    m = re.match(r'https?://(?:www\.)?github\.com/([^/]+)/([^/]+)/blob/([^/]+)/(.+)', url)
    if not m: return url
    owner, repo, ref, path = m.groups()
    return f'https://raw.githubusercontent.com/{owner}/{repo}/{ref}/{path}'

# %% ../nbs/00_core.ipynb #9a126dad
def _extract_section(soup, url, selector=None):
    "Extract a specific section from soup, or the whole thing"
    if selector: return '\n\n'.join(str(s) for s in soup.select(selector))
    parsed = urlparse(url)
    if not parsed.fragment: return str(soup)
    section = soup.find(id=parsed.fragment)
    if not section: return ''
    elements = [section]
    current = section.next_sibling
    while current:
        if hasattr(current, 'name') and current.name == section.name: break
        elements.append(current)
        current = current.next_sibling
    return ''.join(str(el) for el in elements)

# %% ../nbs/00_core.ipynb #6d6bb188
def _convert_math(soup, mode):
    for math in soup.find_all('math'):
        annot = math.find('annotation', {'encoding': 'application/x-tex'})
        if not annot: continue
        tex,display = annot.text.strip(), math.get('display') == 'block'
        if mode == 'dollar': wrap = f'$${tex}$$' if display else f'${tex}$'
        else: wrap = f'$${tex}$$' if display else fr'\({tex}\)'
        math.replace_with(wrap)

# %% ../nbs/00_core.ipynb #7a0536e7
def read_gh_repo(owner, repo, ref=None, path=''):
    "Read GitHub repo info: description, file list, and README"
    api = GhApi()
    info = api.repos.get(owner, repo)
    res = [f"# {info.full_name}", info.description or '']
    ref = ref or info.default_branch
    contents = api.repos.get_content(owner, repo, path or '', ref=ref)
    files = [f"- {'üìÅ ' if c.type=='dir' else ''}{c.name}" for c in contents]
    res.append(f'\n## /{path or ""} Files\n' + '\n'.join(files))
    if not path:
        try:
            readme = api.repos.get_readme(owner, repo, ref=ref)
            res.append('\n## README\n' + base64.b64decode(readme.content).decode())
        except HTTP404NotFoundError: pass
    return '\n'.join(res)

# %% ../nbs/00_core.ipynb #d5c677e7
def read_url(url:str, as_md:bool=True, extract_section:bool=True, selector:str=None, ai_img:bool=False):
    "Read url from web"
    from bs4 import BeautifulSoup
    gh = parse_gh_url(url)
    if gh:
        if gh['typ']=='blob': url = gh_blob_to_raw(url)
        elif gh['typ'] in (None, 'tree'): return read_gh_repo(gh['owner'], gh['repo'], gh['ref'], gh['path'])
    o = scrape_url(url)
    ctype = (o.headers.get('content-type') or 'text/plain').split(';')[0]
    res = o.text
    if ctype == 'text/html':
        soup = BeautifulSoup(res, 'lxml')
        if ('#' in url and extract_section) or selector: soup = BeautifulSoup(_extract_section(soup, url, selector), 'lxml')
        mmode = _get_math_mode()
        if mmode: _convert_math(soup, mmode)
        base = soup.find('base')
        base_url = urljoin(url, base['href'] if base else '')
        res = get_md(soup, base_url, mmode) if as_md else str(soup)
    if ai_img: res = _aify_imgs(res)
    return res

# %% ../nbs/00_core.ipynb #dd0a0b71
def fix_editable_priority():
    import sys
    from importlib.machinery import PathFinder
    try: sys.meta_path.append(sys.meta_path.pop(sys.meta_path.index(PathFinder)))
    except ValueError: pass

# %% ../nbs/00_core.ipynb #cf893c28
@patch
def _get_info(self:Inspector, obj, oname='', formatter=None, info=None, detail_level=0, omit_sections=()):
    "Custom formatter for ? and ?? output"
    orig = self._orig__get_info(obj, oname=oname, formatter=formatter, info=info,
                                detail_level=detail_level, omit_sections=omit_sections)
    out = []
    if detail_level==0:
        info_dict = self.info(obj, oname=oname, info=info, detail_level=0)
        out.append(f"```python\n{DocmentText(obj, docstring=False)}\n```")
        if c:=info_dict.get('docstring'): out.append(f'\n\n```\n{c}\n```\n\n')
        if c:=info_dict.get('file'): out.append(f"**File:** `{c}`")
        if c:=info_dict.get('type_name'): out.append(f"**Type:** {c}")
        return {'text/markdown': '\n\n'.join(out), 'text/html': '', 'text/plain': orig['text/plain']}
    info_dict = self.info(obj, oname=oname, info=info, detail_level=2)
    if c:=info_dict.get('source'): out.append(f"\n```python\n{dedent(c)}\n```")
    if c:=info_dict.get('file'): out.append(f"**File:** `{c}`")
    return {'text/markdown': '\n\n'.join(out), 'text/html': '', 'text/plain': orig['text/plain']}

# %% ../nbs/00_core.ipynb #2e7ddf52
def load_ipython_extension(ip):
    from ipykernel_helper import transient,run_cmd
    ns = ip.user_ns
    ns['read_url'],ns['transient'],ns['run_cmd'] = read_url,transient,run_cmd
