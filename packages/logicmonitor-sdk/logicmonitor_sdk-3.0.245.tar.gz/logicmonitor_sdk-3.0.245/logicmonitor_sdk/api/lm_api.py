# coding: utf-8

"""
    LogicMonitor REST API

    LogicMonitor is a SaaS-based performance monitoring platform that provides full visibility into complex, hybrid infrastructures, offering granular performance monitoring and actionable data and insights. logicmonitor_sdk enables you to manage your LogicMonitor account programmatically. <br> <br> Note: <ul> <li> For Python SDKs, the REQUEST parameters can contain camelCase or an underscore. </li> <li> Both underscore and camelCase are supported if parameters are encapsulated within the body. </li> <li> Only camelCase is supported if parameters are encapsulated within the body and also if the user is passing raw JSON as REQUEST parameter. However, the RESPONSE parameters always contain an underscore. For example, you can use testLocation or test_location in the REQUEST parameter. But the RESPONSE parameter will always be test_location. </li> <li> The fields parameter only supports camelCase. </li> </ul>  # noqa: E501

    OpenAPI spec version: 3.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from logicmonitor_sdk.api_client import ApiClient


class LMApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def ack_alert_by_id(self, body, id, **kwargs):  # noqa: E501
        """Acknowledge alert by ID  # noqa: E501

        Acknowledge the alert with the given ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ack_alert_by_id(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertAck body: (required)
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ack_alert_by_id_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.ack_alert_by_id_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def ack_alert_by_id_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Acknowledge alert by ID  # noqa: E501

        Acknowledge the alert with the given ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ack_alert_by_id_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertAck body: (required)
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ack_alert_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `ack_alert_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `ack_alert_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/alert/alerts/{id}/ack', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ack_collector_down_alert_by_id(self, id, body, **kwargs):  # noqa: E501
        """ack collector down alert  # noqa: E501

        ack collector down alert  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ack_collector_down_alert_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AckCollectorDown body: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ack_collector_down_alert_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.ack_collector_down_alert_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def ack_collector_down_alert_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """ack collector down alert  # noqa: E501

        ack collector down alert  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ack_collector_down_alert_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AckCollectorDown body: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ack_collector_down_alert_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `ack_collector_down_alert_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `ack_collector_down_alert_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{id}/ackdown', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_access_group(self, **kwargs):  # noqa: E501
        """Create a access group  # noqa: E501

        Create a access group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_access_group(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccessGroup body:
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_access_group_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_access_group_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_access_group_with_http_info(self, **kwargs):  # noqa: E501
        """Create a access group  # noqa: E501

        Create a access group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_access_group_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccessGroup body:
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_access_group" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_admin(self, body, **kwargs):  # noqa: E501
        """add user  # noqa: E501

        add user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_admin(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Admin body: (required)
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_admin_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_admin_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_admin_with_http_info(self, body, **kwargs):  # noqa: E501
        """add user  # noqa: E501

        add user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_admin_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Admin body: (required)
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_admin" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_admin`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Admin'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_alert_note_by_id(self, body, id, **kwargs):  # noqa: E501
        """Add alert note  # noqa: E501

        Add a note to the alert with the given ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_alert_note_by_id(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertAck body: (required)
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_alert_note_by_id_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_alert_note_by_id_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def add_alert_note_by_id_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Add alert note  # noqa: E501

        Add a note to the alert with the given ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_alert_note_by_id_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertAck body: (required)
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_alert_note_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_alert_note_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `add_alert_note_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/alert/alerts/{id}/note', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_alert_rule(self, body, **kwargs):  # noqa: E501
        """add alert rule  # noqa: E501

        add alert rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_alert_rule(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_alert_rule_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_alert_rule_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_alert_rule_with_http_info(self, body, **kwargs):  # noqa: E501
        """add alert rule  # noqa: E501

        add alert rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_alert_rule_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_alert_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_alert_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_api_token_by_admin_id(self, admin_id, body, **kwargs):  # noqa: E501
        """Add API tokens for a user  # noqa: E501

        Add new API tokens for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_api_token_by_admin_id(admin_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param APIToken body: (required)
        :param str type:
        :return: APIToken
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_api_token_by_admin_id_with_http_info(admin_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_api_token_by_admin_id_with_http_info(admin_id, body, **kwargs)  # noqa: E501
            return data

    def add_api_token_by_admin_id_with_http_info(self, admin_id, body, **kwargs):  # noqa: E501
        """Add API tokens for a user  # noqa: E501

        Add new API tokens for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_api_token_by_admin_id_with_http_info(admin_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param APIToken body: (required)
        :param str type:
        :return: APIToken
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['admin_id', 'body', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_api_token_by_admin_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'admin_id' is set
        if ('admin_id' not in params or
                params['admin_id'] is None):
            raise ValueError("Missing the required parameter `admin_id` when calling `add_api_token_by_admin_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_api_token_by_admin_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'admin_id' in params:
            path_params['adminId'] = params['admin_id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'APIToken'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{adminId}/apitokens', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_applies_to_function(self, **kwargs):  # noqa: E501
        """Add applies to function  # noqa: E501

        Create a new applies to function  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_applies_to_function(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AppliesToFunction body:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_applies_to_function_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_applies_to_function_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_applies_to_function_with_http_info(self, **kwargs):  # noqa: E501
        """Add applies to function  # noqa: E501

        Create a new applies to function  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_applies_to_function_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AppliesToFunction body:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_applies_to_function" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AppliesToFunction'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_collector(self, body, **kwargs):  # noqa: E501
        """add collector  # noqa: E501

        add collector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_collector(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Collector body: (required)
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_collector_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_collector_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_collector_with_http_info(self, body, **kwargs):  # noqa: E501
        """add collector  # noqa: E501

        add collector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_collector_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Collector body: (required)
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_collector" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_collector`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Collector'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_collector_group(self, body, **kwargs):  # noqa: E501
        """Add collector group  # noqa: E501

        Create a new collector group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_collector_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CollectorGroup body: (required)
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_collector_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_collector_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_collector_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add collector group  # noqa: E501

        Create a new collector group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_collector_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CollectorGroup body: (required)
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_collector_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_collector_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_config_source(self, **kwargs):  # noqa: E501
        """Add a new config source  # noqa: E501

        Create a new config source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_config_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigSource body:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_config_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_config_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_config_source_with_http_info(self, **kwargs):  # noqa: E501
        """Add a new config source  # noqa: E501

        Create a new config source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_config_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigSource body:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_config_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dashboard(self, body, **kwargs):  # noqa: E501
        """add dashboard  # noqa: E501

        add dashboard  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Dashboard body: (required)
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_dashboard_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dashboard_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_dashboard_with_http_info(self, body, **kwargs):  # noqa: E501
        """add dashboard  # noqa: E501

        add dashboard  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Dashboard body: (required)
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dashboard" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_dashboard`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Dashboard'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dashboard_group(self, body, **kwargs):  # noqa: E501
        """add dashboard group  # noqa: E501

        add dashboard group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_dashboard_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dashboard_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_dashboard_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """add dashboard group  # noqa: E501

        add dashboard group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dashboard_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_dashboard_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dashboard_group_asynchronously(self, id, **kwargs):  # noqa: E501
        """add dashboard group asynchronously  # noqa: E501

        add dashboard group asynchronously  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard_group_asynchronously(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body:
        :param bool recursive:
        :return: RestDashboardGroupAsyncCloneResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_dashboard_group_asynchronously_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_dashboard_group_asynchronously_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def add_dashboard_group_asynchronously_with_http_info(self, id, **kwargs):  # noqa: E501
        """add dashboard group asynchronously  # noqa: E501

        add dashboard group asynchronously  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dashboard_group_asynchronously_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body:
        :param bool recursive:
        :return: RestDashboardGroupAsyncCloneResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'recursive']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dashboard_group_asynchronously" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `add_dashboard_group_asynchronously`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestDashboardGroupAsyncCloneResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups/{id}/asyncclone', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_datasource_by_id(self, **kwargs):  # noqa: E501
        """Add datasource  # noqa: E501

        Adds a new datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_datasource_by_id(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DataSource body:
        :param bool create_graph:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_datasource_by_id_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_datasource_by_id_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_datasource_by_id_with_http_info(self, **kwargs):  # noqa: E501
        """Add datasource  # noqa: E501

        Adds a new datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_datasource_by_id_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DataSource body:
        :param bool create_graph:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'create_graph']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'create_graph' in params:
            query_params.append(('createGraph', params['create_graph']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device(self, body, **kwargs):  # noqa: E501
        """add a new device (Request schema may change depending upon the type of uptime device being added)  # noqa: E501

        add a new device (Request schema may change depending upon the type of uptime device being added)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Device body: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param bool add_from_wizard:
        :param bool need_stc_grp_and_sorted_cp:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_device_with_http_info(self, body, **kwargs):  # noqa: E501
        """add a new device (Request schema may change depending upon the type of uptime device being added)  # noqa: E501

        add a new device (Request schema may change depending upon the type of uptime device being added)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Device body: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param bool add_from_wizard:
        :param bool need_stc_grp_and_sorted_cp:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'end', 'netflow_filter', 'start', 'add_from_wizard', 'need_stc_grp_and_sorted_cp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'add_from_wizard' in params:
            query_params.append(('addFromWizard', params['add_from_wizard']))  # noqa: E501
        if 'need_stc_grp_and_sorted_cp' in params:
            query_params.append(('needStcGrpAndSortedCP', params['need_stc_grp_and_sorted_cp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Device'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device_datasource_instance(self, device_id, hds_id, body, **kwargs):  # noqa: E501
        """add device instance  # noqa: E501

        add device instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_datasource_instance(device_id, hds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param DeviceDataSourceInstance body: (required)
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_datasource_instance_with_http_info(device_id, hds_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_datasource_instance_with_http_info(device_id, hds_id, body, **kwargs)  # noqa: E501
            return data

    def add_device_datasource_instance_with_http_info(self, device_id, hds_id, body, **kwargs):  # noqa: E501
        """add device instance  # noqa: E501

        add device instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_datasource_instance_with_http_info(device_id, hds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param DeviceDataSourceInstance body: (required)
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device_datasource_instance" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `add_device_datasource_instance`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `add_device_datasource_instance`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device_datasource_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstance'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device_datasource_instance_group(self, device_ds_id, device_id, body, **kwargs):  # noqa: E501
        """Add device datasource instance group  # noqa: E501

        Add a new device datasource instance group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_datasource_instance_group(device_ds_id, device_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_datasource_instance_group_with_http_info(device_ds_id, device_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_datasource_instance_group_with_http_info(device_ds_id, device_id, body, **kwargs)  # noqa: E501
            return data

    def add_device_datasource_instance_group_with_http_info(self, device_ds_id, device_id, body, **kwargs):  # noqa: E501
        """Add device datasource instance group  # noqa: E501

        Add a new device datasource instance group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_datasource_instance_group_with_http_info(device_ds_id, device_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_ds_id', 'device_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device_datasource_instance_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `add_device_datasource_instance_group`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `add_device_datasource_instance_group`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device_datasource_instance_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device_group(self, body, **kwargs):  # noqa: E501
        """add device group  # noqa: E501

        add device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceGroup body: (required)
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_device_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """add device group  # noqa: E501

        add device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceGroup body: (required)
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device_group_cluster_alert_conf(self, device_group_id, body, **kwargs):  # noqa: E501
        """Add cluster alert configuration  # noqa: E501

        Add cluster alert configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_group_cluster_alert_conf(device_group_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param DeviceClusterAlertConfig body: (required)
        :return: DeviceClusterAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_group_cluster_alert_conf_with_http_info(device_group_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_group_cluster_alert_conf_with_http_info(device_group_id, body, **kwargs)  # noqa: E501
            return data

    def add_device_group_cluster_alert_conf_with_http_info(self, device_group_id, body, **kwargs):  # noqa: E501
        """Add cluster alert configuration  # noqa: E501

        Add cluster alert configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_group_cluster_alert_conf_with_http_info(device_group_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param DeviceClusterAlertConfig body: (required)
        :return: DeviceClusterAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device_group_cluster_alert_conf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `add_device_group_cluster_alert_conf`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device_group_cluster_alert_conf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceClusterAlertConfig'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/clusterAlertConf', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device_group_property(self, gid, body, **kwargs):  # noqa: E501
        """Add device group property  # noqa: E501

        Add a new property to a specific device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_group_property(gid, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_group_property_with_http_info(gid, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_group_property_with_http_info(gid, body, **kwargs)  # noqa: E501
            return data

    def add_device_group_property_with_http_info(self, gid, body, **kwargs):  # noqa: E501
        """Add device group property  # noqa: E501

        Add a new property to a specific device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_group_property_with_http_info(gid, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device_group_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `add_device_group_property`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device_group_property`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_device_property(self, device_id, body, **kwargs):  # noqa: E501
        """Add device property  # noqa: E501

        Add a new property to a specific device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_property(device_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_device_property_with_http_info(device_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_device_property_with_http_info(device_id, body, **kwargs)  # noqa: E501
            return data

    def add_device_property_with_http_info(self, device_id, body, **kwargs):  # noqa: E501
        """Add device property  # noqa: E501

        Add a new property to a specific device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_device_property_with_http_info(device_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_device_property" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `add_device_property`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_device_property`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_diagnostic_source(self, **kwargs):  # noqa: E501
        """Add diagnostics source  # noqa: E501

        Adds a new diagnostics source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_diagnostic_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DiagnosticsSource body:
        :return: DiagnosticsSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_diagnostic_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_diagnostic_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_diagnostic_source_with_http_info(self, **kwargs):  # noqa: E501
        """Add diagnostics source  # noqa: E501

        Adds a new diagnostics source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_diagnostic_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DiagnosticsSource body:
        :return: DiagnosticsSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_diagnostic_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DiagnosticsSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/diagnosticsources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_dns_mapping(self, **kwargs):  # noqa: E501
        """Add DNS mapping  # noqa: E501

        Add a new DNS mapping  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dns_mapping(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestDNSMappingV3 body:
        :return: RestDNSMappingV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_dns_mapping_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_dns_mapping_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_dns_mapping_with_http_info(self, **kwargs):  # noqa: E501
        """Add DNS mapping  # noqa: E501

        Add a new DNS mapping  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_dns_mapping_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestDNSMappingV3 body:
        :return: RestDNSMappingV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_dns_mapping" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestDNSMappingV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/dnsmappings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_escalation_chain(self, body, **kwargs):  # noqa: E501
        """Add escalation chain  # noqa: E501

        Create a new escalation chain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_escalation_chain(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_escalation_chain_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_escalation_chain_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_escalation_chain_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add escalation chain  # noqa: E501

        Create a new escalation chain  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_escalation_chain_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_escalation_chain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_escalation_chain`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EscalatingChain'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/chains', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_event_source(self, **kwargs):  # noqa: E501
        """Add event source  # noqa: E501

        Adds a new event source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_event_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EventSource body:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_event_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_event_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_event_source_with_http_info(self, **kwargs):  # noqa: E501
        """Add event source  # noqa: E501

        Adds a new event source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_event_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EventSource body:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_event_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EventSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_job_monitor(self, **kwargs):  # noqa: E501
        """Add JobMonitor  # noqa: E501

        Create a new JobMonitor  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_job_monitor(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchJob body:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_job_monitor_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_job_monitor_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_job_monitor_with_http_info(self, **kwargs):  # noqa: E501
        """Add JobMonitor  # noqa: E501

        Create a new JobMonitor  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_job_monitor_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BatchJob body:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_job_monitor" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'BatchJob'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_log_query_group(self, body, **kwargs):  # noqa: E501
        """Create a new log query group  # noqa: E501

        Add a log query group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_log_query_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogQueryGroup body: (required)
        :return: LogQueryGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_log_query_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_log_query_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_log_query_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new log query group  # noqa: E501

        Add a log query group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_log_query_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogQueryGroup body: (required)
        :return: LogQueryGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_log_query_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_log_query_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogQueryGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/logquerygroups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_log_source(self, **kwargs):  # noqa: E501
        """Add log source  # noqa: E501

        Adds a new log source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_log_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogSource body:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_log_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_log_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_log_source_with_http_info(self, **kwargs):  # noqa: E501
        """Add log source  # noqa: E501

        Adds a new log source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_log_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogSource body:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_log_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_netscan(self, **kwargs):  # noqa: E501
        """Add a new netscan  # noqa: E501

        Create a new netscan  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_netscan(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Netscan body:
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_netscan_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_netscan_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_netscan_with_http_info(self, **kwargs):  # noqa: E501
        """Add a new netscan  # noqa: E501

        Create a new netscan  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_netscan_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Netscan body:
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_netscan" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Netscan'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/netscans', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_oid(self, **kwargs):  # noqa: E501
        """Add a new OID  # noqa: E501

        Create a new OID and add it to the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_oid(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_oid_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_oid_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_oid_with_http_info(self, **kwargs):  # noqa: E501
        """Add a new OID  # noqa: E501

        Create a new OID and add it to the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_oid_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_oid" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestOidV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_ops_note(self, body, **kwargs):  # noqa: E501
        """add opsnote  # noqa: E501

        add opsnote  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ops_note(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OpsNote body: (required)
        :return: OpsNote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_ops_note_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_ops_note_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_ops_note_with_http_info(self, body, **kwargs):  # noqa: E501
        """add opsnote  # noqa: E501

        add opsnote  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ops_note_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OpsNote body: (required)
        :return: OpsNote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_ops_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_ops_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'OpsNote'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/opsnotes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_property_rule(self, **kwargs):  # noqa: E501
        """Add a new property rule  # noqa: E501

        Creates a new property rule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_property_rule(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PropertyRule body:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_property_rule_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_property_rule_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_property_rule_with_http_info(self, **kwargs):  # noqa: E501
        """Add a new property rule  # noqa: E501

        Creates a new property rule in the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_property_rule_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PropertyRule body:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_property_rule" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_recipient_group(self, body, **kwargs):  # noqa: E501
        """Add recipient group  # noqa: E501

        Add a new recipient group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_recipient_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_recipient_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_recipient_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_recipient_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add recipient group  # noqa: E501

        Add a new recipient group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_recipient_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_recipient_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_recipient_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RecipientGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/recipientgroups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_remediation_source(self, **kwargs):  # noqa: E501
        """Add remediation source  # noqa: E501

        Adds a new remediation source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_remediation_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RemediationSource body:
        :return: RemediationSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_remediation_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_remediation_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_remediation_source_with_http_info(self, **kwargs):  # noqa: E501
        """Add remediation source  # noqa: E501

        Adds a new remediation source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_remediation_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RemediationSource body:
        :return: RemediationSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_remediation_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RemediationSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/remediationsources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_report(self, body, **kwargs):  # noqa: E501
        """Add report  # noqa: E501

        Create a new report  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_report(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_report_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_report_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_report_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add report  # noqa: E501

        Create a new report  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_report_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportBase'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_report_group(self, body, **kwargs):  # noqa: E501
        """Add report group  # noqa: E501

        Add a new report group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_report_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_report_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_report_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_report_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add report group  # noqa: E501

        Add a new report group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_report_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_report_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_report_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_role(self, body, **kwargs):  # noqa: E501
        """Add role  # noqa: E501

        Create a new role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_role(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_role_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_role_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_role_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add role  # noqa: E501

        Create a new role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_role_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_role" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Role'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_sdt(self, body, **kwargs):  # noqa: E501
        """add SDT (Response may contain extra fields depending upon the type of SDT being added)  # noqa: E501

        add SDT (Response may contain extra fields depending upon the type of SDT being added)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_sdt(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_sdt_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_sdt_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_sdt_with_http_info(self, body, **kwargs):  # noqa: E501
        """add SDT (Response may contain extra fields depending upon the type of SDT being added)  # noqa: E501

        add SDT (Response may contain extra fields depending upon the type of SDT being added)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_sdt_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_sdt" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_sdt`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDT'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_topology_source(self, **kwargs):  # noqa: E501
        """Add TopologySource  # noqa: E501

        Add TopologySource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_topology_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopologySource body:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_topology_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_topology_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_topology_source_with_http_info(self, **kwargs):  # noqa: E501
        """Add TopologySource  # noqa: E501

        Add TopologySource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_topology_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TopologySource body:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_topology_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'TopologySource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_website(self, body, **kwargs):  # noqa: E501
        """Add website  # noqa: E501

        Add website. Request structure may vary based on the check type {PingCheck | WebCheck model}. Use the respective model in SDK.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_website(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Website body: (required)
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_website_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_website_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_website_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add website  # noqa: E501

        Add website. Request structure may vary based on the check type {PingCheck | WebCheck model}. Use the respective model in SDK.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_website_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Website body: (required)
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_website" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_website`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Website'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_website_group(self, body, **kwargs):  # noqa: E501
        """add website group  # noqa: E501

        add website group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_website_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebsiteGroup body: (required)
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_website_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_website_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_website_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """add website group  # noqa: E501

        add website group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_website_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebsiteGroup body: (required)
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_website_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_website_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_widget(self, body, **kwargs):  # noqa: E501
        """Add widget  # noqa: E501

        Adds a new widget. Based on widget type, the request and response may contain additional attributes. Please refer to the models corresponding to specific widget types at the bottom of this page for detailed attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_widget(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_widget_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_widget_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_widget_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add widget  # noqa: E501

        Adds a new widget. Based on widget type, the request and response may contain additional attributes. Please refer to the models corresponding to specific widget types at the bottom of this page for detailed attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_widget_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_widget" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_widget`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Widget'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def collect_device_config_source_config(self, instance_id, device_id, hds_id, **kwargs):  # noqa: E501
        """collect a config for a device  # noqa: E501

        collect a config for a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collect_device_config_source_config(instance_id, device_id, hds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int instance_id: (required)
        :param int device_id: (required)
        :param int hds_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.collect_device_config_source_config_with_http_info(instance_id, device_id, hds_id, **kwargs)  # noqa: E501
        else:
            (data) = self.collect_device_config_source_config_with_http_info(instance_id, device_id, hds_id, **kwargs)  # noqa: E501
            return data

    def collect_device_config_source_config_with_http_info(self, instance_id, device_id, hds_id, **kwargs):  # noqa: E501
        """collect a config for a device  # noqa: E501

        collect a config for a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collect_device_config_source_config_with_http_info(instance_id, device_id, hds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int instance_id: (required)
        :param int device_id: (required)
        :param int hds_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['instance_id', 'device_id', 'hds_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collect_device_config_source_config" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `collect_device_config_source_config`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `collect_device_config_source_config`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `collect_device_config_source_config`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/config/configCollection', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_log_partition(self, **kwargs):  # noqa: E501
        """Create a new log partition  # noqa: E501

        Create a new log partition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_log_partition(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogPartition body:
        :return: LogPartition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_log_partition_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_log_partition_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_log_partition_with_http_info(self, **kwargs):  # noqa: E501
        """Create a new log partition  # noqa: E501

        Create a new log partition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_log_partition_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LogPartition body:
        :return: LogPartition
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_log_partition" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogPartition'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/partitions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_access_group(self, id, **kwargs):  # noqa: E501
        """Delete access group  # noqa: E501

        Delete access group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_access_group(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_access_group_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_access_group_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_access_group_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete access group  # noqa: E501

        Delete access group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_access_group_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_access_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_access_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_admin_by_id(self, id, **kwargs):  # noqa: E501
        """delete user  # noqa: E501

        delete user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_admin_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_admin_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_admin_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_admin_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete user  # noqa: E501

        delete user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_admin_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_admin_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_admin_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_alert_rule_by_id(self, id, **kwargs):  # noqa: E501
        """delete alert rule  # noqa: E501

        delete alert rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_alert_rule_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_alert_rule_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_alert_rule_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_alert_rule_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete alert rule  # noqa: E501

        delete alert rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_alert_rule_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_alert_rule_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_alert_rule_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_api_token_by_id(self, admin_id, apitoken_id, **kwargs):  # noqa: E501
        """Delete API token  # noqa: E501

        Delete a specific API token by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_api_token_by_id(admin_id, apitoken_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param int apitoken_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_api_token_by_id_with_http_info(admin_id, apitoken_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_api_token_by_id_with_http_info(admin_id, apitoken_id, **kwargs)  # noqa: E501
            return data

    def delete_api_token_by_id_with_http_info(self, admin_id, apitoken_id, **kwargs):  # noqa: E501
        """Delete API token  # noqa: E501

        Delete a specific API token by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_api_token_by_id_with_http_info(admin_id, apitoken_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param int apitoken_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['admin_id', 'apitoken_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_api_token_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'admin_id' is set
        if ('admin_id' not in params or
                params['admin_id'] is None):
            raise ValueError("Missing the required parameter `admin_id` when calling `delete_api_token_by_id`")  # noqa: E501
        # verify the required parameter 'apitoken_id' is set
        if ('apitoken_id' not in params or
                params['apitoken_id'] is None):
            raise ValueError("Missing the required parameter `apitoken_id` when calling `delete_api_token_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'admin_id' in params:
            path_params['adminId'] = params['admin_id']  # noqa: E501
        if 'apitoken_id' in params:
            path_params['apitokenId'] = params['apitoken_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{adminId}/apitokens/{apitokenId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_applies_to_function_by_id(self, id, **kwargs):  # noqa: E501
        """Delete applies to function  # noqa: E501

        Delete a specific applies to function by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_applies_to_function_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool ignore_reference:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_applies_to_function_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_applies_to_function_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_applies_to_function_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete applies to function  # noqa: E501

        Delete a specific applies to function by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_applies_to_function_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool ignore_reference:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'ignore_reference']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_applies_to_function_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_applies_to_function_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'ignore_reference' in params:
            query_params.append(('ignoreReference', params['ignore_reference']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_collector_by_id(self, id, **kwargs):  # noqa: E501
        """delete collector  # noqa: E501

        delete collector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_collector_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_collector_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_collector_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_collector_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete collector  # noqa: E501

        delete collector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_collector_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_collector_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_collector_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_collector_group_by_id(self, id, **kwargs):  # noqa: E501
        """Delete collector group  # noqa: E501

        Delete a specific collector group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_collector_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_collector_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_collector_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_collector_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete collector group  # noqa: E501

        Delete a specific collector group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_collector_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_collector_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_collector_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_config_source_by_id(self, id, **kwargs):  # noqa: E501
        """Delete config source by ID  # noqa: E501

        Delete a config source based on the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_config_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete config source by ID  # noqa: E501

        Delete a config source based on the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_config_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_config_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dashboard_by_id(self, id, **kwargs):  # noqa: E501
        """delete dashboard  # noqa: E501

        delete dashboard  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dashboard_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dashboard_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dashboard_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_dashboard_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete dashboard  # noqa: E501

        delete dashboard  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dashboard_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dashboard_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_dashboard_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dashboard_group_by_id(self, id, **kwargs):  # noqa: E501
        """delete dashboard group  # noqa: E501

        delete dashboard group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dashboard_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool allow_non_empty_group:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dashboard_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dashboard_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_dashboard_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete dashboard group  # noqa: E501

        delete dashboard group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dashboard_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool allow_non_empty_group:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'allow_non_empty_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dashboard_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_dashboard_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'allow_non_empty_group' in params:
            query_params.append(('allowNonEmptyGroup', params['allow_non_empty_group']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_datasource_by_id(self, id, **kwargs):  # noqa: E501
        """Delete datasource  # noqa: E501

        Deletes a datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_datasource_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_datasource_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete datasource  # noqa: E501

        Deletes a datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_datasource_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device_by_id(self, id, **kwargs):  # noqa: E501
        """delete a device  # noqa: E501

        delete a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param bool delete_hard:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_device_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete a device  # noqa: E501

        delete a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param bool delete_hard:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'netflow_filter', 'start', 'delete_hard']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_device_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'delete_hard' in params:
            query_params.append(('deleteHard', params['delete_hard']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device_datasource_instance_by_id(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """delete a device instance  # noqa: E501

        delete a device instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_datasource_instance_by_id(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
            return data

    def delete_device_datasource_instance_by_id_with_http_info(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """delete a device instance  # noqa: E501

        delete a device instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_datasource_instance_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `delete_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `delete_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_device_datasource_instance_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device_group_by_id(self, id, **kwargs):  # noqa: E501
        """delete device group  # noqa: E501

        delete device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool delete_children:
        :param bool delete_hard:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_device_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete device group  # noqa: E501

        delete device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool delete_children:
        :param bool delete_hard:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'delete_children', 'delete_hard']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_device_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'delete_children' in params:
            query_params.append(('deleteChildren', params['delete_children']))  # noqa: E501
        if 'delete_hard' in params:
            query_params.append(('deleteHard', params['delete_hard']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device_group_cluster_alert_conf_by_id(self, device_group_id, id, **kwargs):  # noqa: E501
        """Delete cluster alert configuration  # noqa: E501

        Delete cluster alert configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_group_cluster_alert_conf_by_id(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
            return data

    def delete_device_group_cluster_alert_conf_by_id_with_http_info(self, device_group_id, id, **kwargs):  # noqa: E501
        """Delete cluster alert configuration  # noqa: E501

        Delete cluster alert configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_group_cluster_alert_conf_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `delete_device_group_cluster_alert_conf_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_device_group_cluster_alert_conf_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/clusterAlertConf/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device_group_property_by_name(self, gid, name, **kwargs):  # noqa: E501
        """Delete device group property  # noqa: E501

        Delete a specific property of a device group by its name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_group_property_by_name(gid, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_group_property_by_name_with_http_info(gid, name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_group_property_by_name_with_http_info(gid, name, **kwargs)  # noqa: E501
            return data

    def delete_device_group_property_by_name_with_http_info(self, gid, name, **kwargs):  # noqa: E501
        """Delete device group property  # noqa: E501

        Delete a specific property of a device group by its name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_group_property_by_name_with_http_info(gid, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_group_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `delete_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_device_group_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device_property_by_name(self, device_id, name, **kwargs):  # noqa: E501
        """Delete device property  # noqa: E501

        Delete a specific property of a device by its name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_property_by_name(device_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_property_by_name_with_http_info(device_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_property_by_name_with_http_info(device_id, name, **kwargs)  # noqa: E501
            return data

    def delete_device_property_by_name_with_http_info(self, device_id, name, **kwargs):  # noqa: E501
        """Delete device property  # noqa: E501

        Delete a specific property of a device by its name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_property_by_name_with_http_info(device_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `delete_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_device_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_diagnostic_source_by_id(self, id, **kwargs):  # noqa: E501
        """Delete a diagnostic source module  # noqa: E501

        Deletes a diagnostic source module by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_diagnostic_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_diagnostic_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_diagnostic_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_diagnostic_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a diagnostic source module  # noqa: E501

        Deletes a diagnostic source module by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_diagnostic_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_diagnostic_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_diagnostic_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/diagnosticsources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_escalation_chain_by_id(self, id, **kwargs):  # noqa: E501
        """Delete escalation chain  # noqa: E501

        Delete a specific escalation chain by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_escalation_chain_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_escalation_chain_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_escalation_chain_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_escalation_chain_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete escalation chain  # noqa: E501

        Delete a specific escalation chain by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_escalation_chain_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_escalation_chain_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_escalation_chain_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/chains/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_event_source_by_id(self, id, **kwargs):  # noqa: E501
        """Delete event source by ID  # noqa: E501

        Deletes an event source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_event_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_event_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete event source by ID  # noqa: E501

        Deletes an event source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_event_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_event_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_event_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_job_monitor(self, id, **kwargs):  # noqa: E501
        """Delete JobMonitor  # noqa: E501

        Delete a specific JobMonitor by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_job_monitor(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_job_monitor_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete JobMonitor  # noqa: E501

        Delete a specific JobMonitor by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_job_monitor_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_job_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_job_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_log_partition_by_id(self, id, **kwargs):  # noqa: E501
        """Delete a log partition by ID  # noqa: E501

        Delete a log partition by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_log_partition_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_log_partition_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_log_partition_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_log_partition_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a log partition by ID  # noqa: E501

        Delete a log partition by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_log_partition_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_log_partition_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_log_partition_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/partitions/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_log_query_group(self, id, **kwargs):  # noqa: E501
        """Delete log query group  # noqa: E501

        Delete log query group by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_log_query_group(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_log_query_group_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_log_query_group_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_log_query_group_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete log query group  # noqa: E501

        Delete log query group by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_log_query_group_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_log_query_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_log_query_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/logquerygroups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_log_source(self, id, **kwargs):  # noqa: E501
        """Delete log source  # noqa: E501

        Deletes an existing log source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_log_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_log_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_log_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_log_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete log source  # noqa: E501

        Deletes an existing log source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_log_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_log_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_log_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_netscan_by_id(self, id, **kwargs):  # noqa: E501
        """Delete a netscan  # noqa: E501

        Delete a specific netscan by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_netscan_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_netscan_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_netscan_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_netscan_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a netscan  # noqa: E501

        Delete a specific netscan by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_netscan_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_netscan_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_netscan_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/netscans/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_oid(self, id, **kwargs):  # noqa: E501
        """Delete an OID  # noqa: E501

        Delete an existing OID from the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_oid(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_oid_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_oid_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_oid_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete an OID  # noqa: E501

        Delete an existing OID from the system  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_oid_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_oid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_oid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ops_note_by_id(self, id, **kwargs):  # noqa: E501
        """delete opsnote  # noqa: E501

        delete opsnote  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ops_note_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ops_note_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ops_note_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_ops_note_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete opsnote  # noqa: E501

        delete opsnote  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ops_note_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ops_note_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_ops_note_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/opsnotes/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_property_rule(self, id, **kwargs):  # noqa: E501
        """delete a property rule  # noqa: E501

        Delete a property rule by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_property_rule(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_property_rule_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_property_rule_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_property_rule_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete a property rule  # noqa: E501

        Delete a property rule by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_property_rule_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_property_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_property_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_recipient_group_by_id(self, id, **kwargs):  # noqa: E501
        """Delete recipient group  # noqa: E501

        Delete a specific recipient group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_recipient_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_recipient_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_recipient_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_recipient_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete recipient group  # noqa: E501

        Delete a specific recipient group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_recipient_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_recipient_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_recipient_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/recipientgroups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_remediation_source_by_id(self, id, **kwargs):  # noqa: E501
        """Delete a remediation source module  # noqa: E501

        Deletes a remediation source module by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_remediation_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_remediation_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_remediation_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_remediation_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a remediation source module  # noqa: E501

        Deletes a remediation source module by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_remediation_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_remediation_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_remediation_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/remediationsources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_report_by_id(self, id, **kwargs):  # noqa: E501
        """Delete report  # noqa: E501

        Delete a specific report by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_report_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_report_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete report  # noqa: E501

        Delete a specific report by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_report_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_report_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_report_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_report_group_by_id(self, id, **kwargs):  # noqa: E501
        """Delete report group  # noqa: E501

        Delete a specific report group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_report_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_report_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_report_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_report_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete report group  # noqa: E501

        Delete a specific report group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_report_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_report_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_report_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_role_by_id(self, id, **kwargs):  # noqa: E501
        """Delete role  # noqa: E501

        Delete a specific role by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_role_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_role_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_role_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_role_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete role  # noqa: E501

        Delete a specific role by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_role_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_role_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_role_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_sdt_by_id(self, id, **kwargs):  # noqa: E501
        """delete SDT  # noqa: E501

        delete SDT  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_sdt_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_sdt_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_sdt_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_sdt_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete SDT  # noqa: E501

        delete SDT  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_sdt_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_sdt_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_sdt_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_topology_source(self, id, **kwargs):  # noqa: E501
        """Delete TopologySource  # noqa: E501

        Delete TopologySource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_topology_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_topology_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_topology_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_topology_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete TopologySource  # noqa: E501

        Delete TopologySource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_topology_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_topology_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_topology_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_website_by_id(self, id, **kwargs):  # noqa: E501
        """delete website  # noqa: E501

        delete website  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_website_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_website_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_website_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_website_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete website  # noqa: E501

        delete website  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_website_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_website_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_website_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_website_group_by_id(self, id, **kwargs):  # noqa: E501
        """delete website group  # noqa: E501

        delete website group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_website_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int delete_children:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_website_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_website_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_website_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete website group  # noqa: E501

        delete website group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_website_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int delete_children:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'delete_children']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_website_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_website_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'delete_children' in params:
            query_params.append(('deleteChildren', params['delete_children']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_widget_by_id(self, id, **kwargs):  # noqa: E501
        """Delete widget  # noqa: E501

        Deletes a widget by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_widget_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_widget_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_widget_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_widget_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete widget  # noqa: E501

        Deletes a widget by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_widget_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_widget_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_widget_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def discover_subscriptions(self, body, **kwargs):  # noqa: E501
        """view subscriptions  # noqa: E501

        view subscriptions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.discover_subscriptions(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureSubscriptionsDiscoverV3 body: (required)
        :return: AzureSubscriptionIdPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.discover_subscriptions_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.discover_subscriptions_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def discover_subscriptions_with_http_info(self, body, **kwargs):  # noqa: E501
        """view subscriptions  # noqa: E501

        view subscriptions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.discover_subscriptions_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureSubscriptionsDiscoverV3 body: (required)
        :return: AzureSubscriptionIdPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method discover_subscriptions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `discover_subscriptions`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AzureSubscriptionIdPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/azure/functions/discoverSubscriptions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def escalated_alert_by_id(self, id, **kwargs):  # noqa: E501
        """Escalate alert by ID  # noqa: E501

        Escalate the alert with the given ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.escalated_alert_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.escalated_alert_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.escalated_alert_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def escalated_alert_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Escalate alert by ID  # noqa: E501

        Escalate the alert with the given ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.escalated_alert_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method escalated_alert_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `escalated_alert_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/alert/alerts/{id}/escalate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execute_debug_command(self, **kwargs):  # noqa: E501
        """Execute a Collector debug command  # noqa: E501

        Execute a Collector debug command  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_debug_command(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Debug body:
        :param int collector_id:
        :return: Debug
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.execute_debug_command_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.execute_debug_command_with_http_info(**kwargs)  # noqa: E501
            return data

    def execute_debug_command_with_http_info(self, **kwargs):  # noqa: E501
        """Execute a Collector debug command  # noqa: E501

        Execute a Collector debug command  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_debug_command_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Debug body:
        :param int collector_id:
        :return: Debug
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'collector_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_debug_command" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'collector_id' in params:
            query_params.append(('collectorId', params['collector_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Debug'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/debug', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execute_diagnostics_manually(self, **kwargs):  # noqa: E501
        """Trigger a diagnostic module for host.  # noqa: E501

        Trigger a diagnostic module for host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_diagnostics_manually(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DiagnosticsSourceExecution body:
        :return: DiagnosticsSourceExecution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.execute_diagnostics_manually_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.execute_diagnostics_manually_with_http_info(**kwargs)  # noqa: E501
            return data

    def execute_diagnostics_manually_with_http_info(self, **kwargs):  # noqa: E501
        """Trigger a diagnostic module for host.  # noqa: E501

        Trigger a diagnostic module for host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_diagnostics_manually_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DiagnosticsSourceExecution body:
        :return: DiagnosticsSourceExecution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_diagnostics_manually" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DiagnosticsSourceExecution'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/diagnosticsources/executemanually', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execute_remediation_manually(self, **kwargs):  # noqa: E501
        """Trigger a remediation module for host.  # noqa: E501

        Trigger a remediation module for host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_remediation_manually(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RemediationSourceExecution body:
        :return: RemediationSourceExecution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.execute_remediation_manually_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.execute_remediation_manually_with_http_info(**kwargs)  # noqa: E501
            return data

    def execute_remediation_manually_with_http_info(self, **kwargs):  # noqa: E501
        """Trigger a remediation module for host.  # noqa: E501

        Trigger a remediation module for host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_remediation_manually_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RemediationSourceExecution body:
        :return: RemediationSourceExecution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_remediation_manually" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RemediationSourceExecution'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/remediationsources/executemanually', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_device_instances_data(self, body, **kwargs):  # noqa: E501
        """Fetch device instances data  # noqa: E501

        Retrieve a paginated list of data for device instances  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_device_instances_data(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceInstances body: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str aggregate: The aggregate option
        :return: DeviceInstanceDataPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.fetch_device_instances_data_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.fetch_device_instances_data_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def fetch_device_instances_data_with_http_info(self, body, **kwargs):  # noqa: E501
        """Fetch device instances data  # noqa: E501

        Retrieve a paginated list of data for device instances  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_device_instances_data_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceInstances body: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str aggregate: The aggregate option
        :return: DeviceInstanceDataPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'period', 'start', 'end', 'aggregate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_device_instances_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `fetch_device_instances_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'aggregate' in params:
            query_params.append(('aggregate', params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceInstanceDataPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/instances/datafetch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_report_using_task_id(self, id, task_id, **kwargs):  # noqa: E501
        """Get report for task ID  # noqa: E501

        Fetch the report associated with a specific task ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_report_using_task_id(id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str task_id: (required)
        :return: GenerateReportResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.fetch_report_using_task_id_with_http_info(id, task_id, **kwargs)  # noqa: E501
        else:
            (data) = self.fetch_report_using_task_id_with_http_info(id, task_id, **kwargs)  # noqa: E501
            return data

    def fetch_report_using_task_id_with_http_info(self, id, task_id, **kwargs):  # noqa: E501
        """Get report for task ID  # noqa: E501

        Fetch the report associated with a specific task ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_report_using_task_id_with_http_info(id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str task_id: (required)
        :return: GenerateReportResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'task_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_report_using_task_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `fetch_report_using_task_id`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if ('task_id' not in params or
                params['task_id'] is None):
            raise ValueError("Missing the required parameter `task_id` when calling `fetch_report_using_task_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'task_id' in params:
            path_params['taskId'] = params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GenerateReportResult'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}/tasks/{taskId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_report_by_id(self, id, **kwargs):  # noqa: E501
        """Run a report  # noqa: E501

        Generate a report based on the given report ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_report_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param GenerateReportRequest body:
        :return: GenerateReportResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.generate_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.generate_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def generate_report_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Run a report  # noqa: E501

        Generate a report based on the given report ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_report_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param GenerateReportRequest body:
        :return: GenerateReportResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_report_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `generate_report_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GenerateReportResult'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}/executions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_group_by_id(self, id, **kwargs):  # noqa: E501
        """Get access group by id  # noqa: E501

        Get access group by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_access_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_access_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get access group by id  # noqa: E501

        Get access group by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_access_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_group_list(self, **kwargs):  # noqa: E501
        """Get access group list  # noqa: E501

        Get access group list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AccessGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_access_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_access_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get access group list  # noqa: E501

        Get access group list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AccessGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_admin_by_id(self, id, **kwargs):  # noqa: E501
        """get user  # noqa: E501

        get user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_admin_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_admin_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_admin_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get user  # noqa: E501

        get user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_admin_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_admin_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Admin'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_admin_list(self, **kwargs):  # noqa: E501
        """get user list  # noqa: E501

        get user list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type:
        :param str permission:
        :param str filter_group_string:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AdminPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_admin_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_admin_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_admin_list_with_http_info(self, **kwargs):  # noqa: E501
        """get user list  # noqa: E501

        get user list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type:
        :param str permission:
        :param str filter_group_string:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AdminPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'permission', 'filter_group_string', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_admin_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'permission' in params:
            query_params.append(('permission', params['permission']))  # noqa: E501
        if 'filter_group_string' in params:
            query_params.append(('filterGroupString', params['filter_group_string']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AdminPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_by_id(self, id, **kwargs):  # noqa: E501
        """get alert  # noqa: E501

        get alert by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :return: Alert
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_alert_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get alert  # noqa: E501

        get alert by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :return: Alert
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'need_message', 'custom_columns', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_alert_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'need_message' in params:
            query_params.append(('needMessage', params['need_message']))  # noqa: E501
        if 'custom_columns' in params:
            query_params.append(('customColumns', params['custom_columns']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Alert'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/alert/alerts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_list(self, **kwargs):  # noqa: E501
        """Get alert list  # noqa: E501

        Retrieve the list of alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertListPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_alert_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get alert list  # noqa: E501

        Retrieve the list of alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertListPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertListPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/alert/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_list_by_device_group_id(self, id, **kwargs):  # noqa: E501
        """get device group alerts  # noqa: E501

        get device group alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list_by_device_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_list_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_list_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_alert_list_by_device_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get device group alerts  # noqa: E501

        get device group alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list_by_device_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'need_message', 'custom_columns', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_list_by_device_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_alert_list_by_device_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'need_message' in params:
            query_params.append(('needMessage', params['need_message']))  # noqa: E501
        if 'custom_columns' in params:
            query_params.append(('customColumns', params['custom_columns']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_list_by_device_id(self, id, **kwargs):  # noqa: E501
        """get alerts  # noqa: E501

        get alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list_by_device_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param bool need_message:
        :param str custom_columns:
        :param str bound:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_list_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_list_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_alert_list_by_device_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get alerts  # noqa: E501

        get alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_list_by_device_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param bool need_message:
        :param str custom_columns:
        :param str bound:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'netflow_filter', 'start', 'need_message', 'custom_columns', 'bound', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_list_by_device_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_alert_list_by_device_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'need_message' in params:
            query_params.append(('needMessage', params['need_message']))  # noqa: E501
        if 'custom_columns' in params:
            query_params.append(('customColumns', params['custom_columns']))  # noqa: E501
        if 'bound' in params:
            query_params.append(('bound', params['bound']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_rule_by_id(self, id, **kwargs):  # noqa: E501
        """get alert rule by id  # noqa: E501

        get alert rule by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_rule_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_rule_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_rule_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_alert_rule_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get alert rule by id  # noqa: E501

        get alert rule by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_rule_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_rule_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_alert_rule_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_rule_list(self, **kwargs):  # noqa: E501
        """get alert rule list  # noqa: E501

        get alert rule list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_rule_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertRulePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alert_rule_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_alert_rule_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_alert_rule_list_with_http_info(self, **kwargs):  # noqa: E501
        """get alert rule list  # noqa: E501

        get alert rule list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_rule_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertRulePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_rule_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertRulePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_log_partitions(self, **kwargs):  # noqa: E501
        """Retrieve a list of all log partitions  # noqa: E501

        Retrieve a list of all log partitions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_log_partitions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Pagination
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_log_partitions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_log_partitions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_log_partitions_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a list of all log partitions  # noqa: E501

        Retrieve a list of all log partitions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_log_partitions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Pagination
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_log_partitions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Pagination'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/partitions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_sdt_list_by_device_id(self, id, **kwargs):  # noqa: E501
        """get SDTs for a device  # noqa: E501

        get SDTs for a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_sdt_list_by_device_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_sdt_list_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_sdt_list_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_all_sdt_list_by_device_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get SDTs for a device  # noqa: E501

        get SDTs for a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_sdt_list_by_device_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'netflow_filter', 'start', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_sdt_list_by_device_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_all_sdt_list_by_device_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDTPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/sdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_sdt_list_by_website_group_id(self, id, **kwargs):  # noqa: E501
        """get a list of SDTs for a website group (Response may contain extra fields depending upon the type of SDT)  # noqa: E501

        get a list of SDTs for a website group (Response may contain extra fields depending upon the type of SDT)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_sdt_list_by_website_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_sdt_list_by_website_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_sdt_list_by_website_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_all_sdt_list_by_website_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get a list of SDTs for a website group (Response may contain extra fields depending upon the type of SDT)  # noqa: E501

        get a list of SDTs for a website group (Response may contain extra fields depending upon the type of SDT)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_sdt_list_by_website_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_sdt_list_by_website_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_all_sdt_list_by_website_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDTPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}/sdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_api_token_list(self, **kwargs):  # noqa: E501
        """Get a list of API tokens across users  # noqa: E501

        Retrieve a paginated list of API tokens for all users  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_token_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type:
        :param str permission:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ApiTokenPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_api_token_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_api_token_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_api_token_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of API tokens across users  # noqa: E501

        Retrieve a paginated list of API tokens for all users  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_token_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type:
        :param str permission:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ApiTokenPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'permission', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_api_token_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'permission' in params:
            query_params.append(('permission', params['permission']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ApiTokenPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/apitokens', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_api_token_list_by_admin_id(self, admin_id, **kwargs):  # noqa: E501
        """Get API tokens for a user  # noqa: E501

        Retrieve a paginated list of API tokens for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_token_list_by_admin_id(admin_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param str type:
        :param str permission:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ApiTokenPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_api_token_list_by_admin_id_with_http_info(admin_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_api_token_list_by_admin_id_with_http_info(admin_id, **kwargs)  # noqa: E501
            return data

    def get_api_token_list_by_admin_id_with_http_info(self, admin_id, **kwargs):  # noqa: E501
        """Get API tokens for a user  # noqa: E501

        Retrieve a paginated list of API tokens for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_api_token_list_by_admin_id_with_http_info(admin_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param str type:
        :param str permission:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ApiTokenPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['admin_id', 'type', 'permission', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_api_token_list_by_admin_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'admin_id' is set
        if ('admin_id' not in params or
                params['admin_id'] is None):
            raise ValueError("Missing the required parameter `admin_id` when calling `get_api_token_list_by_admin_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'admin_id' in params:
            path_params['adminId'] = params['admin_id']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'permission' in params:
            query_params.append(('permission', params['permission']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ApiTokenPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{adminId}/apitokens', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_applies_to_function_by_id(self, id, **kwargs):  # noqa: E501
        """Get applies to function by ID  # noqa: E501

        Retrieve a specific applies to function using its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applies_to_function_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_applies_to_function_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_applies_to_function_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_applies_to_function_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get applies to function by ID  # noqa: E501

        Retrieve a specific applies to function using its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applies_to_function_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_applies_to_function_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_applies_to_function_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AppliesToFunction'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_applies_to_function_list(self, **kwargs):  # noqa: E501
        """Get applies to function list  # noqa: E501

        Retrieve a paginated list of functions that apply  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applies_to_function_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RestAppliesToFunctionPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_applies_to_function_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_applies_to_function_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_applies_to_function_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get applies to function list  # noqa: E501

        Retrieve a paginated list of functions that apply  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applies_to_function_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RestAppliesToFunctionPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_applies_to_function_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestAppliesToFunctionPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_associated_device_list_by_data_source_id(self, id, **kwargs):  # noqa: E501
        """Get devices associated with a datasource  # noqa: E501

        Retrieves the list of devices associated with a specific datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_associated_device_list_by_data_source_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDataSourceAssociatedPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_associated_device_list_by_data_source_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_associated_device_list_by_data_source_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_associated_device_list_by_data_source_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get devices associated with a datasource  # noqa: E501

        Retrieves the list of devices associated with a specific datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_associated_device_list_by_data_source_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDataSourceAssociatedPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_associated_device_list_by_data_source_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_associated_device_list_by_data_source_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceAssociatedPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_audit_log_by_id(self, id, **kwargs):  # noqa: E501
        """Get audit log by id  # noqa: E501

        Retrieve a specific audit log by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_audit_log_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: AuditLog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_audit_log_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_audit_log_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_audit_log_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get audit log by id  # noqa: E501

        Retrieve a specific audit log by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_audit_log_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: AuditLog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_audit_log_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_audit_log_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AuditLog'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accesslogs/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_audit_log_list(self, **kwargs):  # noqa: E501
        """Get audit logs  # noqa: E501

        Retrieve a paginated list of audit logs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_audit_log_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AccessLogPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_audit_log_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_audit_log_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_audit_log_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get audit logs  # noqa: E501

        Retrieve a paginated list of audit logs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_audit_log_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AccessLogPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_audit_log_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessLogPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accesslogs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aws_account_id(self, **kwargs):  # noqa: E501
        """Get AWS account ID  # noqa: E501

        Retrieve the AWS account ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aws_account_id(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsAccountId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aws_account_id_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_aws_account_id_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_aws_account_id_with_http_info(self, **kwargs):  # noqa: E501
        """Get AWS account ID  # noqa: E501

        Retrieve the AWS account ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aws_account_id_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsAccountId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aws_account_id" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AwsAccountId'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/aws/accountId', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aws_external_id(self, **kwargs):  # noqa: E501
        """Get AWS external ID  # noqa: E501

        Retrieve the AWS external ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aws_external_id(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsExternalId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aws_external_id_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_aws_external_id_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_aws_external_id_with_http_info(self, **kwargs):  # noqa: E501
        """Get AWS external ID  # noqa: E501

        Retrieve the AWS external ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aws_external_id_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AwsExternalId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aws_external_id" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AwsExternalId'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/aws/externalId', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_by_id(self, id, **kwargs):  # noqa: E501
        """get collector  # noqa: E501

        get collector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_collector_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get collector  # noqa: E501

        get collector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_collector_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Collector'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_group_by_id(self, id, **kwargs):  # noqa: E501
        """Get collector group  # noqa: E501

        Retrieve details of a specific collector group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_collector_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get collector group  # noqa: E501

        Retrieve details of a specific collector group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_collector_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_group_list(self, **kwargs):  # noqa: E501
        """Get collector group list  # noqa: E501

        Retrieve a paginated list of collector groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_collector_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get collector group list  # noqa: E501

        Retrieve a paginated list of collector groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_installer(self, collector_id, os_and_arch, **kwargs):  # noqa: E501
        """get collector installer  # noqa: E501

        get collector installer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_installer(collector_id, os_and_arch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int collector_id: (required)
        :param str os_and_arch: (required)
        :param int collector_version: The version of the installer you'd like to download. This defaults to the latest GD Collector, unless useEA is true
        :param str token:
        :param bool monitor_others:
        :param str collector_size: The size of the Collector you'd like to install. Options are nano, small (requires 2GB memory), medium (requires 4GB memory), large (requires 8GB memory), extra large (requires 16GB memory), double extra large (requires 32GB memory). Requires collector version 22.180 or higher. Defaults to small
        :param bool use_ea: If true, the latest EA Collector version will be used. Defaults to false
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_installer_with_http_info(collector_id, os_and_arch, **kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_installer_with_http_info(collector_id, os_and_arch, **kwargs)  # noqa: E501
            return data

    def get_collector_installer_with_http_info(self, collector_id, os_and_arch, **kwargs):  # noqa: E501
        """get collector installer  # noqa: E501

        get collector installer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_installer_with_http_info(collector_id, os_and_arch, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int collector_id: (required)
        :param str os_and_arch: (required)
        :param int collector_version: The version of the installer you'd like to download. This defaults to the latest GD Collector, unless useEA is true
        :param str token:
        :param bool monitor_others:
        :param str collector_size: The size of the Collector you'd like to install. Options are nano, small (requires 2GB memory), medium (requires 4GB memory), large (requires 8GB memory), extra large (requires 16GB memory), double extra large (requires 32GB memory). Requires collector version 22.180 or higher. Defaults to small
        :param bool use_ea: If true, the latest EA Collector version will be used. Defaults to false
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collector_id', 'os_and_arch', 'collector_version', 'token', 'monitor_others', 'collector_size', 'use_ea']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_installer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'collector_id' is set
        if ('collector_id' not in params or
                params['collector_id'] is None):
            raise ValueError("Missing the required parameter `collector_id` when calling `get_collector_installer`")  # noqa: E501
        # verify the required parameter 'os_and_arch' is set
        if ('os_and_arch' not in params or
                params['os_and_arch'] is None):
            raise ValueError("Missing the required parameter `os_and_arch` when calling `get_collector_installer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'collector_id' in params:
            path_params['collectorId'] = params['collector_id']  # noqa: E501
        if 'os_and_arch' in params:
            path_params['osAndArch'] = params['os_and_arch']  # noqa: E501

        query_params = []
        if 'collector_version' in params:
            query_params.append(('collectorVersion', params['collector_version']))  # noqa: E501
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501
        if 'monitor_others' in params:
            query_params.append(('monitorOthers', params['monitor_others']))  # noqa: E501
        if 'collector_size' in params:
            query_params.append(('collectorSize', params['collector_size']))  # noqa: E501
        if 'use_ea' in params:
            query_params.append(('useEA', params['use_ea']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'str'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{collectorId}/installers/{osAndArch}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_list(self, **kwargs):  # noqa: E501
        """get collector list  # noqa: E501

        get collector list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_collector_list_with_http_info(self, **kwargs):  # noqa: E501
        """get collector list  # noqa: E501

        get collector list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_collector_version_list(self, **kwargs):  # noqa: E501
        """get collector version list  # noqa: E501

        get collector version list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_version_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorVersionPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_collector_version_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_collector_version_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_collector_version_list_with_http_info(self, **kwargs):  # noqa: E501
        """get collector version list  # noqa: E501

        get collector version list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_collector_version_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: CollectorVersionPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_collector_version_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorVersionPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_source_by_id(self, id, **kwargs):  # noqa: E501
        """Get config source by ID  # noqa: E501

        Retrieve a config source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_config_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get config source by ID  # noqa: E501

        Retrieve a config source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_config_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_config_source_list(self, **kwargs):  # noqa: E501
        """Get config source list  # noqa: E501

        Retrieve a list of config sources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ConfigsourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_config_source_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_config_source_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_config_source_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get config source list  # noqa: E501

        Retrieve a list of config sources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_config_source_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ConfigsourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_source_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigsourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contract_info_by_company(self, **kwargs):  # noqa: E501
        """get contract info by company  # noqa: E501

        get contract info by company  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contract_info_by_company(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RestContractInfoBaseV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_contract_info_by_company_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_contract_info_by_company_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_contract_info_by_company_with_http_info(self, **kwargs):  # noqa: E501
        """get contract info by company  # noqa: E501

        get contract info by company  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contract_info_by_company_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RestContractInfoBaseV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contract_info_by_company" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestContractInfoBaseV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/usage/contractInfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_by_id(self, id, **kwargs):  # noqa: E501
        """get dashboard  # noqa: E501

        get dashboard  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool template:
        :param str format:
        :param str fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dashboard_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_dashboard_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get dashboard  # noqa: E501

        get dashboard  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool template:
        :param str format:
        :param str fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'template', 'format', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_dashboard_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'template' in params:
            query_params.append(('template', params['template']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Dashboard'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_group_by_id(self, id, **kwargs):  # noqa: E501
        """Get dashboard group by ID  # noqa: E501

        Retrieves a dashboard group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool template:
        :param str format:
        :param str fields:
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dashboard_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_dashboard_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get dashboard group by ID  # noqa: E501

        Retrieves a dashboard group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool template:
        :param str format:
        :param str fields:
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'template', 'format', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_dashboard_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'template' in params:
            query_params.append(('template', params['template']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_group_list(self, **kwargs):  # noqa: E501
        """get dashboard group list  # noqa: E501

        get dashboard group list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DashboardGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dashboard_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_dashboard_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """get dashboard group list  # noqa: E501

        get dashboard group list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DashboardGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dashboard_list(self, **kwargs):  # noqa: E501
        """Get dashboard list  # noqa: E501

        Retrieves a list of dashboards  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DashboardPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dashboard_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_dashboard_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_dashboard_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get dashboard list  # noqa: E501

        Retrieves a list of dashboards  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dashboard_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DashboardPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dashboard_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_data_source_overview_graph_by_id(self, ds_id, id, **kwargs):  # noqa: E501
        """Get datasource overview graph by ID  # noqa: E501

        Retrieves a datasource overview graph based on the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_source_overview_graph_by_id(ds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ds_id: (required)
        :param int id: (required)
        :return: DataSourceOverviewGraph
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_data_source_overview_graph_by_id_with_http_info(ds_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_data_source_overview_graph_by_id_with_http_info(ds_id, id, **kwargs)  # noqa: E501
            return data

    def get_data_source_overview_graph_by_id_with_http_info(self, ds_id, id, **kwargs):  # noqa: E501
        """Get datasource overview graph by ID  # noqa: E501

        Retrieves a datasource overview graph based on the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_source_overview_graph_by_id_with_http_info(ds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ds_id: (required)
        :param int id: (required)
        :return: DataSourceOverviewGraph
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ds_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_data_source_overview_graph_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ds_id' is set
        if ('ds_id' not in params or
                params['ds_id'] is None):
            raise ValueError("Missing the required parameter `ds_id` when calling `get_data_source_overview_graph_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_data_source_overview_graph_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ds_id' in params:
            path_params['dsId'] = params['ds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSourceOverviewGraph'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{dsId}/ographs/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_data_source_overview_graph_list(self, ds_id, **kwargs):  # noqa: E501
        """Get datasource overview graph list  # noqa: E501

        Retrieves the list of datasource overview graphs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_source_overview_graph_list(ds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ds_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DatasourceOverviewGraphPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_data_source_overview_graph_list_with_http_info(ds_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_data_source_overview_graph_list_with_http_info(ds_id, **kwargs)  # noqa: E501
            return data

    def get_data_source_overview_graph_list_with_http_info(self, ds_id, **kwargs):  # noqa: E501
        """Get datasource overview graph list  # noqa: E501

        Retrieves the list of datasource overview graphs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_data_source_overview_graph_list_with_http_info(ds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ds_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DatasourceOverviewGraphPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ds_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_data_source_overview_graph_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ds_id' is set
        if ('ds_id' not in params or
                params['ds_id'] is None):
            raise ValueError("Missing the required parameter `ds_id` when calling `get_data_source_overview_graph_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ds_id' in params:
            path_params['dsId'] = params['ds_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DatasourceOverviewGraphPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{dsId}/ographs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_datasource_by_id(self, id, **kwargs):  # noqa: E501
        """Get datasource by ID  # noqa: E501

        Retrieves a datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasource_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :param str fields:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_datasource_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get datasource by ID  # noqa: E501

        Retrieves a datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasource_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :param str fields:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_datasource_list(self, **kwargs):  # noqa: E501
        """Get datasource list  # noqa: E501

        Retrieves a list of datasources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasource_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_datasource_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_datasource_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_datasource_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get datasource list  # noqa: E501

        Retrieves a list of datasources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_datasource_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_datasource_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DatasourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_debug_command_result(self, id, **kwargs):  # noqa: E501
        """Get the result of a Collector debug command using sessionId  # noqa: E501

        Get the result of a Collector debug command using sessionId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_debug_command_result(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int collector_id:
        :return: Debug
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_debug_command_result_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_debug_command_result_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_debug_command_result_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the result of a Collector debug command using sessionId  # noqa: E501

        Get the result of a Collector debug command using sessionId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_debug_command_result_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param int collector_id:
        :return: Debug
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'collector_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_debug_command_result" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_debug_command_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'collector_id' in params:
            query_params.append(('collectorId', params['collector_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Debug'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/debug/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_delta_devices(self, delta_id, **kwargs):  # noqa: E501
        """Get delta devices using deltaId  # noqa: E501

        Get delta devices using deltaId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_delta_devices(delta_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delta_id: (required)
        :return: DeviceDeltaPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_delta_devices_with_http_info(delta_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_delta_devices_with_http_info(delta_id, **kwargs)  # noqa: E501
            return data

    def get_delta_devices_with_http_info(self, delta_id, **kwargs):  # noqa: E501
        """Get delta devices using deltaId  # noqa: E501

        Get delta devices using deltaId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_delta_devices_with_http_info(delta_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delta_id: (required)
        :return: DeviceDeltaPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delta_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_delta_devices" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delta_id' is set
        if ('delta_id' not in params or
                params['delta_id'] is None):
            raise ValueError("Missing the required parameter `delta_id` when calling `get_delta_devices`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'delta_id' in params:
            path_params['deltaId'] = params['delta_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDeltaPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/delta/{deltaId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_delta_id_with_devices(self, **kwargs):  # noqa: E501
        """Get filter matched devices with new deltaId  # noqa: E501

        Get filter matched devices with new deltaId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_delta_id_with_devices(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delta_id:
        :return: DeviceDeltaPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_delta_id_with_devices_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_delta_id_with_devices_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_delta_id_with_devices_with_http_info(self, **kwargs):  # noqa: E501
        """Get filter matched devices with new deltaId  # noqa: E501

        Get filter matched devices with new deltaId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_delta_id_with_devices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str delta_id:
        :return: DeviceDeltaPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delta_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_delta_id_with_devices" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'delta_id' in params:
            query_params.append(('deltaId', params['delta_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDeltaPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/delta', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_by_id(self, id, **kwargs):  # noqa: E501
        """get device by id  # noqa: E501

        get device by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param bool need_stc_grp_and_sorted_cp:
        :param str fields:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get device by id  # noqa: E501

        get device by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param bool need_stc_grp_and_sorted_cp:
        :param str fields:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'netflow_filter', 'start', 'need_stc_grp_and_sorted_cp', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'need_stc_grp_and_sorted_cp' in params:
            query_params.append(('needStcGrpAndSortedCP', params['need_stc_grp_and_sorted_cp']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Device'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_config_source_config_by_id(self, instance_id, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get a config for a device  # noqa: E501

        get a config for a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_config_source_config_by_id(instance_id, device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int instance_id: (required)
        :param int device_id: (required)
        :param int hds_id: (required)
        :param str id: (required)
        :param str format:
        :param int start_epoch:
        :param str fields:
        :return: DeviceDataSourceInstanceConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_config_source_config_by_id_with_http_info(instance_id, device_id, hds_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_config_source_config_by_id_with_http_info(instance_id, device_id, hds_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_config_source_config_by_id_with_http_info(self, instance_id, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get a config for a device  # noqa: E501

        get a config for a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_config_source_config_by_id_with_http_info(instance_id, device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int instance_id: (required)
        :param int device_id: (required)
        :param int hds_id: (required)
        :param str id: (required)
        :param str format:
        :param int start_epoch:
        :param str fields:
        :return: DeviceDataSourceInstanceConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['instance_id', 'device_id', 'hds_id', 'id', 'format', 'start_epoch', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_config_source_config_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `get_device_config_source_config_by_id`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_config_source_config_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_config_source_config_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_config_source_config_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'start_epoch' in params:
            query_params.append(('startEpoch', params['start_epoch']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceConfig'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/config/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_config_source_config_list(self, instance_id, device_id, hds_id, **kwargs):  # noqa: E501
        """get detailed config information for the instance  # noqa: E501

        get detailed config information for the instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_config_source_config_list(instance_id, device_id, hds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int instance_id: (required)
        :param int device_id: (required)
        :param int hds_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstanceConfigPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_config_source_config_list_with_http_info(instance_id, device_id, hds_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_config_source_config_list_with_http_info(instance_id, device_id, hds_id, **kwargs)  # noqa: E501
            return data

    def get_device_config_source_config_list_with_http_info(self, instance_id, device_id, hds_id, **kwargs):  # noqa: E501
        """get detailed config information for the instance  # noqa: E501

        get detailed config information for the instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_config_source_config_list_with_http_info(instance_id, device_id, hds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int instance_id: (required)
        :param int device_id: (required)
        :param int hds_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstanceConfigPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['instance_id', 'device_id', 'hds_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_config_source_config_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `get_device_config_source_config_list`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_config_source_config_list`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_config_source_config_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDatasourceInstanceConfigPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_by_id(self, device_id, id, **kwargs):  # noqa: E501
        """Get device datasource  # noqa: E501

        Retrieve a specific device datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_by_id(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_by_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_by_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_by_id_with_http_info(self, device_id, id, **kwargs):  # noqa: E501
        """Get device datasource  # noqa: E501

        Retrieve a specific device datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_by_id_with_http_info(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_data_by_id(self, device_id, id, **kwargs):  # noqa: E501
        """Get device datasource data  # noqa: E501

        Retrieve data for a specific device datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_data_by_id(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :param str aggregate: The aggregate option
        :return: DeviceDataSourceData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_data_by_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_data_by_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_data_by_id_with_http_info(self, device_id, id, **kwargs):  # noqa: E501
        """Get device datasource data  # noqa: E501

        Retrieve data for a specific device datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_data_by_id_with_http_info(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :param str aggregate: The aggregate option
        :return: DeviceDataSourceData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'id', 'period', 'start', 'end', 'datapoints', 'format', 'aggregate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_data_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_data_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_data_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'datapoints' in params:
            query_params.append(('datapoints', params['datapoints']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'aggregate' in params:
            query_params.append(('aggregate', params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceData'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{id}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_alert_setting_by_id(self, device_id, hds_id, instance_id, id, **kwargs):  # noqa: E501
        """get device instance alert setting  # noqa: E501

        get device instance alert setting  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_alert_setting_by_id(device_id, hds_id, instance_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSourceInstanceAlertSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_alert_setting_by_id_with_http_info(self, device_id, hds_id, instance_id, id, **kwargs):  # noqa: E501
        """get device instance alert setting  # noqa: E501

        get device instance alert setting  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSourceInstanceAlertSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'instance_id', 'id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_alert_setting_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `get_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_instance_alert_setting_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceAlertSetting'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/alertsettings/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_alert_setting_list_of_device(self, device_id, **kwargs):  # noqa: E501
        """get a list of alert settings for a device  # noqa: E501

        get a list of alert settings for a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_alert_setting_list_of_device(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param int size:
        :param int offset:
        :return: DeviceDataSourceInstanceAlertSettingPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_alert_setting_list_of_device_with_http_info(device_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_alert_setting_list_of_device_with_http_info(device_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_alert_setting_list_of_device_with_http_info(self, device_id, **kwargs):  # noqa: E501
        """get a list of alert settings for a device  # noqa: E501

        get a list of alert settings for a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_alert_setting_list_of_device_with_http_info(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param int size:
        :param int offset:
        :return: DeviceDataSourceInstanceAlertSettingPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'end', 'netflow_filter', 'start', 'size', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_alert_setting_list_of_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_alert_setting_list_of_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceAlertSettingPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/alertsettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_alert_setting_list_of_dsi(self, device_id, hds_id, instance_id, **kwargs):  # noqa: E501
        """get a list of alert settings for a device datasource instance  # noqa: E501

        get a list of alert settings for a device datasource instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_alert_setting_list_of_dsi(device_id, hds_id, instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int size:
        :param int offset:
        :return: DeviceDataSourceInstanceAlertSettingPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_alert_setting_list_of_dsi_with_http_info(device_id, hds_id, instance_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_alert_setting_list_of_dsi_with_http_info(device_id, hds_id, instance_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_alert_setting_list_of_dsi_with_http_info(self, device_id, hds_id, instance_id, **kwargs):  # noqa: E501
        """get a list of alert settings for a device datasource instance  # noqa: E501

        get a list of alert settings for a device datasource instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_alert_setting_list_of_dsi_with_http_info(device_id, hds_id, instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int size:
        :param int offset:
        :return: DeviceDataSourceInstanceAlertSettingPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'instance_id', 'size', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_alert_setting_list_of_dsi" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_alert_setting_list_of_dsi`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_alert_setting_list_of_dsi`")  # noqa: E501
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `get_device_datasource_instance_alert_setting_list_of_dsi`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501

        query_params = []
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceAlertSettingPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/alertsettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_by_id(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance  # noqa: E501

        get device instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_by_id(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_by_id_with_http_info(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance  # noqa: E501

        get device instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_instance_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstance'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_data(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance data  # noqa: E501

        get device instance data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_data(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :return: DeviceDataSourceInstanceData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_data_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_data_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_data_with_http_info(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance data  # noqa: E501

        get device instance data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_data_with_http_info(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :return: DeviceDataSourceInstanceData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'period', 'start', 'end', 'datapoints', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_data`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_data`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_instance_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'datapoints' in params:
            query_params.append(('datapoints', params['datapoints']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceData'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_graph_data(self, device_id, hds_id, id, graph_id, **kwargs):  # noqa: E501
        """get device instance graph data  # noqa: E501

        get device instance graph data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_graph_data(device_id, hds_id, id, graph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param int graph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_graph_data_with_http_info(device_id, hds_id, id, graph_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_graph_data_with_http_info(device_id, hds_id, id, graph_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_graph_data_with_http_info(self, device_id, hds_id, id, graph_id, **kwargs):  # noqa: E501
        """get device instance graph data  # noqa: E501

        get device instance graph data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_graph_data_with_http_info(device_id, hds_id, id, graph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param int graph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'graph_id', 'start', 'end', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_graph_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_graph_data`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_graph_data`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_instance_graph_data`")  # noqa: E501
        # verify the required parameter 'graph_id' is set
        if ('graph_id' not in params or
                params['graph_id'] is None):
            raise ValueError("Missing the required parameter `graph_id` when calling `get_device_datasource_instance_graph_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'graph_id' in params:
            path_params['graphId'] = params['graph_id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}/graphs/{graphId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_group_by_id(self, device_ds_id, device_id, id, **kwargs):  # noqa: E501
        """Get device datasource instance group  # noqa: E501

        Retrieve a specific device datasource instance group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_by_id(device_ds_id, device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_group_by_id_with_http_info(device_ds_id, device_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_group_by_id_with_http_info(device_ds_id, device_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_group_by_id_with_http_info(self, device_ds_id, device_id, id, **kwargs):  # noqa: E501
        """Get device datasource instance group  # noqa: E501

        Retrieve a specific device datasource instance group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_by_id_with_http_info(device_ds_id, device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_ds_id', 'device_id', 'id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `get_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_instance_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_group_list(self, device_ds_id, device_id, **kwargs):  # noqa: E501
        """Get device datasource instance group list  # noqa: E501

        Retrieve a paginated list of device datasource instance groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_list(device_ds_id, device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstanceGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_group_list_with_http_info(device_ds_id, device_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_group_list_with_http_info(device_ds_id, device_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_group_list_with_http_info(self, device_ds_id, device_id, **kwargs):  # noqa: E501
        """Get device datasource instance group list  # noqa: E501

        Retrieve a paginated list of device datasource instance groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_list_with_http_info(device_ds_id, device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstanceGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_ds_id', 'device_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_group_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `get_device_datasource_instance_group_list`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_group_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDatasourceInstanceGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_group_overview_graph_data(self, device_ds_id, device_id, dsig_id, ograph_id, **kwargs):  # noqa: E501
        """Get device instance group overview graph data  # noqa: E501

        Retrieve graph data for the overview of a device instance group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_overview_graph_data(device_ds_id, device_id, dsig_id, ograph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param int dsig_id: (required)
        :param int ograph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_group_overview_graph_data_with_http_info(device_ds_id, device_id, dsig_id, ograph_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_group_overview_graph_data_with_http_info(device_ds_id, device_id, dsig_id, ograph_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_group_overview_graph_data_with_http_info(self, device_ds_id, device_id, dsig_id, ograph_id, **kwargs):  # noqa: E501
        """Get device instance group overview graph data  # noqa: E501

        Retrieve graph data for the overview of a device instance group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_group_overview_graph_data_with_http_info(device_ds_id, device_id, dsig_id, ograph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param int dsig_id: (required)
        :param int ograph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_ds_id', 'device_id', 'dsig_id', 'ograph_id', 'start', 'end', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_group_overview_graph_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `get_device_datasource_instance_group_overview_graph_data`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_group_overview_graph_data`")  # noqa: E501
        # verify the required parameter 'dsig_id' is set
        if ('dsig_id' not in params or
                params['dsig_id'] is None):
            raise ValueError("Missing the required parameter `dsig_id` when calling `get_device_datasource_instance_group_overview_graph_data`")  # noqa: E501
        # verify the required parameter 'ograph_id' is set
        if ('ograph_id' not in params or
                params['ograph_id'] is None):
            raise ValueError("Missing the required parameter `ograph_id` when calling `get_device_datasource_instance_group_overview_graph_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'dsig_id' in params:
            path_params['dsigId'] = params['dsig_id']  # noqa: E501
        if 'ograph_id' in params:
            path_params['ographId'] = params['ograph_id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups/{dsigId}/graphs/{ographId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_list(self, device_id, hds_id, **kwargs):  # noqa: E501
        """get device instance list  # noqa: E501

        get device instance list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_list(device_id, hds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstancePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_list_with_http_info(device_id, hds_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_list_with_http_info(device_id, hds_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_list_with_http_info(self, device_id, hds_id, **kwargs):  # noqa: E501
        """get device instance list  # noqa: E501

        get device instance list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_list_with_http_info(device_id, hds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstancePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_list`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDatasourceInstancePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_instance_sdt_history(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance SDT history  # noqa: E501

        get device instance SDT history  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_sdt_history(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_instance_sdt_history_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_instance_sdt_history_with_http_info(device_id, hds_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_instance_sdt_history_with_http_info(self, device_id, hds_id, id, **kwargs):  # noqa: E501
        """get device instance SDT history  # noqa: E501

        get device instance SDT history  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_instance_sdt_history_with_http_info(device_id, hds_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_instance_sdt_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_instance_sdt_history`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `get_device_datasource_instance_sdt_history`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_datasource_instance_sdt_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupSDTHistoryPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}/historysdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_datasource_list(self, device_id, **kwargs):  # noqa: E501
        """Get device datasource list  # noqa: E501

        Retrieve a paginated list of device datasources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_list(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_datasource_list_with_http_info(device_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_datasource_list_with_http_info(device_id, **kwargs)  # noqa: E501
            return data

    def get_device_datasource_list_with_http_info(self, device_id, **kwargs):  # noqa: E501
        """Get device datasource list  # noqa: E501

        Retrieve a paginated list of device datasources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_datasource_list_with_http_info(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_datasource_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_datasource_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDatasourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_eventsource_list(self, device_id, **kwargs):  # noqa: E501
        """Get device eventsource list  # noqa: E501

        Retrieve a paginated list of device eventsources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_eventsource_list(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :return: RestDeviceEventsourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_eventsource_list_with_http_info(device_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_eventsource_list_with_http_info(device_id, **kwargs)  # noqa: E501
            return data

    def get_device_eventsource_list_with_http_info(self, device_id, **kwargs):  # noqa: E501
        """Get device eventsource list  # noqa: E501

        Retrieve a paginated list of device eventsources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_eventsource_list_with_http_info(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :return: RestDeviceEventsourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_eventsource_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_eventsource_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestDeviceEventsourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/deviceeventsources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_by_id(self, id, **kwargs):  # noqa: E501
        """get device group  # noqa: E501

        get device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get device group  # noqa: E501

        get device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_cluster_alert_conf_by_id(self, device_group_id, id, **kwargs):  # noqa: E501
        """Get cluster alert configuration by id  # noqa: E501

        Get cluster alert configuration by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_cluster_alert_conf_by_id(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :return: DeviceClusterAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_group_cluster_alert_conf_by_id_with_http_info(self, device_group_id, id, **kwargs):  # noqa: E501
        """Get cluster alert configuration by id  # noqa: E501

        Get cluster alert configuration by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :return: DeviceClusterAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_cluster_alert_conf_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `get_device_group_cluster_alert_conf_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_group_cluster_alert_conf_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceClusterAlertConfig'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/clusterAlertConf/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_cluster_alert_conf_list(self, device_group_id, **kwargs):  # noqa: E501
        """get a list of cluster alert configurations for a device group  # noqa: E501

        get a list of cluster alert configurations for a device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_cluster_alert_conf_list(device_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceClusterAlertConfigPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_cluster_alert_conf_list_with_http_info(device_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_cluster_alert_conf_list_with_http_info(device_group_id, **kwargs)  # noqa: E501
            return data

    def get_device_group_cluster_alert_conf_list_with_http_info(self, device_group_id, **kwargs):  # noqa: E501
        """get a list of cluster alert configurations for a device group  # noqa: E501

        get a list of cluster alert configurations for a device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_cluster_alert_conf_list_with_http_info(device_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceClusterAlertConfigPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_cluster_alert_conf_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `get_device_group_cluster_alert_conf_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceClusterAlertConfigPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/clusterAlertConf', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_datasource_alert_setting(self, device_group_id, ds_id, **kwargs):  # noqa: E501
        """Get device group datasource alert setting  # noqa: E501

        Retrieve the alert setting for a specific device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_alert_setting(device_group_id, ds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param str fields:
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, **kwargs)  # noqa: E501
            return data

    def get_device_group_datasource_alert_setting_with_http_info(self, device_group_id, ds_id, **kwargs):  # noqa: E501
        """Get device group datasource alert setting  # noqa: E501

        Retrieve the alert setting for a specific device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param str fields:
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'ds_id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_datasource_alert_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `get_device_group_datasource_alert_setting`")  # noqa: E501
        # verify the required parameter 'ds_id' is set
        if ('ds_id' not in params or
                params['ds_id'] is None):
            raise ValueError("Missing the required parameter `ds_id` when calling `get_device_group_datasource_alert_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'ds_id' in params:
            path_params['dsId'] = params['ds_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSourceAlertConfig'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{dsId}/alertsettings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_datasource_by_id(self, device_group_id, id, **kwargs):  # noqa: E501
        """get device group datasource  # noqa: E501

        get device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_by_id(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
            return data

    def get_device_group_datasource_by_id_with_http_info(self, device_group_id, id, **kwargs):  # noqa: E501
        """get device group datasource  # noqa: E501

        get device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_by_id_with_http_info(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param str fields:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `get_device_group_datasource_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_group_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_datasource_list(self, device_group_id, **kwargs):  # noqa: E501
        """get device group datasource list  # noqa: E501

        get device group datasource list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_list(device_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param bool include_disabled_data_source_without_instance:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupDatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_datasource_list_with_http_info(device_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_datasource_list_with_http_info(device_group_id, **kwargs)  # noqa: E501
            return data

    def get_device_group_datasource_list_with_http_info(self, device_group_id, **kwargs):  # noqa: E501
        """get device group datasource list  # noqa: E501

        get device group datasource list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_datasource_list_with_http_info(device_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param bool include_disabled_data_source_without_instance:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupDatasourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'include_disabled_data_source_without_instance', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_datasource_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `get_device_group_datasource_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501

        query_params = []
        if 'include_disabled_data_source_without_instance' in params:
            query_params.append(('includeDisabledDataSourceWithoutInstance', params['include_disabled_data_source_without_instance']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDatasourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_list(self, **kwargs):  # noqa: E501
        """get device group list  # noqa: E501

        get device group list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_device_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """get device group list  # noqa: E501

        get device group list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_property_by_name(self, gid, name, **kwargs):  # noqa: E501
        """Get device group property by name  # noqa: E501

        Retrieve a specific device group property by its name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_property_by_name(gid, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param str fields:
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_property_by_name_with_http_info(gid, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_property_by_name_with_http_info(gid, name, **kwargs)  # noqa: E501
            return data

    def get_device_group_property_by_name_with_http_info(self, gid, name, **kwargs):  # noqa: E501
        """Get device group property by name  # noqa: E501

        Retrieve a specific device group property by its name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_property_by_name_with_http_info(gid, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param str fields:
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'name', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `get_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_device_group_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_property_list(self, gid, **kwargs):  # noqa: E501
        """Get device group properties  # noqa: E501

        Retrieve a paginated list of properties for a specific device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_property_list(gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_property_list_with_http_info(gid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_property_list_with_http_info(gid, **kwargs)  # noqa: E501
            return data

    def get_device_group_property_list_with_http_info(self, gid, **kwargs):  # noqa: E501
        """Get device group properties  # noqa: E501

        Retrieve a paginated list of properties for a specific device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_property_list_with_http_info(gid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_property_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `get_device_group_property_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_group_sdt_list(self, id, **kwargs):  # noqa: E501
        """get device group SDTs  # noqa: E501

        get device group SDTs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_sdt_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_group_sdt_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_group_sdt_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_group_sdt_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """get device group SDTs  # noqa: E501

        get device group SDTs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_group_sdt_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_group_sdt_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_group_sdt_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDTPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}/sdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_instance_graph_data_only_by_instance_id(self, instance_id, graph_id, **kwargs):  # noqa: E501
        """get device instance data  # noqa: E501

        get device instance data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_instance_graph_data_only_by_instance_id(instance_id, graph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int instance_id: (required)
        :param int graph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_instance_graph_data_only_by_instance_id_with_http_info(instance_id, graph_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_instance_graph_data_only_by_instance_id_with_http_info(instance_id, graph_id, **kwargs)  # noqa: E501
            return data

    def get_device_instance_graph_data_only_by_instance_id_with_http_info(self, instance_id, graph_id, **kwargs):  # noqa: E501
        """get device instance data  # noqa: E501

        get device instance data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_instance_graph_data_only_by_instance_id_with_http_info(instance_id, graph_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int instance_id: (required)
        :param int graph_id: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['instance_id', 'graph_id', 'start', 'end', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_instance_graph_data_only_by_instance_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `get_device_instance_graph_data_only_by_instance_id`")  # noqa: E501
        # verify the required parameter 'graph_id' is set
        if ('graph_id' not in params or
                params['graph_id'] is None):
            raise ValueError("Missing the required parameter `graph_id` when calling `get_device_instance_graph_data_only_by_instance_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501
        if 'graph_id' in params:
            path_params['graphId'] = params['graph_id']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devicedatasourceinstances/{instanceId}/graphs/{graphId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_instance_list(self, id, **kwargs):  # noqa: E501
        """get device instance list  # noqa: E501

        get device instance list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_instance_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstancePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_instance_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_instance_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_instance_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """get device instance list  # noqa: E501

        get device instance list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_instance_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDatasourceInstancePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'netflow_filter', 'start', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_instance_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_instance_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDatasourceInstancePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/instances', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_list(self, **kwargs):  # noqa: E501
        """Get device list  # noqa: E501

        Retrieve a paginated list of devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param bool include_deleted_resources:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_device_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_device_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get device list  # noqa: E501

        Retrieve a paginated list of devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param bool include_deleted_resources:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['end', 'netflow_filter', 'start', 'include_deleted_resources', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'include_deleted_resources' in params:
            query_params.append(('includeDeletedResources', params['include_deleted_resources']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DevicePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_property_by_name(self, device_id, name, **kwargs):  # noqa: E501
        """Get device property by name  # noqa: E501

        Retrieve a specific device property by its name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_property_by_name(device_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param str fields:
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_property_by_name_with_http_info(device_id, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_property_by_name_with_http_info(device_id, name, **kwargs)  # noqa: E501
            return data

    def get_device_property_by_name_with_http_info(self, device_id, name, **kwargs):  # noqa: E501
        """Get device property by name  # noqa: E501

        Retrieve a specific device property by its name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_property_by_name_with_http_info(device_id, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param str fields:
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'name', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_device_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_property_list(self, device_id, **kwargs):  # noqa: E501
        """Get device properties  # noqa: E501

        Retrieve a paginated list of properties for a specific device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_property_list(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_property_list_with_http_info(device_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_property_list_with_http_info(device_id, **kwargs)  # noqa: E501
            return data

    def get_device_property_list_with_http_info(self, device_id, **kwargs):  # noqa: E501
        """Get device properties  # noqa: E501

        Retrieve a paginated list of properties for a specific device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_property_list_with_http_info(device_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_property_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_device_property_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_diagnostic_sources_by_id(self, id, **kwargs):  # noqa: E501
        """Get diagnostics sources by ID  # noqa: E501

        Retrieves a diagnostics source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_diagnostic_sources_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: DiagnosticsSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_diagnostic_sources_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_diagnostic_sources_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_diagnostic_sources_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get diagnostics sources by ID  # noqa: E501

        Retrieves a diagnostics source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_diagnostic_sources_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: DiagnosticsSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_diagnostic_sources_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_diagnostic_sources_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DiagnosticsSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/diagnosticsources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_diagnostic_sources_list(self, **kwargs):  # noqa: E501
        """Get diagnostics sources list  # noqa: E501

        Retrieves a list of diagnostics sources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_diagnostic_sources_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DiagnosticsourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_diagnostic_sources_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_diagnostic_sources_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_diagnostic_sources_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get diagnostics sources list  # noqa: E501

        Retrieves a list of diagnostics sources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_diagnostic_sources_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DiagnosticsourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_diagnostic_sources_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DiagnosticsourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/diagnosticsources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_escalation_chain_by_id(self, id, **kwargs):  # noqa: E501
        """Get escalation chain by ID  # noqa: E501

        Retrieve details of a specific escalation chain by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_escalation_chain_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_escalation_chain_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_escalation_chain_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_escalation_chain_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get escalation chain by ID  # noqa: E501

        Retrieve details of a specific escalation chain by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_escalation_chain_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_escalation_chain_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_escalation_chain_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EscalatingChain'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/chains/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_escalation_chain_list(self, **kwargs):  # noqa: E501
        """Get escalation chain list  # noqa: E501

        Retrieve a paginated list of escalation chains  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_escalation_chain_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: EscalationChainPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_escalation_chain_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_escalation_chain_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_escalation_chain_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get escalation chain list  # noqa: E501

        Retrieve a paginated list of escalation chains  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_escalation_chain_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: EscalationChainPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_escalation_chain_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EscalationChainPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/chains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_source_by_id(self, id, **kwargs):  # noqa: E501
        """Get event source by ID  # noqa: E501

        Retrieves an event source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_event_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get event source by ID  # noqa: E501

        Retrieves an event source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_event_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EventSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_source_list(self, **kwargs):  # noqa: E501
        """Get event source list  # noqa: E501

        Retrieves the list of event sources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_source_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: EventSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_event_source_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_event_source_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_event_source_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get event source list  # noqa: E501

        Retrieves the list of event sources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_source_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: EventSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_source_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EventSourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_external_api_stats(self, **kwargs):  # noqa: E501
        """get external api stats info  # noqa: E501

        get external api stats info  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_api_stats(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiPerfMetrics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_external_api_stats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_external_api_stats_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_external_api_stats_with_http_info(self, **kwargs):  # noqa: E501
        """get external api stats info  # noqa: E501

        get external api stats info  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_external_api_stats_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ApiPerfMetrics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_external_api_stats" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ApiPerfMetrics'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/apiStats/externalApis', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_immediate_device_list_by_device_group_id(self, id, **kwargs):  # noqa: E501
        """get immediate devices under group  # noqa: E501

        get immediate devices under group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_immediate_device_list_by_device_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_immediate_device_list_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_immediate_device_list_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_immediate_device_list_by_device_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get immediate devices under group  # noqa: E501

        get immediate devices under group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_immediate_device_list_by_device_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_immediate_device_list_by_device_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_immediate_device_list_by_device_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DevicePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_immediate_website_list_by_website_group_id(self, id, **kwargs):  # noqa: E501
        """get a list of websites for a group (Response may contain extra fields depending upon the type of check { PingCheck | WebCheck} being added)  # noqa: E501

        get a list of websites for a group (Response may contain extra fields depending upon the type of check { PingCheck | WebCheck} being added)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_immediate_website_list_by_website_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsitePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_immediate_website_list_by_website_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_immediate_website_list_by_website_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_immediate_website_list_by_website_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get a list of websites for a group (Response may contain extra fields depending upon the type of check { PingCheck | WebCheck} being added)  # noqa: E501

        get a list of websites for a group (Response may contain extra fields depending upon the type of check { PingCheck | WebCheck} being added)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_immediate_website_list_by_website_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsitePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_immediate_website_list_by_website_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_immediate_website_list_by_website_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsitePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}/websites', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_integration_audit_logs(self, **kwargs):  # noqa: E501
        """Get integration audit logs list  # noqa: E501

        Retrieves the list of integration audit logs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_integration_audit_logs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: IntegrationAuditLogPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_integration_audit_logs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_integration_audit_logs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_integration_audit_logs_with_http_info(self, **kwargs):  # noqa: E501
        """Get integration audit logs list  # noqa: E501

        Retrieves the list of integration audit logs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_integration_audit_logs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: IntegrationAuditLogPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_integration_audit_logs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'IntegrationAuditLogPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/integrations/auditlogs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_monitor_by_id(self, id, **kwargs):  # noqa: E501
        """Get JobMonitor by ID  # noqa: E501

        Retrieve a specific JobMonitor using its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_monitor_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_monitor_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_monitor_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_job_monitor_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get JobMonitor by ID  # noqa: E501

        Retrieve a specific JobMonitor using its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_monitor_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_monitor_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_job_monitor_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'BatchJob'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_monitor_list(self, **kwargs):  # noqa: E501
        """Get JobMonitor List  # noqa: E501

        Retrieve a paginated list of Job Monitors  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_monitor_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: BatchJobPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_monitor_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_job_monitor_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_job_monitor_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get JobMonitor List  # noqa: E501

        Retrieve a paginated list of Job Monitors  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_monitor_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: BatchJobPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_monitor_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'BatchJobPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log_queries_by_group_id(self, id, **kwargs):  # noqa: E501
        """Get log queries by group ID  # noqa: E501

        Fetch log queries belonging to a log query group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_queries_by_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_log_queries_by_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_log_queries_by_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_log_queries_by_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get log queries by group ID  # noqa: E501

        Fetch log queries belonging to a log query group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_queries_by_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log_queries_by_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_log_queries_by_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/logquerygroups/{id}/logqueries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log_query_group_by_id(self, id, **kwargs):  # noqa: E501
        """Get log query group by ID  # noqa: E501

        Fetch a log query group by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_query_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: LogQueryGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_log_query_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_log_query_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_log_query_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get log query group by ID  # noqa: E501

        Fetch a log query group by ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_query_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: LogQueryGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log_query_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_log_query_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogQueryGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/logquerygroups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log_query_group_list(self, **kwargs):  # noqa: E501
        """Get log query group list  # noqa: E501

        Get all log query groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_query_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: LogQueryGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_log_query_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_log_query_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_log_query_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get log query group list  # noqa: E501

        Get all log query groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_query_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: LogQueryGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log_query_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogQueryGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/logquerygroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log_query_group_list_by_group_type(self, group_type, **kwargs):  # noqa: E501
        """Get log query groups by groupType  # noqa: E501

        Returns log query groups filtered by the provided groupType. If allGroups=true, returns all groups (subject to permissions); otherwise returns groups for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_query_group_list_by_group_type(group_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_type: (required)
        :param bool all_groups:
        :return: LogQueryGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_log_query_group_list_by_group_type_with_http_info(group_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_log_query_group_list_by_group_type_with_http_info(group_type, **kwargs)  # noqa: E501
            return data

    def get_log_query_group_list_by_group_type_with_http_info(self, group_type, **kwargs):  # noqa: E501
        """Get log query groups by groupType  # noqa: E501

        Returns log query groups filtered by the provided groupType. If allGroups=true, returns all groups (subject to permissions); otherwise returns groups for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_query_group_list_by_group_type_with_http_info(group_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_type: (required)
        :param bool all_groups:
        :return: LogQueryGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_type', 'all_groups']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log_query_group_list_by_group_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_type' is set
        if ('group_type' not in params or
                params['group_type'] is None):
            raise ValueError("Missing the required parameter `group_type` when calling `get_log_query_group_list_by_group_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_type' in params:
            path_params['groupType'] = params['group_type']  # noqa: E501

        query_params = []
        if 'all_groups' in params:
            query_params.append(('allGroups', params['all_groups']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogQueryGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/logquerygroups/grouptype/{groupType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log_source_by_id(self, id, **kwargs):  # noqa: E501
        """Get log source  # noqa: E501

        Retrieves a specific log source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str format:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_log_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_log_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_log_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get log source  # noqa: E501

        Retrieves a specific log source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str format:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_log_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log_source_list(self, **kwargs):  # noqa: E501
        """Get log source list  # noqa: E501

        Retrieves a list of log sources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_source_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: LogSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_log_source_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_log_source_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_log_source_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get log source list  # noqa: E501

        Retrieves a list of log sources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_source_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :return: LogSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log_source_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogSourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metrics_summary(self, **kwargs):  # noqa: E501
        """get metrics usage with company settings summary  # noqa: E501

        get metrics usage with company settings summary  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metrics_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CompanyMetricsSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_metrics_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_metrics_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_metrics_summary_with_http_info(self, **kwargs):  # noqa: E501
        """get metrics usage with company settings summary  # noqa: E501

        get metrics usage with company settings summary  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metrics_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CompanyMetricsSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metrics_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CompanyMetricsSummary'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/metrics/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metrics_usage(self, **kwargs):  # noqa: E501
        """Get metrics usage  # noqa: E501

        Retrieve the metrics usage information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metrics_usage(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Usage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_metrics_usage_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_metrics_usage_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_metrics_usage_with_http_info(self, **kwargs):  # noqa: E501
        """Get metrics usage  # noqa: E501

        Retrieve the metrics usage information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metrics_usage_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Usage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metrics_usage" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Usage'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/metrics/usage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_netflow_endpoint_list(self, id, **kwargs):  # noqa: E501
        """get netflow endpoints  # noqa: E501

        get netflow endpoints  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_endpoint_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str port:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: EndpointPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_netflow_endpoint_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_netflow_endpoint_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_netflow_endpoint_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """get netflow endpoints  # noqa: E501

        get netflow endpoints  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_endpoint_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str port:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: EndpointPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'netflow_filter', 'start', 'port', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_netflow_endpoint_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_netflow_endpoint_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'port' in params:
            query_params.append(('port', params['port']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EndpointPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/endpoints', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_netflow_flow_list(self, id, **kwargs):  # noqa: E501
        """get netflow flows  # noqa: E501

        get netflow flows  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_flow_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: FlowRecordPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_netflow_flow_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_netflow_flow_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_netflow_flow_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """get netflow flows  # noqa: E501

        get netflow flows  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_flow_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: FlowRecordPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'netflow_filter', 'start', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_netflow_flow_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_netflow_flow_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'FlowRecordPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/flows', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_netflow_port_list(self, id, **kwargs):  # noqa: E501
        """get netflow ports  # noqa: E501

        get netflow ports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_port_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str ip:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PortPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_netflow_port_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_netflow_port_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_netflow_port_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """get netflow ports  # noqa: E501

        get netflow ports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netflow_port_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str ip:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PortPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'netflow_filter', 'start', 'ip', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_netflow_port_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_netflow_port_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'ip' in params:
            query_params.append(('ip', params['ip']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PortPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/ports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_netscan_by_id(self, id, **kwargs):  # noqa: E501
        """Get netscan by ID  # noqa: E501

        Retrieve a specific netscan by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netscan_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_netscan_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_netscan_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_netscan_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get netscan by ID  # noqa: E501

        Retrieve a specific netscan by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netscan_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_netscan_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_netscan_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Netscan'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/netscans/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_netscan_list(self, **kwargs):  # noqa: E501
        """Get netscan list  # noqa: E501

        Retrieve a list of netscans  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netscan_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: NetscanPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_netscan_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_netscan_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_netscan_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get netscan list  # noqa: E501

        Retrieve a list of netscans  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_netscan_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: NetscanPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_netscan_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'NetscanPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/netscans', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_oid_by_id(self, id, **kwargs):  # noqa: E501
        """Get OID by ID  # noqa: E501

        Retrieve the OID details by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oid_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_oid_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_oid_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_oid_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get OID by ID  # noqa: E501

        Retrieve the OID details by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oid_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_oid_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_oid_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestOidV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_oid_list(self, **kwargs):  # noqa: E501
        """Get OID's list  # noqa: E501

        Retrieve the list of OIDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oid_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: OidSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_oid_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_oid_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_oid_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get OID's list  # noqa: E501

        Retrieve the list of OIDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_oid_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: OidSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_oid_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'OidSourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ops_note_by_id(self, id, **kwargs):  # noqa: E501
        """get opsnote by id  # noqa: E501

        get opsnote by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ops_note_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str fields:
        :return: OpsNote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ops_note_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ops_note_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_ops_note_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get opsnote by id  # noqa: E501

        get opsnote by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ops_note_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str fields:
        :return: OpsNote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ops_note_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_ops_note_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'OpsNote'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/opsnotes/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ops_note_list(self, **kwargs):  # noqa: E501
        """get opsnote list  # noqa: E501

        get opsnote list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ops_note_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter: Filter the response based on tags, createdBy, happenedOn, monitorObjectGroups, monitorObjectNames, or _all field values
        :return: OpsNotePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ops_note_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_ops_note_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_ops_note_list_with_http_info(self, **kwargs):  # noqa: E501
        """get opsnote list  # noqa: E501

        get opsnote list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ops_note_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter: Filter the response based on tags, createdBy, happenedOn, monitorObjectGroups, monitorObjectNames, or _all field values
        :return: OpsNotePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ops_note_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'OpsNotePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/opsnotes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_partition_by_id(self, id, **kwargs):  # noqa: E501
        """Retrieve details of a specific log partition  # noqa: E501

        Retrieve details of a specific log partition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_partition_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: LogPartition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_partition_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_partition_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_partition_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve details of a specific log partition  # noqa: E501

        Retrieve details of a specific log partition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_partition_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: LogPartition
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_partition_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_partition_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogPartition'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/partitions/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_property_rules_by_id(self, id, **kwargs):  # noqa: E501
        """Get property rules by id  # noqa: E501

        Fetches a property rule by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_property_rules_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_property_rules_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_property_rules_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_property_rules_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get property rules by id  # noqa: E501

        Fetches a property rule by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_property_rules_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_property_rules_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_property_rules_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_property_rules_list(self, **kwargs):  # noqa: E501
        """Get property rules list  # noqa: E501

        Fetches a list of property rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_property_rules_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyRulePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_property_rules_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_property_rules_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_property_rules_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get property rules list  # noqa: E501

        Fetches a list of property rules  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_property_rules_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str format:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyRulePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_property_rules_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyRulePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recipient_group_by_id(self, id, **kwargs):  # noqa: E501
        """Get recipient group by id  # noqa: E501

        Retrieve a specific recipient group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipient_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recipient_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recipient_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_recipient_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get recipient group by id  # noqa: E501

        Retrieve a specific recipient group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipient_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recipient_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_recipient_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RecipientGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/recipientgroups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recipient_group_list(self, **kwargs):  # noqa: E501
        """Get recipient group list  # noqa: E501

        Retrieve a paginated list of recipient groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipient_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RecipientGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recipient_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_recipient_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_recipient_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get recipient group list  # noqa: E501

        Retrieve a paginated list of recipient groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipient_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RecipientGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recipient_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RecipientGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/recipientgroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recommendation_by_id(self, id, **kwargs):  # noqa: E501
        """Get recommendation by ID  # noqa: E501

        Retrieves a recommendation by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recommendation_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: an alphanumeric identifier composed of the recommendation's database ID, the associated resource ID, and the recommendation type, delimited with hyphens, e.g. 123-456-EBS_UNATTACHED (required)
        :param str fields:
        :return: RestCloudRecommendationV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recommendation_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recommendation_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_recommendation_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get recommendation by ID  # noqa: E501

        Retrieves a recommendation by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recommendation_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: an alphanumeric identifier composed of the recommendation's database ID, the associated resource ID, and the recommendation type, delimited with hyphens, e.g. 123-456-EBS_UNATTACHED (required)
        :param str fields:
        :return: RestCloudRecommendationV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recommendation_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_recommendation_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestCloudRecommendationV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/cost-optimization/recommendations/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recommendation_categories_list(self, **kwargs):  # noqa: E501
        """Get recommendation category list  # noqa: E501

        Retrieves the list of recommendation categories  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recommendation_categories_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RestCloudRecommendationCategoryV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recommendation_categories_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_recommendation_categories_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_recommendation_categories_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get recommendation category list  # noqa: E501

        Retrieves the list of recommendation categories  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recommendation_categories_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RestCloudRecommendationCategoryV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recommendation_categories_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestCloudRecommendationCategoryV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/cost-optimization/recommendations/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recommendations_list(self, **kwargs):  # noqa: E501
        """Get recommendation list  # noqa: E501

        Retrieves a list of recommendations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recommendations_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size: The number of recommendations to return. Max permitted value is 500
        :param int offset:
        :param str filter: Filtering is available with the : (equals) operator for recommendationStatus and recommendationCategory. Only one value at a time is supported for recommendationCategory, but multiple recommendationStatuses may be filtered on with the | (OR) operator. Also, only the , (AND) relation is supported when combining multiple filters
        :return: RestCloudRecommendationV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recommendations_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_recommendations_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_recommendations_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get recommendation list  # noqa: E501

        Retrieves a list of recommendations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recommendations_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size: The number of recommendations to return. Max permitted value is 500
        :param int offset:
        :param str filter: Filtering is available with the : (equals) operator for recommendationStatus and recommendationCategory. Only one value at a time is supported for recommendationCategory, but multiple recommendationStatuses may be filtered on with the | (OR) operator. Also, only the , (AND) relation is supported when combining multiple filters
        :return: RestCloudRecommendationV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recommendations_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestCloudRecommendationV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/cost-optimization/recommendations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_remediation_sources_by_id(self, id, **kwargs):  # noqa: E501
        """Get remediation sources by ID  # noqa: E501

        Retrieves a remediation source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_remediation_sources_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: RemediationSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_remediation_sources_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_remediation_sources_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_remediation_sources_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get remediation sources by ID  # noqa: E501

        Retrieves a remediation source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_remediation_sources_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: RemediationSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_remediation_sources_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_remediation_sources_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RemediationSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/remediationsources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_remediation_sources_list(self, **kwargs):  # noqa: E501
        """Get remediation sources list  # noqa: E501

        Retrieves a list of remediation sources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_remediation_sources_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RemediationSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_remediation_sources_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_remediation_sources_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_remediation_sources_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get remediation sources list  # noqa: E501

        Retrieves a list of remediation sources  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_remediation_sources_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RemediationSourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_remediation_sources_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RemediationSourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/remediationsources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_by_id(self, id, **kwargs):  # noqa: E501
        """Get report by ID  # noqa: E501

        Retrieve the details of a specific report by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_report_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_report_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get report by ID  # noqa: E501

        Retrieve the details of a specific report by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_report_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportBase'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_group_by_id(self, id, **kwargs):  # noqa: E501
        """Get report group by id  # noqa: E501

        Retrieve a specific report group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_report_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_report_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_report_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get report group by id  # noqa: E501

        Retrieve a specific report group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_report_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_group_list(self, **kwargs):  # noqa: E501
        """Get report group list  # noqa: E501

        Retrieve a paginated list of report groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ReportGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_report_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_report_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_report_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get report group list  # noqa: E501

        Retrieve a paginated list of report groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ReportGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_report_list(self, **kwargs):  # noqa: E501
        """Get report list  # noqa: E501

        Retrieve a paginated list of reports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool show_next_gen_reports:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ReportPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_report_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_report_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_report_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get report list  # noqa: E501

        Retrieve a paginated list of reports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_report_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool show_next_gen_reports:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: ReportPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['show_next_gen_reports', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_report_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'show_next_gen_reports' in params:
            query_params.append(('showNextGenReports', params['show_next_gen_reports']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_retention_list(self, **kwargs):  # noqa: E501
        """Retrieve the list of log retentions  # noqa: E501

        Retrieve the list of log retentions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_retention_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Pagination
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_retention_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_retention_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_retention_list_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve the list of log retentions  # noqa: E501

        Retrieve the list of log retentions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_retention_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Pagination
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_retention_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Pagination'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/partitions/retentions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_role_by_id(self, id, **kwargs):  # noqa: E501
        """Get role by ID  # noqa: E501

        Retrieve details of a specific role by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_role_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_role_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_role_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get role by ID  # noqa: E501

        Retrieve details of a specific role by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_role_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_role_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Role'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_role_list(self, **kwargs):  # noqa: E501
        """Get role list  # noqa: E501

        Retrieve a paginated list of roles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool exclude_admin:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RolePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_role_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_role_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_role_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get role list  # noqa: E501

        Retrieve a paginated list of roles  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool exclude_admin:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: RolePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['exclude_admin', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_role_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'exclude_admin' in params:
            query_params.append(('excludeAdmin', params['exclude_admin']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RolePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_by_id(self, id, **kwargs):  # noqa: E501
        """get SDT by id (Response may contain extra fields depending upon the type of SDT of given id)  # noqa: E501

        get SDT by id (Response may contain extra fields depending upon the type of SDT of given id)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_sdt_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get SDT by id (Response may contain extra fields depending upon the type of SDT of given id)  # noqa: E501

        get SDT by id (Response may contain extra fields depending upon the type of SDT of given id)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sdt_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDT'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_history_by_device_data_source_id(self, device_id, id, **kwargs):  # noqa: E501
        """Get SDT history for the device dataSource  # noqa: E501

        Retrieve the SDT (Service Disruption Time) history for a specific device dataSource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_data_source_id(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDataSourceSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_history_by_device_data_source_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_history_by_device_data_source_id_with_http_info(device_id, id, **kwargs)  # noqa: E501
            return data

    def get_sdt_history_by_device_data_source_id_with_http_info(self, device_id, id, **kwargs):  # noqa: E501
        """Get SDT history for the device dataSource  # noqa: E501

        Retrieve the SDT (Service Disruption Time) history for a specific device dataSource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_data_source_id_with_http_info(device_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceDataSourceSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_history_by_device_data_source_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `get_sdt_history_by_device_data_source_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sdt_history_by_device_data_source_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceSDTHistoryPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{id}/historysdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_history_by_device_group_id(self, id, **kwargs):  # noqa: E501
        """get SDT history for the group  # noqa: E501

        get SDT history for the group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_history_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_history_by_device_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_sdt_history_by_device_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get SDT history for the group  # noqa: E501

        get SDT history for the group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceGroupSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_history_by_device_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sdt_history_by_device_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupSDTHistoryPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}/historysdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_history_by_device_id(self, id, **kwargs):  # noqa: E501
        """get SDT history for the device  # noqa: E501

        get SDT history for the device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_history_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_history_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_sdt_history_by_device_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get SDT history for the device  # noqa: E501

        get SDT history for the device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_device_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DeviceSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'netflow_filter', 'start', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_history_by_device_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sdt_history_by_device_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceSDTHistoryPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/historysdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_history_by_website_group_id(self, id, **kwargs):  # noqa: E501
        """get SDT history for the website group (Response may contain extra fields depending upon the type of SDT)  # noqa: E501

        get SDT history for the website group (Response may contain extra fields depending upon the type of SDT)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_website_group_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsiteGroupSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_history_by_website_group_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_history_by_website_group_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_sdt_history_by_website_group_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get SDT history for the website group (Response may contain extra fields depending upon the type of SDT)  # noqa: E501

        get SDT history for the website group (Response may contain extra fields depending upon the type of SDT)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_website_group_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsiteGroupSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_history_by_website_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sdt_history_by_website_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteGroupSDTHistoryPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}/historysdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_history_by_website_id(self, id, **kwargs):  # noqa: E501
        """get SDT history for the website (Response may contain extra fields depending upon the type of SDT)  # noqa: E501

        get SDT history for the website (Response may contain extra fields depending upon the type of SDT)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_website_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsiteSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_history_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_history_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_sdt_history_by_website_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get SDT history for the website (Response may contain extra fields depending upon the type of SDT)  # noqa: E501

        get SDT history for the website (Response may contain extra fields depending upon the type of SDT)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_history_by_website_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsiteSDTHistoryPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_history_by_website_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sdt_history_by_website_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteSDTHistoryPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}/historysdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sdt_list(self, **kwargs):  # noqa: E501
        """get SDT list  # noqa: E501

        get SDT list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sdt_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_sdt_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_sdt_list_with_http_info(self, **kwargs):  # noqa: E501
        """get SDT list  # noqa: E501

        get SDT list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sdt_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sdt_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDTPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_site_monitor_check_point_list(self, **kwargs):  # noqa: E501
        """Get website checkpoint list  # noqa: E501

        Retrieves the list of website checkpoints  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_site_monitor_check_point_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Type of checkpoint to filter. If not specified, returns website legacy checkpoints.
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SiteMonitorCheckPointPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_site_monitor_check_point_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_site_monitor_check_point_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_site_monitor_check_point_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get website checkpoint list  # noqa: E501

        Retrieves the list of website checkpoints  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_site_monitor_check_point_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: Type of checkpoint to filter. If not specified, returns website legacy checkpoints.
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SiteMonitorCheckPointPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_site_monitor_check_point_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SiteMonitorCheckPointPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/smcheckpoints', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_top_talkers_graph(self, id, **kwargs):  # noqa: E501
        """get top talkers graph  # noqa: E501

        get top talkers graph  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_top_talkers_graph(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str format:
        :param str keyword:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_top_talkers_graph_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_top_talkers_graph_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_top_talkers_graph_with_http_info(self, id, **kwargs):  # noqa: E501
        """get top talkers graph  # noqa: E501

        get top talkers graph  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_top_talkers_graph_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str format:
        :param str keyword:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'netflow_filter', 'start', 'format', 'keyword']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_top_talkers_graph" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_top_talkers_graph`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'keyword' in params:
            query_params.append(('keyword', params['keyword']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/topTalkersGraph', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_topology_source_by_id(self, id, **kwargs):  # noqa: E501
        """Get TopologySource by id  # noqa: E501

        Get TopologySource by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topology_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_topology_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_topology_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_topology_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get TopologySource by id  # noqa: E501

        Get TopologySource by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topology_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_topology_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_topology_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'TopologySource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_topology_source_list(self, **kwargs):  # noqa: E501
        """Get TopologySource List  # noqa: E501

        Get TopologySource List  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topology_source_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TopologySourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_topology_source_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_topology_source_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_topology_source_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get TopologySource List  # noqa: E501

        Get TopologySource List  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topology_source_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TopologySourcePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_topology_source_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'TopologySourcePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_unmonitored_device_list(self, **kwargs):  # noqa: E501
        """Get unmonitored device list  # noqa: E501

        Retrieve a paginated list of unmonitored devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unmonitored_device_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: UnmonitoredDevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_unmonitored_device_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_unmonitored_device_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_unmonitored_device_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get unmonitored device list  # noqa: E501

        Retrieve a paginated list of unmonitored devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unmonitored_device_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: UnmonitoredDevicePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unmonitored_device_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'UnmonitoredDevicePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/unmonitoreddevices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_update_reason_list_by_config_source_id(self, id, **kwargs):  # noqa: E501
        """Get update history for a configSource  # noqa: E501

        Retrieve the list of update reasons/history for a specific configSource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_update_reason_list_by_config_source_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ConfigSourceUpdateReasonsPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_update_reason_list_by_config_source_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_update_reason_list_by_config_source_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_update_reason_list_by_config_source_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get update history for a configSource  # noqa: E501

        Retrieve the list of update reasons/history for a specific configSource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_update_reason_list_by_config_source_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ConfigSourceUpdateReasonsPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_update_reason_list_by_config_source_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_update_reason_list_by_config_source_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSourceUpdateReasonsPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/{id}/updatereasons', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_update_reason_list_by_data_source_id(self, id, **kwargs):  # noqa: E501
        """Get update history for a datasource  # noqa: E501

        Retrieves the update history for a specific datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_update_reason_list_by_data_source_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DataSourceUpdateReasonsPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_update_reason_list_by_data_source_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_update_reason_list_by_data_source_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_update_reason_list_by_data_source_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get update history for a datasource  # noqa: E501

        Retrieves the update history for a specific datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_update_reason_list_by_data_source_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: DataSourceUpdateReasonsPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_update_reason_list_by_data_source_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_update_reason_list_by_data_source_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSourceUpdateReasonsPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}/updatereasons', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_v4_metadata(self, **kwargs):  # noqa: E501
        """get metadata  # noqa: E501

        get metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v4_metadata(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Response
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_v4_metadata_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_v4_metadata_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_v4_metadata_with_http_info(self, **kwargs):  # noqa: E501
        """get metadata  # noqa: E501

        get metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_v4_metadata_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Response
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_v4_metadata" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Response'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logicmodules/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_alert_list_by_website_id(self, id, **kwargs):  # noqa: E501
        """get alerts for a website  # noqa: E501

        get alerts for a website  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_alert_list_by_website_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_alert_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_alert_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_website_alert_list_by_website_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get alerts for a website  # noqa: E501

        get alerts for a website  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_alert_list_by_website_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param bool need_message:
        :param str custom_columns:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: AlertPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'need_message', 'custom_columns', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_alert_list_by_website_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_alert_list_by_website_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'need_message' in params:
            query_params.append(('needMessage', params['need_message']))  # noqa: E501
        if 'custom_columns' in params:
            query_params.append(('customColumns', params['custom_columns']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_by_id(self, id, **kwargs):  # noqa: E501
        """get website by id  # noqa: E501

        get website by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_website_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get website by id  # noqa: E501

        get website by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str format:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Website'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_checkpoint_data_by_id(self, srv_id, check_id, **kwargs):  # noqa: E501
        """get data for a website checkpoint  # noqa: E501

        get data for a website checkpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_checkpoint_data_by_id(srv_id, check_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int srv_id: (required)
        :param int check_id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :param str aggregate: the aggregate option
        :return: WebsiteCheckpointRawData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_checkpoint_data_by_id_with_http_info(srv_id, check_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_checkpoint_data_by_id_with_http_info(srv_id, check_id, **kwargs)  # noqa: E501
            return data

    def get_website_checkpoint_data_by_id_with_http_info(self, srv_id, check_id, **kwargs):  # noqa: E501
        """get data for a website checkpoint  # noqa: E501

        get data for a website checkpoint  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_checkpoint_data_by_id_with_http_info(srv_id, check_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int srv_id: (required)
        :param int check_id: (required)
        :param float period:
        :param int start:
        :param int end:
        :param str datapoints:
        :param str format:
        :param str aggregate: the aggregate option
        :return: WebsiteCheckpointRawData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['srv_id', 'check_id', 'period', 'start', 'end', 'datapoints', 'format', 'aggregate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_checkpoint_data_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'srv_id' is set
        if ('srv_id' not in params or
                params['srv_id'] is None):
            raise ValueError("Missing the required parameter `srv_id` when calling `get_website_checkpoint_data_by_id`")  # noqa: E501
        # verify the required parameter 'check_id' is set
        if ('check_id' not in params or
                params['check_id'] is None):
            raise ValueError("Missing the required parameter `check_id` when calling `get_website_checkpoint_data_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'srv_id' in params:
            path_params['srvId'] = params['srv_id']  # noqa: E501
        if 'check_id' in params:
            path_params['checkId'] = params['check_id']  # noqa: E501

        query_params = []
        if 'period' in params:
            query_params.append(('period', params['period']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'datapoints' in params:
            query_params.append(('datapoints', params['datapoints']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'aggregate' in params:
            query_params.append(('aggregate', params['aggregate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteCheckpointRawData'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{srvId}/checkpoints/{checkId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_data_by_graph_name(self, id, graph_name, **kwargs):  # noqa: E501
        """get website data by graph name  # noqa: E501

        get website data by graph name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_data_by_graph_name(id, graph_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str graph_name: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_data_by_graph_name_with_http_info(id, graph_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_data_by_graph_name_with_http_info(id, graph_name, **kwargs)  # noqa: E501
            return data

    def get_website_data_by_graph_name_with_http_info(self, id, graph_name, **kwargs):  # noqa: E501
        """get website data by graph name  # noqa: E501

        get website data by graph name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_data_by_graph_name_with_http_info(id, graph_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str graph_name: (required)
        :param int start:
        :param int end:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'graph_name', 'start', 'end', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_data_by_graph_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_data_by_graph_name`")  # noqa: E501
        # verify the required parameter 'graph_name' is set
        if ('graph_name' not in params or
                params['graph_name'] is None):
            raise ValueError("Missing the required parameter `graph_name` when calling `get_website_data_by_graph_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'graph_name' in params:
            path_params['graphName'] = params['graph_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}/graphs/{graphName}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_graph_data(self, checkpoint_id, website_id, graph_name, **kwargs):  # noqa: E501
        """Get website graph data  # noqa: E501

        Retrieves the graph data for a website  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_graph_data(checkpoint_id, website_id, graph_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int checkpoint_id: (required)
        :param int website_id: (required)
        :param str graph_name: (required)
        :param int end:
        :param int start:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_graph_data_with_http_info(checkpoint_id, website_id, graph_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_graph_data_with_http_info(checkpoint_id, website_id, graph_name, **kwargs)  # noqa: E501
            return data

    def get_website_graph_data_with_http_info(self, checkpoint_id, website_id, graph_name, **kwargs):  # noqa: E501
        """Get website graph data  # noqa: E501

        Retrieves the graph data for a website  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_graph_data_with_http_info(checkpoint_id, website_id, graph_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int checkpoint_id: (required)
        :param int website_id: (required)
        :param str graph_name: (required)
        :param int end:
        :param int start:
        :param str format:
        :return: GraphPlot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['checkpoint_id', 'website_id', 'graph_name', 'end', 'start', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_graph_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'checkpoint_id' is set
        if ('checkpoint_id' not in params or
                params['checkpoint_id'] is None):
            raise ValueError("Missing the required parameter `checkpoint_id` when calling `get_website_graph_data`")  # noqa: E501
        # verify the required parameter 'website_id' is set
        if ('website_id' not in params or
                params['website_id'] is None):
            raise ValueError("Missing the required parameter `website_id` when calling `get_website_graph_data`")  # noqa: E501
        # verify the required parameter 'graph_name' is set
        if ('graph_name' not in params or
                params['graph_name'] is None):
            raise ValueError("Missing the required parameter `graph_name` when calling `get_website_graph_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'checkpoint_id' in params:
            path_params['checkpointId'] = params['checkpoint_id']  # noqa: E501
        if 'website_id' in params:
            path_params['websiteId'] = params['website_id']  # noqa: E501
        if 'graph_name' in params:
            path_params['graphName'] = params['graph_name']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'GraphPlot'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{websiteId}/checkpoints/{checkpointId}/graphs/{graphName}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_group_by_id(self, id, **kwargs):  # noqa: E501
        """get website group  # noqa: E501

        get website group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_group_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_group_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_website_group_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get website group  # noqa: E501

        get website group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_group_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_group_list(self, **kwargs):  # noqa: E501
        """get website group list  # noqa: E501

        get website group list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_group_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsiteGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_group_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_website_group_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_website_group_list_with_http_info(self, **kwargs):  # noqa: E501
        """get website group list  # noqa: E501

        get website group list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_group_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsiteGroupPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_group_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteGroupPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_list(self, **kwargs):  # noqa: E501
        """get website list  # noqa: E501

        get website list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collector_ids:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsitePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_website_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_website_list_with_http_info(self, **kwargs):  # noqa: E501
        """get website list  # noqa: E501

        get website list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collector_ids:
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WebsitePaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['collector_ids', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'collector_ids' in params:
            query_params.append(('collectorIds', params['collector_ids']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsitePaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_property_list_by_website_id(self, id, **kwargs):  # noqa: E501
        """get a list of properties for a website  # noqa: E501

        get a list of properties for a website  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_property_list_by_website_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_property_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_property_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_website_property_list_by_website_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get a list of properties for a website  # noqa: E501

        get a list of properties for a website  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_property_list_by_website_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: PropertyPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_property_list_by_website_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_property_list_by_website_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_website_sdt_list_by_website_id(self, id, **kwargs):  # noqa: E501
        """get a list of SDTs for a website  # noqa: E501

        get a list of SDTs for a website  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_sdt_list_by_website_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_website_sdt_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_website_sdt_list_by_website_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_website_sdt_list_by_website_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get a list of SDTs for a website  # noqa: E501

        get a list of SDTs for a website  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_website_sdt_list_by_website_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: SDTPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_website_sdt_list_by_website_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_website_sdt_list_by_website_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDTPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}/sdts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_widget_by_id(self, id, **kwargs):  # noqa: E501
        """Get widget by ID  # noqa: E501

        Retrieves a widget by its ID. Based on widget type, the response may contain additional attributes. Please refer to the models corresponding to specific widget types at the bottom of this page for detailed attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_widget_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_widget_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_widget_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get widget by ID  # noqa: E501

        Retrieves a widget by its ID. Based on widget type, the response may contain additional attributes. Please refer to the models corresponding to specific widget types at the bottom of this page for detailed attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_widget_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_widget_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Widget'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_widget_data_by_id(self, id, **kwargs):  # noqa: E501
        """get widget data (Based upon widget type the response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        get widget data (Based upon widget type the response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_data_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str format:
        :param int start:
        :return: WidgetData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_widget_data_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_widget_data_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_widget_data_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get widget data (Based upon widget type the response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501

        get widget data (Based upon widget type the response may contain additional attributes. Please refer models corresponding to specific widget type at the bottom of this page to check the attributes)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_data_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str format:
        :param int start:
        :return: WidgetData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'format', 'start']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_widget_data_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_widget_data_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WidgetData'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets/{id}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_widget_list(self, **kwargs):  # noqa: E501
        """Get widget list  # noqa: E501

        Retrieves a list of widgets. Based on widget type, the response may contain additional attributes. Please refer to the models corresponding to specific widget types at the bottom of this page for detailed attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WidgetPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_widget_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_widget_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_widget_list_with_http_info(self, **kwargs):  # noqa: E501
        """Get widget list  # noqa: E501

        Retrieves a list of widgets. Based on widget type, the response may contain additional attributes. Please refer to the models corresponding to specific widget types at the bottom of this page for detailed attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WidgetPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_widget_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WidgetPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_widget_list_by_dashboard_id(self, id, **kwargs):  # noqa: E501
        """get widget list by DashboardId  # noqa: E501

        get widget list by DashboardId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_list_by_dashboard_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WidgetPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_widget_list_by_dashboard_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_widget_list_by_dashboard_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_widget_list_by_dashboard_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """get widget list by DashboardId  # noqa: E501

        get widget list by DashboardId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_widget_list_by_dashboard_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str fields:
        :param int size:
        :param int offset:
        :param str filter:
        :return: WidgetPaginationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'size', 'offset', 'filter']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_widget_list_by_dashboard_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_widget_list_by_dashboard_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WidgetPaginationResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards/{id}/widgets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_applies_to_function_json(self, **kwargs):  # noqa: E501
        """Import AppliesTo function via json  # noqa: E501

        Import a AppliesTo function using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_applies_to_function_json(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_applies_to_function_json_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_applies_to_function_json_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_applies_to_function_json_with_http_info(self, **kwargs):  # noqa: E501
        """Import AppliesTo function via json  # noqa: E501

        Import a AppliesTo function using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_applies_to_function_json_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'handle_conflict', 'fields_to_preserve']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_applies_to_function_json" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'handle_conflict' in params:
            query_params.append(('handleConflict', params['handle_conflict']))  # noqa: E501
        if 'fields_to_preserve' in params:
            query_params.append(('fieldsToPreserve', params['fields_to_preserve']))  # noqa: E501
            collection_formats['fieldsToPreserve'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AppliesToFunction'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions/importjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_batch_job(self, **kwargs):  # noqa: E501
        """Import batch job via XML  # noqa: E501

        Import a batch job using XML data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_batch_job(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_batch_job_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_batch_job_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_batch_job_with_http_info(self, **kwargs):  # noqa: E501
        """Import batch job via XML  # noqa: E501

        Import a batch job using XML data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_batch_job_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_batch_job" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs/importxml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_config_source(self, **kwargs):  # noqa: E501
        """Import config source via XML  # noqa: E501

        Import configuration source data from an XML file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_config_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_config_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_config_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_config_source_with_http_info(self, **kwargs):  # noqa: E501
        """Import config source via XML  # noqa: E501

        Import configuration source data from an XML file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_config_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_config_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/importxml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_config_source_json(self, **kwargs):  # noqa: E501
        """Import ConfigSource via json  # noqa: E501

        Import a ConfigSource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_config_source_json(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_config_source_json_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_config_source_json_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_config_source_json_with_http_info(self, **kwargs):  # noqa: E501
        """Import ConfigSource via json  # noqa: E501

        Import a ConfigSource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_config_source_json_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'handle_conflict', 'fields_to_preserve']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_config_source_json" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'handle_conflict' in params:
            query_params.append(('handleConflict', params['handle_conflict']))  # noqa: E501
        if 'fields_to_preserve' in params:
            query_params.append(('fieldsToPreserve', params['fields_to_preserve']))  # noqa: E501
            collection_formats['fieldsToPreserve'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/importjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_data_source(self, **kwargs):  # noqa: E501
        """Import datasource via XML  # noqa: E501

        Imports a datasource from an XML file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_data_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_data_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_data_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_data_source_with_http_info(self, **kwargs):  # noqa: E501
        """Import datasource via XML  # noqa: E501

        Imports a datasource from an XML file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_data_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_data_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/importxml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_data_source_json(self, **kwargs):  # noqa: E501
        """Import DataSource via json  # noqa: E501

        Import a DataSource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_data_source_json(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_data_source_json_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_data_source_json_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_data_source_json_with_http_info(self, **kwargs):  # noqa: E501
        """Import DataSource via json  # noqa: E501

        Import a DataSource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_data_source_json_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'handle_conflict', 'fields_to_preserve']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_data_source_json" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'handle_conflict' in params:
            query_params.append(('handleConflict', params['handle_conflict']))  # noqa: E501
        if 'fields_to_preserve' in params:
            query_params.append(('fieldsToPreserve', params['fields_to_preserve']))  # noqa: E501
            collection_formats['fieldsToPreserve'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/importjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_diagnostic_source_json(self, **kwargs):  # noqa: E501
        """Import DiagnosticSource via json  # noqa: E501

        Import a DiagnosticSource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_diagnostic_source_json(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: RestDiagnosticSourceV4
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_diagnostic_source_json_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_diagnostic_source_json_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_diagnostic_source_json_with_http_info(self, **kwargs):  # noqa: E501
        """Import DiagnosticSource via json  # noqa: E501

        Import a DiagnosticSource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_diagnostic_source_json_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: RestDiagnosticSourceV4
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'handle_conflict', 'fields_to_preserve']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_diagnostic_source_json" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'handle_conflict' in params:
            query_params.append(('handleConflict', params['handle_conflict']))  # noqa: E501
        if 'fields_to_preserve' in params:
            query_params.append(('fieldsToPreserve', params['fields_to_preserve']))  # noqa: E501
            collection_formats['fieldsToPreserve'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestDiagnosticSourceV4'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/diagnosticsources/importjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_event_source(self, **kwargs):  # noqa: E501
        """Import event source via XML  # noqa: E501

        Imports an event source from an XML file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_event_source(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_event_source_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_event_source_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_event_source_with_http_info(self, **kwargs):  # noqa: E501
        """Import event source via XML  # noqa: E501

        Imports an event source from an XML file  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_event_source_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_event_source" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources/importxml', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_event_source_json(self, **kwargs):  # noqa: E501
        """Import EventSource via json  # noqa: E501

        Import a EventSource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_event_source_json(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_event_source_json_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_event_source_json_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_event_source_json_with_http_info(self, **kwargs):  # noqa: E501
        """Import EventSource via json  # noqa: E501

        Import a EventSource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_event_source_json_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'handle_conflict', 'fields_to_preserve']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_event_source_json" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'handle_conflict' in params:
            query_params.append(('handleConflict', params['handle_conflict']))  # noqa: E501
        if 'fields_to_preserve' in params:
            query_params.append(('fieldsToPreserve', params['fields_to_preserve']))  # noqa: E501
            collection_formats['fieldsToPreserve'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EventSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources/importjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_job_monitor_json(self, **kwargs):  # noqa: E501
        """Import batch JobMonitor via json  # noqa: E501

        Import a JobMonitor using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_job_monitor_json(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_job_monitor_json_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_job_monitor_json_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_job_monitor_json_with_http_info(self, **kwargs):  # noqa: E501
        """Import batch JobMonitor via json  # noqa: E501

        Import a JobMonitor using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_job_monitor_json_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'handle_conflict', 'fields_to_preserve']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_job_monitor_json" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'handle_conflict' in params:
            query_params.append(('handleConflict', params['handle_conflict']))  # noqa: E501
        if 'fields_to_preserve' in params:
            query_params.append(('fieldsToPreserve', params['fields_to_preserve']))  # noqa: E501
            collection_formats['fieldsToPreserve'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'BatchJob'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs/importjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_log_source_json(self, **kwargs):  # noqa: E501
        """Import LogSource via json  # noqa: E501

        Import a LogSource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_log_source_json(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_log_source_json_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_log_source_json_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_log_source_json_with_http_info(self, **kwargs):  # noqa: E501
        """Import LogSource via json  # noqa: E501

        Import a LogSource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_log_source_json_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'handle_conflict', 'fields_to_preserve']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_log_source_json" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'handle_conflict' in params:
            query_params.append(('handleConflict', params['handle_conflict']))  # noqa: E501
        if 'fields_to_preserve' in params:
            query_params.append(('fieldsToPreserve', params['fields_to_preserve']))  # noqa: E501
            collection_formats['fieldsToPreserve'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources/importjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_oid_json(self, **kwargs):  # noqa: E501
        """Import OID via json  # noqa: E501

        Import a OID using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_oid_json(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_oid_json_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_oid_json_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_oid_json_with_http_info(self, **kwargs):  # noqa: E501
        """Import OID via json  # noqa: E501

        Import a OID using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_oid_json_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'handle_conflict', 'fields_to_preserve']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_oid_json" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'handle_conflict' in params:
            query_params.append(('handleConflict', params['handle_conflict']))  # noqa: E501
        if 'fields_to_preserve' in params:
            query_params.append(('fieldsToPreserve', params['fields_to_preserve']))  # noqa: E501
            collection_formats['fieldsToPreserve'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestOidV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids/importjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_property_source_json(self, **kwargs):  # noqa: E501
        """Import PropertySource via json  # noqa: E501

        Import a PropertySource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_property_source_json(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_property_source_json_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_property_source_json_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_property_source_json_with_http_info(self, **kwargs):  # noqa: E501
        """Import PropertySource via json  # noqa: E501

        Import a PropertySource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_property_source_json_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'handle_conflict', 'fields_to_preserve']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_property_source_json" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'handle_conflict' in params:
            query_params.append(('handleConflict', params['handle_conflict']))  # noqa: E501
        if 'fields_to_preserve' in params:
            query_params.append(('fieldsToPreserve', params['fields_to_preserve']))  # noqa: E501
            collection_formats['fieldsToPreserve'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules/importjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_topology_source_json(self, **kwargs):  # noqa: E501
        """Import TopologySource via json  # noqa: E501

        Import a TopologySource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_topology_source_json(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_topology_source_json_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_topology_source_json_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_topology_source_json_with_http_info(self, **kwargs):  # noqa: E501
        """Import TopologySource via json  # noqa: E501

        Import a TopologySource using json data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_topology_source_json_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FormDataContentDisposition file:
        :param str handle_conflict:
        :param list[str] fields_to_preserve:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'handle_conflict', 'fields_to_preserve']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_topology_source_json" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'handle_conflict' in params:
            query_params.append(('handleConflict', params['handle_conflict']))  # noqa: E501
        if 'fields_to_preserve' in params:
            query_params.append(('fieldsToPreserve', params['fields_to_preserve']))  # noqa: E501
            collection_formats['fieldsToPreserve'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            form_params.append(('file', params['file']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'TopologySource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources/importjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def map_un_map_module_to_access_group(self, **kwargs):  # noqa: E501
        """Create a mapping of access group & module  # noqa: E501

        Map a module to an access group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.map_un_map_module_to_access_group(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestMapModuleV3 body:
        :return: RestMapModuleV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.map_un_map_module_to_access_group_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.map_un_map_module_to_access_group_with_http_info(**kwargs)  # noqa: E501
            return data

    def map_un_map_module_to_access_group_with_http_info(self, **kwargs):  # noqa: E501
        """Create a mapping of access group & module  # noqa: E501

        Map a module to an access group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.map_un_map_module_to_access_group_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestMapModuleV3 body:
        :return: RestMapModuleV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method map_un_map_module_to_access_group" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestMapModuleV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/mapunmap/modules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def move_log_queries(self, id, body, **kwargs):  # noqa: E501
        """Move log queries to another group  # noqa: E501

        Move one or more log queries into a different log query group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_log_queries(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param list[str] body: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.move_log_queries_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.move_log_queries_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def move_log_queries_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Move log queries to another group  # noqa: E501

        Move one or more log queries into a different log query group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_log_queries_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param list[str] body: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_log_queries" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `move_log_queries`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `move_log_queries`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/logquerygroups/{id}/move', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partition_action(self, id, action, **kwargs):  # noqa: E501
        """Perform an action on a specified log partition  # noqa: E501

        Perform an action on a specified log partition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partition_action(id, action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str action: (required)
        :return: LogPartition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partition_action_with_http_info(id, action, **kwargs)  # noqa: E501
        else:
            (data) = self.partition_action_with_http_info(id, action, **kwargs)  # noqa: E501
            return data

    def partition_action_with_http_info(self, id, action, **kwargs):  # noqa: E501
        """Perform an action on a specified log partition  # noqa: E501

        Perform an action on a specified log partition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partition_action_with_http_info(id, action, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str action: (required)
        :return: LogPartition
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partition_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `partition_action`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `partition_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'action' in params:
            path_params['action'] = params['action']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogPartition'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/partitions/{id}/{action}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_access_group(self, id, body, **kwargs):  # noqa: E501
        """Update access group  # noqa: E501

        Update access group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_access_group(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AccessGroup body: (required)
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_access_group_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_access_group_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_access_group_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update access group  # noqa: E501

        Update access group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_access_group_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AccessGroup body: (required)
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_access_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_access_group`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_access_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_admin_by_id(self, id, body, **kwargs):  # noqa: E501
        """update user  # noqa: E501

        update user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_admin_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Admin body: (required)
        :param bool change_password:
        :param bool validation_only:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_admin_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_admin_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_admin_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update user  # noqa: E501

        update user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_admin_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Admin body: (required)
        :param bool change_password:
        :param bool validation_only:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'change_password', 'validation_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_admin_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_admin_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_admin_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'change_password' in params:
            query_params.append(('changePassword', params['change_password']))  # noqa: E501
        if 'validation_only' in params:
            query_params.append(('validationOnly', params['validation_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Admin'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_alert_rule_by_id(self, id, body, **kwargs):  # noqa: E501
        """update alert rule  # noqa: E501

        update alert rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_alert_rule_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_alert_rule_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_alert_rule_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_alert_rule_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update alert rule  # noqa: E501

        update alert rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_alert_rule_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_alert_rule_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_alert_rule_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_alert_rule_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_api_token_by_admin_id(self, admin_id, apitoken_id, body, **kwargs):  # noqa: E501
        """Update API tokens for a user  # noqa: E501

        Update the API tokens for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_api_token_by_admin_id(admin_id, apitoken_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param int apitoken_id: (required)
        :param APIToken body: (required)
        :return: APIToken
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_api_token_by_admin_id_with_http_info(admin_id, apitoken_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_api_token_by_admin_id_with_http_info(admin_id, apitoken_id, body, **kwargs)  # noqa: E501
            return data

    def patch_api_token_by_admin_id_with_http_info(self, admin_id, apitoken_id, body, **kwargs):  # noqa: E501
        """Update API tokens for a user  # noqa: E501

        Update the API tokens for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_api_token_by_admin_id_with_http_info(admin_id, apitoken_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param int apitoken_id: (required)
        :param APIToken body: (required)
        :return: APIToken
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['admin_id', 'apitoken_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_api_token_by_admin_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'admin_id' is set
        if ('admin_id' not in params or
                params['admin_id'] is None):
            raise ValueError("Missing the required parameter `admin_id` when calling `patch_api_token_by_admin_id`")  # noqa: E501
        # verify the required parameter 'apitoken_id' is set
        if ('apitoken_id' not in params or
                params['apitoken_id'] is None):
            raise ValueError("Missing the required parameter `apitoken_id` when calling `patch_api_token_by_admin_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_api_token_by_admin_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'admin_id' in params:
            path_params['adminId'] = params['admin_id']  # noqa: E501
        if 'apitoken_id' in params:
            path_params['apitokenId'] = params['apitoken_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'APIToken'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{adminId}/apitokens/{apitokenId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_applies_to_function(self, id, **kwargs):  # noqa: E501
        """Update applies to function  # noqa: E501

        Update an existing applies to function  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_applies_to_function(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AppliesToFunction body:
        :param str reason:
        :param bool ignore_reference:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_applies_to_function_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_applies_to_function_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_applies_to_function_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update applies to function  # noqa: E501

        Update an existing applies to function  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_applies_to_function_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AppliesToFunction body:
        :param str reason:
        :param bool ignore_reference:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason', 'ignore_reference']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_applies_to_function" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_applies_to_function`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'ignore_reference' in params:
            query_params.append(('ignoreReference', params['ignore_reference']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AppliesToFunction'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_collector_by_id(self, id, body, **kwargs):  # noqa: E501
        """update collector  # noqa: E501

        update collector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_collector_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Collector body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_collector_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_collector_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_collector_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update collector  # noqa: E501

        update collector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_collector_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Collector body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'auto_balance_monitored_devices', 'force_update_failed_over_devices', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_collector_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_collector_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_collector_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'auto_balance_monitored_devices' in params:
            query_params.append(('autoBalanceMonitoredDevices', params['auto_balance_monitored_devices']))  # noqa: E501
        if 'force_update_failed_over_devices' in params:
            query_params.append(('forceUpdateFailedOverDevices', params['force_update_failed_over_devices']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Collector'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_collector_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update collector group  # noqa: E501

        Update the details of a specific collector group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_collector_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param CollectorGroup body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_collector_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_collector_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_collector_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update collector group  # noqa: E501

        Update the details of a specific collector group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_collector_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param CollectorGroup body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'auto_balance_monitored_devices', 'force_update_failed_over_devices', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_collector_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_collector_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_collector_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'auto_balance_monitored_devices' in params:
            query_params.append(('autoBalanceMonitoredDevices', params['auto_balance_monitored_devices']))  # noqa: E501
        if 'force_update_failed_over_devices' in params:
            query_params.append(('forceUpdateFailedOverDevices', params['force_update_failed_over_devices']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_config_source_by_id(self, id, **kwargs):  # noqa: E501
        """Update config source by ID  # noqa: E501

        Update the config source details based on the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ConfigSource body:
        :param str reason:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_config_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update config source by ID  # noqa: E501

        Update the config source details based on the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_config_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ConfigSource body:
        :param str reason:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_config_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_config_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_dashboard_by_id(self, id, body, **kwargs):  # noqa: E501
        """update dashboard  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_dashboard_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Dashboard body: (required)
        :param bool overwrite_group_fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_dashboard_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_dashboard_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_dashboard_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update dashboard  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_dashboard_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Dashboard body: (required)
        :param bool overwrite_group_fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'overwrite_group_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_dashboard_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_dashboard_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_dashboard_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'overwrite_group_fields' in params:
            query_params.append(('overwriteGroupFields', params['overwrite_group_fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Dashboard'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_dashboard_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update dashboard group  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_dashboard_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_dashboard_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_dashboard_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_dashboard_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update dashboard group  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_dashboard_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_dashboard_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_dashboard_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_dashboard_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_datasource_by_id(self, id, **kwargs):  # noqa: E501
        """Update datasource  # noqa: E501

        Updates a datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_datasource_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DataSource body:
        :param str reason:
        :param bool force_unique_identifier:
        :param str force_restricted_change_key:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_datasource_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update datasource  # noqa: E501

        Updates a datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_datasource_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DataSource body:
        :param str reason:
        :param bool force_unique_identifier:
        :param str force_restricted_change_key:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason', 'force_unique_identifier', 'force_restricted_change_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'force_unique_identifier' in params:
            query_params.append(('forceUniqueIdentifier', params['force_unique_identifier']))  # noqa: E501
        if 'force_restricted_change_key' in params:
            query_params.append(('forceRestrictedChangeKey', params['force_restricted_change_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_default_dashboard(self, id, **kwargs):  # noqa: E501
        """Update default dashboard  # noqa: E501

        Update the default dashboard settings for a user or group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_default_dashboard(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param RestUserCustomizedDataV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_default_dashboard_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_default_dashboard_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_default_dashboard_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update default dashboard  # noqa: E501

        Update the default dashboard settings for a user or group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_default_dashboard_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param RestUserCustomizedDataV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_default_dashboard" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_default_dashboard`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/userdata/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device(self, id, body, **kwargs):  # noqa: E501
        """update a device (Request schema may change depending upon the type of uptime device being updated)  # noqa: E501

        update a device (Request schema may change depending upon the type of uptime device being updated)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Device body: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str op_type:
        :param bool need_stc_grp_and_sorted_cp:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update a device (Request schema may change depending upon the type of uptime device being updated)  # noqa: E501

        update a device (Request schema may change depending upon the type of uptime device being updated)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Device body: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str op_type:
        :param bool need_stc_grp_and_sorted_cp:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'end', 'netflow_filter', 'start', 'op_type', 'need_stc_grp_and_sorted_cp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501
        if 'need_stc_grp_and_sorted_cp' in params:
            query_params.append(('needStcGrpAndSortedCP', params['need_stc_grp_and_sorted_cp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Device'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_datasource_instance_alert_setting_by_id(self, device_id, hds_id, instance_id, id, body, **kwargs):  # noqa: E501
        """update device instance alert setting  # noqa: E501

        update device instance alert setting  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_alert_setting_by_id(device_id, hds_id, instance_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceAlertSetting body: (required)
        :return: DeviceDataSourceInstanceAlertSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_datasource_instance_alert_setting_by_id_with_http_info(self, device_id, hds_id, instance_id, id, body, **kwargs):  # noqa: E501
        """update device instance alert setting  # noqa: E501

        update device instance alert setting  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceAlertSetting body: (required)
        :return: DeviceDataSourceInstanceAlertSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'instance_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_datasource_instance_alert_setting_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `patch_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `patch_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `patch_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_datasource_instance_alert_setting_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceAlertSetting'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/alertsettings/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_datasource_instance_by_id(self, device_id, hds_id, id, body, **kwargs):  # noqa: E501
        """update device instance  # noqa: E501

        update device instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_by_id(device_id, hds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param DeviceDataSourceInstance body: (required)
        :param str op_type:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_datasource_instance_by_id_with_http_info(self, device_id, hds_id, id, body, **kwargs):  # noqa: E501
        """update device instance  # noqa: E501

        update device instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param DeviceDataSourceInstance body: (required)
        :param str op_type:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_datasource_instance_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `patch_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `patch_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_datasource_instance_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstance'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_datasource_instance_group_by_id(self, device_ds_id, device_id, id, body, **kwargs):  # noqa: E501
        """Update device datasource instance group  # noqa: E501

        Update a specific device datasource instance group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_group_by_id(device_ds_id, device_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_datasource_instance_group_by_id_with_http_info(device_ds_id, device_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_datasource_instance_group_by_id_with_http_info(device_ds_id, device_id, id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_datasource_instance_group_by_id_with_http_info(self, device_ds_id, device_id, id, body, **kwargs):  # noqa: E501
        """Update device datasource instance group  # noqa: E501

        Update a specific device datasource instance group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_datasource_instance_group_by_id_with_http_info(device_ds_id, device_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_ds_id', 'device_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_datasource_instance_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `patch_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `patch_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_datasource_instance_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update device group  # noqa: E501

        update device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DeviceGroup body: (required)
        :param str op_type:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update device group  # noqa: E501

        update device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DeviceGroup body: (required)
        :param str op_type:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_group_cluster_alert_conf_by_id(self, device_group_id, id, body, **kwargs):  # noqa: E501
        """Update cluster alert configuration  # noqa: E501

        Update cluster alert configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_cluster_alert_conf_by_id(device_group_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceClusterAlertConfig body: (required)
        :return: DeviceClusterAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_group_cluster_alert_conf_by_id_with_http_info(self, device_group_id, id, body, **kwargs):  # noqa: E501
        """Update cluster alert configuration  # noqa: E501

        Update cluster alert configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceClusterAlertConfig body: (required)
        :return: DeviceClusterAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_group_cluster_alert_conf_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `patch_device_group_cluster_alert_conf_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device_group_cluster_alert_conf_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_group_cluster_alert_conf_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceClusterAlertConfig'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/clusterAlertConf/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_group_datasource_alert_setting(self, device_group_id, ds_id, body, **kwargs):  # noqa: E501
        """Update device group datasource alert setting  # noqa: E501

        Update the alert setting for a specific device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_datasource_alert_setting(device_group_id, ds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param DeviceGroupDataSourceAlertConfig body: (required)
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, **kwargs)  # noqa: E501
            return data

    def patch_device_group_datasource_alert_setting_with_http_info(self, device_group_id, ds_id, body, **kwargs):  # noqa: E501
        """Update device group datasource alert setting  # noqa: E501

        Update the alert setting for a specific device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param DeviceGroupDataSourceAlertConfig body: (required)
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'ds_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_group_datasource_alert_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `patch_device_group_datasource_alert_setting`")  # noqa: E501
        # verify the required parameter 'ds_id' is set
        if ('ds_id' not in params or
                params['ds_id'] is None):
            raise ValueError("Missing the required parameter `ds_id` when calling `patch_device_group_datasource_alert_setting`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_group_datasource_alert_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'ds_id' in params:
            path_params['dsId'] = params['ds_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSourceAlertConfig'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{dsId}/alertsettings', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_group_datasource_by_id(self, device_group_id, id, **kwargs):  # noqa: E501
        """update device group datasource  # noqa: E501

        update device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_datasource_by_id(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceGroupDataSource body:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
            return data

    def patch_device_group_datasource_by_id_with_http_info(self, device_group_id, id, **kwargs):  # noqa: E501
        """update device group datasource  # noqa: E501

        update device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_datasource_by_id_with_http_info(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceGroupDataSource body:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_group_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `patch_device_group_datasource_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_device_group_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_group_property_by_name(self, gid, name, body, **kwargs):  # noqa: E501
        """Update device group property  # noqa: E501

        Update a specific property of a device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_property_by_name(gid, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_group_property_by_name_with_http_info(gid, name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_group_property_by_name_with_http_info(gid, name, body, **kwargs)  # noqa: E501
            return data

    def patch_device_group_property_by_name_with_http_info(self, gid, name, body, **kwargs):  # noqa: E501
        """Update device group property  # noqa: E501

        Update a specific property of a device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_group_property_by_name_with_http_info(gid, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_group_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `patch_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_group_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_device_property_by_name(self, device_id, name, body, **kwargs):  # noqa: E501
        """Update device property  # noqa: E501

        Update a specific property of a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_property_by_name(device_id, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_device_property_by_name_with_http_info(device_id, name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_device_property_by_name_with_http_info(device_id, name, body, **kwargs)  # noqa: E501
            return data

    def patch_device_property_by_name_with_http_info(self, device_id, name, body, **kwargs):  # noqa: E501
        """Update device property  # noqa: E501

        Update a specific property of a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_device_property_by_name_with_http_info(device_id, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_device_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `patch_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `patch_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_device_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_diagnostic_source_by_id(self, id, **kwargs):  # noqa: E501
        """Update a diagnostics source  # noqa: E501

        Updates a diagnostics source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_diagnostic_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DiagnosticsSource body:
        :param str reason:
        :return: DiagnosticsSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_diagnostic_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_diagnostic_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_diagnostic_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a diagnostics source  # noqa: E501

        Updates a diagnostics source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_diagnostic_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DiagnosticsSource body:
        :param str reason:
        :return: DiagnosticsSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_diagnostic_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_diagnostic_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DiagnosticsSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/diagnosticsources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_escalation_chain_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update escalation chain  # noqa: E501

        Update the details of a specific escalation chain by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_escalation_chain_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_escalation_chain_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_escalation_chain_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_escalation_chain_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update escalation chain  # noqa: E501

        Update the details of a specific escalation chain by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_escalation_chain_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_escalation_chain_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_escalation_chain_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_escalation_chain_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EscalatingChain'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/chains/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_event_source_by_id(self, id, **kwargs):  # noqa: E501
        """Update event source by ID  # noqa: E501

        Updates the event source with the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_event_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EventSource body:
        :param str reason:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_event_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update event source by ID  # noqa: E501

        Updates the event source with the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_event_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EventSource body:
        :param str reason:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_event_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_event_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EventSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_job_monitor(self, id, **kwargs):  # noqa: E501
        """Update JobMonitor  # noqa: E501

        Update an existing JobMonitor by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_job_monitor(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param BatchJob body:
        :param str reason:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_job_monitor_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update JobMonitor  # noqa: E501

        Update an existing JobMonitor by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_job_monitor_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param BatchJob body:
        :param str reason:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_job_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_job_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'BatchJob'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_log_partition(self, id, **kwargs):  # noqa: E501
        """Update an existing log partition  # noqa: E501

        Update an existing log partition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_log_partition(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param LogPartition body:
        :return: LogPartition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_log_partition_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_log_partition_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_log_partition_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update an existing log partition  # noqa: E501

        Update an existing log partition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_log_partition_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param LogPartition body:
        :return: LogPartition
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_log_partition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_log_partition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogPartition'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/partitions/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_log_query_group(self, id, body, **kwargs):  # noqa: E501
        """Update log query group  # noqa: E501

        Modify an existing log query group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_log_query_group(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param LogQueryGroup body: (required)
        :return: LogQueryGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_log_query_group_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_log_query_group_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_log_query_group_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update log query group  # noqa: E501

        Modify an existing log query group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_log_query_group_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param LogQueryGroup body: (required)
        :return: LogQueryGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_log_query_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_log_query_group`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_log_query_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogQueryGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/logquerygroups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_log_source(self, id, **kwargs):  # noqa: E501
        """Update log source  # noqa: E501

        Updates an existing log source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_log_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param LogSource body:
        :param str reason:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_log_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_log_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_log_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update log source  # noqa: E501

        Updates an existing log source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_log_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param LogSource body:
        :param str reason:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_log_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_log_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_netscan(self, id, **kwargs):  # noqa: E501
        """Update a netscan  # noqa: E501

        Update an existing netscan  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_netscan(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Netscan body:
        :param str reason:
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_netscan_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_netscan_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_netscan_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a netscan  # noqa: E501

        Update an existing netscan  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_netscan_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Netscan body:
        :param str reason:
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_netscan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_netscan`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Netscan'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/netscans/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_oid(self, id, **kwargs):  # noqa: E501
        """Update an OID  # noqa: E501

        Update the details of an existing OID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_oid(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_oid_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_oid_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_oid_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update an OID  # noqa: E501

        Update the details of an existing OID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_oid_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_oid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_oid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestOidV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_ops_note_by_id(self, id, body, **kwargs):  # noqa: E501
        """update opsnote  # noqa: E501

        update opsnote  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ops_note_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param OpsNote body: (required)
        :return: OpsNote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_ops_note_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_ops_note_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_ops_note_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update opsnote  # noqa: E501

        update opsnote  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_ops_note_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param OpsNote body: (required)
        :return: OpsNote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_ops_note_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_ops_note_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_ops_note_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'OpsNote'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/opsnotes/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_property_rule(self, id, **kwargs):  # noqa: E501
        """update a property rule  # noqa: E501

        Update a property rule by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_property_rule(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param PropertyRule body:
        :param str reason:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_property_rule_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_property_rule_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_property_rule_with_http_info(self, id, **kwargs):  # noqa: E501
        """update a property rule  # noqa: E501

        Update a property rule by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_property_rule_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param PropertyRule body:
        :param str reason:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_property_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_property_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_recipient_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update recipient group  # noqa: E501

        Update a specific recipient group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_recipient_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_recipient_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_recipient_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_recipient_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update recipient group  # noqa: E501

        Update a specific recipient group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_recipient_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_recipient_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_recipient_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_recipient_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RecipientGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/recipientgroups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_remediation_source_by_id(self, id, **kwargs):  # noqa: E501
        """Update a remediation source  # noqa: E501

        Updates a remediation source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_remediation_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RemediationSource body:
        :param str reason:
        :return: RemediationSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_remediation_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_remediation_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_remediation_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a remediation source  # noqa: E501

        Updates a remediation source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_remediation_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RemediationSource body:
        :param str reason:
        :return: RemediationSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_remediation_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_remediation_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RemediationSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/remediationsources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_report_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update report  # noqa: E501

        Update the details of a specific report by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_report_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_report_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_report_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_report_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update report  # noqa: E501

        Update the details of a specific report by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_report_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_report_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_report_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_report_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportBase'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_report_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update report group  # noqa: E501

        Update a specific report group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_report_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_report_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_report_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_report_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update report group  # noqa: E501

        Update a specific report group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_report_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_report_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_report_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_report_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_role_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update role  # noqa: E501

        Update the details of a specific role by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_role_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_role_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_role_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_role_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update role  # noqa: E501

        Update the details of a specific role by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_role_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_role_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_role_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_role_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Role'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_sdt_by_id(self, id, body, **kwargs):  # noqa: E501
        """update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501

        update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_sdt_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_sdt_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_sdt_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_sdt_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501

        update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_sdt_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_sdt_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_sdt_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_sdt_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDT'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_topology_source(self, id, **kwargs):  # noqa: E501
        """Update TopologySource  # noqa: E501

        Update TopologySource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_topology_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param TopologySource body:
        :param str reason:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_topology_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_topology_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def patch_topology_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update TopologySource  # noqa: E501

        Update TopologySource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_topology_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param TopologySource body:
        :param str reason:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_topology_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_topology_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'TopologySource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_website_by_id(self, id, body, **kwargs):  # noqa: E501
        """update website  # noqa: E501

        Update website. Request structure may vary based on the check type {PingCheck | WebCheck model}. Use the respective model in SDK.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_website_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Website body: (required)
        :param str op_type:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_website_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_website_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_website_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update website  # noqa: E501

        Update website. Request structure may vary based on the check type {PingCheck | WebCheck model}. Use the respective model in SDK.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_website_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Website body: (required)
        :param str op_type:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_website_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_website_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_website_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Website'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_website_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update website group  # noqa: E501

        update website group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_website_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param WebsiteGroup body: (required)
        :param str op_type:
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_website_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_website_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_website_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update website group  # noqa: E501

        update website group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_website_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param WebsiteGroup body: (required)
        :param str op_type:
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_website_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_website_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_website_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_widget_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update widget  # noqa: E501

        Updates a widget. Based on widget type, the request and response may contain additional attributes. Please refer to the models corresponding to specific widget types at the bottom of this page for detailed attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_widget_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_widget_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_widget_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def patch_widget_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update widget  # noqa: E501

        Updates a widget. Based on widget type, the request and response may contain additional attributes. Please refer to the models corresponding to specific widget types at the bottom of this page for detailed attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_widget_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_widget_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `patch_widget_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_widget_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Widget'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schedule_auto_discovery_by_device_id(self, id, **kwargs):  # noqa: E501
        """schedule active discovery for a device  # noqa: E501

        schedule active discovery for a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schedule_auto_discovery_by_device_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.schedule_auto_discovery_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.schedule_auto_discovery_by_device_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def schedule_auto_discovery_by_device_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """schedule active discovery for a device  # noqa: E501

        schedule active discovery for a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schedule_auto_discovery_by_device_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'end', 'netflow_filter', 'start']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schedule_auto_discovery_by_device_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `schedule_auto_discovery_by_device_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}/scheduleAutoDiscovery', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_aws_account(self, body, **kwargs):  # noqa: E501
        """Test AWS account  # noqa: E501

        Test the connection or status of an AWS account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_aws_account(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAwsAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_aws_account_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.test_aws_account_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def test_aws_account_with_http_info(self, body, **kwargs):  # noqa: E501
        """Test AWS account  # noqa: E501

        Test the connection or status of an AWS account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_aws_account_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAwsAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_aws_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `test_aws_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestCloudOkPermissionsV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/aws/functions/testAccount', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_azure_account(self, body, **kwargs):  # noqa: E501
        """test Azure account  # noqa: E501

        test Azure account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_azure_account(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_azure_account_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.test_azure_account_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def test_azure_account_with_http_info(self, body, **kwargs):  # noqa: E501
        """test Azure account  # noqa: E501

        test Azure account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_azure_account_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_azure_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `test_azure_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestCloudOkPermissionsV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/azure/functions/testAccount', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_gcp_account(self, body, **kwargs):  # noqa: E501
        """test GCP account  # noqa: E501

        test GCP account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_gcp_account(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestGcpAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_gcp_account_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.test_gcp_account_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def test_gcp_account_with_http_info(self, body, **kwargs):  # noqa: E501
        """test GCP account  # noqa: E501

        test GCP account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_gcp_account_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestGcpAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_gcp_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `test_gcp_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestCloudOkPermissionsV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/gcp/functions/testAccount', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_saa_s_account(self, body, **kwargs):  # noqa: E501
        """Test SaaS account  # noqa: E501

        Test the connection or status of a SaaS account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_saa_s_account(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestSaaSAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_saa_s_account_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.test_saa_s_account_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def test_saa_s_account_with_http_info(self, body, **kwargs):  # noqa: E501
        """Test SaaS account  # noqa: E501

        Test the connection or status of a SaaS account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_saa_s_account_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestSaaSAccountTestV3 body: (required)
        :return: RestCloudOkPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_saa_s_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `test_saa_s_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestCloudOkPermissionsV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/saas/functions/testAccount', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def trigger_usage_exceeded(self, id, limit, value, **kwargs):  # noqa: E501
        """Trigger usage exceeded action for log partitions  # noqa: E501

        Trigger usage exceeded action for log partitions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.trigger_usage_exceeded(id, limit, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int limit: (required)
        :param int value: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.trigger_usage_exceeded_with_http_info(id, limit, value, **kwargs)  # noqa: E501
        else:
            (data) = self.trigger_usage_exceeded_with_http_info(id, limit, value, **kwargs)  # noqa: E501
            return data

    def trigger_usage_exceeded_with_http_info(self, id, limit, value, **kwargs):  # noqa: E501
        """Trigger usage exceeded action for log partitions  # noqa: E501

        Trigger usage exceeded action for log partitions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.trigger_usage_exceeded_with_http_info(id, limit, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int limit: (required)
        :param int value: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'limit', 'value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method trigger_usage_exceeded" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `trigger_usage_exceeded`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if ('limit' not in params or
                params['limit'] is None):
            raise ValueError("Missing the required parameter `limit` when calling `trigger_usage_exceeded`")  # noqa: E501
        # verify the required parameter 'value' is set
        if ('value' not in params or
                params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `trigger_usage_exceeded`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'limit' in params:
            path_params['limit'] = params['limit']  # noqa: E501
        if 'value' in params:
            path_params['value'] = params['value']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/partitions/triggerUsageExceeded/{id}/{limit}/{value}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_access_group(self, id, body, **kwargs):  # noqa: E501
        """Update access group  # noqa: E501

        Update access group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_group(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AccessGroup body: (required)
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_access_group_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_access_group_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_access_group_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update access group  # noqa: E501

        Update access group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_access_group_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AccessGroup body: (required)
        :return: AccessGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_access_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_access_group`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_access_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AccessGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/accessgroup/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_admin_by_id(self, id, body, **kwargs):  # noqa: E501
        """update user  # noqa: E501

        update user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_admin_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Admin body: (required)
        :param bool change_password:
        :param bool validation_only:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_admin_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_admin_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_admin_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update user  # noqa: E501

        update user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_admin_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Admin body: (required)
        :param bool change_password:
        :param bool validation_only:
        :return: Admin
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'change_password', 'validation_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_admin_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_admin_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_admin_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'change_password' in params:
            query_params.append(('changePassword', params['change_password']))  # noqa: E501
        if 'validation_only' in params:
            query_params.append(('validationOnly', params['validation_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Admin'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_alert_rule_by_id(self, id, body, **kwargs):  # noqa: E501
        """update alert rule  # noqa: E501

        update alert rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_alert_rule_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_alert_rule_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_alert_rule_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_alert_rule_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update alert rule  # noqa: E501

        update alert rule  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_alert_rule_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AlertRule body: (required)
        :return: AlertRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_alert_rule_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_alert_rule_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_alert_rule_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AlertRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/rules/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_api_token_by_admin_id(self, admin_id, apitoken_id, body, **kwargs):  # noqa: E501
        """Update API tokens for a user  # noqa: E501

        Update the API tokens for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_api_token_by_admin_id(admin_id, apitoken_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param int apitoken_id: (required)
        :param APIToken body: (required)
        :return: APIToken
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_api_token_by_admin_id_with_http_info(admin_id, apitoken_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_api_token_by_admin_id_with_http_info(admin_id, apitoken_id, body, **kwargs)  # noqa: E501
            return data

    def update_api_token_by_admin_id_with_http_info(self, admin_id, apitoken_id, body, **kwargs):  # noqa: E501
        """Update API tokens for a user  # noqa: E501

        Update the API tokens for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_api_token_by_admin_id_with_http_info(admin_id, apitoken_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int admin_id: (required)
        :param int apitoken_id: (required)
        :param APIToken body: (required)
        :return: APIToken
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['admin_id', 'apitoken_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_api_token_by_admin_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'admin_id' is set
        if ('admin_id' not in params or
                params['admin_id'] is None):
            raise ValueError("Missing the required parameter `admin_id` when calling `update_api_token_by_admin_id`")  # noqa: E501
        # verify the required parameter 'apitoken_id' is set
        if ('apitoken_id' not in params or
                params['apitoken_id'] is None):
            raise ValueError("Missing the required parameter `apitoken_id` when calling `update_api_token_by_admin_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_api_token_by_admin_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'admin_id' in params:
            path_params['adminId'] = params['admin_id']  # noqa: E501
        if 'apitoken_id' in params:
            path_params['apitokenId'] = params['apitoken_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'APIToken'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/admins/{adminId}/apitokens/{apitokenId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_applies_to_function(self, id, **kwargs):  # noqa: E501
        """Update applies to function  # noqa: E501

        Update an existing applies to function  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_applies_to_function(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AppliesToFunction body:
        :param str reason:
        :param bool ignore_reference:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_applies_to_function_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_applies_to_function_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_applies_to_function_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update applies to function  # noqa: E501

        Update an existing applies to function  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_applies_to_function_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param AppliesToFunction body:
        :param str reason:
        :param bool ignore_reference:
        :return: AppliesToFunction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason', 'ignore_reference']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_applies_to_function" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_applies_to_function`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'ignore_reference' in params:
            query_params.append(('ignoreReference', params['ignore_reference']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'AppliesToFunction'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/functions/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_collector_by_id(self, id, body, **kwargs):  # noqa: E501
        """update collector  # noqa: E501

        update collector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_collector_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Collector body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_collector_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_collector_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_collector_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update collector  # noqa: E501

        update collector  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_collector_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Collector body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: Collector
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'auto_balance_monitored_devices', 'force_update_failed_over_devices', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_collector_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_collector_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_collector_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'auto_balance_monitored_devices' in params:
            query_params.append(('autoBalanceMonitoredDevices', params['auto_balance_monitored_devices']))  # noqa: E501
        if 'force_update_failed_over_devices' in params:
            query_params.append(('forceUpdateFailedOverDevices', params['force_update_failed_over_devices']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Collector'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/collectors/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_collector_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update collector group  # noqa: E501

        Update the details of a specific collector group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_collector_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param CollectorGroup body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_collector_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_collector_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_collector_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update collector group  # noqa: E501

        Update the details of a specific collector group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_collector_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param CollectorGroup body: (required)
        :param bool auto_balance_monitored_devices:
        :param bool force_update_failed_over_devices:
        :param str op_type:
        :return: CollectorGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'auto_balance_monitored_devices', 'force_update_failed_over_devices', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_collector_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_collector_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_collector_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'auto_balance_monitored_devices' in params:
            query_params.append(('autoBalanceMonitoredDevices', params['auto_balance_monitored_devices']))  # noqa: E501
        if 'force_update_failed_over_devices' in params:
            query_params.append(('forceUpdateFailedOverDevices', params['force_update_failed_over_devices']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'CollectorGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/collector/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_config_source_by_id(self, id, **kwargs):  # noqa: E501
        """Update config source by ID  # noqa: E501

        Update the config source details based on the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_config_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ConfigSource body:
        :param str reason:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_config_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_config_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update config source by ID  # noqa: E501

        Update the config source details based on the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_config_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ConfigSource body:
        :param str reason:
        :return: ConfigSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_config_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_config_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ConfigSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/configsources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard_by_id(self, id, body, **kwargs):  # noqa: E501
        """update dashboard  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dashboard_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Dashboard body: (required)
        :param bool overwrite_group_fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dashboard_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_dashboard_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update dashboard  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dashboard_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Dashboard body: (required)
        :param bool overwrite_group_fields:
        :return: Dashboard
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'overwrite_group_fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_dashboard_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_dashboard_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'overwrite_group_fields' in params:
            query_params.append(('overwriteGroupFields', params['overwrite_group_fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Dashboard'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/dashboards/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_dashboard_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update dashboard group  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dashboard_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_dashboard_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_dashboard_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_dashboard_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update dashboard group  # noqa: E501

        The template field works only for the POST API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_dashboard_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DashboardGroup body: (required)
        :return: DashboardGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_dashboard_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_dashboard_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_dashboard_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DashboardGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_datasource_by_id(self, id, **kwargs):  # noqa: E501
        """Update datasource  # noqa: E501

        Updates a datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_datasource_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DataSource body:
        :param str reason:
        :param bool force_unique_identifier:
        :param str force_restricted_change_key:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_datasource_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_datasource_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update datasource  # noqa: E501

        Updates a datasource by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_datasource_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DataSource body:
        :param str reason:
        :param bool force_unique_identifier:
        :param str force_restricted_change_key:
        :return: DataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason', 'force_unique_identifier', 'force_restricted_change_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'force_unique_identifier' in params:
            query_params.append(('forceUniqueIdentifier', params['force_unique_identifier']))  # noqa: E501
        if 'force_restricted_change_key' in params:
            query_params.append(('forceRestrictedChangeKey', params['force_restricted_change_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/datasources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_default_dashboard(self, id, **kwargs):  # noqa: E501
        """Update default dashboard  # noqa: E501

        Update the default dashboard settings for a user or group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_default_dashboard(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param RestUserCustomizedDataV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_default_dashboard_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_default_dashboard_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_default_dashboard_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update default dashboard  # noqa: E501

        Update the default dashboard settings for a user or group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_default_dashboard_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param RestUserCustomizedDataV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_default_dashboard" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_default_dashboard`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/userdata/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device(self, id, body, **kwargs):  # noqa: E501
        """update a device (Request schema may change depending upon the type of uptime device being updated)  # noqa: E501

        update a device (Request schema may change depending upon the type of uptime device being updated)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Device body: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str op_type:
        :param bool need_stc_grp_and_sorted_cp:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_device_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update a device (Request schema may change depending upon the type of uptime device being updated)  # noqa: E501

        update a device (Request schema may change depending upon the type of uptime device being updated)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Device body: (required)
        :param int end:
        :param str netflow_filter:
        :param int start:
        :param str op_type:
        :param bool need_stc_grp_and_sorted_cp:
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'end', 'netflow_filter', 'start', 'op_type', 'need_stc_grp_and_sorted_cp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'netflow_filter' in params:
            query_params.append(('netflowFilter', params['netflow_filter']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501
        if 'need_stc_grp_and_sorted_cp' in params:
            query_params.append(('needStcGrpAndSortedCP', params['need_stc_grp_and_sorted_cp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Device'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_datasource_instance_alert_setting_by_id(self, device_id, hds_id, instance_id, id, body, **kwargs):  # noqa: E501
        """update device instance alert setting  # noqa: E501

        update device instance alert setting  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_alert_setting_by_id(device_id, hds_id, instance_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceAlertSetting body: (required)
        :return: DeviceDataSourceInstanceAlertSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, **kwargs)  # noqa: E501
            return data

    def update_device_datasource_instance_alert_setting_by_id_with_http_info(self, device_id, hds_id, instance_id, id, body, **kwargs):  # noqa: E501
        """update device instance alert setting  # noqa: E501

        update device instance alert setting  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_alert_setting_by_id_with_http_info(device_id, hds_id, instance_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: Device-DataSource ID (required)
        :param int instance_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceAlertSetting body: (required)
        :return: DeviceDataSourceInstanceAlertSetting
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'instance_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_datasource_instance_alert_setting_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `update_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `update_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'instance_id' is set
        if ('instance_id' not in params or
                params['instance_id'] is None):
            raise ValueError("Missing the required parameter `instance_id` when calling `update_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_datasource_instance_alert_setting_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_datasource_instance_alert_setting_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'instance_id' in params:
            path_params['instanceId'] = params['instance_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceAlertSetting'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{instanceId}/alertsettings/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_datasource_instance_by_id(self, device_id, hds_id, id, body, **kwargs):  # noqa: E501
        """update device instance  # noqa: E501

        update device instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_by_id(device_id, hds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param DeviceDataSourceInstance body: (required)
        :param str op_type:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, **kwargs)  # noqa: E501
            return data

    def update_device_datasource_instance_by_id_with_http_info(self, device_id, hds_id, id, body, **kwargs):  # noqa: E501
        """update device instance  # noqa: E501

        update device instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_by_id_with_http_info(device_id, hds_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param int hds_id: The device-datasource ID (required)
        :param int id: (required)
        :param DeviceDataSourceInstance body: (required)
        :param str op_type:
        :return: DeviceDataSourceInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'hds_id', 'id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_datasource_instance_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `update_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'hds_id' is set
        if ('hds_id' not in params or
                params['hds_id'] is None):
            raise ValueError("Missing the required parameter `hds_id` when calling `update_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_datasource_instance_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_datasource_instance_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'hds_id' in params:
            path_params['hdsId'] = params['hds_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstance'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{hdsId}/instances/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_datasource_instance_group_by_id(self, device_ds_id, device_id, id, body, **kwargs):  # noqa: E501
        """Update device datasource instance group  # noqa: E501

        Update a specific device datasource instance group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_group_by_id(device_ds_id, device_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_datasource_instance_group_by_id_with_http_info(device_ds_id, device_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_datasource_instance_group_by_id_with_http_info(device_ds_id, device_id, id, body, **kwargs)  # noqa: E501
            return data

    def update_device_datasource_instance_group_by_id_with_http_info(self, device_ds_id, device_id, id, body, **kwargs):  # noqa: E501
        """Update device datasource instance group  # noqa: E501

        Update a specific device datasource instance group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_datasource_instance_group_by_id_with_http_info(device_ds_id, device_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param int id: (required)
        :param DeviceDataSourceInstanceGroup body: (required)
        :return: DeviceDataSourceInstanceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_ds_id', 'device_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_datasource_instance_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `update_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `update_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_datasource_instance_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_datasource_instance_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceDataSourceInstanceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update device group  # noqa: E501

        update device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DeviceGroup body: (required)
        :param str op_type:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_device_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update device group  # noqa: E501

        update device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DeviceGroup body: (required)
        :param str op_type:
        :return: DeviceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_group_cluster_alert_conf_by_id(self, device_group_id, id, body, **kwargs):  # noqa: E501
        """Update cluster alert configuration  # noqa: E501

        Update cluster alert configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_cluster_alert_conf_by_id(device_group_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceClusterAlertConfig body: (required)
        :return: DeviceClusterAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, body, **kwargs)  # noqa: E501
            return data

    def update_device_group_cluster_alert_conf_by_id_with_http_info(self, device_group_id, id, body, **kwargs):  # noqa: E501
        """Update cluster alert configuration  # noqa: E501

        Update cluster alert configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_cluster_alert_conf_by_id_with_http_info(device_group_id, id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceClusterAlertConfig body: (required)
        :return: DeviceClusterAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_group_cluster_alert_conf_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `update_device_group_cluster_alert_conf_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_group_cluster_alert_conf_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_group_cluster_alert_conf_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceClusterAlertConfig'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/clusterAlertConf/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_group_datasource_alert_setting(self, device_group_id, ds_id, body, **kwargs):  # noqa: E501
        """Update device group datasource alert setting  # noqa: E501

        Update the alert setting for a specific device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_datasource_alert_setting(device_group_id, ds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param DeviceGroupDataSourceAlertConfig body: (required)
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, **kwargs)  # noqa: E501
            return data

    def update_device_group_datasource_alert_setting_with_http_info(self, device_group_id, ds_id, body, **kwargs):  # noqa: E501
        """Update device group datasource alert setting  # noqa: E501

        Update the alert setting for a specific device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_datasource_alert_setting_with_http_info(device_group_id, ds_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int ds_id: (required)
        :param DeviceGroupDataSourceAlertConfig body: (required)
        :return: DeviceGroupDataSourceAlertConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'ds_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_group_datasource_alert_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `update_device_group_datasource_alert_setting`")  # noqa: E501
        # verify the required parameter 'ds_id' is set
        if ('ds_id' not in params or
                params['ds_id'] is None):
            raise ValueError("Missing the required parameter `ds_id` when calling `update_device_group_datasource_alert_setting`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_group_datasource_alert_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'ds_id' in params:
            path_params['dsId'] = params['ds_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSourceAlertConfig'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{dsId}/alertsettings', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_group_datasource_by_id(self, device_group_id, id, **kwargs):  # noqa: E501
        """update device group datasource  # noqa: E501

        update device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_datasource_by_id(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceGroupDataSource body:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_group_datasource_by_id_with_http_info(device_group_id, id, **kwargs)  # noqa: E501
            return data

    def update_device_group_datasource_by_id_with_http_info(self, device_group_id, id, **kwargs):  # noqa: E501
        """update device group datasource  # noqa: E501

        update device group datasource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_datasource_by_id_with_http_info(device_group_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_group_id: (required)
        :param int id: (required)
        :param DeviceGroupDataSource body:
        :return: DeviceGroupDataSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_group_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_group_datasource_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_group_id' is set
        if ('device_group_id' not in params or
                params['device_group_id'] is None):
            raise ValueError("Missing the required parameter `device_group_id` when calling `update_device_group_datasource_by_id`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_group_datasource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_group_id' in params:
            path_params['deviceGroupId'] = params['device_group_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DeviceGroupDataSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{deviceGroupId}/datasources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_group_property_by_name(self, gid, name, body, **kwargs):  # noqa: E501
        """Update device group property  # noqa: E501

        Update a specific property of a device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_property_by_name(gid, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_group_property_by_name_with_http_info(gid, name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_group_property_by_name_with_http_info(gid, name, body, **kwargs)  # noqa: E501
            return data

    def update_device_group_property_by_name_with_http_info(self, gid, name, body, **kwargs):  # noqa: E501
        """Update device group property  # noqa: E501

        Update a specific property of a device group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_group_property_by_name_with_http_info(gid, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int gid: group ID (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['gid', 'name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_group_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'gid' is set
        if ('gid' not in params or
                params['gid'] is None):
            raise ValueError("Missing the required parameter `gid` when calling `update_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_device_group_property_by_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_group_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'gid' in params:
            path_params['gid'] = params['gid']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/groups/{gid}/properties/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_property_by_name(self, device_id, name, body, **kwargs):  # noqa: E501
        """Update device property  # noqa: E501

        Update a specific property of a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_property_by_name(device_id, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_property_by_name_with_http_info(device_id, name, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_property_by_name_with_http_info(device_id, name, body, **kwargs)  # noqa: E501
            return data

    def update_device_property_by_name_with_http_info(self, device_id, name, body, **kwargs):  # noqa: E501
        """Update device property  # noqa: E501

        Update a specific property of a device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_property_by_name_with_http_info(device_id, name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_id: (required)
        :param str name: (required)
        :param EntityProperty body: (required)
        :return: EntityProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_id', 'name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_property_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `update_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_device_property_by_name`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_property_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EntityProperty'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/properties/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_diagnostic_source_by_id(self, id, **kwargs):  # noqa: E501
        """Update a diagnostics source  # noqa: E501

        Updates a diagnostics source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_diagnostic_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DiagnosticsSource body:
        :param str reason:
        :return: DiagnosticsSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_diagnostic_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_diagnostic_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_diagnostic_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a diagnostics source  # noqa: E501

        Updates a diagnostics source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_diagnostic_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DiagnosticsSource body:
        :param str reason:
        :return: DiagnosticsSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_diagnostic_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_diagnostic_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'DiagnosticsSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/diagnosticsources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_escalation_chain_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update escalation chain  # noqa: E501

        Update the details of a specific escalation chain by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_escalation_chain_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_escalation_chain_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_escalation_chain_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_escalation_chain_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update escalation chain  # noqa: E501

        Update the details of a specific escalation chain by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_escalation_chain_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EscalatingChain body: (required)
        :return: EscalatingChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_escalation_chain_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_escalation_chain_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_escalation_chain_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EscalatingChain'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/alert/chains/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_event_source_by_id(self, id, **kwargs):  # noqa: E501
        """Update event source by ID  # noqa: E501

        Updates the event source with the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_event_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EventSource body:
        :param str reason:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_event_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_event_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update event source by ID  # noqa: E501

        Updates the event source with the provided ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_event_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param EventSource body:
        :param str reason:
        :return: EventSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_event_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_event_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'EventSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/eventsources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_instance_group_alert_threshold(self, device_ds_id, device_id, dsig_id, dp_id, **kwargs):  # noqa: E501
        """Update instance group alert threshold  # noqa: E501

        Update the alert threshold for an instance group. Setting the threshold at the default group is not allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_instance_group_alert_threshold(device_ds_id, device_id, dsig_id, dp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param int dsig_id: (required)
        :param int dp_id: (required)
        :param RestDeviceInstanceGroupAlertConfigV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_instance_group_alert_threshold_with_http_info(device_ds_id, device_id, dsig_id, dp_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_instance_group_alert_threshold_with_http_info(device_ds_id, device_id, dsig_id, dp_id, **kwargs)  # noqa: E501
            return data

    def update_instance_group_alert_threshold_with_http_info(self, device_ds_id, device_id, dsig_id, dp_id, **kwargs):  # noqa: E501
        """Update instance group alert threshold  # noqa: E501

        Update the alert threshold for an instance group. Setting the threshold at the default group is not allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_instance_group_alert_threshold_with_http_info(device_ds_id, device_id, dsig_id, dp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int device_ds_id: The device-datasource ID you'd like to add an instance group for (required)
        :param int device_id: (required)
        :param int dsig_id: (required)
        :param int dp_id: (required)
        :param RestDeviceInstanceGroupAlertConfigV3 body:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_ds_id', 'device_id', 'dsig_id', 'dp_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_instance_group_alert_threshold" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_ds_id' is set
        if ('device_ds_id' not in params or
                params['device_ds_id'] is None):
            raise ValueError("Missing the required parameter `device_ds_id` when calling `update_instance_group_alert_threshold`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if ('device_id' not in params or
                params['device_id'] is None):
            raise ValueError("Missing the required parameter `device_id` when calling `update_instance_group_alert_threshold`")  # noqa: E501
        # verify the required parameter 'dsig_id' is set
        if ('dsig_id' not in params or
                params['dsig_id'] is None):
            raise ValueError("Missing the required parameter `dsig_id` when calling `update_instance_group_alert_threshold`")  # noqa: E501
        # verify the required parameter 'dp_id' is set
        if ('dp_id' not in params or
                params['dp_id'] is None):
            raise ValueError("Missing the required parameter `dp_id` when calling `update_instance_group_alert_threshold`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_ds_id' in params:
            path_params['deviceDsId'] = params['device_ds_id']  # noqa: E501
        if 'device_id' in params:
            path_params['deviceId'] = params['device_id']  # noqa: E501
        if 'dsig_id' in params:
            path_params['dsigId'] = params['dsig_id']  # noqa: E501
        if 'dp_id' in params:
            path_params['dpId'] = params['dp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'object'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/device/devices/{deviceId}/devicedatasources/{deviceDsId}/groups/{dsigId}/datapoints/{dpId}/alertconfig', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_job_monitor(self, id, **kwargs):  # noqa: E501
        """Update JobMonitor  # noqa: E501

        Update an existing JobMonitor by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_job_monitor(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param BatchJob body:
        :param str reason:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_job_monitor_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_job_monitor_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update JobMonitor  # noqa: E501

        Update an existing JobMonitor by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_job_monitor_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param BatchJob body:
        :param str reason:
        :return: BatchJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_job_monitor" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_job_monitor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'BatchJob'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/batchjobs/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_log_partition(self, id, **kwargs):  # noqa: E501
        """Update an existing log partition  # noqa: E501

        Update an existing log partition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_log_partition(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param LogPartition body:
        :return: LogPartition
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_log_partition_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_log_partition_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_log_partition_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update an existing log partition  # noqa: E501

        Update an existing log partition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_log_partition_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param LogPartition body:
        :return: LogPartition
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_log_partition" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_log_partition`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogPartition'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/partitions/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_log_query_group(self, id, body, **kwargs):  # noqa: E501
        """Update log query group  # noqa: E501

        Modify an existing log query group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_log_query_group(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param LogQueryGroup body: (required)
        :return: LogQueryGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_log_query_group_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_log_query_group_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_log_query_group_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update log query group  # noqa: E501

        Modify an existing log query group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_log_query_group_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param LogQueryGroup body: (required)
        :return: LogQueryGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_log_query_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_log_query_group`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_log_query_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogQueryGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/log/logquerygroups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_log_source(self, id, **kwargs):  # noqa: E501
        """Update log source  # noqa: E501

        Updates an existing log source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_log_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param LogSource body:
        :param str reason:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_log_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_log_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_log_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update log source  # noqa: E501

        Updates an existing log source  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_log_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param LogSource body:
        :param str reason:
        :return: LogSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_log_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_log_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'LogSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/logsources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_netscan(self, id, **kwargs):  # noqa: E501
        """Update a netscan  # noqa: E501

        Update an existing netscan  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_netscan(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Netscan body:
        :param str reason:
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_netscan_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_netscan_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_netscan_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a netscan  # noqa: E501

        Update an existing netscan  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_netscan_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Netscan body:
        :param str reason:
        :return: Netscan
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_netscan" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_netscan`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Netscan'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/netscans/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_oid(self, id, **kwargs):  # noqa: E501
        """Update an OID  # noqa: E501

        Update the details of an existing OID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_oid(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_oid_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_oid_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_oid_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update an OID  # noqa: E501

        Update the details of an existing OID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_oid_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RestOidV3 body:
        :return: RestOidV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_oid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_oid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestOidV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/oids/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ops_note_by_id(self, id, body, **kwargs):  # noqa: E501
        """update opsnote  # noqa: E501

        update opsnote  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ops_note_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param OpsNote body: (required)
        :return: OpsNote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ops_note_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ops_note_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_ops_note_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update opsnote  # noqa: E501

        update opsnote  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ops_note_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param OpsNote body: (required)
        :return: OpsNote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ops_note_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_ops_note_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_ops_note_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'OpsNote'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/opsnotes/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_property_rule(self, id, **kwargs):  # noqa: E501
        """update a property rule  # noqa: E501

        Update a property rule by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_property_rule(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param PropertyRule body:
        :param str reason:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_property_rule_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_property_rule_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_property_rule_with_http_info(self, id, **kwargs):  # noqa: E501
        """update a property rule  # noqa: E501

        Update a property rule by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_property_rule_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param PropertyRule body:
        :param str reason:
        :return: PropertyRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_property_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_property_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'PropertyRule'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/propertyrules/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_recipient_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update recipient group  # noqa: E501

        Update a specific recipient group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_recipient_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_recipient_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_recipient_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_recipient_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update recipient group  # noqa: E501

        Update a specific recipient group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_recipient_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RecipientGroup body: (required)
        :return: RecipientGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_recipient_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_recipient_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_recipient_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RecipientGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/recipientgroups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_remediation_source_by_id(self, id, **kwargs):  # noqa: E501
        """Update a remediation source  # noqa: E501

        Updates a remediation source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_remediation_source_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RemediationSource body:
        :param str reason:
        :return: RemediationSource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_remediation_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_remediation_source_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_remediation_source_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update a remediation source  # noqa: E501

        Updates a remediation source by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_remediation_source_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param RemediationSource body:
        :param str reason:
        :return: RemediationSource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_remediation_source_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_remediation_source_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RemediationSource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/remediationsources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_report_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update report  # noqa: E501

        Update the details of a specific report by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_report_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_report_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_report_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_report_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update report  # noqa: E501

        Update the details of a specific report by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_report_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportBase body: (required)
        :return: ReportBase
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_report_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_report_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_report_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportBase'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/reports/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_report_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update report group  # noqa: E501

        Update a specific report group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_report_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_report_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_report_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_report_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update report group  # noqa: E501

        Update a specific report group by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_report_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param ReportGroup body: (required)
        :return: ReportGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_report_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_report_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_report_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'ReportGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/report/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_role_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update role  # noqa: E501

        Update the details of a specific role by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_role_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_role_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_role_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_role_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update role  # noqa: E501

        Update the details of a specific role by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_role_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Role body: (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_role_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_role_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_role_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Role'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/roles/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_sdt_by_id(self, id, body, **kwargs):  # noqa: E501
        """update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501

        update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_sdt_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_sdt_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_sdt_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_sdt_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501

        update SDT (Response may contain extra fields depending upon the type of SDT being updated)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_sdt_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param SDT body: (required)
        :return: SDT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_sdt_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_sdt_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_sdt_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'SDT'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/sdt/sdts/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_topology_source(self, id, **kwargs):  # noqa: E501
        """Update TopologySource  # noqa: E501

        Update TopologySource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_topology_source(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param TopologySource body:
        :param str reason:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_topology_source_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_topology_source_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_topology_source_with_http_info(self, id, **kwargs):  # noqa: E501
        """Update TopologySource  # noqa: E501

        Update TopologySource  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_topology_source_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param TopologySource body:
        :param str reason:
        :return: TopologySource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'reason']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_topology_source" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_topology_source`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'TopologySource'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/setting/topologysources/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_website_by_id(self, id, body, **kwargs):  # noqa: E501
        """update website  # noqa: E501

        Update website. Request structure may vary based on the check type {PingCheck | WebCheck model}. Use the respective model in SDK.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_website_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Website body: (required)
        :param str op_type:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_website_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_website_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_website_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update website  # noqa: E501

        Update website. Request structure may vary based on the check type {PingCheck | WebCheck model}. Use the respective model in SDK.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_website_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Website body: (required)
        :param str op_type:
        :return: Website
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_website_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_website_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_website_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Website'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/websites/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_website_group_by_id(self, id, body, **kwargs):  # noqa: E501
        """update website group  # noqa: E501

        update website group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_website_group_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param WebsiteGroup body: (required)
        :param str op_type:
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_website_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_website_group_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_website_group_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """update website group  # noqa: E501

        update website group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_website_group_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param WebsiteGroup body: (required)
        :param str op_type:
        :return: WebsiteGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body', 'op_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_website_group_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_website_group_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_website_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'op_type' in params:
            query_params.append(('opType', params['op_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'WebsiteGroup'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/website/groups/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_widget_by_id(self, id, body, **kwargs):  # noqa: E501
        """Update widget  # noqa: E501

        Updates a widget. Based on widget type, the request and response may contain additional attributes. Please refer to the models corresponding to specific widget types at the bottom of this page for detailed attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_widget_by_id(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_widget_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_widget_by_id_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def update_widget_by_id_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Update widget  # noqa: E501

        Updates a widget. Based on widget type, the request and response may contain additional attributes. Please refer to the models corresponding to specific widget types at the bottom of this page for detailed attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_widget_by_id_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param Widget body: (required)
        :return: Widget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_widget_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_widget_by_id`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_widget_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'Widget'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/dashboard/widgets/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_aws_billing_permissions(self, body, **kwargs):  # noqa: E501
        """Verify AWS Billing Permissions  # noqa: E501

        Verify the billing permissions of an AWS account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_aws_billing_permissions(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAwsAccountTestV3 body: (required)
        :return: RestAWSVerifyBillingPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.verify_aws_billing_permissions_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.verify_aws_billing_permissions_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def verify_aws_billing_permissions_with_http_info(self, body, **kwargs):  # noqa: E501
        """Verify AWS Billing Permissions  # noqa: E501

        Verify the billing permissions of an AWS account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_aws_billing_permissions_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAwsAccountTestV3 body: (required)
        :return: RestAWSVerifyBillingPermissionsV3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_aws_billing_permissions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `verify_aws_billing_permissions`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestAWSVerifyBillingPermissionsV3'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/aws/functions/verifyBillingPermissions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_storage_accounts_permissions(self, body, **kwargs):  # noqa: E501
        """view storage accounts  # noqa: E501

        view storage accounts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_storage_accounts_permissions(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureStorageAccountVerify body: (required)
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.verify_storage_accounts_permissions_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.verify_storage_accounts_permissions_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def verify_storage_accounts_permissions_with_http_info(self, body, **kwargs):  # noqa: E501
        """view storage accounts  # noqa: E501

        view storage accounts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_storage_accounts_permissions_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RestAzureStorageAccountVerify body: (required)
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('return_raw_response')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_storage_accounts_permissions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `verify_storage_accounts_permissions`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['LMv1']  # noqa: E501
        if 'return_raw_response' in params and params["return_raw_response"]==True:
            _response_type="raw_response"
        else:
            _response_type = 'RestResponse'
        _preload_content_value = True
        if _response_type == 'str':
            _preload_content_value = False

        return self.api_client.call_api(
            '/azure/functions/verifyStorageAccountsPermissions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=_response_type,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=_preload_content_value,
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
