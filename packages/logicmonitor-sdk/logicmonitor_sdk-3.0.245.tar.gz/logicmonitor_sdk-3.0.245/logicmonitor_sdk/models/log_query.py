# coding: utf-8

"""
    LogicMonitor REST API

    LogicMonitor is a SaaS-based performance monitoring platform that provides full visibility into complex, hybrid infrastructures, offering granular performance monitoring and actionable data and insights. logicmonitor_sdk enables you to manage your LogicMonitor account programmatically. <br> <br> Note: <ul> <li> For Python SDKs, the REQUEST parameters can contain camelCase or an underscore. </li> <li> Both underscore and camelCase are supported if parameters are encapsulated within the body. </li> <li> Only camelCase is supported if parameters are encapsulated within the body and also if the user is passing raw JSON as REQUEST parameter. However, the RESPONSE parameters always contain an underscore. For example, you can use testLocation or test_location in the REQUEST parameter. But the RESPONSE parameter will always be test_location. </li> <li> The fields parameter only supports camelCase. </li> </ul>  # noqa: E501

    OpenAPI spec version: 3.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class LogQuery(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'partitions': 'list[str]',
        'trackable': 'bool',
        'identifier': 'ObjectIdentifier',
        'start_ms': 'int',
        'end_ms': 'int',
        'query': 'str',
        'group_id': 'int',
        'into_rest_response': 'RestResponse',
        'label': 'str',
        'favourite': 'bool',
        'version': 'str',
        'duration': 'str',
        'admin_name': 'str',
        'group_name': 'str',
        'related_into_rest_response': 'RestResponse',
        'model': 'str',
        'id': 'str',
        'is_aggregate': 'bool'
    }

    attribute_map = {
        'partitions': 'partitions',
        'trackable': 'trackable',
        'identifier': 'identifier',
        'start_ms': 'startMs',
        'end_ms': 'endMs',
        'query': 'query',
        'group_id': 'groupId',
        'into_rest_response': 'intoRestResponse',
        'label': 'label',
        'favourite': 'favourite',
        'version': 'version',
        'duration': 'duration',
        'admin_name': 'adminName',
        'group_name': 'groupName',
        'related_into_rest_response': 'relatedIntoRestResponse',
        'model': 'model',
        'id': 'id',
        'is_aggregate': 'isAggregate'
    }

    def __init__(self, partitions=None, trackable=None, identifier=None, start_ms=None, end_ms=None, query=None, group_id=None, into_rest_response=None, label=None, favourite=None, version=None, duration=None, admin_name=None, group_name=None, related_into_rest_response=None, model=None, id=None, is_aggregate=None):  # noqa: E501
        """LogQuery - a model defined in Swagger"""  # noqa: E501
        self._partitions = None
        self._trackable = None
        self._identifier = None
        self._start_ms = None
        self._end_ms = None
        self._query = None
        self._group_id = None
        self._into_rest_response = None
        self._label = None
        self._favourite = None
        self._version = None
        self._duration = None
        self._admin_name = None
        self._group_name = None
        self._related_into_rest_response = None
        self._model = None
        self._id = None
        self._is_aggregate = None
        self.discriminator = None
        if partitions is not None:
            self.partitions = partitions
        if trackable is not None:
            self.trackable = trackable
        if identifier is not None:
            self.identifier = identifier
        if start_ms is not None:
            self.start_ms = start_ms
        if end_ms is not None:
            self.end_ms = end_ms
        if query is not None:
            self.query = query
        if group_id is not None:
            self.group_id = group_id
        if into_rest_response is not None:
            self.into_rest_response = into_rest_response
        if label is not None:
            self.label = label
        if favourite is not None:
            self.favourite = favourite
        self.version = version
        if duration is not None:
            self.duration = duration
        if admin_name is not None:
            self.admin_name = admin_name
        if group_name is not None:
            self.group_name = group_name
        if related_into_rest_response is not None:
            self.related_into_rest_response = related_into_rest_response
        if model is not None:
            self.model = model
        self.id = id
        if is_aggregate is not None:
            self.is_aggregate = is_aggregate

    @property
    def partitions(self):
        """Gets the partitions of this LogQuery.  # noqa: E501

        partitions associated with the query  # noqa: E501

        :return: The partitions of this LogQuery.  # noqa: E501
        :rtype: list[str]
        """
        return self._partitions

    @partitions.setter
    def partitions(self, partitions):
        """Sets the partitions of this LogQuery.

        partitions associated with the query  # noqa: E501

        :param partitions: The partitions of this LogQuery.  # noqa: E501
        :type: list[str]
        """

        self._partitions = partitions

    @property
    def trackable(self):
        """Gets the trackable of this LogQuery.  # noqa: E501


        :return: The trackable of this LogQuery.  # noqa: E501
        :rtype: bool
        """
        return self._trackable

    @trackable.setter
    def trackable(self, trackable):
        """Sets the trackable of this LogQuery.


        :param trackable: The trackable of this LogQuery.  # noqa: E501
        :type: bool
        """

        self._trackable = trackable

    @property
    def identifier(self):
        """Gets the identifier of this LogQuery.  # noqa: E501


        :return: The identifier of this LogQuery.  # noqa: E501
        :rtype: ObjectIdentifier
        """
        return self._identifier

    @identifier.setter
    def identifier(self, identifier):
        """Sets the identifier of this LogQuery.


        :param identifier: The identifier of this LogQuery.  # noqa: E501
        :type: ObjectIdentifier
        """

        self._identifier = identifier

    @property
    def start_ms(self):
        """Gets the start_ms of this LogQuery.  # noqa: E501

        start time epoch in ms for log filter  # noqa: E501

        :return: The start_ms of this LogQuery.  # noqa: E501
        :rtype: int
        """
        return self._start_ms

    @start_ms.setter
    def start_ms(self, start_ms):
        """Sets the start_ms of this LogQuery.

        start time epoch in ms for log filter  # noqa: E501

        :param start_ms: The start_ms of this LogQuery.  # noqa: E501
        :type: int
        """

        self._start_ms = start_ms

    @property
    def end_ms(self):
        """Gets the end_ms of this LogQuery.  # noqa: E501

        end time epoch in ms for log filter  # noqa: E501

        :return: The end_ms of this LogQuery.  # noqa: E501
        :rtype: int
        """
        return self._end_ms

    @end_ms.setter
    def end_ms(self, end_ms):
        """Sets the end_ms of this LogQuery.

        end time epoch in ms for log filter  # noqa: E501

        :param end_ms: The end_ms of this LogQuery.  # noqa: E501
        :type: int
        """

        self._end_ms = end_ms

    @property
    def query(self):
        """Gets the query of this LogQuery.  # noqa: E501

        query for log filter  # noqa: E501

        :return: The query of this LogQuery.  # noqa: E501
        :rtype: str
        """
        return self._query

    @query.setter
    def query(self, query):
        """Sets the query of this LogQuery.

        query for log filter  # noqa: E501

        :param query: The query of this LogQuery.  # noqa: E501
        :type: str
        """

        self._query = query

    @property
    def group_id(self):
        """Gets the group_id of this LogQuery.  # noqa: E501

        group id  # noqa: E501

        :return: The group_id of this LogQuery.  # noqa: E501
        :rtype: int
        """
        return self._group_id

    @group_id.setter
    def group_id(self, group_id):
        """Sets the group_id of this LogQuery.

        group id  # noqa: E501

        :param group_id: The group_id of this LogQuery.  # noqa: E501
        :type: int
        """

        self._group_id = group_id

    @property
    def into_rest_response(self):
        """Gets the into_rest_response of this LogQuery.  # noqa: E501


        :return: The into_rest_response of this LogQuery.  # noqa: E501
        :rtype: RestResponse
        """
        return self._into_rest_response

    @into_rest_response.setter
    def into_rest_response(self, into_rest_response):
        """Sets the into_rest_response of this LogQuery.


        :param into_rest_response: The into_rest_response of this LogQuery.  # noqa: E501
        :type: RestResponse
        """

        self._into_rest_response = into_rest_response

    @property
    def label(self):
        """Gets the label of this LogQuery.  # noqa: E501

        label for log filter  # noqa: E501

        :return: The label of this LogQuery.  # noqa: E501
        :rtype: str
        """
        return self._label

    @label.setter
    def label(self, label):
        """Sets the label of this LogQuery.

        label for log filter  # noqa: E501

        :param label: The label of this LogQuery.  # noqa: E501
        :type: str
        """

        self._label = label

    @property
    def favourite(self):
        """Gets the favourite of this LogQuery.  # noqa: E501


        :return: The favourite of this LogQuery.  # noqa: E501
        :rtype: bool
        """
        return self._favourite

    @favourite.setter
    def favourite(self, favourite):
        """Sets the favourite of this LogQuery.


        :param favourite: The favourite of this LogQuery.  # noqa: E501
        :type: bool
        """

        self._favourite = favourite

    @property
    def version(self):
        """Gets the version of this LogQuery.  # noqa: E501

        query grammar version  # noqa: E501

        :return: The version of this LogQuery.  # noqa: E501
        :rtype: str
        """
        return self._version

    @version.setter
    def version(self, version):
        """Sets the version of this LogQuery.

        query grammar version  # noqa: E501

        :param version: The version of this LogQuery.  # noqa: E501
        :type: str
        """
        if version is None:
            raise ValueError("Invalid value for `version`, must not be `None`")  # noqa: E501

        self._version = version

    @property
    def duration(self):
        """Gets the duration of this LogQuery.  # noqa: E501

        time range  # noqa: E501

        :return: The duration of this LogQuery.  # noqa: E501
        :rtype: str
        """
        return self._duration

    @duration.setter
    def duration(self, duration):
        """Sets the duration of this LogQuery.

        time range  # noqa: E501

        :param duration: The duration of this LogQuery.  # noqa: E501
        :type: str
        """

        self._duration = duration

    @property
    def admin_name(self):
        """Gets the admin_name of this LogQuery.  # noqa: E501

        username associated with the log query  # noqa: E501

        :return: The admin_name of this LogQuery.  # noqa: E501
        :rtype: str
        """
        return self._admin_name

    @admin_name.setter
    def admin_name(self, admin_name):
        """Sets the admin_name of this LogQuery.

        username associated with the log query  # noqa: E501

        :param admin_name: The admin_name of this LogQuery.  # noqa: E501
        :type: str
        """

        self._admin_name = admin_name

    @property
    def group_name(self):
        """Gets the group_name of this LogQuery.  # noqa: E501

        log query group name  # noqa: E501

        :return: The group_name of this LogQuery.  # noqa: E501
        :rtype: str
        """
        return self._group_name

    @group_name.setter
    def group_name(self, group_name):
        """Sets the group_name of this LogQuery.

        log query group name  # noqa: E501

        :param group_name: The group_name of this LogQuery.  # noqa: E501
        :type: str
        """

        self._group_name = group_name

    @property
    def related_into_rest_response(self):
        """Gets the related_into_rest_response of this LogQuery.  # noqa: E501


        :return: The related_into_rest_response of this LogQuery.  # noqa: E501
        :rtype: RestResponse
        """
        return self._related_into_rest_response

    @related_into_rest_response.setter
    def related_into_rest_response(self, related_into_rest_response):
        """Sets the related_into_rest_response of this LogQuery.


        :param related_into_rest_response: The related_into_rest_response of this LogQuery.  # noqa: E501
        :type: RestResponse
        """

        self._related_into_rest_response = related_into_rest_response

    @property
    def model(self):
        """Gets the model of this LogQuery.  # noqa: E501


        :return: The model of this LogQuery.  # noqa: E501
        :rtype: str
        """
        return self._model

    @model.setter
    def model(self, model):
        """Sets the model of this LogQuery.


        :param model: The model of this LogQuery.  # noqa: E501
        :type: str
        """
        allowed_values = ["accessLogs", "accessGroups", "adminNotifications", "aggregateSavings", "alerts", "visualizationAggregateEntry", "visualizationAggregateValue", "alertDependencyRules", "alertRoutings", "alertRules", "diagnosticRules", "alertTuningConfigAncestry", "alertTuningConfigs", "alertTuningConfigsHistory", "alertTuningConfigSlots", "alertTuningGraphs", "alertsTuningSeries", "asnMappings", "billingConfigurations", "cloudAccounts", "cloudResourceProperty", "clusterAlertRoutings", "clusterAlertTuningConfigs", "collectors", "collectorEvents", "collectorGroups", "collectorStatus", "collectorUpgradeHistory", "collectorUpgradeInfo", "configSources", "configSourceInstance", "configSourceInstanceAlert", "collectorLogs", "config", "configAlert", "correlationGraphs", "dashboards", "datapoints", "dataQueries", "dataSources", "dataSourceInstances", "dataSourceInstanceAlertSettings", "dataSourceInstanceGroups", "datasets", "dnsMappings", "escalationChains", "eventSources", "integrations", "integrationAuditLogs", "logSources", "exchangeAccessGroups", "exchangeActiveDiscoveryFilters", "exchangeAppliesToFunctions", "exchangeChangelogs", "exchangeConfigSources", "exchangeConfigSourceConfigChecks", "exchangeDataSources", "exchangeDataSourceDataPoints", "exchangeDataSourceDataPointDisplayStatusNames", "exchangeDataSourceGraphs", "exchangeDataSourceGraphSeries", "exchangeDataSourceGraphVirtualSeries", "exchangeDataSourceOverviewGraphs", "exchangeDataSourceOverviewGraphSeries", "exchangeDataSourceOverviewGraphVirtualSeries", "exchangeDiagnosticSources", "exchangeEventSources", "exchangeEventSourceFilters", "exchangeEventSourceLogFiles", "exchangeJobMonitors", "exchangeLogSources", "exchangeLogSourceFilters", "exchangeSnmpTrapLogSourceFilters", "exchangeLogSourceLogFields", "exchangeLogSourceResourceMappings", "exchangeLogSourceCollectorMappings", "exchangeLogicModules", "exchangeLogicModulePackages", "exchangeLogicModulePermissions", "exchangePackagedLogicModules", "exchangePropertySources", "exchangeRemediationSources", "exchangeSNMPSysOIDMaps", "exchangeTopologySources", "externalResourceIdentifiers", "failedDataSourceInfo", "filterFieldList", "graphs", "graphMeta", "healthMetrics", "hierarchy", "hostclusterAlertDefs", "hostDiagnosticSourceDetails", "diagnosticExecutionContext", "remediationExecutionContext", "latestDiagnosticExecutionResultContext", "diagnosticExecutionSearchContext", "remediationSourceExecutionSearchContext", "diagnosticSourceAssociatedDevices", "hostRemediationSourceDetails", "hostGroups", "internalAlertSettings", "jobMonitors", "jobMonitorExecutions", "lmSupportAccessHasConnection", "lmSupportAccessState", "lmotelCollectors", "lmotelCollectorVersions", "lmCollectorVersions", "logalerts", "logicModuleGroups", "logpipelinesources", "logpipelineprocessors", "matchedEvents", "metaGroupings", "metricsCorrelation", "monitoredResources", "netscanGroups", "netscans", "netflow", "netflowAlertRule", "allLevels", "nocWidgets", "normalizedProperties", "netscanPolicies", "netscanExecutions", "opsNotes", "opsNoteResourceScopes", "opsNoteServiceScopes", "opsNoteResourceGroupScopes", "opsNoteServiceGroupScopes", "opsNoteGroupAllScopes", "opsNoteTags", "orgTreeNodes", "portMappings", "productIds", "properties", "propertySources", "rawData", "recentlyDeletedItems", "recipientGroups", "cloudRecommendations", "cloudRecommendationAdditionalData", "recommendationTypes", "relationships", "reports", "reportHistories", "reportGroups", "resources", "resourceDashboards", "resourceDataSources", "resourceDatapoints", "resourceEventSources", "resourceConfigSources", "ConfigSourcesGoldStandard", "ConfigSourceConfiguration", "resourceDashboardTemplates", "resourceGroups", "resourceGroupDataSourceConfigs", "resourceGroupEventSourceConfigs", "resourceGroupInfoSourceConfigs", "resourceJobMonitors", "resourceLogPipelineResources", "resourceLogSources", "sdts", "services", "serviceCheckpoints", "serviceGroups", "sharedQueries", "siteMonitors", "slaWidgets", "spanCount", "securityRecommendations", "subscriptions", "topology", "topologyMaps", "topologyMapsHistogram", "topologyMapsGraphs", "subEntities", "subEntitiesDetails", "topologySavedMapsGroupType", "topologySavedMapsGroup", "topologyManualMapping", "topologyManualInterfaceList", "traffic", "treeNodes", "unmonitoredResources", "userdata", "users", "userSettings", "websiteCheckpoints", "websiteGroups", "websites", "ServicePreview", "BizServiceDatapoint", "ServiceTemplateView", "ServiceMemberPreview", "RestServiceTemplate", "ServiceTemplateServiceStats", "synthetics", "usage", "tracesDevicesNamesIds", "tracesGraphIds", "tracesServices", "tracesDeviceDatasources", "tracesDeviceDatasourceInstances", "tracesNamespaceGraphDetails", "tracesResourceNamesIds", "tracesTopologyEdgeData", "members", "apiTokens", "roleGroups", "roles", "userGroups", "sharingTokens", "syntheticsDSInstanceRawData", "syntheticsDSInstanceStepData", "syntheticsDSInstanceAlerts", "usageDimensions", "vizResourceInfo", "lmqlResult", "lmqlParsed", "partitions", "logPartitionChangelog", "cloudRecommendationStatus", "recommendationStatusUpdateRequest", "websiteDevice", "mibUpload", "logQueryGroups", "logQueryGroupChangelog", "logQuery", "trackingLogQueries", "billingBudgets"]  # noqa: E501
        if model not in allowed_values:
            raise ValueError(
                "Invalid value for `model` ({0}), must be one of {1}"  # noqa: E501
                .format(model, allowed_values)
            )

        self._model = model

    @property
    def id(self):
        """Gets the id of this LogQuery.  # noqa: E501

        uuid of record  # noqa: E501

        :return: The id of this LogQuery.  # noqa: E501
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this LogQuery.

        uuid of record  # noqa: E501

        :param id: The id of this LogQuery.  # noqa: E501
        :type: str
        """
        if id is None:
            raise ValueError("Invalid value for `id`, must not be `None`")  # noqa: E501

        self._id = id

    @property
    def is_aggregate(self):
        """Gets the is_aggregate of this LogQuery.  # noqa: E501

        is aggregate query or not  # noqa: E501

        :return: The is_aggregate of this LogQuery.  # noqa: E501
        :rtype: bool
        """
        return self._is_aggregate

    @is_aggregate.setter
    def is_aggregate(self, is_aggregate):
        """Sets the is_aggregate of this LogQuery.

        is aggregate query or not  # noqa: E501

        :param is_aggregate: The is_aggregate of this LogQuery.  # noqa: E501
        :type: bool
        """

        self._is_aggregate = is_aggregate

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(LogQuery, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LogQuery):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
