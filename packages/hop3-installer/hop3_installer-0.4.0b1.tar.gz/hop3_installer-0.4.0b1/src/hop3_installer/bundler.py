# Copyright (c) 2025-2026, Abilian SAS
# SPDX-License-Identifier: Apache-2.0
"""Single-file installer bundler.

This module bundles the modular installer source into standalone single-file
scripts that can be distributed independently.

Usage:
    python -m hop3_installer.bundler --type cli --output install-cli.py
    python -m hop3_installer.bundler --type server --output install-server.py
    python -m hop3_installer.bundler --all --output-dir dist/
"""

from __future__ import annotations

import argparse
import ast
import re
import sys
from datetime import datetime
from pathlib import Path

# =============================================================================
# Configuration
# =============================================================================

SRC_DIR = Path(__file__).parent

# Files to include in each installer, in order
CLI_MODULES = [
    "common.py",
    "cli_installer/config.py",
    "cli_installer/cli.py",
    "cli_installer/checks.py",
    "cli_installer/python.py",
    "cli_installer/shell.py",
    "cli_installer/verify.py",
    "cli_installer/installer.py",
]

SERVER_MODULES = [
    "common.py",
    "server_installer/config.py",
    "server_installer/cli.py",
    "server_installer/user.py",
    "server_installer/deps_common.py",
    "server_installer/redis.py",
    "server_installer/deps_debian.py",
    "server_installer/deps_fedora.py",
    "server_installer/deps.py",
    "server_installer/python.py",
    "server_installer/services.py",
    "server_installer/ssl.py",
    "server_installer/nginx.py",
    "server_installer/postgres.py",
    "server_installer/mysql.py",
    "server_installer/acme.py",
    "server_installer/verify.py",
    "server_installer/installer.py",
]


def is_stdlib_module(module_name: str) -> bool:
    """Check if a module is from the Python standard library.

    Uses sys.stdlib_module_names (Python 3.10+) for accurate detection.
    This eliminates the need to maintain a hardcoded list of stdlib modules.

    Args:
        module_name: Module name (e.g., "os", "urllib.request")

    Returns:
        True if the module is part of the standard library
    """
    # Get the top-level module name (e.g., "urllib" from "urllib.request")
    top_level = module_name.split(".", maxsplit=1)[0]
    return top_level in sys.stdlib_module_names


# Header template
HEADER_TEMPLATE = '''#!/usr/bin/env python3
# =============================================================================
#
#                    AUTO-GENERATED FILE - DO NOT EDIT!
#
#   This file is automatically generated by the hop3-installer bundler.
#   Any manual changes will be overwritten on the next bundle.
#
#   To modify this installer, edit the source files in:
#     packages/hop3-installer/src/hop3_installer/
#
#   Then regenerate with:
#     uv run hop3-install bundle --all --output-dir installer/
#
# =============================================================================
# Copyright (c) 2025-2026, Abilian SAS
# SPDX-License-Identifier: Apache-2.0
"""
{description}

{usage}

Generated by hop3-installer bundler on {date}
"""

from __future__ import annotations

# =============================================================================
# Version Check (must run before any 3.10+ features are used at runtime)
# =============================================================================
import sys

MIN_PYTHON = (3, 10)

if sys.version_info < MIN_PYTHON:
    print(f"Error: Python {{MIN_PYTHON[0]}}.{{MIN_PYTHON[1]}}+ required")
    print(f"Found: Python {{sys.version_info.major}}.{{sys.version_info.minor}}")
    print()
    print("Please install a newer Python version:")
    print("  Ubuntu/Debian: sudo apt install python3.11")
    print("  Fedora:        sudo dnf install python3.11")
    print("  macOS:         brew install python@3.11")
    sys.exit(1)

# =============================================================================
# Imports (standard library only)
# =============================================================================
# ruff: noqa: E402 - imports must come after version check

'''

CLI_DESCRIPTION = "Hop3 CLI Installer - Install the hop3 command-line tool"
CLI_USAGE = """Usage:
    curl -LsSf https://hop3.cloud/install-cli.py | python3 -
    curl -LsSf https://hop3.cloud/install-cli.py | python3 - --git
    python3 install-cli.py --help"""

SERVER_DESCRIPTION = "Hop3 Server Installer - Install the Hop3 server"
SERVER_USAGE = """Usage:
    curl -LsSf https://hop3.cloud/install-server.py | sudo python3 -
    curl -LsSf https://hop3.cloud/install-server.py | sudo python3 - --git
    sudo python3 install-server.py --help"""


# =============================================================================
# Code Extraction
# =============================================================================


def _is_multiline_import(stripped: str) -> bool:
    """Check if an import statement spans multiple lines."""
    return "(" in stripped and ")" not in stripped


def _should_skip_import(stripped: str) -> bool:
    """Check if an import should be skipped (relative or future imports)."""
    return stripped.startswith("from .") or "from __future__" in stripped


def _extract_module_name(stripped: str) -> str | None:
    """Extract module name from an import statement."""
    if stripped.startswith("import "):
        match = re.match(r"import\s+([\w.]+)", stripped)
        return match.group(1) if match else None
    if stripped.startswith("from "):
        match = re.match(r"from\s+([\w.]+)\s+import", stripped)
        return match.group(1) if match else None
    return None


def extract_imports(source: str) -> tuple[set[str], str]:
    """Extract import statements from source code.

    Returns:
        Tuple of (set of import names, source with imports removed)
    """
    imports: set[str] = set()
    lines = source.split("\n")
    new_lines: list[str] = []
    in_multiline_import = False

    for line in lines:
        stripped = line.strip()

        # Skip empty lines at the start (before first non-import)
        if not stripped and not new_lines and not in_multiline_import:
            continue

        # Handle continuation of multi-line imports
        if in_multiline_import:
            if ")" in stripped:
                in_multiline_import = False
            continue

        # Check for import statements
        if stripped.startswith(("import ", "from ")):
            is_multiline = _is_multiline_import(stripped)

            if _should_skip_import(stripped):
                if is_multiline:
                    in_multiline_import = True
                continue

            module_name = _extract_module_name(stripped)
            if module_name:
                imports.add(module_name)

            if is_multiline:
                in_multiline_import = True
            continue

        new_lines.append(line)

    return imports, "\n".join(new_lines)


def _skip_leading_whitespace_and_comments(lines: list[str], start: int) -> int:
    """Skip leading whitespace and comment lines, return new index."""
    i = start
    while i < len(lines):
        stripped = lines[i].strip()
        if stripped and not stripped.startswith("#"):
            break
        i += 1
    return i


def _skip_module_docstring(lines: list[str], start: int) -> int:
    """Skip module docstring if present, return new index."""
    if start >= len(lines):
        return start

    stripped = lines[start].strip()
    if not (stripped.startswith('"""') or stripped.startswith("'''")):
        return start

    quote = stripped[:3]
    # Single-line docstring like """text"""
    if stripped.count(quote) >= 2 and len(stripped) > 3:
        return start + 1

    # Multi-line docstring - find the end
    i = start + 1
    while i < len(lines):
        if quote in lines[i]:
            return i + 1
        i += 1
    return i


def extract_code_body(source: str) -> str:
    """Extract the main code body, removing module docstrings and boilerplate.

    Only removes:
    - Leading comments and whitespace
    - Module-level docstring (first triple-quoted string at column 0)
    - if __name__ == "__main__" block at the end
    """
    lines = source.split("\n")
    n = len(lines)

    # Skip leading content
    i = _skip_leading_whitespace_and_comments(lines, 0)
    i = _skip_module_docstring(lines, i)

    # Skip any blank lines after docstring
    while i < n and not lines[i].strip():
        i += 1

    # Collect remaining lines until if __name__ block
    new_lines = []
    while i < n:
        stripped = lines[i].strip()
        if stripped.startswith('if __name__ == "__main__"'):
            break
        new_lines.append(lines[i])
        i += 1

    return "\n".join(new_lines)


def process_module(filepath: Path) -> tuple[set[str], str]:
    """Process a module file.

    Returns:
        Tuple of (imports, code body)
    """
    source = filepath.read_text()

    # Extract imports
    imports, source_no_imports = extract_imports(source)

    # Extract code body
    code = extract_code_body(source_no_imports)

    return imports, code


# =============================================================================
# Bundler
# =============================================================================


def bundle_installer(installer_type: str) -> str:
    """Bundle an installer into a single file.

    Args:
        installer_type: 'cli' or 'server'

    Returns:
        The bundled source code
    """
    if installer_type == "cli":
        modules = CLI_MODULES
        description = CLI_DESCRIPTION
        usage = CLI_USAGE
    else:
        modules = SERVER_MODULES
        description = SERVER_DESCRIPTION
        usage = SERVER_USAGE

    # Collect imports and code from all modules
    all_imports: set[str] = set()
    code_sections: list[str] = []

    for module_path in modules:
        filepath = SRC_DIR / module_path
        if not filepath.exists():
            raise FileNotFoundError(f"Module not found: {filepath}")

        imports, code = process_module(filepath)
        all_imports.update(imports)

        # Add section header
        section_name = module_path.replace("/", ".").replace(".py", "")
        code_sections.append(
            f"\n# {'=' * 77}\n# Module: {section_name}\n# {'=' * 77}\n"
        )
        code_sections.append(code)

    # Generate header
    header = HEADER_TEMPLATE.format(
        description=description,
        usage=usage,
        date=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
    )

    # Generate import block (only stdlib imports)
    import_lines = []
    for imp in sorted(all_imports):
        if is_stdlib_module(imp):
            import_lines.append(f"import {imp}")
        # Skip non-stdlib imports (they should all be relative)

    # Add specific imports needed by bundled code
    import_lines.append("from dataclasses import dataclass, field")
    import_lines.append("from pathlib import Path")
    import_lines.append("from typing import overload")

    import_block = "\n".join(import_lines) + "\n"

    # Combine everything
    parts = [header, import_block]
    parts.extend(code_sections)

    # Add main block
    parts.append(
        """

# =============================================================================
# Entry Point
# =============================================================================

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\\n\\nInstallation cancelled.")
        sys.exit(130)
    except Exception as e:
        print(f"\\n{Colors.RED}Error:{Colors.RESET} {e}", file=sys.stderr)
        sys.exit(1)
"""
    )

    return "\n".join(parts)


def validate_bundle(source: str) -> bool:
    """Validate that the bundled source is valid Python.

    Returns:
        True if valid, False otherwise
    """
    try:
        ast.parse(source)
        return True
    except SyntaxError as e:
        print(f"Syntax error in bundled source: {e}", file=sys.stderr)
        return False


# =============================================================================
# CLI
# =============================================================================


def create_parser() -> argparse.ArgumentParser:
    """Create argument parser."""
    parser = argparse.ArgumentParser(
        description="Bundle hop3-installer modules into single-file scripts",
    )

    parser.add_argument(
        "--type",
        choices=["cli", "server"],
        help="Type of installer to bundle",
    )

    parser.add_argument(
        "--output",
        type=Path,
        help="Output file path",
    )

    parser.add_argument(
        "--all",
        action="store_true",
        help="Bundle all installers",
    )

    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path.cwd(),
        help="Output directory for --all (default: current directory)",
    )

    parser.add_argument(
        "--validate",
        action="store_true",
        default=True,
        help="Validate bundled source (default: True)",
    )

    return parser


def main() -> int:
    """Main entry point."""
    parser = create_parser()
    args = parser.parse_args()

    if args.all:
        # Bundle all installers
        for installer_type in ["cli", "server"]:
            output_file = args.output_dir / f"install-{installer_type}.py"
            print(f"Bundling {installer_type} installer...")

            try:
                source = bundle_installer(installer_type)

                if args.validate and not validate_bundle(source):
                    print(f"  ERROR: Bundled {installer_type} is not valid Python")
                    return 1

                output_file.write_text(source)
                output_file.chmod(0o755)
                print(f"  Created: {output_file}")
            except Exception as e:
                print(f"  ERROR: {e}")
                return 1

        print("\nAll installers bundled successfully!")
        return 0

    if not args.type:
        parser.error("--type is required unless using --all")

    if not args.output:
        args.output = Path(f"install-{args.type}.py")

    print(f"Bundling {args.type} installer...")

    try:
        source = bundle_installer(args.type)

        if args.validate and not validate_bundle(source):
            print("ERROR: Bundled source is not valid Python")
            return 1

        args.output.write_text(source)
        args.output.chmod(0o755)
        print(f"Created: {args.output}")
    except Exception as e:
        print(f"ERROR: {e}")
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
