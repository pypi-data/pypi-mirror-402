from .node import *
from ._from import *
from .functions import *
from .output import *
from .select import *
from .filter import *
from .distinct import *
from .sort import *
import abc
import geopandas as gpd
import pandas as pd
import pyarrow as pa
import xarray as xr
from ..session import BaseBeaconSession
from _typeshed import Incomplete
from abc import abstractmethod
from datetime import datetime
from requests import Response as Response
from typing import Iterator
from typing_extensions import Optional, Self, Union

class BaseQuery(metaclass=abc.ABCMeta):
    http_session: Incomplete
    output_format: Incomplete
    def __init__(self, http_session: BaseBeaconSession) -> None: ...
    @abstractmethod
    def compile(self) -> dict: ...
    def set_output(self, output_format: Output) -> None: ...
    def output(self) -> dict: ...
    def compile_query(self) -> str: ...
    def explain(self) -> dict: ...
    def execute(self, stream: bool = False) -> Response: ...
    def execute_streaming(self, force: bool = False) -> pa.RecordBatchStreamReader: ...
    def to_xarray_dataset(self, dimension_columns: list[str], chunks: Union[dict, None] = None, auto_cleanup: bool = True, force: bool = False) -> xr.Dataset: ...
    def to_pandas_dataframe(self) -> pd.DataFrame: ...
    def to_geo_pandas_dataframe(self, longitude_column: str, latitude_column: str, crs: str = 'EPSG:4326') -> gpd.GeoDataFrame: ...
    def to_parquet(self, file_path: str, streaming_chunk_size: int = ...): ...
    def to_geoparquet(self, file_path: str, longitude_column: str, latitude_column: str, streaming_chunk_size: int = ...): ...
    def to_csv(self, file_path: str, streaming_chunk_size: int = ...): ...
    def to_arrow(self, file_path: str, streaming_chunk_size: int = ...): ...
    def to_netcdf(self, file_path: str, build_nc_local: bool = True, streaming_chunk_size: int = ...): ...
    def to_nd_netcdf(self, file_path: str, dimension_columns: list[str], streaming_chunk_size: int = ..., force: bool = False): ...
    def to_zarr(self, file_path: str): ...
    def to_odv(self, odv_output: Odv, file_path: str): ...

class SQLQuery(BaseQuery):
    query: Incomplete
    def __init__(self, http_session: BaseBeaconSession, query: str) -> None: ...
    def compile(self) -> dict: ...

class JSONQuery(BaseQuery):
    selects: Incomplete
    filters: Incomplete
    sorts: Incomplete
    distinct: Incomplete
    limit: Incomplete
    offset: Incomplete
    def __init__(self, http_session: BaseBeaconSession, _from: From) -> None: ...
    def compile(self) -> dict: ...
    def select(self, selects: list[Select]) -> Self: ...
    def add_select(self, select: Select) -> Self: ...
    def add_selects(self, selects: list[Select]) -> Self: ...
    def add_select_column(self, column: str, alias: Optional[str] = None) -> Self: ...
    def add_select_columns(self, columns: list[tuple[str, Optional[str]]]) -> Self: ...
    def add_select_coalesced(self, mergeable_columns: list[str], alias: str) -> Self: ...
    def filter(self, filters: list[Filter]) -> Self: ...
    def add_filter(self, filter: Filter) -> Self: ...
    def add_bbox_filter(self, longitude_column: str, latitude_column: str, bbox: tuple[float, float, float, float]) -> Self: ...
    def add_polygon_filter(self, longitude_column: str, latitude_column: str, polygon: list[tuple[float, float]]) -> Self: ...
    def add_range_filter(self, column: str, gt_eq: Union[str, int, float, datetime, None] = None, lt_eq: Union[str, int, float, datetime, None] = None, gt: Union[str, int, float, datetime, None] = None, lt: Union[str, int, float, datetime, None] = None) -> Self: ...
    def add_equals_filter(self, column: str, eq: Union[str, int, float, bool, datetime]) -> Self: ...
    def add_not_equals_filter(self, column: str, neq: Union[str, int, float, bool, datetime]) -> Self: ...
    def add_is_null_filter(self, column: str) -> Self: ...
    def add_is_not_null_filter(self, column: str) -> Self: ...
    def set_distinct(self, columns: list[str]) -> Self: ...
    def add_sort(self, column: str, ascending: bool = True) -> Self: ...
    def set_limit(self, limit: int) -> Self: ...
    def set_offset(self, offset: int) -> Self: ...
