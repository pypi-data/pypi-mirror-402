# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
from baml_py import type_builder
from baml_py import baml_py
# These are exports, not used here, hence the linter is disabled
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder # noqa: F401 # pylint: disable=unused-import
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME

class TypeBuilder(type_builder.TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["AICommandHistoryItem","AICommandRequest","AICommandResult","AccordionGroup","AccordionSection","ActionError","ActionEventPayload","ActionItem","ActionOutput","ActionRequest","ActionResponse","AiTimingSuggestion","AiTimingSuggestionRequest","AuthVerifyResponse","BetweenSessionEvent","CardAction","CardData","ChatMessage","ChatRequest","ChatResponse","ClientContext","ClientGoal","ClientList","ClientNote","ClientNoteList","ClientProfile","ClientStats","ClientSummary","CoacheePreSessionInput","CommandCenterData","CommandCenterEventPayload","CommandCenterItem","Commitment","ConnectionPayload","ContextChangedPayload","CorrectionPair","CreateGoalRequest","CreateResourceRequest","CreateScheduledMessageRequest","CurrentRead","DashboardData","DashboardPreferences","DashboardSection","DisclosureConfig","EmptyState","ErrorPayload","EventEnvelope","EventMeta","FinalizeNotesRequest","FinalizeNotesResponse","FrontendActionResult","FrontendCommand","FrontendCommandPayload","FrontendToolConfig","GenerateNotesRequest","GeneratePrepRequest","GoalFilter","GoalList","GoalMilestone","GoalProgressUpdate","GoalResponse","GroupedList","HeartbeatPayload","InquiriesSection","InquiryQuestion","IntegrationConfig","IntegrationConnectRequest","IntegrationConnectResponse","IntegrationDisconnectRequest","IntegrationList","InvitationsSection","KeyPoint","LastSessionRecap","LifeContextItem","ListGroup","ListItem","LoadingState","MessagePayload","NavigationOption","NextSection","NorthStarReminder","ObservationEntry","ObservationPayload","OnboardingEventPayload","OnboardingPhaseProgress","OnboardingProgress","OnboardingUpdateRequest","OnboardingUpdateResponse","PageContext","PatternEvidence","PatternIntelligence","PrepDocument","PrepList","PrepNotificationPayload","PrepResponse","PrepSummary","PrepTemplate","PriorityItemPayload","PrivateIntelligence","ProfileScrapeRequest","ProfileScrapeResponse","Quote","RecentClient","ResolvedContext","ResourceEventPayload","ResourceItem","ResourceLink","ResourceListData","ResourceMetadata","ResourcesSection","ScheduledMessage","ScheduledMessageAuditEntry","ScheduledMessageEventPayload","ScheduledMessageFilter","ScheduledMessageList","ScheduledMessagePreferences","ScrapedCoachProfile","SessionContext","SessionEventPayload","SessionNoteSection","SessionNotes","SessionNotesEventPayload","SessionNotesFilter","SessionNotesList","SessionNotesResponse","SessionNotesSummary","SessionPrepStatus","StateHistoryEntry","StateHistoryQuery","StateUpdateRequest","StateUpdateResponse","StyleAnalysis","StyleAnalysisRequest","StyleAnalysisResponse","StyleDashboardData","StyleInsight","StyleTrendPoint","StyleTuning","SuggestedAction","SuggestedOpener","T15PrepEventPayload","TonePreference","ToneVector","ToolDefinition","ToolParameter","TransparentMessage","UpdateClientProfileRequest","UpdateClientProfileResponse","UpdateGoalRequest","UpdatePreferencesRequest","UpdatePrepNotesRequest","UpdateResourceRequest","UpdateScheduledMessageRequest","UpdateSectionRequest","UserActiveState","VoiceCorrection","VoiceCorrectionRequest","VoiceCorrectionResponse","VoiceEventPayload","VoiceMatchResult","VoiceProfile","VoiceProfileConfig","VoiceProfileV1","VoiceSample","VoiceSampleInput","VoiceSampleSubmitRequest","VoiceSampleSubmitResponse","VoiceSamplesPayload",]
        ), enums=set(
          ["AICommandType","ActionSpecificity","ActionVariant","BadgeVariant","BetweenSessionEventType","CoachFeedback","CommandItemType","CommitmentSource","CommitmentStatus","DashboardView","DisclosureLevel","EditType","EventType","FrontendActionStatus","FrontendToolName","GoalCategory","GoalStatus","InquiryCategory","IntegrationStatus","IntegrationType","LifeContextArea","MessageChannel","MessageRole","MessageStatus","ObservationType","OnboardingAction","OnboardingPhase","OpenerCategory","PatternTrend","PhaseStatus","PrepSectionId","PrepStatus","PrepStatusValue","Priority","ResourceLinkType","ResourceType","Sentiment","SessionNoteSectionId","SessionNotesStatus","StateSource","ToolName","TransparencyIndicator","VoiceContentType","VoiceSampleStatus","VoiceSampleType","VoiceTrainingStatus",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)

    # #########################################################################
    # Generated enums 46
    # #########################################################################

    @property
    def AICommandType(self) -> "AICommandTypeViewer":
        return AICommandTypeViewer(self)

    @property
    def ActionSpecificity(self) -> "ActionSpecificityViewer":
        return ActionSpecificityViewer(self)

    @property
    def ActionVariant(self) -> "ActionVariantViewer":
        return ActionVariantViewer(self)

    @property
    def BadgeVariant(self) -> "BadgeVariantViewer":
        return BadgeVariantViewer(self)

    @property
    def BetweenSessionEventType(self) -> "BetweenSessionEventTypeViewer":
        return BetweenSessionEventTypeViewer(self)

    @property
    def CoachFeedback(self) -> "CoachFeedbackViewer":
        return CoachFeedbackViewer(self)

    @property
    def CommandItemType(self) -> "CommandItemTypeViewer":
        return CommandItemTypeViewer(self)

    @property
    def CommitmentSource(self) -> "CommitmentSourceViewer":
        return CommitmentSourceViewer(self)

    @property
    def CommitmentStatus(self) -> "CommitmentStatusViewer":
        return CommitmentStatusViewer(self)

    @property
    def DashboardView(self) -> "DashboardViewViewer":
        return DashboardViewViewer(self)

    @property
    def DisclosureLevel(self) -> "DisclosureLevelViewer":
        return DisclosureLevelViewer(self)

    @property
    def EditType(self) -> "EditTypeViewer":
        return EditTypeViewer(self)

    @property
    def EventType(self) -> "EventTypeViewer":
        return EventTypeViewer(self)

    @property
    def FrontendActionStatus(self) -> "FrontendActionStatusViewer":
        return FrontendActionStatusViewer(self)

    @property
    def FrontendToolName(self) -> "FrontendToolNameViewer":
        return FrontendToolNameViewer(self)

    @property
    def GoalCategory(self) -> "GoalCategoryViewer":
        return GoalCategoryViewer(self)

    @property
    def GoalStatus(self) -> "GoalStatusViewer":
        return GoalStatusViewer(self)

    @property
    def InquiryCategory(self) -> "InquiryCategoryViewer":
        return InquiryCategoryViewer(self)

    @property
    def IntegrationStatus(self) -> "IntegrationStatusViewer":
        return IntegrationStatusViewer(self)

    @property
    def IntegrationType(self) -> "IntegrationTypeViewer":
        return IntegrationTypeViewer(self)

    @property
    def LifeContextArea(self) -> "LifeContextAreaViewer":
        return LifeContextAreaViewer(self)

    @property
    def MessageChannel(self) -> "MessageChannelViewer":
        return MessageChannelViewer(self)

    @property
    def MessageRole(self) -> "MessageRoleViewer":
        return MessageRoleViewer(self)

    @property
    def MessageStatus(self) -> "MessageStatusViewer":
        return MessageStatusViewer(self)

    @property
    def ObservationType(self) -> "ObservationTypeViewer":
        return ObservationTypeViewer(self)

    @property
    def OnboardingAction(self) -> "OnboardingActionViewer":
        return OnboardingActionViewer(self)

    @property
    def OnboardingPhase(self) -> "OnboardingPhaseViewer":
        return OnboardingPhaseViewer(self)

    @property
    def OpenerCategory(self) -> "OpenerCategoryViewer":
        return OpenerCategoryViewer(self)

    @property
    def PatternTrend(self) -> "PatternTrendViewer":
        return PatternTrendViewer(self)

    @property
    def PhaseStatus(self) -> "PhaseStatusViewer":
        return PhaseStatusViewer(self)

    @property
    def PrepSectionId(self) -> "PrepSectionIdViewer":
        return PrepSectionIdViewer(self)

    @property
    def PrepStatus(self) -> "PrepStatusViewer":
        return PrepStatusViewer(self)

    @property
    def PrepStatusValue(self) -> "PrepStatusValueViewer":
        return PrepStatusValueViewer(self)

    @property
    def Priority(self) -> "PriorityViewer":
        return PriorityViewer(self)

    @property
    def ResourceLinkType(self) -> "ResourceLinkTypeViewer":
        return ResourceLinkTypeViewer(self)

    @property
    def ResourceType(self) -> "ResourceTypeViewer":
        return ResourceTypeViewer(self)

    @property
    def Sentiment(self) -> "SentimentViewer":
        return SentimentViewer(self)

    @property
    def SessionNoteSectionId(self) -> "SessionNoteSectionIdViewer":
        return SessionNoteSectionIdViewer(self)

    @property
    def SessionNotesStatus(self) -> "SessionNotesStatusViewer":
        return SessionNotesStatusViewer(self)

    @property
    def StateSource(self) -> "StateSourceViewer":
        return StateSourceViewer(self)

    @property
    def ToolName(self) -> "ToolNameViewer":
        return ToolNameViewer(self)

    @property
    def TransparencyIndicator(self) -> "TransparencyIndicatorViewer":
        return TransparencyIndicatorViewer(self)

    @property
    def VoiceContentType(self) -> "VoiceContentTypeViewer":
        return VoiceContentTypeViewer(self)

    @property
    def VoiceSampleStatus(self) -> "VoiceSampleStatusViewer":
        return VoiceSampleStatusViewer(self)

    @property
    def VoiceSampleType(self) -> "VoiceSampleTypeViewer":
        return VoiceSampleTypeViewer(self)

    @property
    def VoiceTrainingStatus(self) -> "VoiceTrainingStatusViewer":
        return VoiceTrainingStatusViewer(self)


    # #########################################################################
    # Generated classes 168
    # #########################################################################

    @property
    def AICommandHistoryItem(self) -> "AICommandHistoryItemViewer":
        return AICommandHistoryItemViewer(self)

    @property
    def AICommandRequest(self) -> "AICommandRequestViewer":
        return AICommandRequestViewer(self)

    @property
    def AICommandResult(self) -> "AICommandResultViewer":
        return AICommandResultViewer(self)

    @property
    def AccordionGroup(self) -> "AccordionGroupViewer":
        return AccordionGroupViewer(self)

    @property
    def AccordionSection(self) -> "AccordionSectionViewer":
        return AccordionSectionViewer(self)

    @property
    def ActionError(self) -> "ActionErrorViewer":
        return ActionErrorViewer(self)

    @property
    def ActionEventPayload(self) -> "ActionEventPayloadViewer":
        return ActionEventPayloadViewer(self)

    @property
    def ActionItem(self) -> "ActionItemViewer":
        return ActionItemViewer(self)

    @property
    def ActionOutput(self) -> "ActionOutputViewer":
        return ActionOutputViewer(self)

    @property
    def ActionRequest(self) -> "ActionRequestViewer":
        return ActionRequestViewer(self)

    @property
    def ActionResponse(self) -> "ActionResponseViewer":
        return ActionResponseViewer(self)

    @property
    def AiTimingSuggestion(self) -> "AiTimingSuggestionViewer":
        return AiTimingSuggestionViewer(self)

    @property
    def AiTimingSuggestionRequest(self) -> "AiTimingSuggestionRequestViewer":
        return AiTimingSuggestionRequestViewer(self)

    @property
    def AuthVerifyResponse(self) -> "AuthVerifyResponseViewer":
        return AuthVerifyResponseViewer(self)

    @property
    def BetweenSessionEvent(self) -> "BetweenSessionEventViewer":
        return BetweenSessionEventViewer(self)

    @property
    def CardAction(self) -> "CardActionViewer":
        return CardActionViewer(self)

    @property
    def CardData(self) -> "CardDataViewer":
        return CardDataViewer(self)

    @property
    def ChatMessage(self) -> "ChatMessageViewer":
        return ChatMessageViewer(self)

    @property
    def ChatRequest(self) -> "ChatRequestViewer":
        return ChatRequestViewer(self)

    @property
    def ChatResponse(self) -> "ChatResponseViewer":
        return ChatResponseViewer(self)

    @property
    def ClientContext(self) -> "ClientContextViewer":
        return ClientContextViewer(self)

    @property
    def ClientGoal(self) -> "ClientGoalViewer":
        return ClientGoalViewer(self)

    @property
    def ClientList(self) -> "ClientListViewer":
        return ClientListViewer(self)

    @property
    def ClientNote(self) -> "ClientNoteViewer":
        return ClientNoteViewer(self)

    @property
    def ClientNoteList(self) -> "ClientNoteListViewer":
        return ClientNoteListViewer(self)

    @property
    def ClientProfile(self) -> "ClientProfileViewer":
        return ClientProfileViewer(self)

    @property
    def ClientStats(self) -> "ClientStatsViewer":
        return ClientStatsViewer(self)

    @property
    def ClientSummary(self) -> "ClientSummaryViewer":
        return ClientSummaryViewer(self)

    @property
    def CoacheePreSessionInput(self) -> "CoacheePreSessionInputViewer":
        return CoacheePreSessionInputViewer(self)

    @property
    def CommandCenterData(self) -> "CommandCenterDataViewer":
        return CommandCenterDataViewer(self)

    @property
    def CommandCenterEventPayload(self) -> "CommandCenterEventPayloadViewer":
        return CommandCenterEventPayloadViewer(self)

    @property
    def CommandCenterItem(self) -> "CommandCenterItemViewer":
        return CommandCenterItemViewer(self)

    @property
    def Commitment(self) -> "CommitmentViewer":
        return CommitmentViewer(self)

    @property
    def ConnectionPayload(self) -> "ConnectionPayloadViewer":
        return ConnectionPayloadViewer(self)

    @property
    def ContextChangedPayload(self) -> "ContextChangedPayloadViewer":
        return ContextChangedPayloadViewer(self)

    @property
    def CorrectionPair(self) -> "CorrectionPairViewer":
        return CorrectionPairViewer(self)

    @property
    def CreateGoalRequest(self) -> "CreateGoalRequestViewer":
        return CreateGoalRequestViewer(self)

    @property
    def CreateResourceRequest(self) -> "CreateResourceRequestViewer":
        return CreateResourceRequestViewer(self)

    @property
    def CreateScheduledMessageRequest(self) -> "CreateScheduledMessageRequestViewer":
        return CreateScheduledMessageRequestViewer(self)

    @property
    def CurrentRead(self) -> "CurrentReadViewer":
        return CurrentReadViewer(self)

    @property
    def DashboardData(self) -> "DashboardDataViewer":
        return DashboardDataViewer(self)

    @property
    def DashboardPreferences(self) -> "DashboardPreferencesViewer":
        return DashboardPreferencesViewer(self)

    @property
    def DashboardSection(self) -> "DashboardSectionViewer":
        return DashboardSectionViewer(self)

    @property
    def DisclosureConfig(self) -> "DisclosureConfigViewer":
        return DisclosureConfigViewer(self)

    @property
    def EmptyState(self) -> "EmptyStateViewer":
        return EmptyStateViewer(self)

    @property
    def ErrorPayload(self) -> "ErrorPayloadViewer":
        return ErrorPayloadViewer(self)

    @property
    def EventEnvelope(self) -> "EventEnvelopeViewer":
        return EventEnvelopeViewer(self)

    @property
    def EventMeta(self) -> "EventMetaViewer":
        return EventMetaViewer(self)

    @property
    def FinalizeNotesRequest(self) -> "FinalizeNotesRequestViewer":
        return FinalizeNotesRequestViewer(self)

    @property
    def FinalizeNotesResponse(self) -> "FinalizeNotesResponseViewer":
        return FinalizeNotesResponseViewer(self)

    @property
    def FrontendActionResult(self) -> "FrontendActionResultViewer":
        return FrontendActionResultViewer(self)

    @property
    def FrontendCommand(self) -> "FrontendCommandViewer":
        return FrontendCommandViewer(self)

    @property
    def FrontendCommandPayload(self) -> "FrontendCommandPayloadViewer":
        return FrontendCommandPayloadViewer(self)

    @property
    def FrontendToolConfig(self) -> "FrontendToolConfigViewer":
        return FrontendToolConfigViewer(self)

    @property
    def GenerateNotesRequest(self) -> "GenerateNotesRequestViewer":
        return GenerateNotesRequestViewer(self)

    @property
    def GeneratePrepRequest(self) -> "GeneratePrepRequestViewer":
        return GeneratePrepRequestViewer(self)

    @property
    def GoalFilter(self) -> "GoalFilterViewer":
        return GoalFilterViewer(self)

    @property
    def GoalList(self) -> "GoalListViewer":
        return GoalListViewer(self)

    @property
    def GoalMilestone(self) -> "GoalMilestoneViewer":
        return GoalMilestoneViewer(self)

    @property
    def GoalProgressUpdate(self) -> "GoalProgressUpdateViewer":
        return GoalProgressUpdateViewer(self)

    @property
    def GoalResponse(self) -> "GoalResponseViewer":
        return GoalResponseViewer(self)

    @property
    def GroupedList(self) -> "GroupedListViewer":
        return GroupedListViewer(self)

    @property
    def HeartbeatPayload(self) -> "HeartbeatPayloadViewer":
        return HeartbeatPayloadViewer(self)

    @property
    def InquiriesSection(self) -> "InquiriesSectionViewer":
        return InquiriesSectionViewer(self)

    @property
    def InquiryQuestion(self) -> "InquiryQuestionViewer":
        return InquiryQuestionViewer(self)

    @property
    def IntegrationConfig(self) -> "IntegrationConfigViewer":
        return IntegrationConfigViewer(self)

    @property
    def IntegrationConnectRequest(self) -> "IntegrationConnectRequestViewer":
        return IntegrationConnectRequestViewer(self)

    @property
    def IntegrationConnectResponse(self) -> "IntegrationConnectResponseViewer":
        return IntegrationConnectResponseViewer(self)

    @property
    def IntegrationDisconnectRequest(self) -> "IntegrationDisconnectRequestViewer":
        return IntegrationDisconnectRequestViewer(self)

    @property
    def IntegrationList(self) -> "IntegrationListViewer":
        return IntegrationListViewer(self)

    @property
    def InvitationsSection(self) -> "InvitationsSectionViewer":
        return InvitationsSectionViewer(self)

    @property
    def KeyPoint(self) -> "KeyPointViewer":
        return KeyPointViewer(self)

    @property
    def LastSessionRecap(self) -> "LastSessionRecapViewer":
        return LastSessionRecapViewer(self)

    @property
    def LifeContextItem(self) -> "LifeContextItemViewer":
        return LifeContextItemViewer(self)

    @property
    def ListGroup(self) -> "ListGroupViewer":
        return ListGroupViewer(self)

    @property
    def ListItem(self) -> "ListItemViewer":
        return ListItemViewer(self)

    @property
    def LoadingState(self) -> "LoadingStateViewer":
        return LoadingStateViewer(self)

    @property
    def MessagePayload(self) -> "MessagePayloadViewer":
        return MessagePayloadViewer(self)

    @property
    def NavigationOption(self) -> "NavigationOptionViewer":
        return NavigationOptionViewer(self)

    @property
    def NextSection(self) -> "NextSectionViewer":
        return NextSectionViewer(self)

    @property
    def NorthStarReminder(self) -> "NorthStarReminderViewer":
        return NorthStarReminderViewer(self)

    @property
    def ObservationEntry(self) -> "ObservationEntryViewer":
        return ObservationEntryViewer(self)

    @property
    def ObservationPayload(self) -> "ObservationPayloadViewer":
        return ObservationPayloadViewer(self)

    @property
    def OnboardingEventPayload(self) -> "OnboardingEventPayloadViewer":
        return OnboardingEventPayloadViewer(self)

    @property
    def OnboardingPhaseProgress(self) -> "OnboardingPhaseProgressViewer":
        return OnboardingPhaseProgressViewer(self)

    @property
    def OnboardingProgress(self) -> "OnboardingProgressViewer":
        return OnboardingProgressViewer(self)

    @property
    def OnboardingUpdateRequest(self) -> "OnboardingUpdateRequestViewer":
        return OnboardingUpdateRequestViewer(self)

    @property
    def OnboardingUpdateResponse(self) -> "OnboardingUpdateResponseViewer":
        return OnboardingUpdateResponseViewer(self)

    @property
    def PageContext(self) -> "PageContextViewer":
        return PageContextViewer(self)

    @property
    def PatternEvidence(self) -> "PatternEvidenceViewer":
        return PatternEvidenceViewer(self)

    @property
    def PatternIntelligence(self) -> "PatternIntelligenceViewer":
        return PatternIntelligenceViewer(self)

    @property
    def PrepDocument(self) -> "PrepDocumentViewer":
        return PrepDocumentViewer(self)

    @property
    def PrepList(self) -> "PrepListViewer":
        return PrepListViewer(self)

    @property
    def PrepNotificationPayload(self) -> "PrepNotificationPayloadViewer":
        return PrepNotificationPayloadViewer(self)

    @property
    def PrepResponse(self) -> "PrepResponseViewer":
        return PrepResponseViewer(self)

    @property
    def PrepSummary(self) -> "PrepSummaryViewer":
        return PrepSummaryViewer(self)

    @property
    def PrepTemplate(self) -> "PrepTemplateViewer":
        return PrepTemplateViewer(self)

    @property
    def PriorityItemPayload(self) -> "PriorityItemPayloadViewer":
        return PriorityItemPayloadViewer(self)

    @property
    def PrivateIntelligence(self) -> "PrivateIntelligenceViewer":
        return PrivateIntelligenceViewer(self)

    @property
    def ProfileScrapeRequest(self) -> "ProfileScrapeRequestViewer":
        return ProfileScrapeRequestViewer(self)

    @property
    def ProfileScrapeResponse(self) -> "ProfileScrapeResponseViewer":
        return ProfileScrapeResponseViewer(self)

    @property
    def Quote(self) -> "QuoteViewer":
        return QuoteViewer(self)

    @property
    def RecentClient(self) -> "RecentClientViewer":
        return RecentClientViewer(self)

    @property
    def ResolvedContext(self) -> "ResolvedContextViewer":
        return ResolvedContextViewer(self)

    @property
    def ResourceEventPayload(self) -> "ResourceEventPayloadViewer":
        return ResourceEventPayloadViewer(self)

    @property
    def ResourceItem(self) -> "ResourceItemViewer":
        return ResourceItemViewer(self)

    @property
    def ResourceLink(self) -> "ResourceLinkViewer":
        return ResourceLinkViewer(self)

    @property
    def ResourceListData(self) -> "ResourceListDataViewer":
        return ResourceListDataViewer(self)

    @property
    def ResourceMetadata(self) -> "ResourceMetadataViewer":
        return ResourceMetadataViewer(self)

    @property
    def ResourcesSection(self) -> "ResourcesSectionViewer":
        return ResourcesSectionViewer(self)

    @property
    def ScheduledMessage(self) -> "ScheduledMessageViewer":
        return ScheduledMessageViewer(self)

    @property
    def ScheduledMessageAuditEntry(self) -> "ScheduledMessageAuditEntryViewer":
        return ScheduledMessageAuditEntryViewer(self)

    @property
    def ScheduledMessageEventPayload(self) -> "ScheduledMessageEventPayloadViewer":
        return ScheduledMessageEventPayloadViewer(self)

    @property
    def ScheduledMessageFilter(self) -> "ScheduledMessageFilterViewer":
        return ScheduledMessageFilterViewer(self)

    @property
    def ScheduledMessageList(self) -> "ScheduledMessageListViewer":
        return ScheduledMessageListViewer(self)

    @property
    def ScheduledMessagePreferences(self) -> "ScheduledMessagePreferencesViewer":
        return ScheduledMessagePreferencesViewer(self)

    @property
    def ScrapedCoachProfile(self) -> "ScrapedCoachProfileViewer":
        return ScrapedCoachProfileViewer(self)

    @property
    def SessionContext(self) -> "SessionContextViewer":
        return SessionContextViewer(self)

    @property
    def SessionEventPayload(self) -> "SessionEventPayloadViewer":
        return SessionEventPayloadViewer(self)

    @property
    def SessionNoteSection(self) -> "SessionNoteSectionViewer":
        return SessionNoteSectionViewer(self)

    @property
    def SessionNotes(self) -> "SessionNotesViewer":
        return SessionNotesViewer(self)

    @property
    def SessionNotesEventPayload(self) -> "SessionNotesEventPayloadViewer":
        return SessionNotesEventPayloadViewer(self)

    @property
    def SessionNotesFilter(self) -> "SessionNotesFilterViewer":
        return SessionNotesFilterViewer(self)

    @property
    def SessionNotesList(self) -> "SessionNotesListViewer":
        return SessionNotesListViewer(self)

    @property
    def SessionNotesResponse(self) -> "SessionNotesResponseViewer":
        return SessionNotesResponseViewer(self)

    @property
    def SessionNotesSummary(self) -> "SessionNotesSummaryViewer":
        return SessionNotesSummaryViewer(self)

    @property
    def SessionPrepStatus(self) -> "SessionPrepStatusViewer":
        return SessionPrepStatusViewer(self)

    @property
    def StateHistoryEntry(self) -> "StateHistoryEntryViewer":
        return StateHistoryEntryViewer(self)

    @property
    def StateHistoryQuery(self) -> "StateHistoryQueryViewer":
        return StateHistoryQueryViewer(self)

    @property
    def StateUpdateRequest(self) -> "StateUpdateRequestViewer":
        return StateUpdateRequestViewer(self)

    @property
    def StateUpdateResponse(self) -> "StateUpdateResponseViewer":
        return StateUpdateResponseViewer(self)

    @property
    def StyleAnalysis(self) -> "StyleAnalysisViewer":
        return StyleAnalysisViewer(self)

    @property
    def StyleAnalysisRequest(self) -> "StyleAnalysisRequestViewer":
        return StyleAnalysisRequestViewer(self)

    @property
    def StyleAnalysisResponse(self) -> "StyleAnalysisResponseViewer":
        return StyleAnalysisResponseViewer(self)

    @property
    def StyleDashboardData(self) -> "StyleDashboardDataViewer":
        return StyleDashboardDataViewer(self)

    @property
    def StyleInsight(self) -> "StyleInsightViewer":
        return StyleInsightViewer(self)

    @property
    def StyleTrendPoint(self) -> "StyleTrendPointViewer":
        return StyleTrendPointViewer(self)

    @property
    def StyleTuning(self) -> "StyleTuningViewer":
        return StyleTuningViewer(self)

    @property
    def SuggestedAction(self) -> "SuggestedActionViewer":
        return SuggestedActionViewer(self)

    @property
    def SuggestedOpener(self) -> "SuggestedOpenerViewer":
        return SuggestedOpenerViewer(self)

    @property
    def T15PrepEventPayload(self) -> "T15PrepEventPayloadViewer":
        return T15PrepEventPayloadViewer(self)

    @property
    def TonePreference(self) -> "TonePreferenceViewer":
        return TonePreferenceViewer(self)

    @property
    def ToneVector(self) -> "ToneVectorViewer":
        return ToneVectorViewer(self)

    @property
    def ToolDefinition(self) -> "ToolDefinitionViewer":
        return ToolDefinitionViewer(self)

    @property
    def ToolParameter(self) -> "ToolParameterViewer":
        return ToolParameterViewer(self)

    @property
    def TransparentMessage(self) -> "TransparentMessageViewer":
        return TransparentMessageViewer(self)

    @property
    def UpdateClientProfileRequest(self) -> "UpdateClientProfileRequestViewer":
        return UpdateClientProfileRequestViewer(self)

    @property
    def UpdateClientProfileResponse(self) -> "UpdateClientProfileResponseViewer":
        return UpdateClientProfileResponseViewer(self)

    @property
    def UpdateGoalRequest(self) -> "UpdateGoalRequestViewer":
        return UpdateGoalRequestViewer(self)

    @property
    def UpdatePreferencesRequest(self) -> "UpdatePreferencesRequestViewer":
        return UpdatePreferencesRequestViewer(self)

    @property
    def UpdatePrepNotesRequest(self) -> "UpdatePrepNotesRequestViewer":
        return UpdatePrepNotesRequestViewer(self)

    @property
    def UpdateResourceRequest(self) -> "UpdateResourceRequestViewer":
        return UpdateResourceRequestViewer(self)

    @property
    def UpdateScheduledMessageRequest(self) -> "UpdateScheduledMessageRequestViewer":
        return UpdateScheduledMessageRequestViewer(self)

    @property
    def UpdateSectionRequest(self) -> "UpdateSectionRequestViewer":
        return UpdateSectionRequestViewer(self)

    @property
    def UserActiveState(self) -> "UserActiveStateViewer":
        return UserActiveStateViewer(self)

    @property
    def VoiceCorrection(self) -> "VoiceCorrectionViewer":
        return VoiceCorrectionViewer(self)

    @property
    def VoiceCorrectionRequest(self) -> "VoiceCorrectionRequestViewer":
        return VoiceCorrectionRequestViewer(self)

    @property
    def VoiceCorrectionResponse(self) -> "VoiceCorrectionResponseViewer":
        return VoiceCorrectionResponseViewer(self)

    @property
    def VoiceEventPayload(self) -> "VoiceEventPayloadViewer":
        return VoiceEventPayloadViewer(self)

    @property
    def VoiceMatchResult(self) -> "VoiceMatchResultViewer":
        return VoiceMatchResultViewer(self)

    @property
    def VoiceProfile(self) -> "VoiceProfileViewer":
        return VoiceProfileViewer(self)

    @property
    def VoiceProfileConfig(self) -> "VoiceProfileConfigViewer":
        return VoiceProfileConfigViewer(self)

    @property
    def VoiceProfileV1(self) -> "VoiceProfileV1Viewer":
        return VoiceProfileV1Viewer(self)

    @property
    def VoiceSample(self) -> "VoiceSampleViewer":
        return VoiceSampleViewer(self)

    @property
    def VoiceSampleInput(self) -> "VoiceSampleInputViewer":
        return VoiceSampleInputViewer(self)

    @property
    def VoiceSampleSubmitRequest(self) -> "VoiceSampleSubmitRequestViewer":
        return VoiceSampleSubmitRequestViewer(self)

    @property
    def VoiceSampleSubmitResponse(self) -> "VoiceSampleSubmitResponseViewer":
        return VoiceSampleSubmitResponseViewer(self)

    @property
    def VoiceSamplesPayload(self) -> "VoiceSamplesPayloadViewer":
        return VoiceSamplesPayloadViewer(self)



# #########################################################################
# Generated enums 46
# #########################################################################

class AICommandTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("AICommandType")
        self._values: typing.Set[str] = set([  "TONE_ADJUSTMENT",  "CONTENT_ADDITION",  "CONTENT_REMOVAL",  "SECTION_MODIFICATION",  "VOICE_CORRECTION",  "SPECIFIC_EDIT",  ])
        self._vals = AICommandTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "AICommandTypeValues":
        return self._vals


class AICommandTypeViewer(AICommandTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class AICommandTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def TONE_ADJUSTMENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TONE_ADJUSTMENT"))
    
    @property
    def CONTENT_ADDITION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONTENT_ADDITION"))
    
    @property
    def CONTENT_REMOVAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONTENT_REMOVAL"))
    
    @property
    def SECTION_MODIFICATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SECTION_MODIFICATION"))
    
    @property
    def VOICE_CORRECTION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VOICE_CORRECTION"))
    
    @property
    def SPECIFIC_EDIT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SPECIFIC_EDIT"))
    
    


class ActionSpecificityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ActionSpecificity")
        self._values: typing.Set[str] = set([  "WHEN",  "WHAT",  "HOW",  "WHO",  ])
        self._vals = ActionSpecificityValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ActionSpecificityValues":
        return self._vals


class ActionSpecificityViewer(ActionSpecificityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ActionSpecificityValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def WHEN(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WHEN"))
    
    @property
    def WHAT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WHAT"))
    
    @property
    def HOW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HOW"))
    
    @property
    def WHO(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WHO"))
    
    


class ActionVariantAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ActionVariant")
        self._values: typing.Set[str] = set([  "PRIMARY",  "SECONDARY",  "GHOST",  "LINK",  "DANGER",  ])
        self._vals = ActionVariantValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ActionVariantValues":
        return self._vals


class ActionVariantViewer(ActionVariantAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ActionVariantValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def PRIMARY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PRIMARY"))
    
    @property
    def SECONDARY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SECONDARY"))
    
    @property
    def GHOST(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("GHOST"))
    
    @property
    def LINK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LINK"))
    
    @property
    def DANGER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DANGER"))
    
    


class BadgeVariantAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("BadgeVariant")
        self._values: typing.Set[str] = set([  "DEFAULT",  "PRIMARY",  "SECONDARY",  "SUCCESS",  "WARNING",  "DANGER",  "INFO",  ])
        self._vals = BadgeVariantValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "BadgeVariantValues":
        return self._vals


class BadgeVariantViewer(BadgeVariantAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class BadgeVariantValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def DEFAULT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DEFAULT"))
    
    @property
    def PRIMARY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PRIMARY"))
    
    @property
    def SECONDARY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SECONDARY"))
    
    @property
    def SUCCESS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SUCCESS"))
    
    @property
    def WARNING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WARNING"))
    
    @property
    def DANGER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DANGER"))
    
    @property
    def INFO(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("INFO"))
    
    


class BetweenSessionEventTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("BetweenSessionEventType")
        self._values: typing.Set[str] = set([  "CHECK_IN",  "JOURNAL",  "COMPLETION",  "CONVERSATION",  ])
        self._vals = BetweenSessionEventTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "BetweenSessionEventTypeValues":
        return self._vals


class BetweenSessionEventTypeViewer(BetweenSessionEventTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class BetweenSessionEventTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def CHECK_IN(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CHECK_IN"))
    
    @property
    def JOURNAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("JOURNAL"))
    
    @property
    def COMPLETION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETION"))
    
    @property
    def CONVERSATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONVERSATION"))
    
    


class CoachFeedbackAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("CoachFeedback")
        self._values: typing.Set[str] = set([  "OFF_VOICE",  "PERFECT",  ])
        self._vals = CoachFeedbackValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "CoachFeedbackValues":
        return self._vals


class CoachFeedbackViewer(CoachFeedbackAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class CoachFeedbackValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def OFF_VOICE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OFF_VOICE"))
    
    @property
    def PERFECT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PERFECT"))
    
    


class CommandItemTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("CommandItemType")
        self._values: typing.Set[str] = set([  "CLIENT_ACTION",  "SESSION_PREP",  "FOLLOW_UP",  "PATTERN_ALERT",  ])
        self._vals = CommandItemTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "CommandItemTypeValues":
        return self._vals


class CommandItemTypeViewer(CommandItemTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class CommandItemTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def CLIENT_ACTION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CLIENT_ACTION"))
    
    @property
    def SESSION_PREP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_PREP"))
    
    @property
    def FOLLOW_UP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FOLLOW_UP"))
    
    @property
    def PATTERN_ALERT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PATTERN_ALERT"))
    
    


class CommitmentSourceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("CommitmentSource")
        self._values: typing.Set[str] = set([  "SESSION",  "BETWEEN_SESSION",  ])
        self._vals = CommitmentSourceValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "CommitmentSourceValues":
        return self._vals


class CommitmentSourceViewer(CommitmentSourceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class CommitmentSourceValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def SESSION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION"))
    
    @property
    def BETWEEN_SESSION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("BETWEEN_SESSION"))
    
    


class CommitmentStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("CommitmentStatus")
        self._values: typing.Set[str] = set([  "COMPLETED",  "PENDING",  "PARTIAL",  "UNKNOWN",  ])
        self._vals = CommitmentStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "CommitmentStatusValues":
        return self._vals


class CommitmentStatusViewer(CommitmentStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class CommitmentStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETED"))
    
    @property
    def PENDING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PENDING"))
    
    @property
    def PARTIAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PARTIAL"))
    
    @property
    def UNKNOWN(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("UNKNOWN"))
    
    


class DashboardViewAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("DashboardView")
        self._values: typing.Set[str] = set([  "OVERVIEW",  "SESSIONS",  "CLIENTS",  "ACTIONS",  ])
        self._vals = DashboardViewValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "DashboardViewValues":
        return self._vals


class DashboardViewViewer(DashboardViewAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class DashboardViewValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def OVERVIEW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OVERVIEW"))
    
    @property
    def SESSIONS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSIONS"))
    
    @property
    def CLIENTS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CLIENTS"))
    
    @property
    def ACTIONS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTIONS"))
    
    


class DisclosureLevelAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("DisclosureLevel")
        self._values: typing.Set[str] = set([  "SUMMARY",  "HEADINGS",  "KEY_POINTS",  "FULL_DETAIL",  "EXACT_QUOTE",  "TIMESTAMP",  ])
        self._vals = DisclosureLevelValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "DisclosureLevelValues":
        return self._vals


class DisclosureLevelViewer(DisclosureLevelAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class DisclosureLevelValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def SUMMARY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SUMMARY"))
    
    @property
    def HEADINGS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HEADINGS"))
    
    @property
    def KEY_POINTS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("KEY_POINTS"))
    
    @property
    def FULL_DETAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FULL_DETAIL"))
    
    @property
    def EXACT_QUOTE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXACT_QUOTE"))
    
    @property
    def TIMESTAMP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TIMESTAMP"))
    
    


class EditTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("EditType")
        self._values: typing.Set[str] = set([  "MINOR_TWEAK",  "SIGNIFICANT_CHANGE",  "COMPLETE_REWRITE",  ])
        self._vals = EditTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "EditTypeValues":
        return self._vals


class EditTypeViewer(EditTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class EditTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def MINOR_TWEAK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MINOR_TWEAK"))
    
    @property
    def SIGNIFICANT_CHANGE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SIGNIFICANT_CHANGE"))
    
    @property
    def COMPLETE_REWRITE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETE_REWRITE"))
    
    


class EventTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("EventType")
        self._values: typing.Set[str] = set([  "CONTEXT_CHANGED",  "STATE_UPDATED",  "MESSAGE_RECEIVED",  "MESSAGE_SENT",  "CONVERSATION_STARTED",  "CONVERSATION_ENDED",  "ACTION_PENDING",  "ACTION_EXECUTING",  "ACTION_COMPLETED",  "ACTION_FAILED",  "ACTION_CANCELLED",  "FRONTEND_COMMAND",  "FRONTEND_COMMAND_RESULT",  "SCHEDULED_MESSAGE_CREATED",  "SCHEDULED_MESSAGE_UPDATED",  "SCHEDULED_MESSAGE_APPROVED",  "SCHEDULED_MESSAGE_SENT",  "SCHEDULED_MESSAGE_CANCELLED",  "SCHEDULED_MESSAGE_FAILED",  "SCHEDULED_MESSAGE_REVIEW_DUE",  "COMMAND_CENTER_UPDATED",  "PRIORITY_ITEM_ADDED",  "PRIORITY_ITEM_COMPLETED",  "VOICE_CORRECTION_SUBMITTED",  "VOICE_PROFILE_UPDATED",  "OBSERVATION_DETECTED",  "CURRENT_READ_UPDATED",  "RESOURCE_CREATED",  "RESOURCE_UPDATED",  "RESOURCE_DELETED",  "SESSION_STARTED",  "SESSION_UPDATED",  "SESSION_ENDED",  "CONNECTION_ESTABLISHED",  "CONNECTION_ERROR",  "HEARTBEAT",  "ERROR",  "ONBOARDING_STEP_COMPLETED",  "ONBOARDING_PHASE_STARTED",  "VOICE_SAMPLES_SUBMITTED",  "T15_PREP_GENERATED",  "T15_PREP_UPDATED",  "T15_PREP_VIEWED",  "PREP_NOTIFICATION",  "PREP_READY",  "PREP_VIEWED",  "SESSION_NOTES_GENERATED",  "SESSION_NOTES_UPDATED",  "SESSION_NOTES_FINALIZED",  "SESSION_NOTES_SHARED",  ])
        self._vals = EventTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "EventTypeValues":
        return self._vals


class EventTypeViewer(EventTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class EventTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def CONTEXT_CHANGED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONTEXT_CHANGED"))
    
    @property
    def STATE_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("STATE_UPDATED"))
    
    @property
    def MESSAGE_RECEIVED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MESSAGE_RECEIVED"))
    
    @property
    def MESSAGE_SENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MESSAGE_SENT"))
    
    @property
    def CONVERSATION_STARTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONVERSATION_STARTED"))
    
    @property
    def CONVERSATION_ENDED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONVERSATION_ENDED"))
    
    @property
    def ACTION_PENDING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTION_PENDING"))
    
    @property
    def ACTION_EXECUTING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTION_EXECUTING"))
    
    @property
    def ACTION_COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTION_COMPLETED"))
    
    @property
    def ACTION_FAILED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTION_FAILED"))
    
    @property
    def ACTION_CANCELLED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTION_CANCELLED"))
    
    @property
    def FRONTEND_COMMAND(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FRONTEND_COMMAND"))
    
    @property
    def FRONTEND_COMMAND_RESULT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FRONTEND_COMMAND_RESULT"))
    
    @property
    def SCHEDULED_MESSAGE_CREATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_CREATED"))
    
    @property
    def SCHEDULED_MESSAGE_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_UPDATED"))
    
    @property
    def SCHEDULED_MESSAGE_APPROVED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_APPROVED"))
    
    @property
    def SCHEDULED_MESSAGE_SENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_SENT"))
    
    @property
    def SCHEDULED_MESSAGE_CANCELLED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_CANCELLED"))
    
    @property
    def SCHEDULED_MESSAGE_FAILED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_FAILED"))
    
    @property
    def SCHEDULED_MESSAGE_REVIEW_DUE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_REVIEW_DUE"))
    
    @property
    def COMMAND_CENTER_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMMAND_CENTER_UPDATED"))
    
    @property
    def PRIORITY_ITEM_ADDED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PRIORITY_ITEM_ADDED"))
    
    @property
    def PRIORITY_ITEM_COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PRIORITY_ITEM_COMPLETED"))
    
    @property
    def VOICE_CORRECTION_SUBMITTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VOICE_CORRECTION_SUBMITTED"))
    
    @property
    def VOICE_PROFILE_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VOICE_PROFILE_UPDATED"))
    
    @property
    def OBSERVATION_DETECTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OBSERVATION_DETECTED"))
    
    @property
    def CURRENT_READ_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CURRENT_READ_UPDATED"))
    
    @property
    def RESOURCE_CREATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RESOURCE_CREATED"))
    
    @property
    def RESOURCE_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RESOURCE_UPDATED"))
    
    @property
    def RESOURCE_DELETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RESOURCE_DELETED"))
    
    @property
    def SESSION_STARTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_STARTED"))
    
    @property
    def SESSION_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_UPDATED"))
    
    @property
    def SESSION_ENDED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_ENDED"))
    
    @property
    def CONNECTION_ESTABLISHED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONNECTION_ESTABLISHED"))
    
    @property
    def CONNECTION_ERROR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONNECTION_ERROR"))
    
    @property
    def HEARTBEAT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HEARTBEAT"))
    
    @property
    def ERROR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ERROR"))
    
    @property
    def ONBOARDING_STEP_COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ONBOARDING_STEP_COMPLETED"))
    
    @property
    def ONBOARDING_PHASE_STARTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ONBOARDING_PHASE_STARTED"))
    
    @property
    def VOICE_SAMPLES_SUBMITTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VOICE_SAMPLES_SUBMITTED"))
    
    @property
    def T15_PREP_GENERATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("T15_PREP_GENERATED"))
    
    @property
    def T15_PREP_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("T15_PREP_UPDATED"))
    
    @property
    def T15_PREP_VIEWED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("T15_PREP_VIEWED"))
    
    @property
    def PREP_NOTIFICATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PREP_NOTIFICATION"))
    
    @property
    def PREP_READY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PREP_READY"))
    
    @property
    def PREP_VIEWED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PREP_VIEWED"))
    
    @property
    def SESSION_NOTES_GENERATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES_GENERATED"))
    
    @property
    def SESSION_NOTES_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES_UPDATED"))
    
    @property
    def SESSION_NOTES_FINALIZED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES_FINALIZED"))
    
    @property
    def SESSION_NOTES_SHARED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES_SHARED"))
    
    


class FrontendActionStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("FrontendActionStatus")
        self._values: typing.Set[str] = set([  "PENDING",  "EXECUTING",  "COMPLETED",  "FAILED",  "EXPIRED",  ])
        self._vals = FrontendActionStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "FrontendActionStatusValues":
        return self._vals


class FrontendActionStatusViewer(FrontendActionStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class FrontendActionStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def PENDING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PENDING"))
    
    @property
    def EXECUTING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXECUTING"))
    
    @property
    def COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETED"))
    
    @property
    def FAILED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FAILED"))
    
    @property
    def EXPIRED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXPIRED"))
    
    


class FrontendToolNameAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("FrontendToolName")
        self._values: typing.Set[str] = set([  "NAVIGATE_TO",  "CLICK_ELEMENT",  "EXPAND_SECTION",  "SET_FORM_FIELD",  "SUBMIT_FORM",  "OPEN_MODAL",  "CLOSE_MODAL",  ])
        self._vals = FrontendToolNameValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "FrontendToolNameValues":
        return self._vals


class FrontendToolNameViewer(FrontendToolNameAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class FrontendToolNameValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NAVIGATE_TO(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NAVIGATE_TO"))
    
    @property
    def CLICK_ELEMENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CLICK_ELEMENT"))
    
    @property
    def EXPAND_SECTION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXPAND_SECTION"))
    
    @property
    def SET_FORM_FIELD(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SET_FORM_FIELD"))
    
    @property
    def SUBMIT_FORM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SUBMIT_FORM"))
    
    @property
    def OPEN_MODAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OPEN_MODAL"))
    
    @property
    def CLOSE_MODAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CLOSE_MODAL"))
    
    


class GoalCategoryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("GoalCategory")
        self._values: typing.Set[str] = set([  "CAREER",  "LEADERSHIP",  "RELATIONSHIPS",  "PERSONAL",  "HEALTH",  "OTHER",  ])
        self._vals = GoalCategoryValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "GoalCategoryValues":
        return self._vals


class GoalCategoryViewer(GoalCategoryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class GoalCategoryValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def CAREER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CAREER"))
    
    @property
    def LEADERSHIP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LEADERSHIP"))
    
    @property
    def RELATIONSHIPS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RELATIONSHIPS"))
    
    @property
    def PERSONAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PERSONAL"))
    
    @property
    def HEALTH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HEALTH"))
    
    @property
    def OTHER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OTHER"))
    
    


class GoalStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("GoalStatus")
        self._values: typing.Set[str] = set([  "ACTIVE",  "COMPLETED",  "PAUSED",  "ARCHIVED",  ])
        self._vals = GoalStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "GoalStatusValues":
        return self._vals


class GoalStatusViewer(GoalStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class GoalStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def ACTIVE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTIVE"))
    
    @property
    def COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETED"))
    
    @property
    def PAUSED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PAUSED"))
    
    @property
    def ARCHIVED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ARCHIVED"))
    
    


class InquiryCategoryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("InquiryCategory")
        self._values: typing.Set[str] = set([  "GROWTH",  "REFLECTION",  "CHALLENGE",  "EXPLORATION",  ])
        self._vals = InquiryCategoryValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "InquiryCategoryValues":
        return self._vals


class InquiryCategoryViewer(InquiryCategoryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class InquiryCategoryValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def GROWTH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("GROWTH"))
    
    @property
    def REFLECTION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("REFLECTION"))
    
    @property
    def CHALLENGE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CHALLENGE"))
    
    @property
    def EXPLORATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXPLORATION"))
    
    


class IntegrationStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("IntegrationStatus")
        self._values: typing.Set[str] = set([  "NOT_CONNECTED",  "PENDING",  "CONNECTED",  "EXPIRED",  "ERROR",  ])
        self._vals = IntegrationStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "IntegrationStatusValues":
        return self._vals


class IntegrationStatusViewer(IntegrationStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class IntegrationStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NOT_CONNECTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NOT_CONNECTED"))
    
    @property
    def PENDING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PENDING"))
    
    @property
    def CONNECTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONNECTED"))
    
    @property
    def EXPIRED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXPIRED"))
    
    @property
    def ERROR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ERROR"))
    
    


class IntegrationTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("IntegrationType")
        self._values: typing.Set[str] = set([  "GOOGLE_CALENDAR",  "OUTLOOK_CALENDAR",  "ZOOM",  "GOOGLE_MEET",  "TEAMS",  "SALESFORCE",  "HUBSPOT",  "PRACTICE",  ])
        self._vals = IntegrationTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "IntegrationTypeValues":
        return self._vals


class IntegrationTypeViewer(IntegrationTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class IntegrationTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def GOOGLE_CALENDAR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("GOOGLE_CALENDAR"))
    
    @property
    def OUTLOOK_CALENDAR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OUTLOOK_CALENDAR"))
    
    @property
    def ZOOM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ZOOM"))
    
    @property
    def GOOGLE_MEET(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("GOOGLE_MEET"))
    
    @property
    def TEAMS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TEAMS"))
    
    @property
    def SALESFORCE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SALESFORCE"))
    
    @property
    def HUBSPOT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HUBSPOT"))
    
    @property
    def PRACTICE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PRACTICE"))
    
    


class LifeContextAreaAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("LifeContextArea")
        self._values: typing.Set[str] = set([  "WORK",  "RELATIONSHIPS",  "HEALTH",  "PERSONAL",  "OTHER",  ])
        self._vals = LifeContextAreaValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "LifeContextAreaValues":
        return self._vals


class LifeContextAreaViewer(LifeContextAreaAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class LifeContextAreaValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def WORK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WORK"))
    
    @property
    def RELATIONSHIPS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RELATIONSHIPS"))
    
    @property
    def HEALTH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HEALTH"))
    
    @property
    def PERSONAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PERSONAL"))
    
    @property
    def OTHER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OTHER"))
    
    


class MessageChannelAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("MessageChannel")
        self._values: typing.Set[str] = set([  "EMAIL",  "SMS",  "WHATSAPP",  ])
        self._vals = MessageChannelValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "MessageChannelValues":
        return self._vals


class MessageChannelViewer(MessageChannelAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class MessageChannelValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def EMAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EMAIL"))
    
    @property
    def SMS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SMS"))
    
    @property
    def WHATSAPP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WHATSAPP"))
    
    


class MessageRoleAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("MessageRole")
        self._values: typing.Set[str] = set([  "USER",  "ASSISTANT",  "SYSTEM",  ])
        self._vals = MessageRoleValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "MessageRoleValues":
        return self._vals


class MessageRoleViewer(MessageRoleAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class MessageRoleValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def USER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("USER"))
    
    @property
    def ASSISTANT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ASSISTANT"))
    
    @property
    def SYSTEM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SYSTEM"))
    
    


class MessageStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("MessageStatus")
        self._values: typing.Set[str] = set([  "DRAFT",  "APPROVED",  "PENDING_REVIEW",  "SENT",  "CANCELLED",  "FAILED",  ])
        self._vals = MessageStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "MessageStatusValues":
        return self._vals


class MessageStatusViewer(MessageStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class MessageStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def DRAFT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DRAFT"))
    
    @property
    def APPROVED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("APPROVED"))
    
    @property
    def PENDING_REVIEW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PENDING_REVIEW"))
    
    @property
    def SENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SENT"))
    
    @property
    def CANCELLED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CANCELLED"))
    
    @property
    def FAILED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FAILED"))
    
    


class ObservationTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ObservationType")
        self._values: typing.Set[str] = set([  "PATTERN",  "CHANGE",  "BREAKTHROUGH",  ])
        self._vals = ObservationTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ObservationTypeValues":
        return self._vals


class ObservationTypeViewer(ObservationTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ObservationTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def PATTERN(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PATTERN"))
    
    @property
    def CHANGE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CHANGE"))
    
    @property
    def BREAKTHROUGH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("BREAKTHROUGH"))
    
    


class OnboardingActionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("OnboardingAction")
        self._values: typing.Set[str] = set([  "START",  "COMPLETE",  "SKIP",  "SAVE_PROGRESS",  ])
        self._vals = OnboardingActionValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "OnboardingActionValues":
        return self._vals


class OnboardingActionViewer(OnboardingActionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class OnboardingActionValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def START(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("START"))
    
    @property
    def COMPLETE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETE"))
    
    @property
    def SKIP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SKIP"))
    
    @property
    def SAVE_PROGRESS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SAVE_PROGRESS"))
    
    


class OnboardingPhaseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("OnboardingPhase")
        self._values: typing.Set[str] = set([  "ACCOUNT_CREATED",  "PROFILE_SETUP",  "VOICE_SAMPLES",  "COACHING_STYLE",  "INTEGRATIONS",  "CLIENT_IMPORT",  "TUTORIAL",  "COMPLETED",  ])
        self._vals = OnboardingPhaseValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "OnboardingPhaseValues":
        return self._vals


class OnboardingPhaseViewer(OnboardingPhaseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class OnboardingPhaseValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def ACCOUNT_CREATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACCOUNT_CREATED"))
    
    @property
    def PROFILE_SETUP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PROFILE_SETUP"))
    
    @property
    def VOICE_SAMPLES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VOICE_SAMPLES"))
    
    @property
    def COACHING_STYLE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COACHING_STYLE"))
    
    @property
    def INTEGRATIONS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("INTEGRATIONS"))
    
    @property
    def CLIENT_IMPORT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CLIENT_IMPORT"))
    
    @property
    def TUTORIAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TUTORIAL"))
    
    @property
    def COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETED"))
    
    


class OpenerCategoryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("OpenerCategory")
        self._values: typing.Set[str] = set([  "COMMITMENT",  "PATTERN",  "CONTEXT",  "EXPLORATION",  ])
        self._vals = OpenerCategoryValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "OpenerCategoryValues":
        return self._vals


class OpenerCategoryViewer(OpenerCategoryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class OpenerCategoryValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def COMMITMENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMMITMENT"))
    
    @property
    def PATTERN(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PATTERN"))
    
    @property
    def CONTEXT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONTEXT"))
    
    @property
    def EXPLORATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXPLORATION"))
    
    


class PatternTrendAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("PatternTrend")
        self._values: typing.Set[str] = set([  "INCREASING",  "STABLE",  "DECREASING",  ])
        self._vals = PatternTrendValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "PatternTrendValues":
        return self._vals


class PatternTrendViewer(PatternTrendAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class PatternTrendValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def INCREASING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("INCREASING"))
    
    @property
    def STABLE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("STABLE"))
    
    @property
    def DECREASING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DECREASING"))
    
    


class PhaseStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("PhaseStatus")
        self._values: typing.Set[str] = set([  "NOT_STARTED",  "IN_PROGRESS",  "COMPLETED",  "SKIPPED",  ])
        self._vals = PhaseStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "PhaseStatusValues":
        return self._vals


class PhaseStatusViewer(PhaseStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class PhaseStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NOT_STARTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NOT_STARTED"))
    
    @property
    def IN_PROGRESS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("IN_PROGRESS"))
    
    @property
    def COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETED"))
    
    @property
    def SKIPPED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SKIPPED"))
    
    


class PrepSectionIdAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("PrepSectionId")
        self._values: typing.Set[str] = set([  "NORTH_STAR",  "LAST_SESSION",  "COMMITMENTS",  "LIFE_CONTEXT",  "PATTERNS",  "OPENERS",  "PRIVATE_NOTES",  "BETWEEN_SESSION",  "COACHEE_INPUT",  ])
        self._vals = PrepSectionIdValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "PrepSectionIdValues":
        return self._vals


class PrepSectionIdViewer(PrepSectionIdAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class PrepSectionIdValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NORTH_STAR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NORTH_STAR"))
    
    @property
    def LAST_SESSION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LAST_SESSION"))
    
    @property
    def COMMITMENTS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMMITMENTS"))
    
    @property
    def LIFE_CONTEXT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LIFE_CONTEXT"))
    
    @property
    def PATTERNS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PATTERNS"))
    
    @property
    def OPENERS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OPENERS"))
    
    @property
    def PRIVATE_NOTES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PRIVATE_NOTES"))
    
    @property
    def BETWEEN_SESSION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("BETWEEN_SESSION"))
    
    @property
    def COACHEE_INPUT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COACHEE_INPUT"))
    
    


class PrepStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("PrepStatus")
        self._values: typing.Set[str] = set([  "DRAFT",  "READY",  "VIEWED",  ])
        self._vals = PrepStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "PrepStatusValues":
        return self._vals


class PrepStatusViewer(PrepStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class PrepStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def DRAFT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DRAFT"))
    
    @property
    def READY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("READY"))
    
    @property
    def VIEWED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VIEWED"))
    
    


class PrepStatusValueAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("PrepStatusValue")
        self._values: typing.Set[str] = set([  "NOT_STARTED",  "GENERATING",  "READY",  "VIEWED",  ])
        self._vals = PrepStatusValueValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "PrepStatusValueValues":
        return self._vals


class PrepStatusValueViewer(PrepStatusValueAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class PrepStatusValueValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NOT_STARTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NOT_STARTED"))
    
    @property
    def GENERATING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("GENERATING"))
    
    @property
    def READY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("READY"))
    
    @property
    def VIEWED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VIEWED"))
    
    


class PriorityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Priority")
        self._values: typing.Set[str] = set([  "FOCUS_NOW",  "SOON",  "LATER",  ])
        self._vals = PriorityValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "PriorityValues":
        return self._vals


class PriorityViewer(PriorityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class PriorityValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def FOCUS_NOW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FOCUS_NOW"))
    
    @property
    def SOON(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SOON"))
    
    @property
    def LATER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LATER"))
    
    


class ResourceLinkTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ResourceLinkType")
        self._values: typing.Set[str] = set([  "DOCUMENT",  "LINK",  "FRAMEWORK",  ])
        self._vals = ResourceLinkTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ResourceLinkTypeValues":
        return self._vals


class ResourceLinkTypeViewer(ResourceLinkTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ResourceLinkTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def DOCUMENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DOCUMENT"))
    
    @property
    def LINK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LINK"))
    
    @property
    def FRAMEWORK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FRAMEWORK"))
    
    


class ResourceTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ResourceType")
        self._values: typing.Set[str] = set([  "DOCUMENT",  "LINK",  "FRAMEWORK",  "TEMPLATE",  ])
        self._vals = ResourceTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ResourceTypeValues":
        return self._vals


class ResourceTypeViewer(ResourceTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ResourceTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def DOCUMENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DOCUMENT"))
    
    @property
    def LINK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LINK"))
    
    @property
    def FRAMEWORK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FRAMEWORK"))
    
    @property
    def TEMPLATE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TEMPLATE"))
    
    


class SentimentAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Sentiment")
        self._values: typing.Set[str] = set([  "POSITIVE",  "NEUTRAL",  "NEGATIVE",  ])
        self._vals = SentimentValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "SentimentValues":
        return self._vals


class SentimentViewer(SentimentAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class SentimentValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def POSITIVE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("POSITIVE"))
    
    @property
    def NEUTRAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NEUTRAL"))
    
    @property
    def NEGATIVE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NEGATIVE"))
    
    


class SessionNoteSectionIdAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("SessionNoteSectionId")
        self._values: typing.Set[str] = set([  "RECAP",  "OBSERVATIONS",  "INQUIRIES",  "INVITATIONS",  "RESOURCES",  "NEXT",  ])
        self._vals = SessionNoteSectionIdValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "SessionNoteSectionIdValues":
        return self._vals


class SessionNoteSectionIdViewer(SessionNoteSectionIdAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class SessionNoteSectionIdValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def RECAP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RECAP"))
    
    @property
    def OBSERVATIONS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OBSERVATIONS"))
    
    @property
    def INQUIRIES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("INQUIRIES"))
    
    @property
    def INVITATIONS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("INVITATIONS"))
    
    @property
    def RESOURCES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RESOURCES"))
    
    @property
    def NEXT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NEXT"))
    
    


class SessionNotesStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("SessionNotesStatus")
        self._values: typing.Set[str] = set([  "DRAFT",  "SENT",  "ARCHIVED",  ])
        self._vals = SessionNotesStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "SessionNotesStatusValues":
        return self._vals


class SessionNotesStatusViewer(SessionNotesStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class SessionNotesStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def DRAFT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DRAFT"))
    
    @property
    def SENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SENT"))
    
    @property
    def ARCHIVED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ARCHIVED"))
    
    


class StateSourceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("StateSource")
        self._values: typing.Set[str] = set([  "FRONTEND",  "EXTENSION",  ])
        self._vals = StateSourceValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "StateSourceValues":
        return self._vals


class StateSourceViewer(StateSourceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class StateSourceValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def FRONTEND(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FRONTEND"))
    
    @property
    def EXTENSION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXTENSION"))
    
    


class ToolNameAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ToolName")
        self._values: typing.Set[str] = set([  "DRAFT_T15",  "DRAFT_SESSION_NOTES",  "SEND_FOLLOW_UP_EMAIL",  "UPDATE_SESSION_STATUS",  "SUMMARIZE_TRANSCRIPT",  "ADD_CLIENT_NOTE",  "SCHEDULE_SESSION",  "LOOKUP_CLIENT",  ])
        self._vals = ToolNameValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ToolNameValues":
        return self._vals


class ToolNameViewer(ToolNameAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ToolNameValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def DRAFT_T15(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DRAFT_T15"))
    
    @property
    def DRAFT_SESSION_NOTES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DRAFT_SESSION_NOTES"))
    
    @property
    def SEND_FOLLOW_UP_EMAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SEND_FOLLOW_UP_EMAIL"))
    
    @property
    def UPDATE_SESSION_STATUS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("UPDATE_SESSION_STATUS"))
    
    @property
    def SUMMARIZE_TRANSCRIPT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SUMMARIZE_TRANSCRIPT"))
    
    @property
    def ADD_CLIENT_NOTE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ADD_CLIENT_NOTE"))
    
    @property
    def SCHEDULE_SESSION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULE_SESSION"))
    
    @property
    def LOOKUP_CLIENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LOOKUP_CLIENT"))
    
    


class TransparencyIndicatorAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("TransparencyIndicator")
        self._values: typing.Set[str] = set([  "COACH_DIRECT",  "AI_DRAFTED_APPROVED",  "AI_AUTONOMOUS",  ])
        self._vals = TransparencyIndicatorValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "TransparencyIndicatorValues":
        return self._vals


class TransparencyIndicatorViewer(TransparencyIndicatorAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class TransparencyIndicatorValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def COACH_DIRECT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COACH_DIRECT"))
    
    @property
    def AI_DRAFTED_APPROVED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("AI_DRAFTED_APPROVED"))
    
    @property
    def AI_AUTONOMOUS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("AI_AUTONOMOUS"))
    
    


class VoiceContentTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("VoiceContentType")
        self._values: typing.Set[str] = set([  "SESSION_NOTES",  "EMAIL",  "MESSAGE",  ])
        self._vals = VoiceContentTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "VoiceContentTypeValues":
        return self._vals


class VoiceContentTypeViewer(VoiceContentTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class VoiceContentTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def SESSION_NOTES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES"))
    
    @property
    def EMAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EMAIL"))
    
    @property
    def MESSAGE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MESSAGE"))
    
    


class VoiceSampleStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("VoiceSampleStatus")
        self._values: typing.Set[str] = set([  "PENDING",  "PROCESSING",  "PROCESSED",  "FAILED",  ])
        self._vals = VoiceSampleStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "VoiceSampleStatusValues":
        return self._vals


class VoiceSampleStatusViewer(VoiceSampleStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class VoiceSampleStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def PENDING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PENDING"))
    
    @property
    def PROCESSING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PROCESSING"))
    
    @property
    def PROCESSED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PROCESSED"))
    
    @property
    def FAILED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FAILED"))
    
    


class VoiceSampleTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("VoiceSampleType")
        self._values: typing.Set[str] = set([  "EMAIL",  "SESSION_NOTES",  "FOLLOW_UP",  "FEEDBACK",  "GENERAL",  ])
        self._vals = VoiceSampleTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "VoiceSampleTypeValues":
        return self._vals


class VoiceSampleTypeViewer(VoiceSampleTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class VoiceSampleTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def EMAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EMAIL"))
    
    @property
    def SESSION_NOTES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES"))
    
    @property
    def FOLLOW_UP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FOLLOW_UP"))
    
    @property
    def FEEDBACK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FEEDBACK"))
    
    @property
    def GENERAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("GENERAL"))
    
    


class VoiceTrainingStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("VoiceTrainingStatus")
        self._values: typing.Set[str] = set([  "NEEDS_SAMPLES",  "READY",  "TRAINING",  "TRAINED",  "RETRAINING",  ])
        self._vals = VoiceTrainingStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "VoiceTrainingStatusValues":
        return self._vals


class VoiceTrainingStatusViewer(VoiceTrainingStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class VoiceTrainingStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NEEDS_SAMPLES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NEEDS_SAMPLES"))
    
    @property
    def READY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("READY"))
    
    @property
    def TRAINING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TRAINING"))
    
    @property
    def TRAINED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TRAINED"))
    
    @property
    def RETRAINING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RETRAINING"))
    
    



# #########################################################################
# Generated classes 168
# #########################################################################

class AICommandHistoryItemAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AICommandHistoryItem")
        self._properties: typing.Set[str] = set([  "id",  "command",  "commandType",  "originalContent",  "editedContent",  "section",  "applied",  "explanation",  "createdAt",  ])
        self._props = AICommandHistoryItemProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AICommandHistoryItemProperties":
        return self._props


class AICommandHistoryItemViewer(AICommandHistoryItemAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AICommandHistoryItemProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def command(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("command"))
    
    @property
    def commandType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("commandType"))
    
    @property
    def originalContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("originalContent"))
    
    @property
    def editedContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editedContent"))
    
    @property
    def section(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("section"))
    
    @property
    def applied(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("applied"))
    
    @property
    def explanation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("explanation"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    


class AICommandRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AICommandRequest")
        self._properties: typing.Set[str] = set([  "contentId",  "section",  "command",  "currentContent",  "commandType",  ])
        self._props = AICommandRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AICommandRequestProperties":
        return self._props


class AICommandRequestViewer(AICommandRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AICommandRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def contentId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contentId"))
    
    @property
    def section(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("section"))
    
    @property
    def command(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("command"))
    
    @property
    def currentContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("currentContent"))
    
    @property
    def commandType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("commandType"))
    
    


class AICommandResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AICommandResult")
        self._properties: typing.Set[str] = set([  "editedContent",  "explanation",  "appliedChange",  "commandId",  ])
        self._props = AICommandResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AICommandResultProperties":
        return self._props


class AICommandResultViewer(AICommandResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AICommandResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def editedContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editedContent"))
    
    @property
    def explanation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("explanation"))
    
    @property
    def appliedChange(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("appliedChange"))
    
    @property
    def commandId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("commandId"))
    
    


class AccordionGroupAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AccordionGroup")
        self._properties: typing.Set[str] = set([  "id",  "sections",  "allowMultipleExpanded",  "defaultExpandedIds",  ])
        self._props = AccordionGroupProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AccordionGroupProperties":
        return self._props


class AccordionGroupViewer(AccordionGroupAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AccordionGroupProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def sections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sections"))
    
    @property
    def allowMultipleExpanded(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("allowMultipleExpanded"))
    
    @property
    def defaultExpandedIds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("defaultExpandedIds"))
    
    


class AccordionSectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AccordionSection")
        self._properties: typing.Set[str] = set([  "id",  "title",  "summary",  "level",  "expanded",  "children",  ])
        self._props = AccordionSectionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AccordionSectionProperties":
        return self._props


class AccordionSectionViewer(AccordionSectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AccordionSectionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("level"))
    
    @property
    def expanded(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("expanded"))
    
    @property
    def children(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("children"))
    
    


class ActionErrorAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionError")
        self._properties: typing.Set[str] = set([  "code",  "message",  "retryable",  "details",  ])
        self._props = ActionErrorProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionErrorProperties":
        return self._props


class ActionErrorViewer(ActionErrorAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ActionErrorProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def code(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("code"))
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def retryable(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("retryable"))
    
    @property
    def details(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("details"))
    
    


class ActionEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionEventPayload")
        self._properties: typing.Set[str] = set([  "actionId",  "tool",  "status",  "parameters",  "result",  "error",  ])
        self._props = ActionEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionEventPayloadProperties":
        return self._props


class ActionEventPayloadViewer(ActionEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ActionEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def actionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionId"))
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def result(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("result"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class ActionItemAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionItem")
        self._properties: typing.Set[str] = set([  "id",  "action",  "specificity",  "details",  "dueDate",  "completed",  ])
        self._props = ActionItemProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionItemProperties":
        return self._props


class ActionItemViewer(ActionItemAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ActionItemProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def specificity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("specificity"))
    
    @property
    def details(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("details"))
    
    @property
    def dueDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dueDate"))
    
    @property
    def completed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completed"))
    
    


class ActionOutputAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionOutput")
        self._properties: typing.Set[str] = set([  "type",  "text",  "structured",  "preview",  ])
        self._props = ActionOutputProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionOutputProperties":
        return self._props


class ActionOutputViewer(ActionOutputAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ActionOutputProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def text(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("text"))
    
    @property
    def structured(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("structured"))
    
    @property
    def preview(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preview"))
    
    


class ActionRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionRequest")
        self._properties: typing.Set[str] = set([  "conversationId",  "tool",  "parameters",  "context",  "confirmed",  ])
        self._props = ActionRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionRequestProperties":
        return self._props


class ActionRequestViewer(ActionRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ActionRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def conversationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conversationId"))
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def confirmed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confirmed"))
    
    


class ActionResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionResponse")
        self._properties: typing.Set[str] = set([  "success",  "actionId",  "tool",  "output",  "error",  "appliedChanges",  "followUpMessage",  "suggestedNextActions",  ])
        self._props = ActionResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionResponseProperties":
        return self._props


class ActionResponseViewer(ActionResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ActionResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def actionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionId"))
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def output(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("output"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    @property
    def appliedChanges(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("appliedChanges"))
    
    @property
    def followUpMessage(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("followUpMessage"))
    
    @property
    def suggestedNextActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggestedNextActions"))
    
    


class AiTimingSuggestionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AiTimingSuggestion")
        self._properties: typing.Set[str] = set([  "suggestedTime",  "reason",  "confidence",  "alternativeTimes",  ])
        self._props = AiTimingSuggestionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AiTimingSuggestionProperties":
        return self._props


class AiTimingSuggestionViewer(AiTimingSuggestionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AiTimingSuggestionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def suggestedTime(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggestedTime"))
    
    @property
    def reason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("reason"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    @property
    def alternativeTimes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alternativeTimes"))
    
    


class AiTimingSuggestionRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AiTimingSuggestionRequest")
        self._properties: typing.Set[str] = set([  "clientId",  "messageType",  "preferredTimeRange",  ])
        self._props = AiTimingSuggestionRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AiTimingSuggestionRequestProperties":
        return self._props


class AiTimingSuggestionRequestViewer(AiTimingSuggestionRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AiTimingSuggestionRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def messageType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("messageType"))
    
    @property
    def preferredTimeRange(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preferredTimeRange"))
    
    


class AuthVerifyResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AuthVerifyResponse")
        self._properties: typing.Set[str] = set([  "authenticated",  "userId",  "username",  "email",  "firstName",  "lastName",  "organizationId",  "permissions",  ])
        self._props = AuthVerifyResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AuthVerifyResponseProperties":
        return self._props


class AuthVerifyResponseViewer(AuthVerifyResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AuthVerifyResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def authenticated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authenticated"))
    
    @property
    def userId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("userId"))
    
    @property
    def username(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("username"))
    
    @property
    def email(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("email"))
    
    @property
    def firstName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("firstName"))
    
    @property
    def lastName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastName"))
    
    @property
    def organizationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("organizationId"))
    
    @property
    def permissions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("permissions"))
    
    


class BetweenSessionEventAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("BetweenSessionEvent")
        self._properties: typing.Set[str] = set([  "id",  "type",  "summary",  "sentiment",  "timestamp",  ])
        self._props = BetweenSessionEventProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "BetweenSessionEventProperties":
        return self._props


class BetweenSessionEventViewer(BetweenSessionEventAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class BetweenSessionEventProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def sentiment(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sentiment"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    


class CardActionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CardAction")
        self._properties: typing.Set[str] = set([  "id",  "label",  "icon",  "variant",  "disabled",  ])
        self._props = CardActionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CardActionProperties":
        return self._props


class CardActionViewer(CardActionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CardActionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def label(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("label"))
    
    @property
    def icon(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("icon"))
    
    @property
    def variant(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("variant"))
    
    @property
    def disabled(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("disabled"))
    
    


class CardDataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CardData")
        self._properties: typing.Set[str] = set([  "id",  "title",  "subtitle",  "description",  "icon",  "badge",  "badgeVariant",  "actions",  ])
        self._props = CardDataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CardDataProperties":
        return self._props


class CardDataViewer(CardDataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CardDataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def subtitle(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subtitle"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def icon(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("icon"))
    
    @property
    def badge(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("badge"))
    
    @property
    def badgeVariant(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("badgeVariant"))
    
    @property
    def actions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actions"))
    
    


class ChatMessageAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ChatMessage")
        self._properties: typing.Set[str] = set([  "role",  "content",  "timestamp",  ])
        self._props = ChatMessageProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChatMessageProperties":
        return self._props


class ChatMessageViewer(ChatMessageAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ChatMessageProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def role(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("role"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    


class ChatRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ChatRequest")
        self._properties: typing.Set[str] = set([  "message",  "context",  "conversationHistory",  "conversationId",  ])
        self._props = ChatRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChatRequestProperties":
        return self._props


class ChatRequestViewer(ChatRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ChatRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def conversationHistory(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conversationHistory"))
    
    @property
    def conversationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conversationId"))
    
    


class ChatResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ChatResponse")
        self._properties: typing.Set[str] = set([  "message",  "conversationId",  "suggestedActions",  "context",  "frontendCommands",  ])
        self._props = ChatResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChatResponseProperties":
        return self._props


class ChatResponseViewer(ChatResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ChatResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def conversationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conversationId"))
    
    @property
    def suggestedActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggestedActions"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def frontendCommands(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("frontendCommands"))
    
    


class ClientContextAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClientContext")
        self._properties: typing.Set[str] = set([  "id",  "name",  "email",  "phone",  "goals",  "recentNotes",  "lastSessionDate",  "nextSessionDate",  "totalSessions",  ])
        self._props = ClientContextProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClientContextProperties":
        return self._props


class ClientContextViewer(ClientContextAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ClientContextProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def email(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("email"))
    
    @property
    def phone(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phone"))
    
    @property
    def goals(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("goals"))
    
    @property
    def recentNotes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recentNotes"))
    
    @property
    def lastSessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastSessionDate"))
    
    @property
    def nextSessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nextSessionDate"))
    
    @property
    def totalSessions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSessions"))
    
    


class ClientGoalAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClientGoal")
        self._properties: typing.Set[str] = set([  "id",  "clientId",  "title",  "description",  "category",  "status",  "progress",  "targetDate",  "completedAt",  "createdAt",  "updatedAt",  ])
        self._props = ClientGoalProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClientGoalProperties":
        return self._props


class ClientGoalViewer(ClientGoalAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ClientGoalProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def category(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("category"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def progress(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("progress"))
    
    @property
    def targetDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("targetDate"))
    
    @property
    def completedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completedAt"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    @property
    def updatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedAt"))
    
    


class ClientListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClientList")
        self._properties: typing.Set[str] = set([  "items",  "total",  "page",  "pageSize",  ])
        self._props = ClientListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClientListProperties":
        return self._props


class ClientListViewer(ClientListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ClientListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def total(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def pageSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageSize"))
    
    


class ClientNoteAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClientNote")
        self._properties: typing.Set[str] = set([  "id",  "clientId",  "content",  "createdAt",  "updatedAt",  ])
        self._props = ClientNoteProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClientNoteProperties":
        return self._props


class ClientNoteViewer(ClientNoteAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ClientNoteProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    @property
    def updatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedAt"))
    
    


class ClientNoteListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClientNoteList")
        self._properties: typing.Set[str] = set([  "items",  "total",  ])
        self._props = ClientNoteListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClientNoteListProperties":
        return self._props


class ClientNoteListViewer(ClientNoteListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ClientNoteListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def total(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total"))
    
    


class ClientProfileAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClientProfile")
        self._properties: typing.Set[str] = set([  "id",  "name",  "email",  "phone",  "company",  "title",  "bio",  "values",  "vision",  "overarchingGoals",  "totalSessions",  "completedGoals",  "activeGoals",  "pendingActions",  "lastSessionDate",  "nextSessionDate",  "coachingStartDate",  ])
        self._props = ClientProfileProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClientProfileProperties":
        return self._props


class ClientProfileViewer(ClientProfileAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ClientProfileProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def email(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("email"))
    
    @property
    def phone(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phone"))
    
    @property
    def company(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("company"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def bio(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("bio"))
    
    @property
    def values(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("values"))
    
    @property
    def vision(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vision"))
    
    @property
    def overarchingGoals(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overarchingGoals"))
    
    @property
    def totalSessions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSessions"))
    
    @property
    def completedGoals(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completedGoals"))
    
    @property
    def activeGoals(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("activeGoals"))
    
    @property
    def pendingActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pendingActions"))
    
    @property
    def lastSessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastSessionDate"))
    
    @property
    def nextSessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nextSessionDate"))
    
    @property
    def coachingStartDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachingStartDate"))
    
    


class ClientStatsAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClientStats")
        self._properties: typing.Set[str] = set([  "clientId",  "totalSessions",  "averageSessionDuration",  "completedGoals",  "activeGoals",  "completedActions",  "pendingActions",  "averageMoodRating",  "sessionFrequency",  "coachingDurationMonths",  ])
        self._props = ClientStatsProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClientStatsProperties":
        return self._props


class ClientStatsViewer(ClientStatsAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ClientStatsProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def totalSessions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSessions"))
    
    @property
    def averageSessionDuration(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("averageSessionDuration"))
    
    @property
    def completedGoals(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completedGoals"))
    
    @property
    def activeGoals(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("activeGoals"))
    
    @property
    def completedActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completedActions"))
    
    @property
    def pendingActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pendingActions"))
    
    @property
    def averageMoodRating(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("averageMoodRating"))
    
    @property
    def sessionFrequency(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionFrequency"))
    
    @property
    def coachingDurationMonths(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachingDurationMonths"))
    
    


class ClientSummaryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClientSummary")
        self._properties: typing.Set[str] = set([  "id",  "name",  "email",  "company",  "totalSessions",  "lastSessionDate",  "nextSessionDate",  ])
        self._props = ClientSummaryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClientSummaryProperties":
        return self._props


class ClientSummaryViewer(ClientSummaryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ClientSummaryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def email(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("email"))
    
    @property
    def company(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("company"))
    
    @property
    def totalSessions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSessions"))
    
    @property
    def lastSessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastSessionDate"))
    
    @property
    def nextSessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nextSessionDate"))
    
    


class CoacheePreSessionInputAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CoacheePreSessionInput")
        self._properties: typing.Set[str] = set([  "submitted",  "submittedAt",  "topics",  "updates",  "questions",  "moodRating",  ])
        self._props = CoacheePreSessionInputProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CoacheePreSessionInputProperties":
        return self._props


class CoacheePreSessionInputViewer(CoacheePreSessionInputAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CoacheePreSessionInputProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def submitted(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("submitted"))
    
    @property
    def submittedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("submittedAt"))
    
    @property
    def topics(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("topics"))
    
    @property
    def updates(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updates"))
    
    @property
    def questions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("questions"))
    
    @property
    def moodRating(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("moodRating"))
    
    


class CommandCenterDataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CommandCenterData")
        self._properties: typing.Set[str] = set([  "focusNow",  "soon",  "later",  "lastUpdated",  ])
        self._props = CommandCenterDataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CommandCenterDataProperties":
        return self._props


class CommandCenterDataViewer(CommandCenterDataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CommandCenterDataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def focusNow(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("focusNow"))
    
    @property
    def soon(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("soon"))
    
    @property
    def later(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("later"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class CommandCenterEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CommandCenterEventPayload")
        self._properties: typing.Set[str] = set([  "focusNowCount",  "soonCount",  "laterCount",  "lastUpdated",  ])
        self._props = CommandCenterEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CommandCenterEventPayloadProperties":
        return self._props


class CommandCenterEventPayloadViewer(CommandCenterEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CommandCenterEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def focusNowCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("focusNowCount"))
    
    @property
    def soonCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("soonCount"))
    
    @property
    def laterCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("laterCount"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class CommandCenterItemAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CommandCenterItem")
        self._properties: typing.Set[str] = set([  "id",  "type",  "clientId",  "clientName",  "priority",  "priorityReason",  "action",  "dueDate",  "crossDomainContext",  "sessionId",  "createdAt",  ])
        self._props = CommandCenterItemProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CommandCenterItemProperties":
        return self._props


class CommandCenterItemViewer(CommandCenterItemAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CommandCenterItemProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def priority(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priority"))
    
    @property
    def priorityReason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priorityReason"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def dueDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dueDate"))
    
    @property
    def crossDomainContext(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("crossDomainContext"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    


class CommitmentAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Commitment")
        self._properties: typing.Set[str] = set([  "id",  "description",  "status",  "source",  "sessionId",  "createdAt",  ])
        self._props = CommitmentProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CommitmentProperties":
        return self._props


class CommitmentViewer(CommitmentAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CommitmentProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    


class ConnectionPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ConnectionPayload")
        self._properties: typing.Set[str] = set([  "connectionId",  "userId",  "capabilities",  ])
        self._props = ConnectionPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ConnectionPayloadProperties":
        return self._props


class ConnectionPayloadViewer(ConnectionPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ConnectionPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def connectionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("connectionId"))
    
    @property
    def userId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("userId"))
    
    @property
    def capabilities(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("capabilities"))
    
    


class ContextChangedPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ContextChangedPayload")
        self._properties: typing.Set[str] = set([  "page",  "clientId",  "clientName",  "sessionId",  "sessionDate",  "availableActions",  "source",  ])
        self._props = ContextChangedPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ContextChangedPayloadProperties":
        return self._props


class ContextChangedPayloadViewer(ContextChangedPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ContextChangedPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def availableActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("availableActions"))
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    


class CorrectionPairAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CorrectionPair")
        self._properties: typing.Set[str] = set([  "originalContent",  "editedContent",  "editType",  "coachFeedback",  "contentType",  "timestamp",  ])
        self._props = CorrectionPairProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CorrectionPairProperties":
        return self._props


class CorrectionPairViewer(CorrectionPairAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CorrectionPairProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def originalContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("originalContent"))
    
    @property
    def editedContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editedContent"))
    
    @property
    def editType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editType"))
    
    @property
    def coachFeedback(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachFeedback"))
    
    @property
    def contentType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contentType"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    


class CreateGoalRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateGoalRequest")
        self._properties: typing.Set[str] = set([  "title",  "description",  "category",  "targetDate",  ])
        self._props = CreateGoalRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateGoalRequestProperties":
        return self._props


class CreateGoalRequestViewer(CreateGoalRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CreateGoalRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def category(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("category"))
    
    @property
    def targetDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("targetDate"))
    
    


class CreateResourceRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateResourceRequest")
        self._properties: typing.Set[str] = set([  "type",  "title",  "description",  "externalUrl",  "tags",  ])
        self._props = CreateResourceRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateResourceRequestProperties":
        return self._props


class CreateResourceRequestViewer(CreateResourceRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CreateResourceRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def externalUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("externalUrl"))
    
    @property
    def tags(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tags"))
    
    


class CreateScheduledMessageRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateScheduledMessageRequest")
        self._properties: typing.Set[str] = set([  "clientId",  "sessionId",  "templateId",  "channel",  "subject",  "body",  "scheduledFor",  "useAiSuggestion",  "autoApprove",  "transparencyIndicator",  "transparencyDisplayName",  ])
        self._props = CreateScheduledMessageRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateScheduledMessageRequestProperties":
        return self._props


class CreateScheduledMessageRequestViewer(CreateScheduledMessageRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CreateScheduledMessageRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def templateId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("templateId"))
    
    @property
    def channel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("channel"))
    
    @property
    def subject(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subject"))
    
    @property
    def body(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("body"))
    
    @property
    def scheduledFor(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledFor"))
    
    @property
    def useAiSuggestion(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("useAiSuggestion"))
    
    @property
    def autoApprove(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("autoApprove"))
    
    @property
    def transparencyIndicator(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transparencyIndicator"))
    
    @property
    def transparencyDisplayName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transparencyDisplayName"))
    
    


class CurrentReadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CurrentRead")
        self._properties: typing.Set[str] = set([  "assessment",  "confidence",  "lastUpdated",  ])
        self._props = CurrentReadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CurrentReadProperties":
        return self._props


class CurrentReadViewer(CurrentReadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CurrentReadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def assessment(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("assessment"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class DashboardDataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DashboardData")
        self._properties: typing.Set[str] = set([  "upcomingSessions",  "recentClients",  "pendingActionsCount",  "todaySessionsCount",  "weekSessionsCount",  "lastUpdated",  ])
        self._props = DashboardDataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DashboardDataProperties":
        return self._props


class DashboardDataViewer(DashboardDataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DashboardDataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def upcomingSessions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("upcomingSessions"))
    
    @property
    def recentClients(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recentClients"))
    
    @property
    def pendingActionsCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pendingActionsCount"))
    
    @property
    def todaySessionsCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("todaySessionsCount"))
    
    @property
    def weekSessionsCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("weekSessionsCount"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class DashboardPreferencesAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DashboardPreferences")
        self._properties: typing.Set[str] = set([  "coachId",  "sections",  "defaultView",  "refreshInterval",  ])
        self._props = DashboardPreferencesProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DashboardPreferencesProperties":
        return self._props


class DashboardPreferencesViewer(DashboardPreferencesAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DashboardPreferencesProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def sections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sections"))
    
    @property
    def defaultView(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("defaultView"))
    
    @property
    def refreshInterval(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("refreshInterval"))
    
    


class DashboardSectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DashboardSection")
        self._properties: typing.Set[str] = set([  "id",  "title",  "priority",  "visible",  "collapsed",  ])
        self._props = DashboardSectionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DashboardSectionProperties":
        return self._props


class DashboardSectionViewer(DashboardSectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DashboardSectionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def priority(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priority"))
    
    @property
    def visible(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("visible"))
    
    @property
    def collapsed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("collapsed"))
    
    


class DisclosureConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DisclosureConfig")
        self._properties: typing.Set[str] = set([  "defaultLevel",  "allowToggle",  "expandByDefault",  ])
        self._props = DisclosureConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DisclosureConfigProperties":
        return self._props


class DisclosureConfigViewer(DisclosureConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class DisclosureConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def defaultLevel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("defaultLevel"))
    
    @property
    def allowToggle(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("allowToggle"))
    
    @property
    def expandByDefault(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("expandByDefault"))
    
    


class EmptyStateAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EmptyState")
        self._properties: typing.Set[str] = set([  "icon",  "title",  "description",  "actionLabel",  "actionHref",  ])
        self._props = EmptyStateProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EmptyStateProperties":
        return self._props


class EmptyStateViewer(EmptyStateAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class EmptyStateProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def icon(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("icon"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def actionLabel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionLabel"))
    
    @property
    def actionHref(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionHref"))
    
    


class ErrorPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ErrorPayload")
        self._properties: typing.Set[str] = set([  "code",  "message",  "details",  "retryable",  ])
        self._props = ErrorPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ErrorPayloadProperties":
        return self._props


class ErrorPayloadViewer(ErrorPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ErrorPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def code(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("code"))
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def details(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("details"))
    
    @property
    def retryable(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("retryable"))
    
    


class EventEnvelopeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EventEnvelope")
        self._properties: typing.Set[str] = set([  "type",  "meta",  "payload",  ])
        self._props = EventEnvelopeProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EventEnvelopeProperties":
        return self._props


class EventEnvelopeViewer(EventEnvelopeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class EventEnvelopeProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def meta(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("meta"))
    
    @property
    def payload(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("payload"))
    
    


class EventMetaAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EventMeta")
        self._properties: typing.Set[str] = set([  "timestamp",  "correlationId",  "contractsVersion",  "actorId",  "requestId",  ])
        self._props = EventMetaProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EventMetaProperties":
        return self._props


class EventMetaViewer(EventMetaAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class EventMetaProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    @property
    def correlationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("correlationId"))
    
    @property
    def contractsVersion(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contractsVersion"))
    
    @property
    def actorId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actorId"))
    
    @property
    def requestId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requestId"))
    
    


class FinalizeNotesRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FinalizeNotesRequest")
        self._properties: typing.Set[str] = set([  "notesId",  "sendToClient",  "personalizedMessage",  ])
        self._props = FinalizeNotesRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FinalizeNotesRequestProperties":
        return self._props


class FinalizeNotesRequestViewer(FinalizeNotesRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FinalizeNotesRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def notesId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notesId"))
    
    @property
    def sendToClient(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sendToClient"))
    
    @property
    def personalizedMessage(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("personalizedMessage"))
    
    


class FinalizeNotesResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FinalizeNotesResponse")
        self._properties: typing.Set[str] = set([  "success",  "status",  "sentAt",  "error",  ])
        self._props = FinalizeNotesResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FinalizeNotesResponseProperties":
        return self._props


class FinalizeNotesResponseViewer(FinalizeNotesResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FinalizeNotesResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def sentAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sentAt"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class FrontendActionResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FrontendActionResult")
        self._properties: typing.Set[str] = set([  "actionId",  "status",  "success",  "message",  "error",  "executedAt",  ])
        self._props = FrontendActionResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FrontendActionResultProperties":
        return self._props


class FrontendActionResultViewer(FrontendActionResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FrontendActionResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def actionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionId"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    @property
    def executedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("executedAt"))
    
    


class FrontendCommandAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FrontendCommand")
        self._properties: typing.Set[str] = set([  "actionId",  "tool",  "parameters",  "timeout",  "requiresConfirmation",  ])
        self._props = FrontendCommandProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FrontendCommandProperties":
        return self._props


class FrontendCommandViewer(FrontendCommandAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FrontendCommandProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def actionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionId"))
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def timeout(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeout"))
    
    @property
    def requiresConfirmation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requiresConfirmation"))
    
    


class FrontendCommandPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FrontendCommandPayload")
        self._properties: typing.Set[str] = set([  "actionId",  "tool",  "parameters",  "timeout",  "requiresConfirmation",  ])
        self._props = FrontendCommandPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FrontendCommandPayloadProperties":
        return self._props


class FrontendCommandPayloadViewer(FrontendCommandPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FrontendCommandPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def actionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionId"))
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def timeout(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeout"))
    
    @property
    def requiresConfirmation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requiresConfirmation"))
    
    


class FrontendToolConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FrontendToolConfig")
        self._properties: typing.Set[str] = set([  "tool",  "requiresConfirmation",  "defaultTimeout",  ])
        self._props = FrontendToolConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FrontendToolConfigProperties":
        return self._props


class FrontendToolConfigViewer(FrontendToolConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FrontendToolConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def requiresConfirmation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requiresConfirmation"))
    
    @property
    def defaultTimeout(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("defaultTimeout"))
    
    


class GenerateNotesRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GenerateNotesRequest")
        self._properties: typing.Set[str] = set([  "sessionId",  "regenerate",  ])
        self._props = GenerateNotesRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GenerateNotesRequestProperties":
        return self._props


class GenerateNotesRequestViewer(GenerateNotesRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class GenerateNotesRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def regenerate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("regenerate"))
    
    


class GeneratePrepRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GeneratePrepRequest")
        self._properties: typing.Set[str] = set([  "sessionId",  "regenerate",  ])
        self._props = GeneratePrepRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GeneratePrepRequestProperties":
        return self._props


class GeneratePrepRequestViewer(GeneratePrepRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class GeneratePrepRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def regenerate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("regenerate"))
    
    


class GoalFilterAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GoalFilter")
        self._properties: typing.Set[str] = set([  "clientId",  "category",  "status",  "searchQuery",  ])
        self._props = GoalFilterProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GoalFilterProperties":
        return self._props


class GoalFilterViewer(GoalFilterAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class GoalFilterProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def category(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("category"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def searchQuery(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("searchQuery"))
    
    


class GoalListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GoalList")
        self._properties: typing.Set[str] = set([  "items",  "total",  "page",  "pageSize",  ])
        self._props = GoalListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GoalListProperties":
        return self._props


class GoalListViewer(GoalListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class GoalListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def total(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def pageSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageSize"))
    
    


class GoalMilestoneAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GoalMilestone")
        self._properties: typing.Set[str] = set([  "id",  "goalId",  "title",  "description",  "targetDate",  "completed",  "completedAt",  ])
        self._props = GoalMilestoneProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GoalMilestoneProperties":
        return self._props


class GoalMilestoneViewer(GoalMilestoneAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class GoalMilestoneProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def goalId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("goalId"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def targetDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("targetDate"))
    
    @property
    def completed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completed"))
    
    @property
    def completedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completedAt"))
    
    


class GoalProgressUpdateAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GoalProgressUpdate")
        self._properties: typing.Set[str] = set([  "goalId",  "progress",  "note",  "updatedAt",  ])
        self._props = GoalProgressUpdateProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GoalProgressUpdateProperties":
        return self._props


class GoalProgressUpdateViewer(GoalProgressUpdateAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class GoalProgressUpdateProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def goalId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("goalId"))
    
    @property
    def progress(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("progress"))
    
    @property
    def note(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("note"))
    
    @property
    def updatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedAt"))
    
    


class GoalResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GoalResponse")
        self._properties: typing.Set[str] = set([  "success",  "goal",  "error",  ])
        self._props = GoalResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GoalResponseProperties":
        return self._props


class GoalResponseViewer(GoalResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class GoalResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def goal(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("goal"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class GroupedListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("GroupedList")
        self._properties: typing.Set[str] = set([  "id",  "groups",  ])
        self._props = GroupedListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "GroupedListProperties":
        return self._props


class GroupedListViewer(GroupedListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class GroupedListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def groups(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("groups"))
    
    


class HeartbeatPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("HeartbeatPayload")
        self._properties: typing.Set[str] = set([  "serverTime",  "connectionAge",  ])
        self._props = HeartbeatPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "HeartbeatPayloadProperties":
        return self._props


class HeartbeatPayloadViewer(HeartbeatPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class HeartbeatPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def serverTime(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("serverTime"))
    
    @property
    def connectionAge(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("connectionAge"))
    
    


class InquiriesSectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("InquiriesSection")
        self._properties: typing.Set[str] = set([  "id",  "summary",  "keyPoints",  "expanded",  "questions",  ])
        self._props = InquiriesSectionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "InquiriesSectionProperties":
        return self._props


class InquiriesSectionViewer(InquiriesSectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class InquiriesSectionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def keyPoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("keyPoints"))
    
    @property
    def expanded(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("expanded"))
    
    @property
    def questions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("questions"))
    
    


class InquiryQuestionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("InquiryQuestion")
        self._properties: typing.Set[str] = set([  "id",  "question",  "category",  "answered",  ])
        self._props = InquiryQuestionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "InquiryQuestionProperties":
        return self._props


class InquiryQuestionViewer(InquiryQuestionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class InquiryQuestionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def question(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("question"))
    
    @property
    def category(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("category"))
    
    @property
    def answered(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("answered"))
    
    


class IntegrationConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntegrationConfig")
        self._properties: typing.Set[str] = set([  "id",  "coachId",  "type",  "status",  "displayName",  "accountEmail",  "connectedAt",  "lastSyncAt",  "settings",  "error",  ])
        self._props = IntegrationConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntegrationConfigProperties":
        return self._props


class IntegrationConfigViewer(IntegrationConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntegrationConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def displayName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("displayName"))
    
    @property
    def accountEmail(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("accountEmail"))
    
    @property
    def connectedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("connectedAt"))
    
    @property
    def lastSyncAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastSyncAt"))
    
    @property
    def settings(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("settings"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class IntegrationConnectRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntegrationConnectRequest")
        self._properties: typing.Set[str] = set([  "type",  "redirectUrl",  ])
        self._props = IntegrationConnectRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntegrationConnectRequestProperties":
        return self._props


class IntegrationConnectRequestViewer(IntegrationConnectRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntegrationConnectRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def redirectUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("redirectUrl"))
    
    


class IntegrationConnectResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntegrationConnectResponse")
        self._properties: typing.Set[str] = set([  "success",  "authUrl",  "error",  ])
        self._props = IntegrationConnectResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntegrationConnectResponseProperties":
        return self._props


class IntegrationConnectResponseViewer(IntegrationConnectResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntegrationConnectResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def authUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authUrl"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class IntegrationDisconnectRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntegrationDisconnectRequest")
        self._properties: typing.Set[str] = set([  "integrationId",  ])
        self._props = IntegrationDisconnectRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntegrationDisconnectRequestProperties":
        return self._props


class IntegrationDisconnectRequestViewer(IntegrationDisconnectRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntegrationDisconnectRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def integrationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("integrationId"))
    
    


class IntegrationListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntegrationList")
        self._properties: typing.Set[str] = set([  "integrations",  "availableTypes",  ])
        self._props = IntegrationListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntegrationListProperties":
        return self._props


class IntegrationListViewer(IntegrationListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntegrationListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def integrations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("integrations"))
    
    @property
    def availableTypes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("availableTypes"))
    
    


class InvitationsSectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("InvitationsSection")
        self._properties: typing.Set[str] = set([  "id",  "summary",  "keyPoints",  "expanded",  "actionItems",  ])
        self._props = InvitationsSectionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "InvitationsSectionProperties":
        return self._props


class InvitationsSectionViewer(InvitationsSectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class InvitationsSectionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def keyPoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("keyPoints"))
    
    @property
    def expanded(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("expanded"))
    
    @property
    def actionItems(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionItems"))
    
    


class KeyPointAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("KeyPoint")
        self._properties: typing.Set[str] = set([  "id",  "text",  "detail",  "quote",  ])
        self._props = KeyPointProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "KeyPointProperties":
        return self._props


class KeyPointViewer(KeyPointAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class KeyPointProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def text(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("text"))
    
    @property
    def detail(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("detail"))
    
    @property
    def quote(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quote"))
    
    


class LastSessionRecapAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("LastSessionRecap")
        self._properties: typing.Set[str] = set([  "themes",  "breakthroughs",  "emotionalMoments",  "summary",  "sessionDate",  ])
        self._props = LastSessionRecapProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "LastSessionRecapProperties":
        return self._props


class LastSessionRecapViewer(LastSessionRecapAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class LastSessionRecapProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def themes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("themes"))
    
    @property
    def breakthroughs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("breakthroughs"))
    
    @property
    def emotionalMoments(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("emotionalMoments"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    


class LifeContextItemAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("LifeContextItem")
        self._properties: typing.Set[str] = set([  "area",  "summary",  "source",  "updatedAt",  ])
        self._props = LifeContextItemProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "LifeContextItemProperties":
        return self._props


class LifeContextItemViewer(LifeContextItemAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class LifeContextItemProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def area(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("area"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    @property
    def updatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedAt"))
    
    


class ListGroupAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ListGroup")
        self._properties: typing.Set[str] = set([  "id",  "title",  "items",  "collapsible",  "collapsed",  ])
        self._props = ListGroupProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ListGroupProperties":
        return self._props


class ListGroupViewer(ListGroupAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ListGroupProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def collapsible(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("collapsible"))
    
    @property
    def collapsed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("collapsed"))
    
    


class ListItemAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ListItem")
        self._properties: typing.Set[str] = set([  "id",  "primary",  "secondary",  "meta",  "avatar",  "selected",  "disabled",  ])
        self._props = ListItemProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ListItemProperties":
        return self._props


class ListItemViewer(ListItemAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ListItemProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def primary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("primary"))
    
    @property
    def secondary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("secondary"))
    
    @property
    def meta(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("meta"))
    
    @property
    def avatar(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("avatar"))
    
    @property
    def selected(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("selected"))
    
    @property
    def disabled(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("disabled"))
    
    


class LoadingStateAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("LoadingState")
        self._properties: typing.Set[str] = set([  "message",  "showProgress",  "progress",  ])
        self._props = LoadingStateProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "LoadingStateProperties":
        return self._props


class LoadingStateViewer(LoadingStateAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class LoadingStateProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def showProgress(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("showProgress"))
    
    @property
    def progress(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("progress"))
    
    


class MessagePayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("MessagePayload")
        self._properties: typing.Set[str] = set([  "conversationId",  "role",  "content",  "timestamp",  ])
        self._props = MessagePayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "MessagePayloadProperties":
        return self._props


class MessagePayloadViewer(MessagePayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class MessagePayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def conversationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conversationId"))
    
    @property
    def role(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("role"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    


class NavigationOptionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NavigationOption")
        self._properties: typing.Set[str] = set([  "label",  "route",  "icon",  ])
        self._props = NavigationOptionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NavigationOptionProperties":
        return self._props


class NavigationOptionViewer(NavigationOptionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class NavigationOptionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def label(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("label"))
    
    @property
    def route(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("route"))
    
    @property
    def icon(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("icon"))
    
    


class NextSectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NextSection")
        self._properties: typing.Set[str] = set([  "id",  "summary",  "keyPoints",  "expanded",  "focusAreas",  "nextSessionDate",  ])
        self._props = NextSectionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NextSectionProperties":
        return self._props


class NextSectionViewer(NextSectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class NextSectionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def keyPoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("keyPoints"))
    
    @property
    def expanded(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("expanded"))
    
    @property
    def focusAreas(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("focusAreas"))
    
    @property
    def nextSessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nextSessionDate"))
    
    


class NorthStarReminderAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NorthStarReminder")
        self._properties: typing.Set[str] = set([  "values",  "vision",  "overarchingGoals",  ])
        self._props = NorthStarReminderProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NorthStarReminderProperties":
        return self._props


class NorthStarReminderViewer(NorthStarReminderAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class NorthStarReminderProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def values(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("values"))
    
    @property
    def vision(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vision"))
    
    @property
    def overarchingGoals(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overarchingGoals"))
    
    


class ObservationEntryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ObservationEntry")
        self._properties: typing.Set[str] = set([  "id",  "type",  "description",  "evidence",  "confidence",  "detectedAt",  "dismissed",  "dismissedBy",  "dismissedAt",  ])
        self._props = ObservationEntryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ObservationEntryProperties":
        return self._props


class ObservationEntryViewer(ObservationEntryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ObservationEntryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def evidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("evidence"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    @property
    def detectedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("detectedAt"))
    
    @property
    def dismissed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dismissed"))
    
    @property
    def dismissedBy(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dismissedBy"))
    
    @property
    def dismissedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dismissedAt"))
    
    


class ObservationPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ObservationPayload")
        self._properties: typing.Set[str] = set([  "observationId",  "clientId",  "type",  "description",  "confidence",  ])
        self._props = ObservationPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ObservationPayloadProperties":
        return self._props


class ObservationPayloadViewer(ObservationPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ObservationPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def observationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("observationId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    


class OnboardingEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OnboardingEventPayload")
        self._properties: typing.Set[str] = set([  "coachId",  "phase",  "previousPhase",  "overallProgress",  "action",  "timestamp",  ])
        self._props = OnboardingEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OnboardingEventPayloadProperties":
        return self._props


class OnboardingEventPayloadViewer(OnboardingEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OnboardingEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def phase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phase"))
    
    @property
    def previousPhase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("previousPhase"))
    
    @property
    def overallProgress(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overallProgress"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    


class OnboardingPhaseProgressAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OnboardingPhaseProgress")
        self._properties: typing.Set[str] = set([  "phase",  "status",  "startedAt",  "completedAt",  "skipped",  "skipReason",  "data",  ])
        self._props = OnboardingPhaseProgressProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OnboardingPhaseProgressProperties":
        return self._props


class OnboardingPhaseProgressViewer(OnboardingPhaseProgressAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OnboardingPhaseProgressProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def phase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phase"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def startedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("startedAt"))
    
    @property
    def completedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completedAt"))
    
    @property
    def skipped(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("skipped"))
    
    @property
    def skipReason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("skipReason"))
    
    @property
    def data(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data"))
    
    


class OnboardingProgressAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OnboardingProgress")
        self._properties: typing.Set[str] = set([  "coachId",  "currentPhase",  "phases",  "overallProgress",  "startedAt",  "completedAt",  "estimatedTimeRemaining",  "canSkipCurrent",  ])
        self._props = OnboardingProgressProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OnboardingProgressProperties":
        return self._props


class OnboardingProgressViewer(OnboardingProgressAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OnboardingProgressProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def currentPhase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("currentPhase"))
    
    @property
    def phases(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phases"))
    
    @property
    def overallProgress(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overallProgress"))
    
    @property
    def startedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("startedAt"))
    
    @property
    def completedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completedAt"))
    
    @property
    def estimatedTimeRemaining(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimatedTimeRemaining"))
    
    @property
    def canSkipCurrent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("canSkipCurrent"))
    
    


class OnboardingUpdateRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OnboardingUpdateRequest")
        self._properties: typing.Set[str] = set([  "phase",  "action",  "data",  ])
        self._props = OnboardingUpdateRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OnboardingUpdateRequestProperties":
        return self._props


class OnboardingUpdateRequestViewer(OnboardingUpdateRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OnboardingUpdateRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def phase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phase"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def data(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data"))
    
    


class OnboardingUpdateResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OnboardingUpdateResponse")
        self._properties: typing.Set[str] = set([  "success",  "progress",  "nextPhase",  "error",  ])
        self._props = OnboardingUpdateResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OnboardingUpdateResponseProperties":
        return self._props


class OnboardingUpdateResponseViewer(OnboardingUpdateResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OnboardingUpdateResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def progress(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("progress"))
    
    @property
    def nextPhase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nextPhase"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class PageContextAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PageContext")
        self._properties: typing.Set[str] = set([  "url",  "route",  "clientId",  "sessionId",  "pageTitle",  "pageData",  ])
        self._props = PageContextProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PageContextProperties":
        return self._props


class PageContextViewer(PageContextAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PageContextProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("url"))
    
    @property
    def route(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("route"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def pageTitle(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageTitle"))
    
    @property
    def pageData(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageData"))
    
    


class PatternEvidenceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PatternEvidence")
        self._properties: typing.Set[str] = set([  "sessionId",  "sessionDate",  "quote",  "timestamp",  ])
        self._props = PatternEvidenceProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PatternEvidenceProperties":
        return self._props


class PatternEvidenceViewer(PatternEvidenceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PatternEvidenceProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def quote(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quote"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    


class PatternIntelligenceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PatternIntelligence")
        self._properties: typing.Set[str] = set([  "id",  "pattern",  "frequency",  "trend",  "evidence",  "lastOccurrence",  ])
        self._props = PatternIntelligenceProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PatternIntelligenceProperties":
        return self._props


class PatternIntelligenceViewer(PatternIntelligenceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PatternIntelligenceProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def pattern(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pattern"))
    
    @property
    def frequency(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("frequency"))
    
    @property
    def trend(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("trend"))
    
    @property
    def evidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("evidence"))
    
    @property
    def lastOccurrence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastOccurrence"))
    
    


class PrepDocumentAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PrepDocument")
        self._properties: typing.Set[str] = set([  "id",  "sessionId",  "clientId",  "clientName",  "sessionTitle",  "sessionDateTime",  "northStarReminder",  "lastSessionRecap",  "commitments",  "lifeContext",  "patternIntelligence",  "suggestedOpeners",  "privateCoachNotes",  "betweenSessionIntelligence",  "coacheePreSessionInput",  "generatedAt",  "status",  ])
        self._props = PrepDocumentProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PrepDocumentProperties":
        return self._props


class PrepDocumentViewer(PrepDocumentAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PrepDocumentProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionTitle(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionTitle"))
    
    @property
    def sessionDateTime(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDateTime"))
    
    @property
    def northStarReminder(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("northStarReminder"))
    
    @property
    def lastSessionRecap(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastSessionRecap"))
    
    @property
    def commitments(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("commitments"))
    
    @property
    def lifeContext(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lifeContext"))
    
    @property
    def patternIntelligence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("patternIntelligence"))
    
    @property
    def suggestedOpeners(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggestedOpeners"))
    
    @property
    def privateCoachNotes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("privateCoachNotes"))
    
    @property
    def betweenSessionIntelligence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("betweenSessionIntelligence"))
    
    @property
    def coacheePreSessionInput(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coacheePreSessionInput"))
    
    @property
    def generatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generatedAt"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    


class PrepListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PrepList")
        self._properties: typing.Set[str] = set([  "items",  "total",  "page",  "pageSize",  ])
        self._props = PrepListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PrepListProperties":
        return self._props


class PrepListViewer(PrepListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PrepListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def total(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def pageSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageSize"))
    
    


class PrepNotificationPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PrepNotificationPayload")
        self._properties: typing.Set[str] = set([  "sessionId",  "clientName",  "sessionDateTime",  "prepStatus",  "minutesUntilSession",  ])
        self._props = PrepNotificationPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PrepNotificationPayloadProperties":
        return self._props


class PrepNotificationPayloadViewer(PrepNotificationPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PrepNotificationPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionDateTime(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDateTime"))
    
    @property
    def prepStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("prepStatus"))
    
    @property
    def minutesUntilSession(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("minutesUntilSession"))
    
    


class PrepResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PrepResponse")
        self._properties: typing.Set[str] = set([  "success",  "document",  "error",  "warnings",  "generationTimeMs",  ])
        self._props = PrepResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PrepResponseProperties":
        return self._props


class PrepResponseViewer(PrepResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PrepResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def document(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("document"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    @property
    def warnings(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("warnings"))
    
    @property
    def generationTimeMs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generationTimeMs"))
    
    


class PrepSummaryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PrepSummary")
        self._properties: typing.Set[str] = set([  "id",  "sessionId",  "clientId",  "clientName",  "sessionDateTime",  "status",  "generatedAt",  ])
        self._props = PrepSummaryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PrepSummaryProperties":
        return self._props


class PrepSummaryViewer(PrepSummaryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PrepSummaryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionDateTime(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDateTime"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def generatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generatedAt"))
    
    


class PrepTemplateAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PrepTemplate")
        self._properties: typing.Set[str] = set([  "id",  "coachId",  "name",  "sectionsEnabled",  "defaultExpanded",  ])
        self._props = PrepTemplateProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PrepTemplateProperties":
        return self._props


class PrepTemplateViewer(PrepTemplateAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PrepTemplateProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def sectionsEnabled(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sectionsEnabled"))
    
    @property
    def defaultExpanded(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("defaultExpanded"))
    
    


class PriorityItemPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PriorityItemPayload")
        self._properties: typing.Set[str] = set([  "itemId",  "type",  "clientId",  "clientName",  "priority",  "action",  ])
        self._props = PriorityItemPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PriorityItemPayloadProperties":
        return self._props


class PriorityItemPayloadViewer(PriorityItemPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PriorityItemPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def itemId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("itemId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def priority(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priority"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    


class PrivateIntelligenceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PrivateIntelligence")
        self._properties: typing.Set[str] = set([  "clientId",  "currentRead",  "observations",  "coachPrivateNotes",  "lastUpdated",  ])
        self._props = PrivateIntelligenceProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PrivateIntelligenceProperties":
        return self._props


class PrivateIntelligenceViewer(PrivateIntelligenceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PrivateIntelligenceProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def currentRead(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("currentRead"))
    
    @property
    def observations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("observations"))
    
    @property
    def coachPrivateNotes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachPrivateNotes"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class ProfileScrapeRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ProfileScrapeRequest")
        self._properties: typing.Set[str] = set([  "urls",  "linkedInUrl",  "websiteUrl",  ])
        self._props = ProfileScrapeRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ProfileScrapeRequestProperties":
        return self._props


class ProfileScrapeRequestViewer(ProfileScrapeRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ProfileScrapeRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def urls(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("urls"))
    
    @property
    def linkedInUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("linkedInUrl"))
    
    @property
    def websiteUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("websiteUrl"))
    
    


class ProfileScrapeResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ProfileScrapeResponse")
        self._properties: typing.Set[str] = set([  "success",  "profiles",  "mergedProfile",  "error",  ])
        self._props = ProfileScrapeResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ProfileScrapeResponseProperties":
        return self._props


class ProfileScrapeResponseViewer(ProfileScrapeResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ProfileScrapeResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def profiles(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("profiles"))
    
    @property
    def mergedProfile(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("mergedProfile"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class QuoteAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Quote")
        self._properties: typing.Set[str] = set([  "text",  "timestamp",  "videoLink",  ])
        self._props = QuoteProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "QuoteProperties":
        return self._props


class QuoteViewer(QuoteAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class QuoteProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def text(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("text"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    @property
    def videoLink(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("videoLink"))
    
    


class RecentClientAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("RecentClient")
        self._properties: typing.Set[str] = set([  "id",  "name",  "firstName",  "lastName",  "avatarUrl",  "lastSessionDate",  "nextSessionDate",  "recentActivity",  "hasPendingPrep",  "pendingActionsCount",  "pendingMessages",  ])
        self._props = RecentClientProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "RecentClientProperties":
        return self._props


class RecentClientViewer(RecentClientAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class RecentClientProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def firstName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("firstName"))
    
    @property
    def lastName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastName"))
    
    @property
    def avatarUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("avatarUrl"))
    
    @property
    def lastSessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastSessionDate"))
    
    @property
    def nextSessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nextSessionDate"))
    
    @property
    def recentActivity(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recentActivity"))
    
    @property
    def hasPendingPrep(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("hasPendingPrep"))
    
    @property
    def pendingActionsCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pendingActionsCount"))
    
    @property
    def pendingMessages(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pendingMessages"))
    
    


class ResolvedContextAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResolvedContext")
        self._properties: typing.Set[str] = set([  "clientId",  "clientName",  "sessionId",  "sessionDate",  "confidence",  ])
        self._props = ResolvedContextProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResolvedContextProperties":
        return self._props


class ResolvedContextViewer(ResolvedContextAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResolvedContextProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    


class ResourceEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResourceEventPayload")
        self._properties: typing.Set[str] = set([  "resourceId",  "clientId",  "type",  "title",  "action",  ])
        self._props = ResourceEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResourceEventPayloadProperties":
        return self._props


class ResourceEventPayloadViewer(ResourceEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResourceEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def resourceId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("resourceId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    


class ResourceItemAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResourceItem")
        self._properties: typing.Set[str] = set([  "id",  "clientId",  "coachId",  "type",  "title",  "description",  "fileUrl",  "externalUrl",  "thumbnailUrl",  "tags",  "metadata",  "createdAt",  "updatedAt",  ])
        self._props = ResourceItemProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResourceItemProperties":
        return self._props


class ResourceItemViewer(ResourceItemAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResourceItemProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def fileUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fileUrl"))
    
    @property
    def externalUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("externalUrl"))
    
    @property
    def thumbnailUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("thumbnailUrl"))
    
    @property
    def tags(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tags"))
    
    @property
    def metadata(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("metadata"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    @property
    def updatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedAt"))
    
    


class ResourceLinkAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResourceLink")
        self._properties: typing.Set[str] = set([  "id",  "title",  "url",  "type",  "description",  ])
        self._props = ResourceLinkProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResourceLinkProperties":
        return self._props


class ResourceLinkViewer(ResourceLinkAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResourceLinkProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("url"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    


class ResourceListDataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResourceListData")
        self._properties: typing.Set[str] = set([  "items",  "total",  "page",  "pageSize",  "nextPage",  ])
        self._props = ResourceListDataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResourceListDataProperties":
        return self._props


class ResourceListDataViewer(ResourceListDataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResourceListDataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def total(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def pageSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageSize"))
    
    @property
    def nextPage(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nextPage"))
    
    


class ResourceMetadataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResourceMetadata")
        self._properties: typing.Set[str] = set([  "fileSize",  "mimeType",  "originalName",  "linkTitle",  "linkDescription",  "linkImage",  ])
        self._props = ResourceMetadataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResourceMetadataProperties":
        return self._props


class ResourceMetadataViewer(ResourceMetadataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResourceMetadataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def fileSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fileSize"))
    
    @property
    def mimeType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("mimeType"))
    
    @property
    def originalName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("originalName"))
    
    @property
    def linkTitle(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("linkTitle"))
    
    @property
    def linkDescription(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("linkDescription"))
    
    @property
    def linkImage(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("linkImage"))
    
    


class ResourcesSectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResourcesSection")
        self._properties: typing.Set[str] = set([  "id",  "summary",  "keyPoints",  "expanded",  "links",  ])
        self._props = ResourcesSectionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResourcesSectionProperties":
        return self._props


class ResourcesSectionViewer(ResourcesSectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResourcesSectionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def keyPoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("keyPoints"))
    
    @property
    def expanded(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("expanded"))
    
    @property
    def links(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("links"))
    
    


class ScheduledMessageAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessage")
        self._properties: typing.Set[str] = set([  "id",  "coachId",  "coachName",  "clientId",  "clientName",  "clientEmail",  "sessionId",  "sessionDate",  "templateUsed",  "channel",  "subject",  "body",  "scheduledFor",  "aiSuggestedTime",  "aiSuggestionReason",  "status",  "approvedAt",  "reviewedAt",  "sentAt",  "cancelledAt",  "cancellationReason",  "deliveryAttempts",  "lastDeliveryError",  "externalMessageId",  "transparencyIndicator",  "transparencyDisplayName",  "canEdit",  "canCancel",  "canSend",  "createdAt",  "updatedAt",  ])
        self._props = ScheduledMessageProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessageProperties":
        return self._props


class ScheduledMessageViewer(ScheduledMessageAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessageProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def coachName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachName"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def clientEmail(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientEmail"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def templateUsed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("templateUsed"))
    
    @property
    def channel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("channel"))
    
    @property
    def subject(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subject"))
    
    @property
    def body(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("body"))
    
    @property
    def scheduledFor(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledFor"))
    
    @property
    def aiSuggestedTime(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("aiSuggestedTime"))
    
    @property
    def aiSuggestionReason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("aiSuggestionReason"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def approvedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("approvedAt"))
    
    @property
    def reviewedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("reviewedAt"))
    
    @property
    def sentAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sentAt"))
    
    @property
    def cancelledAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cancelledAt"))
    
    @property
    def cancellationReason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cancellationReason"))
    
    @property
    def deliveryAttempts(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("deliveryAttempts"))
    
    @property
    def lastDeliveryError(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastDeliveryError"))
    
    @property
    def externalMessageId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("externalMessageId"))
    
    @property
    def transparencyIndicator(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transparencyIndicator"))
    
    @property
    def transparencyDisplayName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transparencyDisplayName"))
    
    @property
    def canEdit(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("canEdit"))
    
    @property
    def canCancel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("canCancel"))
    
    @property
    def canSend(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("canSend"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    @property
    def updatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedAt"))
    
    


class ScheduledMessageAuditEntryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessageAuditEntry")
        self._properties: typing.Set[str] = set([  "id",  "messageId",  "action",  "actorId",  "actorName",  "details",  "createdAt",  ])
        self._props = ScheduledMessageAuditEntryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessageAuditEntryProperties":
        return self._props


class ScheduledMessageAuditEntryViewer(ScheduledMessageAuditEntryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessageAuditEntryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def messageId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("messageId"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def actorId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actorId"))
    
    @property
    def actorName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actorName"))
    
    @property
    def details(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("details"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    


class ScheduledMessageEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessageEventPayload")
        self._properties: typing.Set[str] = set([  "messageId",  "clientId",  "clientName",  "channel",  "subject",  "scheduledFor",  "status",  "previousStatus",  ])
        self._props = ScheduledMessageEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessageEventPayloadProperties":
        return self._props


class ScheduledMessageEventPayloadViewer(ScheduledMessageEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessageEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def messageId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("messageId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def channel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("channel"))
    
    @property
    def subject(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subject"))
    
    @property
    def scheduledFor(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledFor"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def previousStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("previousStatus"))
    
    


class ScheduledMessageFilterAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessageFilter")
        self._properties: typing.Set[str] = set([  "status",  "channel",  "clientId",  "sessionId",  "fromDate",  "toDate",  ])
        self._props = ScheduledMessageFilterProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessageFilterProperties":
        return self._props


class ScheduledMessageFilterViewer(ScheduledMessageFilterAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessageFilterProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def channel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("channel"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def fromDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fromDate"))
    
    @property
    def toDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("toDate"))
    
    


class ScheduledMessageListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessageList")
        self._properties: typing.Set[str] = set([  "items",  "total",  "page",  "pageSize",  "hasNext",  ])
        self._props = ScheduledMessageListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessageListProperties":
        return self._props


class ScheduledMessageListViewer(ScheduledMessageListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessageListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def total(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def pageSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageSize"))
    
    @property
    def hasNext(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("hasNext"))
    
    


class ScheduledMessagePreferencesAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessagePreferences")
        self._properties: typing.Set[str] = set([  "preSendReviewEnabled",  "preSendReviewMinutes",  "autoCancelIfClientResponds",  "defaultChannel",  "createdAt",  "updatedAt",  ])
        self._props = ScheduledMessagePreferencesProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessagePreferencesProperties":
        return self._props


class ScheduledMessagePreferencesViewer(ScheduledMessagePreferencesAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessagePreferencesProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def preSendReviewEnabled(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preSendReviewEnabled"))
    
    @property
    def preSendReviewMinutes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preSendReviewMinutes"))
    
    @property
    def autoCancelIfClientResponds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("autoCancelIfClientResponds"))
    
    @property
    def defaultChannel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("defaultChannel"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    @property
    def updatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedAt"))
    
    


class ScrapedCoachProfileAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScrapedCoachProfile")
        self._properties: typing.Set[str] = set([  "source",  "sourceUrl",  "name",  "title",  "bio",  "certifications",  "specialties",  "yearsExperience",  "photoUrl",  "contactEmail",  "scrapedAt",  "confidence",  ])
        self._props = ScrapedCoachProfileProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScrapedCoachProfileProperties":
        return self._props


class ScrapedCoachProfileViewer(ScrapedCoachProfileAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScrapedCoachProfileProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    @property
    def sourceUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sourceUrl"))
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def bio(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("bio"))
    
    @property
    def certifications(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("certifications"))
    
    @property
    def specialties(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("specialties"))
    
    @property
    def yearsExperience(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("yearsExperience"))
    
    @property
    def photoUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("photoUrl"))
    
    @property
    def contactEmail(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contactEmail"))
    
    @property
    def scrapedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scrapedAt"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    


class SessionContextAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionContext")
        self._properties: typing.Set[str] = set([  "id",  "clientId",  "clientName",  "scheduledAt",  "status",  "t15Summary",  "notes",  "transcript",  "runningNotes",  ])
        self._props = SessionContextProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionContextProperties":
        return self._props


class SessionContextViewer(SessionContextAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionContextProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def scheduledAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledAt"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def t15Summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("t15Summary"))
    
    @property
    def notes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notes"))
    
    @property
    def transcript(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transcript"))
    
    @property
    def runningNotes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("runningNotes"))
    
    


class SessionEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionEventPayload")
        self._properties: typing.Set[str] = set([  "sessionId",  "clientId",  "clientName",  "status",  "scheduledAt",  ])
        self._props = SessionEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionEventPayloadProperties":
        return self._props


class SessionEventPayloadViewer(SessionEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def scheduledAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledAt"))
    
    


class SessionNoteSectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNoteSection")
        self._properties: typing.Set[str] = set([  "id",  "summary",  "keyPoints",  "expanded",  ])
        self._props = SessionNoteSectionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNoteSectionProperties":
        return self._props


class SessionNoteSectionViewer(SessionNoteSectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNoteSectionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def keyPoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("keyPoints"))
    
    @property
    def expanded(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("expanded"))
    
    


class SessionNotesAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotes")
        self._properties: typing.Set[str] = set([  "sessionId",  "recap",  "observations",  "inquiries",  "invitations",  "resources",  "next",  "voiceConfidence",  "generatedAt",  "lastEditedAt",  "status",  ])
        self._props = SessionNotesProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesProperties":
        return self._props


class SessionNotesViewer(SessionNotesAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def recap(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recap"))
    
    @property
    def observations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("observations"))
    
    @property
    def inquiries(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("inquiries"))
    
    @property
    def invitations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("invitations"))
    
    @property
    def resources(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("resources"))
    
    @property
    def next(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("next"))
    
    @property
    def voiceConfidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceConfidence"))
    
    @property
    def generatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generatedAt"))
    
    @property
    def lastEditedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastEditedAt"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    


class SessionNotesEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesEventPayload")
        self._properties: typing.Set[str] = set([  "notesId",  "sessionId",  "clientId",  "clientName",  "sessionDate",  "action",  "status",  "previousStatus",  "sectionsCompleted",  "totalSections",  ])
        self._props = SessionNotesEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesEventPayloadProperties":
        return self._props


class SessionNotesEventPayloadViewer(SessionNotesEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def notesId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notesId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def previousStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("previousStatus"))
    
    @property
    def sectionsCompleted(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sectionsCompleted"))
    
    @property
    def totalSections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSections"))
    
    


class SessionNotesFilterAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesFilter")
        self._properties: typing.Set[str] = set([  "clientId",  "status",  "fromDate",  "toDate",  "searchQuery",  ])
        self._props = SessionNotesFilterProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesFilterProperties":
        return self._props


class SessionNotesFilterViewer(SessionNotesFilterAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesFilterProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def fromDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fromDate"))
    
    @property
    def toDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("toDate"))
    
    @property
    def searchQuery(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("searchQuery"))
    
    


class SessionNotesListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesList")
        self._properties: typing.Set[str] = set([  "items",  "total",  "page",  "pageSize",  ])
        self._props = SessionNotesListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesListProperties":
        return self._props


class SessionNotesListViewer(SessionNotesListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def total(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def pageSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageSize"))
    
    


class SessionNotesResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesResponse")
        self._properties: typing.Set[str] = set([  "success",  "notes",  "error",  "warnings",  "generationTimeMs",  ])
        self._props = SessionNotesResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesResponseProperties":
        return self._props


class SessionNotesResponseViewer(SessionNotesResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def notes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notes"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    @property
    def warnings(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("warnings"))
    
    @property
    def generationTimeMs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generationTimeMs"))
    
    


class SessionNotesSummaryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesSummary")
        self._properties: typing.Set[str] = set([  "id",  "sessionId",  "clientId",  "clientName",  "sessionDate",  "status",  "summary",  "generatedAt",  ])
        self._props = SessionNotesSummaryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesSummaryProperties":
        return self._props


class SessionNotesSummaryViewer(SessionNotesSummaryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesSummaryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def generatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generatedAt"))
    
    


class SessionPrepStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionPrepStatus")
        self._properties: typing.Set[str] = set([  "sessionId",  "clientId",  "clientName",  "sessionDateTime",  "sessionTitle",  "prepStatus",  "timeUntilSession",  "needsAttention",  "clientAvatarUrl",  "meetLink",  ])
        self._props = SessionPrepStatusProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionPrepStatusProperties":
        return self._props


class SessionPrepStatusViewer(SessionPrepStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionPrepStatusProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionDateTime(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDateTime"))
    
    @property
    def sessionTitle(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionTitle"))
    
    @property
    def prepStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("prepStatus"))
    
    @property
    def timeUntilSession(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeUntilSession"))
    
    @property
    def needsAttention(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("needsAttention"))
    
    @property
    def clientAvatarUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientAvatarUrl"))
    
    @property
    def meetLink(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("meetLink"))
    
    


class StateHistoryEntryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StateHistoryEntry")
        self._properties: typing.Set[str] = set([  "id",  "userId",  "page",  "clientId",  "sessionId",  "source",  "createdAt",  ])
        self._props = StateHistoryEntryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StateHistoryEntryProperties":
        return self._props


class StateHistoryEntryViewer(StateHistoryEntryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StateHistoryEntryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def userId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("userId"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    


class StateHistoryQueryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StateHistoryQuery")
        self._properties: typing.Set[str] = set([  "userId",  "fromDate",  "toDate",  "limit",  ])
        self._props = StateHistoryQueryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StateHistoryQueryProperties":
        return self._props


class StateHistoryQueryViewer(StateHistoryQueryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StateHistoryQueryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def userId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("userId"))
    
    @property
    def fromDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fromDate"))
    
    @property
    def toDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("toDate"))
    
    @property
    def limit(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("limit"))
    
    


class StateUpdateRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StateUpdateRequest")
        self._properties: typing.Set[str] = set([  "page",  "clientId",  "sessionId",  "availableActions",  "navigationOptions",  "source",  ])
        self._props = StateUpdateRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StateUpdateRequestProperties":
        return self._props


class StateUpdateRequestViewer(StateUpdateRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StateUpdateRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def availableActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("availableActions"))
    
    @property
    def navigationOptions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("navigationOptions"))
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    


class StateUpdateResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StateUpdateResponse")
        self._properties: typing.Set[str] = set([  "success",  "stateId",  ])
        self._props = StateUpdateResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StateUpdateResponseProperties":
        return self._props


class StateUpdateResponseViewer(StateUpdateResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StateUpdateResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def stateId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("stateId"))
    
    


class StyleAnalysisAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StyleAnalysis")
        self._properties: typing.Set[str] = set([  "toneProfile",  "sentencePatterns",  "transitionPhrases",  "emotionalRegister",  "rhetoricalPatterns",  "confidence",  "sampleCount",  "lastUpdated",  ])
        self._props = StyleAnalysisProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StyleAnalysisProperties":
        return self._props


class StyleAnalysisViewer(StyleAnalysisAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StyleAnalysisProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def toneProfile(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("toneProfile"))
    
    @property
    def sentencePatterns(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sentencePatterns"))
    
    @property
    def transitionPhrases(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transitionPhrases"))
    
    @property
    def emotionalRegister(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("emotionalRegister"))
    
    @property
    def rhetoricalPatterns(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("rhetoricalPatterns"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    @property
    def sampleCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sampleCount"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class StyleAnalysisRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StyleAnalysisRequest")
        self._properties: typing.Set[str] = set([  "coachId",  "correctionPairs",  "existingProfile",  "includeInsights",  ])
        self._props = StyleAnalysisRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StyleAnalysisRequestProperties":
        return self._props


class StyleAnalysisRequestViewer(StyleAnalysisRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StyleAnalysisRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def correctionPairs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("correctionPairs"))
    
    @property
    def existingProfile(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("existingProfile"))
    
    @property
    def includeInsights(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("includeInsights"))
    
    


class StyleAnalysisResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StyleAnalysisResponse")
        self._properties: typing.Set[str] = set([  "styleProfile",  "insights",  "voiceMatchConfidence",  "improvementSuggestions",  ])
        self._props = StyleAnalysisResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StyleAnalysisResponseProperties":
        return self._props


class StyleAnalysisResponseViewer(StyleAnalysisResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StyleAnalysisResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def styleProfile(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("styleProfile"))
    
    @property
    def insights(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("insights"))
    
    @property
    def voiceMatchConfidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceMatchConfidence"))
    
    @property
    def improvementSuggestions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("improvementSuggestions"))
    
    


class StyleDashboardDataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StyleDashboardData")
        self._properties: typing.Set[str] = set([  "profile",  "trendData",  "topInsights",  "recentCorrections",  "improvementAreas",  ])
        self._props = StyleDashboardDataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StyleDashboardDataProperties":
        return self._props


class StyleDashboardDataViewer(StyleDashboardDataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StyleDashboardDataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def profile(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("profile"))
    
    @property
    def trendData(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("trendData"))
    
    @property
    def topInsights(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("topInsights"))
    
    @property
    def recentCorrections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recentCorrections"))
    
    @property
    def improvementAreas(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("improvementAreas"))
    
    


class StyleInsightAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StyleInsight")
        self._properties: typing.Set[str] = set([  "category",  "insight",  "evidence",  "confidence",  ])
        self._props = StyleInsightProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StyleInsightProperties":
        return self._props


class StyleInsightViewer(StyleInsightAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StyleInsightProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def category(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("category"))
    
    @property
    def insight(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("insight"))
    
    @property
    def evidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("evidence"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    


class StyleTrendPointAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StyleTrendPoint")
        self._properties: typing.Set[str] = set([  "date",  "voiceConfidence",  "correctionsCount",  "avgMatchScore",  ])
        self._props = StyleTrendPointProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StyleTrendPointProperties":
        return self._props


class StyleTrendPointViewer(StyleTrendPointAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StyleTrendPointProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def date(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("date"))
    
    @property
    def voiceConfidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceConfidence"))
    
    @property
    def correctionsCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("correctionsCount"))
    
    @property
    def avgMatchScore(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("avgMatchScore"))
    
    


class StyleTuningAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StyleTuning")
        self._properties: typing.Set[str] = set([  "toneAdjustments",  "addPhrases",  "removePhrases",  "notes",  ])
        self._props = StyleTuningProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StyleTuningProperties":
        return self._props


class StyleTuningViewer(StyleTuningAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StyleTuningProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def toneAdjustments(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("toneAdjustments"))
    
    @property
    def addPhrases(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("addPhrases"))
    
    @property
    def removePhrases(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("removePhrases"))
    
    @property
    def notes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notes"))
    
    


class SuggestedActionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SuggestedAction")
        self._properties: typing.Set[str] = set([  "tool",  "label",  "description",  "parameters",  "requiresConfirmation",  ])
        self._props = SuggestedActionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SuggestedActionProperties":
        return self._props


class SuggestedActionViewer(SuggestedActionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SuggestedActionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def label(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("label"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def requiresConfirmation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requiresConfirmation"))
    
    


class SuggestedOpenerAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SuggestedOpener")
        self._properties: typing.Set[str] = set([  "question",  "rationale",  "category",  ])
        self._props = SuggestedOpenerProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SuggestedOpenerProperties":
        return self._props


class SuggestedOpenerViewer(SuggestedOpenerAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SuggestedOpenerProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def question(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("question"))
    
    @property
    def rationale(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("rationale"))
    
    @property
    def category(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("category"))
    
    


class T15PrepEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("T15PrepEventPayload")
        self._properties: typing.Set[str] = set([  "prepId",  "sessionId",  "clientId",  "clientName",  "scheduledAt",  "action",  "sectionsCompleted",  "totalSections",  "overallReadiness",  ])
        self._props = T15PrepEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "T15PrepEventPayloadProperties":
        return self._props


class T15PrepEventPayloadViewer(T15PrepEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class T15PrepEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def prepId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("prepId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def scheduledAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledAt"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def sectionsCompleted(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sectionsCompleted"))
    
    @property
    def totalSections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSections"))
    
    @property
    def overallReadiness(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overallReadiness"))
    
    


class TonePreferenceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TonePreference")
        self._properties: typing.Set[str] = set([  "tone",  "weight",  ])
        self._props = TonePreferenceProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TonePreferenceProperties":
        return self._props


class TonePreferenceViewer(TonePreferenceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TonePreferenceProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def tone(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tone"))
    
    @property
    def weight(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("weight"))
    
    


class ToneVectorAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ToneVector")
        self._properties: typing.Set[str] = set([  "warmth",  "formality",  "directness",  "empathy",  "energy",  ])
        self._props = ToneVectorProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ToneVectorProperties":
        return self._props


class ToneVectorViewer(ToneVectorAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ToneVectorProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def warmth(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("warmth"))
    
    @property
    def formality(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("formality"))
    
    @property
    def directness(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("directness"))
    
    @property
    def empathy(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("empathy"))
    
    @property
    def energy(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("energy"))
    
    


class ToolDefinitionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ToolDefinition")
        self._properties: typing.Set[str] = set([  "name",  "description",  "parameters",  "requiresConfirmation",  "outputType",  ])
        self._props = ToolDefinitionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ToolDefinitionProperties":
        return self._props


class ToolDefinitionViewer(ToolDefinitionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ToolDefinitionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def requiresConfirmation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requiresConfirmation"))
    
    @property
    def outputType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("outputType"))
    
    


class ToolParameterAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ToolParameter")
        self._properties: typing.Set[str] = set([  "name",  "type",  "description",  "required",  "default",  ])
        self._props = ToolParameterProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ToolParameterProperties":
        return self._props


class ToolParameterViewer(ToolParameterAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ToolParameterProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("required"))
    
    @property
    def default(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("default"))
    
    


class TransparentMessageAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TransparentMessage")
        self._properties: typing.Set[str] = set([  "content",  "indicator",  "coachName",  "approvedAt",  ])
        self._props = TransparentMessageProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TransparentMessageProperties":
        return self._props


class TransparentMessageViewer(TransparentMessageAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TransparentMessageProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def indicator(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("indicator"))
    
    @property
    def coachName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachName"))
    
    @property
    def approvedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("approvedAt"))
    
    


class UpdateClientProfileRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdateClientProfileRequest")
        self._properties: typing.Set[str] = set([  "name",  "email",  "phone",  "company",  "title",  "bio",  "values",  "vision",  "overarchingGoals",  ])
        self._props = UpdateClientProfileRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdateClientProfileRequestProperties":
        return self._props


class UpdateClientProfileRequestViewer(UpdateClientProfileRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UpdateClientProfileRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def email(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("email"))
    
    @property
    def phone(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phone"))
    
    @property
    def company(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("company"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def bio(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("bio"))
    
    @property
    def values(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("values"))
    
    @property
    def vision(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vision"))
    
    @property
    def overarchingGoals(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overarchingGoals"))
    
    


class UpdateClientProfileResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdateClientProfileResponse")
        self._properties: typing.Set[str] = set([  "success",  "profile",  "error",  ])
        self._props = UpdateClientProfileResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdateClientProfileResponseProperties":
        return self._props


class UpdateClientProfileResponseViewer(UpdateClientProfileResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UpdateClientProfileResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def profile(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("profile"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class UpdateGoalRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdateGoalRequest")
        self._properties: typing.Set[str] = set([  "title",  "description",  "category",  "status",  "progress",  "targetDate",  ])
        self._props = UpdateGoalRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdateGoalRequestProperties":
        return self._props


class UpdateGoalRequestViewer(UpdateGoalRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UpdateGoalRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def category(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("category"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def progress(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("progress"))
    
    @property
    def targetDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("targetDate"))
    
    


class UpdatePreferencesRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdatePreferencesRequest")
        self._properties: typing.Set[str] = set([  "preSendReviewEnabled",  "preSendReviewMinutes",  "autoCancelIfClientResponds",  "defaultChannel",  ])
        self._props = UpdatePreferencesRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdatePreferencesRequestProperties":
        return self._props


class UpdatePreferencesRequestViewer(UpdatePreferencesRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UpdatePreferencesRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def preSendReviewEnabled(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preSendReviewEnabled"))
    
    @property
    def preSendReviewMinutes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preSendReviewMinutes"))
    
    @property
    def autoCancelIfClientResponds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("autoCancelIfClientResponds"))
    
    @property
    def defaultChannel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("defaultChannel"))
    
    


class UpdatePrepNotesRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdatePrepNotesRequest")
        self._properties: typing.Set[str] = set([  "privateCoachNotes",  ])
        self._props = UpdatePrepNotesRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdatePrepNotesRequestProperties":
        return self._props


class UpdatePrepNotesRequestViewer(UpdatePrepNotesRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UpdatePrepNotesRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def privateCoachNotes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("privateCoachNotes"))
    
    


class UpdateResourceRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdateResourceRequest")
        self._properties: typing.Set[str] = set([  "title",  "description",  "tags",  "externalUrl",  ])
        self._props = UpdateResourceRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdateResourceRequestProperties":
        return self._props


class UpdateResourceRequestViewer(UpdateResourceRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UpdateResourceRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def tags(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tags"))
    
    @property
    def externalUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("externalUrl"))
    
    


class UpdateScheduledMessageRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdateScheduledMessageRequest")
        self._properties: typing.Set[str] = set([  "subject",  "body",  "scheduledFor",  "channel",  ])
        self._props = UpdateScheduledMessageRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdateScheduledMessageRequestProperties":
        return self._props


class UpdateScheduledMessageRequestViewer(UpdateScheduledMessageRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UpdateScheduledMessageRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def subject(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subject"))
    
    @property
    def body(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("body"))
    
    @property
    def scheduledFor(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledFor"))
    
    @property
    def channel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("channel"))
    
    


class UpdateSectionRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdateSectionRequest")
        self._properties: typing.Set[str] = set([  "sectionId",  "summary",  "keyPoints",  ])
        self._props = UpdateSectionRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdateSectionRequestProperties":
        return self._props


class UpdateSectionRequestViewer(UpdateSectionRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UpdateSectionRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sectionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sectionId"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def keyPoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("keyPoints"))
    
    


class UserActiveStateAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UserActiveState")
        self._properties: typing.Set[str] = set([  "page",  "clientId",  "clientName",  "sessionId",  "sessionDate",  "availableActions",  "navigationOptions",  "source",  "lastUpdated",  ])
        self._props = UserActiveStateProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UserActiveStateProperties":
        return self._props


class UserActiveStateViewer(UserActiveStateAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UserActiveStateProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def availableActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("availableActions"))
    
    @property
    def navigationOptions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("navigationOptions"))
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class VoiceCorrectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceCorrection")
        self._properties: typing.Set[str] = set([  "id",  "originalContent",  "editedContent",  "editType",  "coachFeedback",  "contentType",  "sessionId",  "timestamp",  ])
        self._props = VoiceCorrectionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceCorrectionProperties":
        return self._props


class VoiceCorrectionViewer(VoiceCorrectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceCorrectionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def originalContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("originalContent"))
    
    @property
    def editedContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editedContent"))
    
    @property
    def editType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editType"))
    
    @property
    def coachFeedback(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachFeedback"))
    
    @property
    def contentType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contentType"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    


class VoiceCorrectionRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceCorrectionRequest")
        self._properties: typing.Set[str] = set([  "sessionId",  "originalContent",  "editedContent",  "editType",  "coachFeedback",  "contentType",  ])
        self._props = VoiceCorrectionRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceCorrectionRequestProperties":
        return self._props


class VoiceCorrectionRequestViewer(VoiceCorrectionRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceCorrectionRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def originalContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("originalContent"))
    
    @property
    def editedContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editedContent"))
    
    @property
    def editType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editType"))
    
    @property
    def coachFeedback(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachFeedback"))
    
    @property
    def contentType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contentType"))
    
    


class VoiceCorrectionResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceCorrectionResponse")
        self._properties: typing.Set[str] = set([  "success",  "voiceConfidenceAfter",  "improvementNote",  "correctionId",  ])
        self._props = VoiceCorrectionResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceCorrectionResponseProperties":
        return self._props


class VoiceCorrectionResponseViewer(VoiceCorrectionResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceCorrectionResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def voiceConfidenceAfter(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceConfidenceAfter"))
    
    @property
    def improvementNote(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("improvementNote"))
    
    @property
    def correctionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("correctionId"))
    
    


class VoiceEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceEventPayload")
        self._properties: typing.Set[str] = set([  "correctionId",  "voiceConfidence",  "contentType",  ])
        self._props = VoiceEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceEventPayloadProperties":
        return self._props


class VoiceEventPayloadViewer(VoiceEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def correctionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("correctionId"))
    
    @property
    def voiceConfidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceConfidence"))
    
    @property
    def contentType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contentType"))
    
    


class VoiceMatchResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceMatchResult")
        self._properties: typing.Set[str] = set([  "overallScore",  "toneScore",  "structureScore",  "vocabularyScore",  "breakdown",  "suggestions",  ])
        self._props = VoiceMatchResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceMatchResultProperties":
        return self._props


class VoiceMatchResultViewer(VoiceMatchResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceMatchResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def overallScore(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overallScore"))
    
    @property
    def toneScore(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("toneScore"))
    
    @property
    def structureScore(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("structureScore"))
    
    @property
    def vocabularyScore(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vocabularyScore"))
    
    @property
    def breakdown(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("breakdown"))
    
    @property
    def suggestions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggestions"))
    
    


class VoiceProfileAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceProfile")
        self._properties: typing.Set[str] = set([  "coachId",  "voiceConfidence",  "totalCorrections",  "vocabularyPatterns",  "avoidPatterns",  "tonePreferences",  "recentEdits",  "lastTrainedAt",  ])
        self._props = VoiceProfileProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceProfileProperties":
        return self._props


class VoiceProfileViewer(VoiceProfileAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceProfileProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def voiceConfidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceConfidence"))
    
    @property
    def totalCorrections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalCorrections"))
    
    @property
    def vocabularyPatterns(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vocabularyPatterns"))
    
    @property
    def avoidPatterns(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("avoidPatterns"))
    
    @property
    def tonePreferences(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tonePreferences"))
    
    @property
    def recentEdits(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recentEdits"))
    
    @property
    def lastTrainedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastTrainedAt"))
    
    


class VoiceProfileConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceProfileConfig")
        self._properties: typing.Set[str] = set([  "coachId",  "minSamplesRequired",  "currentSampleCount",  "sampleTypes",  "trainingStatus",  "estimatedConfidence",  "canStartTraining",  "lastUpdated",  ])
        self._props = VoiceProfileConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceProfileConfigProperties":
        return self._props


class VoiceProfileConfigViewer(VoiceProfileConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceProfileConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def minSamplesRequired(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("minSamplesRequired"))
    
    @property
    def currentSampleCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("currentSampleCount"))
    
    @property
    def sampleTypes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sampleTypes"))
    
    @property
    def trainingStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("trainingStatus"))
    
    @property
    def estimatedConfidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimatedConfidence"))
    
    @property
    def canStartTraining(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("canStartTraining"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class VoiceProfileV1Ast:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceProfileV1")
        self._properties: typing.Set[str] = set([  "coachId",  "voiceConfidence",  "totalCorrections",  "vocabularyPatterns",  "avoidPatterns",  "tonePreferences",  "recentEdits",  "lastTrainedAt",  "styleAnalysis",  "styleInsights",  "analysisVersion",  "lastAnalyzedAt",  ])
        self._props = VoiceProfileV1Properties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceProfileV1Properties":
        return self._props


class VoiceProfileV1Viewer(VoiceProfileV1Ast):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceProfileV1Properties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def voiceConfidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceConfidence"))
    
    @property
    def totalCorrections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalCorrections"))
    
    @property
    def vocabularyPatterns(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vocabularyPatterns"))
    
    @property
    def avoidPatterns(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("avoidPatterns"))
    
    @property
    def tonePreferences(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tonePreferences"))
    
    @property
    def recentEdits(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recentEdits"))
    
    @property
    def lastTrainedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastTrainedAt"))
    
    @property
    def styleAnalysis(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("styleAnalysis"))
    
    @property
    def styleInsights(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("styleInsights"))
    
    @property
    def analysisVersion(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("analysisVersion"))
    
    @property
    def lastAnalyzedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastAnalyzedAt"))
    
    


class VoiceSampleAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceSample")
        self._properties: typing.Set[str] = set([  "id",  "coachId",  "type",  "content",  "context",  "isPreferred",  "submittedAt",  "processedAt",  "processingStatus",  ])
        self._props = VoiceSampleProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceSampleProperties":
        return self._props


class VoiceSampleViewer(VoiceSampleAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceSampleProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def isPreferred(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("isPreferred"))
    
    @property
    def submittedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("submittedAt"))
    
    @property
    def processedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("processedAt"))
    
    @property
    def processingStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("processingStatus"))
    
    


class VoiceSampleInputAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceSampleInput")
        self._properties: typing.Set[str] = set([  "type",  "content",  "context",  "isPreferred",  ])
        self._props = VoiceSampleInputProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceSampleInputProperties":
        return self._props


class VoiceSampleInputViewer(VoiceSampleInputAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceSampleInputProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def isPreferred(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("isPreferred"))
    
    


class VoiceSampleSubmitRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceSampleSubmitRequest")
        self._properties: typing.Set[str] = set([  "samples",  ])
        self._props = VoiceSampleSubmitRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceSampleSubmitRequestProperties":
        return self._props


class VoiceSampleSubmitRequestViewer(VoiceSampleSubmitRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceSampleSubmitRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def samples(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("samples"))
    
    


class VoiceSampleSubmitResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceSampleSubmitResponse")
        self._properties: typing.Set[str] = set([  "success",  "submittedCount",  "sampleIds",  "voiceProfileStatus",  "minimumSamplesRequired",  "currentSampleCount",  "error",  ])
        self._props = VoiceSampleSubmitResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceSampleSubmitResponseProperties":
        return self._props


class VoiceSampleSubmitResponseViewer(VoiceSampleSubmitResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceSampleSubmitResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def submittedCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("submittedCount"))
    
    @property
    def sampleIds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sampleIds"))
    
    @property
    def voiceProfileStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceProfileStatus"))
    
    @property
    def minimumSamplesRequired(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("minimumSamplesRequired"))
    
    @property
    def currentSampleCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("currentSampleCount"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class VoiceSamplesPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceSamplesPayload")
        self._properties: typing.Set[str] = set([  "coachId",  "sampleCount",  "totalSamples",  "sampleTypes",  "voiceProfileStatus",  ])
        self._props = VoiceSamplesPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceSamplesPayloadProperties":
        return self._props


class VoiceSamplesPayloadViewer(VoiceSamplesPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceSamplesPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def sampleCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sampleCount"))
    
    @property
    def totalSamples(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSamples"))
    
    @property
    def sampleTypes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sampleTypes"))
    
    @property
    def voiceProfileStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceProfileStatus"))
    
    

