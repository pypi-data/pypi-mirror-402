# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
from baml_py import type_builder
from baml_py import baml_py
# These are exports, not used here, hence the linter is disabled
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder # noqa: F401 # pylint: disable=unused-import
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME

class TypeBuilder(type_builder.TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["AICommandHistoryItem","AICommandRequest","AICommandResult","ActionError","ActionEventPayload","ActionOutput","ActionRequest","ActionResponse","AiTimingSuggestion","AiTimingSuggestionRequest","AuthVerifyResponse","ChatMessage","ChatRequest","ChatResponse","ClientContext","CommandCenterData","CommandCenterEventPayload","CommandCenterItem","ConnectionPayload","ContextChangedPayload","CreateResourceRequest","CreateScheduledMessageRequest","CurrentRead","ErrorPayload","EventEnvelope","EventMeta","FrontendActionResult","FrontendCommand","FrontendCommandPayload","FrontendToolConfig","HeartbeatPayload","IntegrationConfig","IntegrationConnectRequest","IntegrationConnectResponse","IntegrationDisconnectRequest","IntegrationList","MessagePayload","NavigationOption","ObservationEntry","ObservationPayload","OnboardingEventPayload","OnboardingPhaseProgress","OnboardingProgress","OnboardingUpdateRequest","OnboardingUpdateResponse","PageContext","PriorityItemPayload","PrivateIntelligence","ProfileScrapeRequest","ProfileScrapeResponse","ResolvedContext","ResourceEventPayload","ResourceItem","ResourceListData","ResourceMetadata","ScheduledMessage","ScheduledMessageAuditEntry","ScheduledMessageEventPayload","ScheduledMessageFilter","ScheduledMessageList","ScheduledMessagePreferences","ScrapedCoachProfile","SessionContext","SessionEventPayload","SessionNotesDocument","SessionNotesEventPayload","SessionNotesFilter","SessionNotesFinalizeRequest","SessionNotesFinalizeResponse","SessionNotesList","SessionNotesRequest","SessionNotesResponse","SessionNotesSummary","SessionSectionContent","SessionSectionUpdateRequest","SessionSectionUpdateResponse","StateHistoryEntry","StateHistoryQuery","StateUpdateRequest","StateUpdateResponse","SuggestedAction","T15PrepDocument","T15PrepEventPayload","T15PrepList","T15PrepRequest","T15PrepResponse","T15PrepSummary","T15SectionContent","T15SectionUpdateRequest","T15SectionUpdateResponse","TonePreference","ToolDefinition","ToolParameter","TransparentMessage","UpdatePreferencesRequest","UpdateResourceRequest","UpdateScheduledMessageRequest","UserActiveState","VoiceCorrection","VoiceCorrectionRequest","VoiceCorrectionResponse","VoiceEventPayload","VoiceProfile","VoiceProfileConfig","VoiceSample","VoiceSampleInput","VoiceSampleSubmitRequest","VoiceSampleSubmitResponse","VoiceSamplesPayload",]
        ), enums=set(
          ["AICommandType","CoachFeedback","CommandItemType","EditType","EventType","FrontendActionStatus","FrontendToolName","IntegrationStatus","IntegrationType","MessageChannel","MessageRole","MessageStatus","ObservationType","OnboardingAction","OnboardingPhase","PhaseStatus","Priority","ResourceType","SessionNoteSection","SessionNotesStatus","StateSource","T15PrepSection","ToolName","TransparencyIndicator","VoiceContentType","VoiceSampleStatus","VoiceSampleType","VoiceTrainingStatus",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)

    # #########################################################################
    # Generated enums 28
    # #########################################################################

    @property
    def AICommandType(self) -> "AICommandTypeViewer":
        return AICommandTypeViewer(self)

    @property
    def CoachFeedback(self) -> "CoachFeedbackViewer":
        return CoachFeedbackViewer(self)

    @property
    def CommandItemType(self) -> "CommandItemTypeViewer":
        return CommandItemTypeViewer(self)

    @property
    def EditType(self) -> "EditTypeViewer":
        return EditTypeViewer(self)

    @property
    def EventType(self) -> "EventTypeViewer":
        return EventTypeViewer(self)

    @property
    def FrontendActionStatus(self) -> "FrontendActionStatusViewer":
        return FrontendActionStatusViewer(self)

    @property
    def FrontendToolName(self) -> "FrontendToolNameViewer":
        return FrontendToolNameViewer(self)

    @property
    def IntegrationStatus(self) -> "IntegrationStatusViewer":
        return IntegrationStatusViewer(self)

    @property
    def IntegrationType(self) -> "IntegrationTypeViewer":
        return IntegrationTypeViewer(self)

    @property
    def MessageChannel(self) -> "MessageChannelViewer":
        return MessageChannelViewer(self)

    @property
    def MessageRole(self) -> "MessageRoleViewer":
        return MessageRoleViewer(self)

    @property
    def MessageStatus(self) -> "MessageStatusViewer":
        return MessageStatusViewer(self)

    @property
    def ObservationType(self) -> "ObservationTypeViewer":
        return ObservationTypeViewer(self)

    @property
    def OnboardingAction(self) -> "OnboardingActionViewer":
        return OnboardingActionViewer(self)

    @property
    def OnboardingPhase(self) -> "OnboardingPhaseViewer":
        return OnboardingPhaseViewer(self)

    @property
    def PhaseStatus(self) -> "PhaseStatusViewer":
        return PhaseStatusViewer(self)

    @property
    def Priority(self) -> "PriorityViewer":
        return PriorityViewer(self)

    @property
    def ResourceType(self) -> "ResourceTypeViewer":
        return ResourceTypeViewer(self)

    @property
    def SessionNoteSection(self) -> "SessionNoteSectionViewer":
        return SessionNoteSectionViewer(self)

    @property
    def SessionNotesStatus(self) -> "SessionNotesStatusViewer":
        return SessionNotesStatusViewer(self)

    @property
    def StateSource(self) -> "StateSourceViewer":
        return StateSourceViewer(self)

    @property
    def T15PrepSection(self) -> "T15PrepSectionViewer":
        return T15PrepSectionViewer(self)

    @property
    def ToolName(self) -> "ToolNameViewer":
        return ToolNameViewer(self)

    @property
    def TransparencyIndicator(self) -> "TransparencyIndicatorViewer":
        return TransparencyIndicatorViewer(self)

    @property
    def VoiceContentType(self) -> "VoiceContentTypeViewer":
        return VoiceContentTypeViewer(self)

    @property
    def VoiceSampleStatus(self) -> "VoiceSampleStatusViewer":
        return VoiceSampleStatusViewer(self)

    @property
    def VoiceSampleType(self) -> "VoiceSampleTypeViewer":
        return VoiceSampleTypeViewer(self)

    @property
    def VoiceTrainingStatus(self) -> "VoiceTrainingStatusViewer":
        return VoiceTrainingStatusViewer(self)


    # #########################################################################
    # Generated classes 109
    # #########################################################################

    @property
    def AICommandHistoryItem(self) -> "AICommandHistoryItemViewer":
        return AICommandHistoryItemViewer(self)

    @property
    def AICommandRequest(self) -> "AICommandRequestViewer":
        return AICommandRequestViewer(self)

    @property
    def AICommandResult(self) -> "AICommandResultViewer":
        return AICommandResultViewer(self)

    @property
    def ActionError(self) -> "ActionErrorViewer":
        return ActionErrorViewer(self)

    @property
    def ActionEventPayload(self) -> "ActionEventPayloadViewer":
        return ActionEventPayloadViewer(self)

    @property
    def ActionOutput(self) -> "ActionOutputViewer":
        return ActionOutputViewer(self)

    @property
    def ActionRequest(self) -> "ActionRequestViewer":
        return ActionRequestViewer(self)

    @property
    def ActionResponse(self) -> "ActionResponseViewer":
        return ActionResponseViewer(self)

    @property
    def AiTimingSuggestion(self) -> "AiTimingSuggestionViewer":
        return AiTimingSuggestionViewer(self)

    @property
    def AiTimingSuggestionRequest(self) -> "AiTimingSuggestionRequestViewer":
        return AiTimingSuggestionRequestViewer(self)

    @property
    def AuthVerifyResponse(self) -> "AuthVerifyResponseViewer":
        return AuthVerifyResponseViewer(self)

    @property
    def ChatMessage(self) -> "ChatMessageViewer":
        return ChatMessageViewer(self)

    @property
    def ChatRequest(self) -> "ChatRequestViewer":
        return ChatRequestViewer(self)

    @property
    def ChatResponse(self) -> "ChatResponseViewer":
        return ChatResponseViewer(self)

    @property
    def ClientContext(self) -> "ClientContextViewer":
        return ClientContextViewer(self)

    @property
    def CommandCenterData(self) -> "CommandCenterDataViewer":
        return CommandCenterDataViewer(self)

    @property
    def CommandCenterEventPayload(self) -> "CommandCenterEventPayloadViewer":
        return CommandCenterEventPayloadViewer(self)

    @property
    def CommandCenterItem(self) -> "CommandCenterItemViewer":
        return CommandCenterItemViewer(self)

    @property
    def ConnectionPayload(self) -> "ConnectionPayloadViewer":
        return ConnectionPayloadViewer(self)

    @property
    def ContextChangedPayload(self) -> "ContextChangedPayloadViewer":
        return ContextChangedPayloadViewer(self)

    @property
    def CreateResourceRequest(self) -> "CreateResourceRequestViewer":
        return CreateResourceRequestViewer(self)

    @property
    def CreateScheduledMessageRequest(self) -> "CreateScheduledMessageRequestViewer":
        return CreateScheduledMessageRequestViewer(self)

    @property
    def CurrentRead(self) -> "CurrentReadViewer":
        return CurrentReadViewer(self)

    @property
    def ErrorPayload(self) -> "ErrorPayloadViewer":
        return ErrorPayloadViewer(self)

    @property
    def EventEnvelope(self) -> "EventEnvelopeViewer":
        return EventEnvelopeViewer(self)

    @property
    def EventMeta(self) -> "EventMetaViewer":
        return EventMetaViewer(self)

    @property
    def FrontendActionResult(self) -> "FrontendActionResultViewer":
        return FrontendActionResultViewer(self)

    @property
    def FrontendCommand(self) -> "FrontendCommandViewer":
        return FrontendCommandViewer(self)

    @property
    def FrontendCommandPayload(self) -> "FrontendCommandPayloadViewer":
        return FrontendCommandPayloadViewer(self)

    @property
    def FrontendToolConfig(self) -> "FrontendToolConfigViewer":
        return FrontendToolConfigViewer(self)

    @property
    def HeartbeatPayload(self) -> "HeartbeatPayloadViewer":
        return HeartbeatPayloadViewer(self)

    @property
    def IntegrationConfig(self) -> "IntegrationConfigViewer":
        return IntegrationConfigViewer(self)

    @property
    def IntegrationConnectRequest(self) -> "IntegrationConnectRequestViewer":
        return IntegrationConnectRequestViewer(self)

    @property
    def IntegrationConnectResponse(self) -> "IntegrationConnectResponseViewer":
        return IntegrationConnectResponseViewer(self)

    @property
    def IntegrationDisconnectRequest(self) -> "IntegrationDisconnectRequestViewer":
        return IntegrationDisconnectRequestViewer(self)

    @property
    def IntegrationList(self) -> "IntegrationListViewer":
        return IntegrationListViewer(self)

    @property
    def MessagePayload(self) -> "MessagePayloadViewer":
        return MessagePayloadViewer(self)

    @property
    def NavigationOption(self) -> "NavigationOptionViewer":
        return NavigationOptionViewer(self)

    @property
    def ObservationEntry(self) -> "ObservationEntryViewer":
        return ObservationEntryViewer(self)

    @property
    def ObservationPayload(self) -> "ObservationPayloadViewer":
        return ObservationPayloadViewer(self)

    @property
    def OnboardingEventPayload(self) -> "OnboardingEventPayloadViewer":
        return OnboardingEventPayloadViewer(self)

    @property
    def OnboardingPhaseProgress(self) -> "OnboardingPhaseProgressViewer":
        return OnboardingPhaseProgressViewer(self)

    @property
    def OnboardingProgress(self) -> "OnboardingProgressViewer":
        return OnboardingProgressViewer(self)

    @property
    def OnboardingUpdateRequest(self) -> "OnboardingUpdateRequestViewer":
        return OnboardingUpdateRequestViewer(self)

    @property
    def OnboardingUpdateResponse(self) -> "OnboardingUpdateResponseViewer":
        return OnboardingUpdateResponseViewer(self)

    @property
    def PageContext(self) -> "PageContextViewer":
        return PageContextViewer(self)

    @property
    def PriorityItemPayload(self) -> "PriorityItemPayloadViewer":
        return PriorityItemPayloadViewer(self)

    @property
    def PrivateIntelligence(self) -> "PrivateIntelligenceViewer":
        return PrivateIntelligenceViewer(self)

    @property
    def ProfileScrapeRequest(self) -> "ProfileScrapeRequestViewer":
        return ProfileScrapeRequestViewer(self)

    @property
    def ProfileScrapeResponse(self) -> "ProfileScrapeResponseViewer":
        return ProfileScrapeResponseViewer(self)

    @property
    def ResolvedContext(self) -> "ResolvedContextViewer":
        return ResolvedContextViewer(self)

    @property
    def ResourceEventPayload(self) -> "ResourceEventPayloadViewer":
        return ResourceEventPayloadViewer(self)

    @property
    def ResourceItem(self) -> "ResourceItemViewer":
        return ResourceItemViewer(self)

    @property
    def ResourceListData(self) -> "ResourceListDataViewer":
        return ResourceListDataViewer(self)

    @property
    def ResourceMetadata(self) -> "ResourceMetadataViewer":
        return ResourceMetadataViewer(self)

    @property
    def ScheduledMessage(self) -> "ScheduledMessageViewer":
        return ScheduledMessageViewer(self)

    @property
    def ScheduledMessageAuditEntry(self) -> "ScheduledMessageAuditEntryViewer":
        return ScheduledMessageAuditEntryViewer(self)

    @property
    def ScheduledMessageEventPayload(self) -> "ScheduledMessageEventPayloadViewer":
        return ScheduledMessageEventPayloadViewer(self)

    @property
    def ScheduledMessageFilter(self) -> "ScheduledMessageFilterViewer":
        return ScheduledMessageFilterViewer(self)

    @property
    def ScheduledMessageList(self) -> "ScheduledMessageListViewer":
        return ScheduledMessageListViewer(self)

    @property
    def ScheduledMessagePreferences(self) -> "ScheduledMessagePreferencesViewer":
        return ScheduledMessagePreferencesViewer(self)

    @property
    def ScrapedCoachProfile(self) -> "ScrapedCoachProfileViewer":
        return ScrapedCoachProfileViewer(self)

    @property
    def SessionContext(self) -> "SessionContextViewer":
        return SessionContextViewer(self)

    @property
    def SessionEventPayload(self) -> "SessionEventPayloadViewer":
        return SessionEventPayloadViewer(self)

    @property
    def SessionNotesDocument(self) -> "SessionNotesDocumentViewer":
        return SessionNotesDocumentViewer(self)

    @property
    def SessionNotesEventPayload(self) -> "SessionNotesEventPayloadViewer":
        return SessionNotesEventPayloadViewer(self)

    @property
    def SessionNotesFilter(self) -> "SessionNotesFilterViewer":
        return SessionNotesFilterViewer(self)

    @property
    def SessionNotesFinalizeRequest(self) -> "SessionNotesFinalizeRequestViewer":
        return SessionNotesFinalizeRequestViewer(self)

    @property
    def SessionNotesFinalizeResponse(self) -> "SessionNotesFinalizeResponseViewer":
        return SessionNotesFinalizeResponseViewer(self)

    @property
    def SessionNotesList(self) -> "SessionNotesListViewer":
        return SessionNotesListViewer(self)

    @property
    def SessionNotesRequest(self) -> "SessionNotesRequestViewer":
        return SessionNotesRequestViewer(self)

    @property
    def SessionNotesResponse(self) -> "SessionNotesResponseViewer":
        return SessionNotesResponseViewer(self)

    @property
    def SessionNotesSummary(self) -> "SessionNotesSummaryViewer":
        return SessionNotesSummaryViewer(self)

    @property
    def SessionSectionContent(self) -> "SessionSectionContentViewer":
        return SessionSectionContentViewer(self)

    @property
    def SessionSectionUpdateRequest(self) -> "SessionSectionUpdateRequestViewer":
        return SessionSectionUpdateRequestViewer(self)

    @property
    def SessionSectionUpdateResponse(self) -> "SessionSectionUpdateResponseViewer":
        return SessionSectionUpdateResponseViewer(self)

    @property
    def StateHistoryEntry(self) -> "StateHistoryEntryViewer":
        return StateHistoryEntryViewer(self)

    @property
    def StateHistoryQuery(self) -> "StateHistoryQueryViewer":
        return StateHistoryQueryViewer(self)

    @property
    def StateUpdateRequest(self) -> "StateUpdateRequestViewer":
        return StateUpdateRequestViewer(self)

    @property
    def StateUpdateResponse(self) -> "StateUpdateResponseViewer":
        return StateUpdateResponseViewer(self)

    @property
    def SuggestedAction(self) -> "SuggestedActionViewer":
        return SuggestedActionViewer(self)

    @property
    def T15PrepDocument(self) -> "T15PrepDocumentViewer":
        return T15PrepDocumentViewer(self)

    @property
    def T15PrepEventPayload(self) -> "T15PrepEventPayloadViewer":
        return T15PrepEventPayloadViewer(self)

    @property
    def T15PrepList(self) -> "T15PrepListViewer":
        return T15PrepListViewer(self)

    @property
    def T15PrepRequest(self) -> "T15PrepRequestViewer":
        return T15PrepRequestViewer(self)

    @property
    def T15PrepResponse(self) -> "T15PrepResponseViewer":
        return T15PrepResponseViewer(self)

    @property
    def T15PrepSummary(self) -> "T15PrepSummaryViewer":
        return T15PrepSummaryViewer(self)

    @property
    def T15SectionContent(self) -> "T15SectionContentViewer":
        return T15SectionContentViewer(self)

    @property
    def T15SectionUpdateRequest(self) -> "T15SectionUpdateRequestViewer":
        return T15SectionUpdateRequestViewer(self)

    @property
    def T15SectionUpdateResponse(self) -> "T15SectionUpdateResponseViewer":
        return T15SectionUpdateResponseViewer(self)

    @property
    def TonePreference(self) -> "TonePreferenceViewer":
        return TonePreferenceViewer(self)

    @property
    def ToolDefinition(self) -> "ToolDefinitionViewer":
        return ToolDefinitionViewer(self)

    @property
    def ToolParameter(self) -> "ToolParameterViewer":
        return ToolParameterViewer(self)

    @property
    def TransparentMessage(self) -> "TransparentMessageViewer":
        return TransparentMessageViewer(self)

    @property
    def UpdatePreferencesRequest(self) -> "UpdatePreferencesRequestViewer":
        return UpdatePreferencesRequestViewer(self)

    @property
    def UpdateResourceRequest(self) -> "UpdateResourceRequestViewer":
        return UpdateResourceRequestViewer(self)

    @property
    def UpdateScheduledMessageRequest(self) -> "UpdateScheduledMessageRequestViewer":
        return UpdateScheduledMessageRequestViewer(self)

    @property
    def UserActiveState(self) -> "UserActiveStateViewer":
        return UserActiveStateViewer(self)

    @property
    def VoiceCorrection(self) -> "VoiceCorrectionViewer":
        return VoiceCorrectionViewer(self)

    @property
    def VoiceCorrectionRequest(self) -> "VoiceCorrectionRequestViewer":
        return VoiceCorrectionRequestViewer(self)

    @property
    def VoiceCorrectionResponse(self) -> "VoiceCorrectionResponseViewer":
        return VoiceCorrectionResponseViewer(self)

    @property
    def VoiceEventPayload(self) -> "VoiceEventPayloadViewer":
        return VoiceEventPayloadViewer(self)

    @property
    def VoiceProfile(self) -> "VoiceProfileViewer":
        return VoiceProfileViewer(self)

    @property
    def VoiceProfileConfig(self) -> "VoiceProfileConfigViewer":
        return VoiceProfileConfigViewer(self)

    @property
    def VoiceSample(self) -> "VoiceSampleViewer":
        return VoiceSampleViewer(self)

    @property
    def VoiceSampleInput(self) -> "VoiceSampleInputViewer":
        return VoiceSampleInputViewer(self)

    @property
    def VoiceSampleSubmitRequest(self) -> "VoiceSampleSubmitRequestViewer":
        return VoiceSampleSubmitRequestViewer(self)

    @property
    def VoiceSampleSubmitResponse(self) -> "VoiceSampleSubmitResponseViewer":
        return VoiceSampleSubmitResponseViewer(self)

    @property
    def VoiceSamplesPayload(self) -> "VoiceSamplesPayloadViewer":
        return VoiceSamplesPayloadViewer(self)



# #########################################################################
# Generated enums 28
# #########################################################################

class AICommandTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("AICommandType")
        self._values: typing.Set[str] = set([  "TONE_ADJUSTMENT",  "CONTENT_ADDITION",  "CONTENT_REMOVAL",  "SECTION_MODIFICATION",  "VOICE_CORRECTION",  "SPECIFIC_EDIT",  ])
        self._vals = AICommandTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "AICommandTypeValues":
        return self._vals


class AICommandTypeViewer(AICommandTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class AICommandTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def TONE_ADJUSTMENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TONE_ADJUSTMENT"))
    
    @property
    def CONTENT_ADDITION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONTENT_ADDITION"))
    
    @property
    def CONTENT_REMOVAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONTENT_REMOVAL"))
    
    @property
    def SECTION_MODIFICATION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SECTION_MODIFICATION"))
    
    @property
    def VOICE_CORRECTION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VOICE_CORRECTION"))
    
    @property
    def SPECIFIC_EDIT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SPECIFIC_EDIT"))
    
    


class CoachFeedbackAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("CoachFeedback")
        self._values: typing.Set[str] = set([  "OFF_VOICE",  "PERFECT",  ])
        self._vals = CoachFeedbackValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "CoachFeedbackValues":
        return self._vals


class CoachFeedbackViewer(CoachFeedbackAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class CoachFeedbackValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def OFF_VOICE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OFF_VOICE"))
    
    @property
    def PERFECT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PERFECT"))
    
    


class CommandItemTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("CommandItemType")
        self._values: typing.Set[str] = set([  "CLIENT_ACTION",  "SESSION_PREP",  "FOLLOW_UP",  "PATTERN_ALERT",  ])
        self._vals = CommandItemTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "CommandItemTypeValues":
        return self._vals


class CommandItemTypeViewer(CommandItemTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class CommandItemTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def CLIENT_ACTION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CLIENT_ACTION"))
    
    @property
    def SESSION_PREP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_PREP"))
    
    @property
    def FOLLOW_UP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FOLLOW_UP"))
    
    @property
    def PATTERN_ALERT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PATTERN_ALERT"))
    
    


class EditTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("EditType")
        self._values: typing.Set[str] = set([  "MINOR_TWEAK",  "SIGNIFICANT_CHANGE",  "COMPLETE_REWRITE",  ])
        self._vals = EditTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "EditTypeValues":
        return self._vals


class EditTypeViewer(EditTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class EditTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def MINOR_TWEAK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MINOR_TWEAK"))
    
    @property
    def SIGNIFICANT_CHANGE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SIGNIFICANT_CHANGE"))
    
    @property
    def COMPLETE_REWRITE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETE_REWRITE"))
    
    


class EventTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("EventType")
        self._values: typing.Set[str] = set([  "CONTEXT_CHANGED",  "STATE_UPDATED",  "MESSAGE_RECEIVED",  "MESSAGE_SENT",  "CONVERSATION_STARTED",  "CONVERSATION_ENDED",  "ACTION_PENDING",  "ACTION_EXECUTING",  "ACTION_COMPLETED",  "ACTION_FAILED",  "ACTION_CANCELLED",  "FRONTEND_COMMAND",  "FRONTEND_COMMAND_RESULT",  "SCHEDULED_MESSAGE_CREATED",  "SCHEDULED_MESSAGE_UPDATED",  "SCHEDULED_MESSAGE_APPROVED",  "SCHEDULED_MESSAGE_SENT",  "SCHEDULED_MESSAGE_CANCELLED",  "SCHEDULED_MESSAGE_FAILED",  "SCHEDULED_MESSAGE_REVIEW_DUE",  "COMMAND_CENTER_UPDATED",  "PRIORITY_ITEM_ADDED",  "PRIORITY_ITEM_COMPLETED",  "VOICE_CORRECTION_SUBMITTED",  "VOICE_PROFILE_UPDATED",  "OBSERVATION_DETECTED",  "CURRENT_READ_UPDATED",  "RESOURCE_CREATED",  "RESOURCE_UPDATED",  "RESOURCE_DELETED",  "SESSION_STARTED",  "SESSION_UPDATED",  "SESSION_ENDED",  "CONNECTION_ESTABLISHED",  "CONNECTION_ERROR",  "HEARTBEAT",  "ERROR",  "ONBOARDING_STEP_COMPLETED",  "ONBOARDING_PHASE_STARTED",  "VOICE_SAMPLES_SUBMITTED",  "T15_PREP_GENERATED",  "T15_PREP_UPDATED",  "T15_PREP_VIEWED",  "SESSION_NOTES_GENERATED",  "SESSION_NOTES_UPDATED",  "SESSION_NOTES_FINALIZED",  "SESSION_NOTES_SHARED",  ])
        self._vals = EventTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "EventTypeValues":
        return self._vals


class EventTypeViewer(EventTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class EventTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def CONTEXT_CHANGED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONTEXT_CHANGED"))
    
    @property
    def STATE_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("STATE_UPDATED"))
    
    @property
    def MESSAGE_RECEIVED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MESSAGE_RECEIVED"))
    
    @property
    def MESSAGE_SENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MESSAGE_SENT"))
    
    @property
    def CONVERSATION_STARTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONVERSATION_STARTED"))
    
    @property
    def CONVERSATION_ENDED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONVERSATION_ENDED"))
    
    @property
    def ACTION_PENDING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTION_PENDING"))
    
    @property
    def ACTION_EXECUTING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTION_EXECUTING"))
    
    @property
    def ACTION_COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTION_COMPLETED"))
    
    @property
    def ACTION_FAILED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTION_FAILED"))
    
    @property
    def ACTION_CANCELLED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACTION_CANCELLED"))
    
    @property
    def FRONTEND_COMMAND(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FRONTEND_COMMAND"))
    
    @property
    def FRONTEND_COMMAND_RESULT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FRONTEND_COMMAND_RESULT"))
    
    @property
    def SCHEDULED_MESSAGE_CREATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_CREATED"))
    
    @property
    def SCHEDULED_MESSAGE_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_UPDATED"))
    
    @property
    def SCHEDULED_MESSAGE_APPROVED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_APPROVED"))
    
    @property
    def SCHEDULED_MESSAGE_SENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_SENT"))
    
    @property
    def SCHEDULED_MESSAGE_CANCELLED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_CANCELLED"))
    
    @property
    def SCHEDULED_MESSAGE_FAILED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_FAILED"))
    
    @property
    def SCHEDULED_MESSAGE_REVIEW_DUE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULED_MESSAGE_REVIEW_DUE"))
    
    @property
    def COMMAND_CENTER_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMMAND_CENTER_UPDATED"))
    
    @property
    def PRIORITY_ITEM_ADDED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PRIORITY_ITEM_ADDED"))
    
    @property
    def PRIORITY_ITEM_COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PRIORITY_ITEM_COMPLETED"))
    
    @property
    def VOICE_CORRECTION_SUBMITTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VOICE_CORRECTION_SUBMITTED"))
    
    @property
    def VOICE_PROFILE_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VOICE_PROFILE_UPDATED"))
    
    @property
    def OBSERVATION_DETECTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OBSERVATION_DETECTED"))
    
    @property
    def CURRENT_READ_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CURRENT_READ_UPDATED"))
    
    @property
    def RESOURCE_CREATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RESOURCE_CREATED"))
    
    @property
    def RESOURCE_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RESOURCE_UPDATED"))
    
    @property
    def RESOURCE_DELETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RESOURCE_DELETED"))
    
    @property
    def SESSION_STARTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_STARTED"))
    
    @property
    def SESSION_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_UPDATED"))
    
    @property
    def SESSION_ENDED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_ENDED"))
    
    @property
    def CONNECTION_ESTABLISHED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONNECTION_ESTABLISHED"))
    
    @property
    def CONNECTION_ERROR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONNECTION_ERROR"))
    
    @property
    def HEARTBEAT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HEARTBEAT"))
    
    @property
    def ERROR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ERROR"))
    
    @property
    def ONBOARDING_STEP_COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ONBOARDING_STEP_COMPLETED"))
    
    @property
    def ONBOARDING_PHASE_STARTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ONBOARDING_PHASE_STARTED"))
    
    @property
    def VOICE_SAMPLES_SUBMITTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VOICE_SAMPLES_SUBMITTED"))
    
    @property
    def T15_PREP_GENERATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("T15_PREP_GENERATED"))
    
    @property
    def T15_PREP_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("T15_PREP_UPDATED"))
    
    @property
    def T15_PREP_VIEWED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("T15_PREP_VIEWED"))
    
    @property
    def SESSION_NOTES_GENERATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES_GENERATED"))
    
    @property
    def SESSION_NOTES_UPDATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES_UPDATED"))
    
    @property
    def SESSION_NOTES_FINALIZED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES_FINALIZED"))
    
    @property
    def SESSION_NOTES_SHARED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES_SHARED"))
    
    


class FrontendActionStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("FrontendActionStatus")
        self._values: typing.Set[str] = set([  "PENDING",  "EXECUTING",  "COMPLETED",  "FAILED",  "EXPIRED",  ])
        self._vals = FrontendActionStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "FrontendActionStatusValues":
        return self._vals


class FrontendActionStatusViewer(FrontendActionStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class FrontendActionStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def PENDING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PENDING"))
    
    @property
    def EXECUTING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXECUTING"))
    
    @property
    def COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETED"))
    
    @property
    def FAILED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FAILED"))
    
    @property
    def EXPIRED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXPIRED"))
    
    


class FrontendToolNameAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("FrontendToolName")
        self._values: typing.Set[str] = set([  "NAVIGATE_TO",  "CLICK_ELEMENT",  "EXPAND_SECTION",  "SET_FORM_FIELD",  "SUBMIT_FORM",  "OPEN_MODAL",  "CLOSE_MODAL",  ])
        self._vals = FrontendToolNameValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "FrontendToolNameValues":
        return self._vals


class FrontendToolNameViewer(FrontendToolNameAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class FrontendToolNameValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NAVIGATE_TO(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NAVIGATE_TO"))
    
    @property
    def CLICK_ELEMENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CLICK_ELEMENT"))
    
    @property
    def EXPAND_SECTION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXPAND_SECTION"))
    
    @property
    def SET_FORM_FIELD(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SET_FORM_FIELD"))
    
    @property
    def SUBMIT_FORM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SUBMIT_FORM"))
    
    @property
    def OPEN_MODAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OPEN_MODAL"))
    
    @property
    def CLOSE_MODAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CLOSE_MODAL"))
    
    


class IntegrationStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("IntegrationStatus")
        self._values: typing.Set[str] = set([  "NOT_CONNECTED",  "PENDING",  "CONNECTED",  "EXPIRED",  "ERROR",  ])
        self._vals = IntegrationStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "IntegrationStatusValues":
        return self._vals


class IntegrationStatusViewer(IntegrationStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class IntegrationStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NOT_CONNECTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NOT_CONNECTED"))
    
    @property
    def PENDING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PENDING"))
    
    @property
    def CONNECTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CONNECTED"))
    
    @property
    def EXPIRED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXPIRED"))
    
    @property
    def ERROR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ERROR"))
    
    


class IntegrationTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("IntegrationType")
        self._values: typing.Set[str] = set([  "GOOGLE_CALENDAR",  "OUTLOOK_CALENDAR",  "ZOOM",  "GOOGLE_MEET",  "TEAMS",  "SALESFORCE",  "HUBSPOT",  "PRACTICE",  ])
        self._vals = IntegrationTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "IntegrationTypeValues":
        return self._vals


class IntegrationTypeViewer(IntegrationTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class IntegrationTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def GOOGLE_CALENDAR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("GOOGLE_CALENDAR"))
    
    @property
    def OUTLOOK_CALENDAR(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OUTLOOK_CALENDAR"))
    
    @property
    def ZOOM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ZOOM"))
    
    @property
    def GOOGLE_MEET(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("GOOGLE_MEET"))
    
    @property
    def TEAMS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TEAMS"))
    
    @property
    def SALESFORCE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SALESFORCE"))
    
    @property
    def HUBSPOT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("HUBSPOT"))
    
    @property
    def PRACTICE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PRACTICE"))
    
    


class MessageChannelAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("MessageChannel")
        self._values: typing.Set[str] = set([  "EMAIL",  "SMS",  "WHATSAPP",  ])
        self._vals = MessageChannelValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "MessageChannelValues":
        return self._vals


class MessageChannelViewer(MessageChannelAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class MessageChannelValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def EMAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EMAIL"))
    
    @property
    def SMS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SMS"))
    
    @property
    def WHATSAPP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("WHATSAPP"))
    
    


class MessageRoleAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("MessageRole")
        self._values: typing.Set[str] = set([  "USER",  "ASSISTANT",  "SYSTEM",  ])
        self._vals = MessageRoleValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "MessageRoleValues":
        return self._vals


class MessageRoleViewer(MessageRoleAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class MessageRoleValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def USER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("USER"))
    
    @property
    def ASSISTANT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ASSISTANT"))
    
    @property
    def SYSTEM(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SYSTEM"))
    
    


class MessageStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("MessageStatus")
        self._values: typing.Set[str] = set([  "DRAFT",  "APPROVED",  "PENDING_REVIEW",  "SENT",  "CANCELLED",  "FAILED",  ])
        self._vals = MessageStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "MessageStatusValues":
        return self._vals


class MessageStatusViewer(MessageStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class MessageStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def DRAFT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DRAFT"))
    
    @property
    def APPROVED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("APPROVED"))
    
    @property
    def PENDING_REVIEW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PENDING_REVIEW"))
    
    @property
    def SENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SENT"))
    
    @property
    def CANCELLED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CANCELLED"))
    
    @property
    def FAILED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FAILED"))
    
    


class ObservationTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ObservationType")
        self._values: typing.Set[str] = set([  "PATTERN",  "CHANGE",  "BREAKTHROUGH",  ])
        self._vals = ObservationTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ObservationTypeValues":
        return self._vals


class ObservationTypeViewer(ObservationTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ObservationTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def PATTERN(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PATTERN"))
    
    @property
    def CHANGE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CHANGE"))
    
    @property
    def BREAKTHROUGH(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("BREAKTHROUGH"))
    
    


class OnboardingActionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("OnboardingAction")
        self._values: typing.Set[str] = set([  "START",  "COMPLETE",  "SKIP",  "SAVE_PROGRESS",  ])
        self._vals = OnboardingActionValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "OnboardingActionValues":
        return self._vals


class OnboardingActionViewer(OnboardingActionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class OnboardingActionValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def START(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("START"))
    
    @property
    def COMPLETE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETE"))
    
    @property
    def SKIP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SKIP"))
    
    @property
    def SAVE_PROGRESS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SAVE_PROGRESS"))
    
    


class OnboardingPhaseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("OnboardingPhase")
        self._values: typing.Set[str] = set([  "ACCOUNT_CREATED",  "PROFILE_SETUP",  "VOICE_SAMPLES",  "COACHING_STYLE",  "INTEGRATIONS",  "CLIENT_IMPORT",  "TUTORIAL",  "COMPLETED",  ])
        self._vals = OnboardingPhaseValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "OnboardingPhaseValues":
        return self._vals


class OnboardingPhaseViewer(OnboardingPhaseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class OnboardingPhaseValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def ACCOUNT_CREATED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ACCOUNT_CREATED"))
    
    @property
    def PROFILE_SETUP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PROFILE_SETUP"))
    
    @property
    def VOICE_SAMPLES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("VOICE_SAMPLES"))
    
    @property
    def COACHING_STYLE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COACHING_STYLE"))
    
    @property
    def INTEGRATIONS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("INTEGRATIONS"))
    
    @property
    def CLIENT_IMPORT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("CLIENT_IMPORT"))
    
    @property
    def TUTORIAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TUTORIAL"))
    
    @property
    def COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETED"))
    
    


class PhaseStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("PhaseStatus")
        self._values: typing.Set[str] = set([  "NOT_STARTED",  "IN_PROGRESS",  "COMPLETED",  "SKIPPED",  ])
        self._vals = PhaseStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "PhaseStatusValues":
        return self._vals


class PhaseStatusViewer(PhaseStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class PhaseStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NOT_STARTED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NOT_STARTED"))
    
    @property
    def IN_PROGRESS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("IN_PROGRESS"))
    
    @property
    def COMPLETED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMPLETED"))
    
    @property
    def SKIPPED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SKIPPED"))
    
    


class PriorityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Priority")
        self._values: typing.Set[str] = set([  "FOCUS_NOW",  "SOON",  "LATER",  ])
        self._vals = PriorityValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "PriorityValues":
        return self._vals


class PriorityViewer(PriorityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class PriorityValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def FOCUS_NOW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FOCUS_NOW"))
    
    @property
    def SOON(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SOON"))
    
    @property
    def LATER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LATER"))
    
    


class ResourceTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ResourceType")
        self._values: typing.Set[str] = set([  "DOCUMENT",  "LINK",  "FRAMEWORK",  "TEMPLATE",  ])
        self._vals = ResourceTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ResourceTypeValues":
        return self._vals


class ResourceTypeViewer(ResourceTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ResourceTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def DOCUMENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DOCUMENT"))
    
    @property
    def LINK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LINK"))
    
    @property
    def FRAMEWORK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FRAMEWORK"))
    
    @property
    def TEMPLATE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TEMPLATE"))
    
    


class SessionNoteSectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("SessionNoteSection")
        self._values: typing.Set[str] = set([  "RECAP",  "OBSERVATIONS",  "INQUIRIES",  "INVITATIONS",  "RESOURCES",  "NEXT",  ])
        self._vals = SessionNoteSectionValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "SessionNoteSectionValues":
        return self._vals


class SessionNoteSectionViewer(SessionNoteSectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class SessionNoteSectionValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def RECAP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RECAP"))
    
    @property
    def OBSERVATIONS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("OBSERVATIONS"))
    
    @property
    def INQUIRIES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("INQUIRIES"))
    
    @property
    def INVITATIONS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("INVITATIONS"))
    
    @property
    def RESOURCES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RESOURCES"))
    
    @property
    def NEXT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NEXT"))
    
    


class SessionNotesStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("SessionNotesStatus")
        self._values: typing.Set[str] = set([  "DRAFT",  "IN_REVIEW",  "FINALIZED",  "SHARED",  ])
        self._vals = SessionNotesStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "SessionNotesStatusValues":
        return self._vals


class SessionNotesStatusViewer(SessionNotesStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class SessionNotesStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def DRAFT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DRAFT"))
    
    @property
    def IN_REVIEW(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("IN_REVIEW"))
    
    @property
    def FINALIZED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FINALIZED"))
    
    @property
    def SHARED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SHARED"))
    
    


class StateSourceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("StateSource")
        self._values: typing.Set[str] = set([  "FRONTEND",  "EXTENSION",  ])
        self._vals = StateSourceValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "StateSourceValues":
        return self._vals


class StateSourceViewer(StateSourceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class StateSourceValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def FRONTEND(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FRONTEND"))
    
    @property
    def EXTENSION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EXTENSION"))
    
    


class T15PrepSectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("T15PrepSection")
        self._values: typing.Set[str] = set([  "NORTH_STAR_REMINDER",  "LAST_SESSION_RECAP",  "COMMITMENTS_TO_CHECK",  "LIFE_CONTEXT",  "PATTERN_INTELLIGENCE",  "SUGGESTED_OPENERS",  "PRIVATE_COACH_NOTES",  "BETWEEN_SESSION_INTELLIGENCE",  "COACHEE_PRE_SESSION_INPUT",  ])
        self._vals = T15PrepSectionValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "T15PrepSectionValues":
        return self._vals


class T15PrepSectionViewer(T15PrepSectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class T15PrepSectionValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NORTH_STAR_REMINDER(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NORTH_STAR_REMINDER"))
    
    @property
    def LAST_SESSION_RECAP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LAST_SESSION_RECAP"))
    
    @property
    def COMMITMENTS_TO_CHECK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COMMITMENTS_TO_CHECK"))
    
    @property
    def LIFE_CONTEXT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LIFE_CONTEXT"))
    
    @property
    def PATTERN_INTELLIGENCE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PATTERN_INTELLIGENCE"))
    
    @property
    def SUGGESTED_OPENERS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SUGGESTED_OPENERS"))
    
    @property
    def PRIVATE_COACH_NOTES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PRIVATE_COACH_NOTES"))
    
    @property
    def BETWEEN_SESSION_INTELLIGENCE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("BETWEEN_SESSION_INTELLIGENCE"))
    
    @property
    def COACHEE_PRE_SESSION_INPUT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COACHEE_PRE_SESSION_INPUT"))
    
    


class ToolNameAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ToolName")
        self._values: typing.Set[str] = set([  "DRAFT_T15",  "DRAFT_SESSION_NOTES",  "SEND_FOLLOW_UP_EMAIL",  "UPDATE_SESSION_STATUS",  "SUMMARIZE_TRANSCRIPT",  "ADD_CLIENT_NOTE",  "SCHEDULE_SESSION",  "LOOKUP_CLIENT",  ])
        self._vals = ToolNameValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ToolNameValues":
        return self._vals


class ToolNameViewer(ToolNameAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class ToolNameValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def DRAFT_T15(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DRAFT_T15"))
    
    @property
    def DRAFT_SESSION_NOTES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("DRAFT_SESSION_NOTES"))
    
    @property
    def SEND_FOLLOW_UP_EMAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SEND_FOLLOW_UP_EMAIL"))
    
    @property
    def UPDATE_SESSION_STATUS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("UPDATE_SESSION_STATUS"))
    
    @property
    def SUMMARIZE_TRANSCRIPT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SUMMARIZE_TRANSCRIPT"))
    
    @property
    def ADD_CLIENT_NOTE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("ADD_CLIENT_NOTE"))
    
    @property
    def SCHEDULE_SESSION(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SCHEDULE_SESSION"))
    
    @property
    def LOOKUP_CLIENT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("LOOKUP_CLIENT"))
    
    


class TransparencyIndicatorAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("TransparencyIndicator")
        self._values: typing.Set[str] = set([  "COACH_DIRECT",  "AI_DRAFTED_APPROVED",  "AI_AUTONOMOUS",  ])
        self._vals = TransparencyIndicatorValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "TransparencyIndicatorValues":
        return self._vals


class TransparencyIndicatorViewer(TransparencyIndicatorAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class TransparencyIndicatorValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def COACH_DIRECT(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("COACH_DIRECT"))
    
    @property
    def AI_DRAFTED_APPROVED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("AI_DRAFTED_APPROVED"))
    
    @property
    def AI_AUTONOMOUS(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("AI_AUTONOMOUS"))
    
    


class VoiceContentTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("VoiceContentType")
        self._values: typing.Set[str] = set([  "SESSION_NOTES",  "EMAIL",  "MESSAGE",  ])
        self._vals = VoiceContentTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "VoiceContentTypeValues":
        return self._vals


class VoiceContentTypeViewer(VoiceContentTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class VoiceContentTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def SESSION_NOTES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES"))
    
    @property
    def EMAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EMAIL"))
    
    @property
    def MESSAGE(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("MESSAGE"))
    
    


class VoiceSampleStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("VoiceSampleStatus")
        self._values: typing.Set[str] = set([  "PENDING",  "PROCESSING",  "PROCESSED",  "FAILED",  ])
        self._vals = VoiceSampleStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "VoiceSampleStatusValues":
        return self._vals


class VoiceSampleStatusViewer(VoiceSampleStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class VoiceSampleStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def PENDING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PENDING"))
    
    @property
    def PROCESSING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PROCESSING"))
    
    @property
    def PROCESSED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("PROCESSED"))
    
    @property
    def FAILED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FAILED"))
    
    


class VoiceSampleTypeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("VoiceSampleType")
        self._values: typing.Set[str] = set([  "EMAIL",  "SESSION_NOTES",  "FOLLOW_UP",  "FEEDBACK",  "GENERAL",  ])
        self._vals = VoiceSampleTypeValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "VoiceSampleTypeValues":
        return self._vals


class VoiceSampleTypeViewer(VoiceSampleTypeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class VoiceSampleTypeValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def EMAIL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("EMAIL"))
    
    @property
    def SESSION_NOTES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("SESSION_NOTES"))
    
    @property
    def FOLLOW_UP(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FOLLOW_UP"))
    
    @property
    def FEEDBACK(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("FEEDBACK"))
    
    @property
    def GENERAL(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("GENERAL"))
    
    


class VoiceTrainingStatusAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("VoiceTrainingStatus")
        self._values: typing.Set[str] = set([  "NEEDS_SAMPLES",  "READY",  "TRAINING",  "TRAINED",  "RETRAINING",  ])
        self._vals = VoiceTrainingStatusValues(self._bldr, self._values)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "VoiceTrainingStatusValues":
        return self._vals


class VoiceTrainingStatusViewer(VoiceTrainingStatusAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_values(self) -> typing.List[typing.Tuple[str, type_builder.EnumValueViewer]]:
        return [(name, type_builder.EnumValueViewer(self._bldr.value(name))) for name in self._values]
    

class VoiceTrainingStatusValues:
    def __init__(self, enum_bldr: baml_py.EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def NEEDS_SAMPLES(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("NEEDS_SAMPLES"))
    
    @property
    def READY(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("READY"))
    
    @property
    def TRAINING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TRAINING"))
    
    @property
    def TRAINED(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("TRAINED"))
    
    @property
    def RETRAINING(self) -> type_builder.EnumValueViewer:
        return type_builder.EnumValueViewer(self.__bldr.value("RETRAINING"))
    
    



# #########################################################################
# Generated classes 109
# #########################################################################

class AICommandHistoryItemAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AICommandHistoryItem")
        self._properties: typing.Set[str] = set([  "id",  "command",  "commandType",  "originalContent",  "editedContent",  "section",  "applied",  "explanation",  "createdAt",  ])
        self._props = AICommandHistoryItemProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AICommandHistoryItemProperties":
        return self._props


class AICommandHistoryItemViewer(AICommandHistoryItemAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AICommandHistoryItemProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def command(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("command"))
    
    @property
    def commandType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("commandType"))
    
    @property
    def originalContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("originalContent"))
    
    @property
    def editedContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editedContent"))
    
    @property
    def section(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("section"))
    
    @property
    def applied(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("applied"))
    
    @property
    def explanation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("explanation"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    


class AICommandRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AICommandRequest")
        self._properties: typing.Set[str] = set([  "contentId",  "section",  "command",  "currentContent",  "commandType",  ])
        self._props = AICommandRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AICommandRequestProperties":
        return self._props


class AICommandRequestViewer(AICommandRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AICommandRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def contentId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contentId"))
    
    @property
    def section(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("section"))
    
    @property
    def command(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("command"))
    
    @property
    def currentContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("currentContent"))
    
    @property
    def commandType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("commandType"))
    
    


class AICommandResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AICommandResult")
        self._properties: typing.Set[str] = set([  "editedContent",  "explanation",  "appliedChange",  "commandId",  ])
        self._props = AICommandResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AICommandResultProperties":
        return self._props


class AICommandResultViewer(AICommandResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AICommandResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def editedContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editedContent"))
    
    @property
    def explanation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("explanation"))
    
    @property
    def appliedChange(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("appliedChange"))
    
    @property
    def commandId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("commandId"))
    
    


class ActionErrorAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionError")
        self._properties: typing.Set[str] = set([  "code",  "message",  "retryable",  "details",  ])
        self._props = ActionErrorProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionErrorProperties":
        return self._props


class ActionErrorViewer(ActionErrorAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ActionErrorProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def code(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("code"))
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def retryable(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("retryable"))
    
    @property
    def details(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("details"))
    
    


class ActionEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionEventPayload")
        self._properties: typing.Set[str] = set([  "actionId",  "tool",  "status",  "parameters",  "result",  "error",  ])
        self._props = ActionEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionEventPayloadProperties":
        return self._props


class ActionEventPayloadViewer(ActionEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ActionEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def actionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionId"))
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def result(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("result"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class ActionOutputAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionOutput")
        self._properties: typing.Set[str] = set([  "type",  "text",  "structured",  "preview",  ])
        self._props = ActionOutputProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionOutputProperties":
        return self._props


class ActionOutputViewer(ActionOutputAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ActionOutputProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def text(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("text"))
    
    @property
    def structured(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("structured"))
    
    @property
    def preview(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preview"))
    
    


class ActionRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionRequest")
        self._properties: typing.Set[str] = set([  "conversationId",  "tool",  "parameters",  "context",  "confirmed",  ])
        self._props = ActionRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionRequestProperties":
        return self._props


class ActionRequestViewer(ActionRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ActionRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def conversationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conversationId"))
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def confirmed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confirmed"))
    
    


class ActionResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ActionResponse")
        self._properties: typing.Set[str] = set([  "success",  "tool",  "output",  "error",  "appliedChanges",  "followUpMessage",  "suggestedNextActions",  ])
        self._props = ActionResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ActionResponseProperties":
        return self._props


class ActionResponseViewer(ActionResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ActionResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def output(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("output"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    @property
    def appliedChanges(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("appliedChanges"))
    
    @property
    def followUpMessage(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("followUpMessage"))
    
    @property
    def suggestedNextActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggestedNextActions"))
    
    


class AiTimingSuggestionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AiTimingSuggestion")
        self._properties: typing.Set[str] = set([  "suggestedTime",  "reason",  "confidence",  "alternativeTimes",  ])
        self._props = AiTimingSuggestionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AiTimingSuggestionProperties":
        return self._props


class AiTimingSuggestionViewer(AiTimingSuggestionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AiTimingSuggestionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def suggestedTime(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggestedTime"))
    
    @property
    def reason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("reason"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    @property
    def alternativeTimes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alternativeTimes"))
    
    


class AiTimingSuggestionRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AiTimingSuggestionRequest")
        self._properties: typing.Set[str] = set([  "clientId",  "messageType",  "preferredTimeRange",  ])
        self._props = AiTimingSuggestionRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AiTimingSuggestionRequestProperties":
        return self._props


class AiTimingSuggestionRequestViewer(AiTimingSuggestionRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AiTimingSuggestionRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def messageType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("messageType"))
    
    @property
    def preferredTimeRange(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preferredTimeRange"))
    
    


class AuthVerifyResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AuthVerifyResponse")
        self._properties: typing.Set[str] = set([  "authenticated",  "userId",  "username",  "email",  "firstName",  "lastName",  "organizationId",  "permissions",  ])
        self._props = AuthVerifyResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AuthVerifyResponseProperties":
        return self._props


class AuthVerifyResponseViewer(AuthVerifyResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class AuthVerifyResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def authenticated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authenticated"))
    
    @property
    def userId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("userId"))
    
    @property
    def username(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("username"))
    
    @property
    def email(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("email"))
    
    @property
    def firstName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("firstName"))
    
    @property
    def lastName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastName"))
    
    @property
    def organizationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("organizationId"))
    
    @property
    def permissions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("permissions"))
    
    


class ChatMessageAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ChatMessage")
        self._properties: typing.Set[str] = set([  "role",  "content",  "timestamp",  ])
        self._props = ChatMessageProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChatMessageProperties":
        return self._props


class ChatMessageViewer(ChatMessageAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ChatMessageProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def role(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("role"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    


class ChatRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ChatRequest")
        self._properties: typing.Set[str] = set([  "message",  "context",  "conversationHistory",  "conversationId",  ])
        self._props = ChatRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChatRequestProperties":
        return self._props


class ChatRequestViewer(ChatRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ChatRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def conversationHistory(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conversationHistory"))
    
    @property
    def conversationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conversationId"))
    
    


class ChatResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ChatResponse")
        self._properties: typing.Set[str] = set([  "message",  "conversationId",  "suggestedActions",  "context",  ])
        self._props = ChatResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChatResponseProperties":
        return self._props


class ChatResponseViewer(ChatResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ChatResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def conversationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conversationId"))
    
    @property
    def suggestedActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggestedActions"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    


class ClientContextAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ClientContext")
        self._properties: typing.Set[str] = set([  "id",  "name",  "email",  "phone",  "goals",  "recentNotes",  "lastSessionDate",  "nextSessionDate",  "totalSessions",  ])
        self._props = ClientContextProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ClientContextProperties":
        return self._props


class ClientContextViewer(ClientContextAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ClientContextProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def email(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("email"))
    
    @property
    def phone(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phone"))
    
    @property
    def goals(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("goals"))
    
    @property
    def recentNotes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recentNotes"))
    
    @property
    def lastSessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastSessionDate"))
    
    @property
    def nextSessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nextSessionDate"))
    
    @property
    def totalSessions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSessions"))
    
    


class CommandCenterDataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CommandCenterData")
        self._properties: typing.Set[str] = set([  "focusNow",  "soon",  "later",  "lastUpdated",  ])
        self._props = CommandCenterDataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CommandCenterDataProperties":
        return self._props


class CommandCenterDataViewer(CommandCenterDataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CommandCenterDataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def focusNow(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("focusNow"))
    
    @property
    def soon(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("soon"))
    
    @property
    def later(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("later"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class CommandCenterEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CommandCenterEventPayload")
        self._properties: typing.Set[str] = set([  "focusNowCount",  "soonCount",  "laterCount",  "lastUpdated",  ])
        self._props = CommandCenterEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CommandCenterEventPayloadProperties":
        return self._props


class CommandCenterEventPayloadViewer(CommandCenterEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CommandCenterEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def focusNowCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("focusNowCount"))
    
    @property
    def soonCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("soonCount"))
    
    @property
    def laterCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("laterCount"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class CommandCenterItemAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CommandCenterItem")
        self._properties: typing.Set[str] = set([  "id",  "type",  "clientId",  "clientName",  "priority",  "priorityReason",  "action",  "dueDate",  "crossDomainContext",  "sessionId",  "createdAt",  ])
        self._props = CommandCenterItemProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CommandCenterItemProperties":
        return self._props


class CommandCenterItemViewer(CommandCenterItemAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CommandCenterItemProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def priority(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priority"))
    
    @property
    def priorityReason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priorityReason"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def dueDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dueDate"))
    
    @property
    def crossDomainContext(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("crossDomainContext"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    


class ConnectionPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ConnectionPayload")
        self._properties: typing.Set[str] = set([  "connectionId",  "userId",  "capabilities",  ])
        self._props = ConnectionPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ConnectionPayloadProperties":
        return self._props


class ConnectionPayloadViewer(ConnectionPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ConnectionPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def connectionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("connectionId"))
    
    @property
    def userId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("userId"))
    
    @property
    def capabilities(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("capabilities"))
    
    


class ContextChangedPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ContextChangedPayload")
        self._properties: typing.Set[str] = set([  "page",  "clientId",  "clientName",  "sessionId",  "sessionDate",  "availableActions",  "source",  ])
        self._props = ContextChangedPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ContextChangedPayloadProperties":
        return self._props


class ContextChangedPayloadViewer(ContextChangedPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ContextChangedPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def availableActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("availableActions"))
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    


class CreateResourceRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateResourceRequest")
        self._properties: typing.Set[str] = set([  "type",  "title",  "description",  "externalUrl",  "tags",  ])
        self._props = CreateResourceRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateResourceRequestProperties":
        return self._props


class CreateResourceRequestViewer(CreateResourceRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CreateResourceRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def externalUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("externalUrl"))
    
    @property
    def tags(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tags"))
    
    


class CreateScheduledMessageRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CreateScheduledMessageRequest")
        self._properties: typing.Set[str] = set([  "clientId",  "sessionId",  "templateId",  "channel",  "subject",  "body",  "scheduledFor",  "useAiSuggestion",  "autoApprove",  "transparencyIndicator",  "transparencyDisplayName",  ])
        self._props = CreateScheduledMessageRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CreateScheduledMessageRequestProperties":
        return self._props


class CreateScheduledMessageRequestViewer(CreateScheduledMessageRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CreateScheduledMessageRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def templateId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("templateId"))
    
    @property
    def channel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("channel"))
    
    @property
    def subject(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subject"))
    
    @property
    def body(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("body"))
    
    @property
    def scheduledFor(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledFor"))
    
    @property
    def useAiSuggestion(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("useAiSuggestion"))
    
    @property
    def autoApprove(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("autoApprove"))
    
    @property
    def transparencyIndicator(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transparencyIndicator"))
    
    @property
    def transparencyDisplayName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transparencyDisplayName"))
    
    


class CurrentReadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("CurrentRead")
        self._properties: typing.Set[str] = set([  "assessment",  "confidence",  "lastUpdated",  ])
        self._props = CurrentReadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CurrentReadProperties":
        return self._props


class CurrentReadViewer(CurrentReadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class CurrentReadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def assessment(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("assessment"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class ErrorPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ErrorPayload")
        self._properties: typing.Set[str] = set([  "code",  "message",  "details",  "retryable",  ])
        self._props = ErrorPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ErrorPayloadProperties":
        return self._props


class ErrorPayloadViewer(ErrorPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ErrorPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def code(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("code"))
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def details(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("details"))
    
    @property
    def retryable(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("retryable"))
    
    


class EventEnvelopeAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EventEnvelope")
        self._properties: typing.Set[str] = set([  "type",  "meta",  "payload",  ])
        self._props = EventEnvelopeProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EventEnvelopeProperties":
        return self._props


class EventEnvelopeViewer(EventEnvelopeAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class EventEnvelopeProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def meta(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("meta"))
    
    @property
    def payload(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("payload"))
    
    


class EventMetaAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("EventMeta")
        self._properties: typing.Set[str] = set([  "timestamp",  "correlationId",  "contractsVersion",  "actorId",  "requestId",  ])
        self._props = EventMetaProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "EventMetaProperties":
        return self._props


class EventMetaViewer(EventMetaAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class EventMetaProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    @property
    def correlationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("correlationId"))
    
    @property
    def contractsVersion(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contractsVersion"))
    
    @property
    def actorId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actorId"))
    
    @property
    def requestId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requestId"))
    
    


class FrontendActionResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FrontendActionResult")
        self._properties: typing.Set[str] = set([  "actionId",  "status",  "success",  "message",  "error",  "executedAt",  ])
        self._props = FrontendActionResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FrontendActionResultProperties":
        return self._props


class FrontendActionResultViewer(FrontendActionResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FrontendActionResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def actionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionId"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    @property
    def executedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("executedAt"))
    
    


class FrontendCommandAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FrontendCommand")
        self._properties: typing.Set[str] = set([  "actionId",  "tool",  "parameters",  "timeout",  "requiresConfirmation",  ])
        self._props = FrontendCommandProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FrontendCommandProperties":
        return self._props


class FrontendCommandViewer(FrontendCommandAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FrontendCommandProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def actionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionId"))
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def timeout(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeout"))
    
    @property
    def requiresConfirmation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requiresConfirmation"))
    
    


class FrontendCommandPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FrontendCommandPayload")
        self._properties: typing.Set[str] = set([  "actionId",  "tool",  "parameters",  "timeout",  "requiresConfirmation",  ])
        self._props = FrontendCommandPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FrontendCommandPayloadProperties":
        return self._props


class FrontendCommandPayloadViewer(FrontendCommandPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FrontendCommandPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def actionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actionId"))
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def timeout(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeout"))
    
    @property
    def requiresConfirmation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requiresConfirmation"))
    
    


class FrontendToolConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FrontendToolConfig")
        self._properties: typing.Set[str] = set([  "tool",  "requiresConfirmation",  "defaultTimeout",  ])
        self._props = FrontendToolConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FrontendToolConfigProperties":
        return self._props


class FrontendToolConfigViewer(FrontendToolConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FrontendToolConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def requiresConfirmation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requiresConfirmation"))
    
    @property
    def defaultTimeout(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("defaultTimeout"))
    
    


class HeartbeatPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("HeartbeatPayload")
        self._properties: typing.Set[str] = set([  "serverTime",  "connectionAge",  ])
        self._props = HeartbeatPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "HeartbeatPayloadProperties":
        return self._props


class HeartbeatPayloadViewer(HeartbeatPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class HeartbeatPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def serverTime(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("serverTime"))
    
    @property
    def connectionAge(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("connectionAge"))
    
    


class IntegrationConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntegrationConfig")
        self._properties: typing.Set[str] = set([  "id",  "coachId",  "type",  "status",  "displayName",  "accountEmail",  "connectedAt",  "lastSyncAt",  "settings",  "error",  ])
        self._props = IntegrationConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntegrationConfigProperties":
        return self._props


class IntegrationConfigViewer(IntegrationConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntegrationConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def displayName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("displayName"))
    
    @property
    def accountEmail(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("accountEmail"))
    
    @property
    def connectedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("connectedAt"))
    
    @property
    def lastSyncAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastSyncAt"))
    
    @property
    def settings(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("settings"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class IntegrationConnectRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntegrationConnectRequest")
        self._properties: typing.Set[str] = set([  "type",  "redirectUrl",  ])
        self._props = IntegrationConnectRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntegrationConnectRequestProperties":
        return self._props


class IntegrationConnectRequestViewer(IntegrationConnectRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntegrationConnectRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def redirectUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("redirectUrl"))
    
    


class IntegrationConnectResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntegrationConnectResponse")
        self._properties: typing.Set[str] = set([  "success",  "authUrl",  "error",  ])
        self._props = IntegrationConnectResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntegrationConnectResponseProperties":
        return self._props


class IntegrationConnectResponseViewer(IntegrationConnectResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntegrationConnectResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def authUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("authUrl"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class IntegrationDisconnectRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntegrationDisconnectRequest")
        self._properties: typing.Set[str] = set([  "integrationId",  ])
        self._props = IntegrationDisconnectRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntegrationDisconnectRequestProperties":
        return self._props


class IntegrationDisconnectRequestViewer(IntegrationDisconnectRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntegrationDisconnectRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def integrationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("integrationId"))
    
    


class IntegrationListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntegrationList")
        self._properties: typing.Set[str] = set([  "integrations",  "availableTypes",  ])
        self._props = IntegrationListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntegrationListProperties":
        return self._props


class IntegrationListViewer(IntegrationListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntegrationListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def integrations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("integrations"))
    
    @property
    def availableTypes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("availableTypes"))
    
    


class MessagePayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("MessagePayload")
        self._properties: typing.Set[str] = set([  "conversationId",  "role",  "content",  "timestamp",  ])
        self._props = MessagePayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "MessagePayloadProperties":
        return self._props


class MessagePayloadViewer(MessagePayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class MessagePayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def conversationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conversationId"))
    
    @property
    def role(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("role"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    


class NavigationOptionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("NavigationOption")
        self._properties: typing.Set[str] = set([  "label",  "route",  "icon",  ])
        self._props = NavigationOptionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NavigationOptionProperties":
        return self._props


class NavigationOptionViewer(NavigationOptionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class NavigationOptionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def label(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("label"))
    
    @property
    def route(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("route"))
    
    @property
    def icon(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("icon"))
    
    


class ObservationEntryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ObservationEntry")
        self._properties: typing.Set[str] = set([  "id",  "type",  "description",  "evidence",  "confidence",  "detectedAt",  "dismissed",  "dismissedBy",  "dismissedAt",  ])
        self._props = ObservationEntryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ObservationEntryProperties":
        return self._props


class ObservationEntryViewer(ObservationEntryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ObservationEntryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def evidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("evidence"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    @property
    def detectedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("detectedAt"))
    
    @property
    def dismissed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dismissed"))
    
    @property
    def dismissedBy(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dismissedBy"))
    
    @property
    def dismissedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("dismissedAt"))
    
    


class ObservationPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ObservationPayload")
        self._properties: typing.Set[str] = set([  "observationId",  "clientId",  "type",  "description",  "confidence",  ])
        self._props = ObservationPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ObservationPayloadProperties":
        return self._props


class ObservationPayloadViewer(ObservationPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ObservationPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def observationId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("observationId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    


class OnboardingEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OnboardingEventPayload")
        self._properties: typing.Set[str] = set([  "coachId",  "phase",  "previousPhase",  "overallProgress",  "action",  "timestamp",  ])
        self._props = OnboardingEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OnboardingEventPayloadProperties":
        return self._props


class OnboardingEventPayloadViewer(OnboardingEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OnboardingEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def phase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phase"))
    
    @property
    def previousPhase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("previousPhase"))
    
    @property
    def overallProgress(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overallProgress"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    


class OnboardingPhaseProgressAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OnboardingPhaseProgress")
        self._properties: typing.Set[str] = set([  "phase",  "status",  "startedAt",  "completedAt",  "skipped",  "skipReason",  "data",  ])
        self._props = OnboardingPhaseProgressProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OnboardingPhaseProgressProperties":
        return self._props


class OnboardingPhaseProgressViewer(OnboardingPhaseProgressAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OnboardingPhaseProgressProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def phase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phase"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def startedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("startedAt"))
    
    @property
    def completedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completedAt"))
    
    @property
    def skipped(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("skipped"))
    
    @property
    def skipReason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("skipReason"))
    
    @property
    def data(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data"))
    
    


class OnboardingProgressAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OnboardingProgress")
        self._properties: typing.Set[str] = set([  "coachId",  "currentPhase",  "phases",  "overallProgress",  "startedAt",  "completedAt",  "estimatedTimeRemaining",  "canSkipCurrent",  ])
        self._props = OnboardingProgressProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OnboardingProgressProperties":
        return self._props


class OnboardingProgressViewer(OnboardingProgressAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OnboardingProgressProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def currentPhase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("currentPhase"))
    
    @property
    def phases(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phases"))
    
    @property
    def overallProgress(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overallProgress"))
    
    @property
    def startedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("startedAt"))
    
    @property
    def completedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completedAt"))
    
    @property
    def estimatedTimeRemaining(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimatedTimeRemaining"))
    
    @property
    def canSkipCurrent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("canSkipCurrent"))
    
    


class OnboardingUpdateRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OnboardingUpdateRequest")
        self._properties: typing.Set[str] = set([  "phase",  "action",  "data",  ])
        self._props = OnboardingUpdateRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OnboardingUpdateRequestProperties":
        return self._props


class OnboardingUpdateRequestViewer(OnboardingUpdateRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OnboardingUpdateRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def phase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("phase"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def data(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("data"))
    
    


class OnboardingUpdateResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OnboardingUpdateResponse")
        self._properties: typing.Set[str] = set([  "success",  "progress",  "nextPhase",  "error",  ])
        self._props = OnboardingUpdateResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OnboardingUpdateResponseProperties":
        return self._props


class OnboardingUpdateResponseViewer(OnboardingUpdateResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OnboardingUpdateResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def progress(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("progress"))
    
    @property
    def nextPhase(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nextPhase"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class PageContextAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PageContext")
        self._properties: typing.Set[str] = set([  "url",  "route",  "clientId",  "sessionId",  "pageTitle",  "pageData",  ])
        self._props = PageContextProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PageContextProperties":
        return self._props


class PageContextViewer(PageContextAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PageContextProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def url(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("url"))
    
    @property
    def route(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("route"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def pageTitle(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageTitle"))
    
    @property
    def pageData(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageData"))
    
    


class PriorityItemPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PriorityItemPayload")
        self._properties: typing.Set[str] = set([  "itemId",  "type",  "clientId",  "clientName",  "priority",  "action",  ])
        self._props = PriorityItemPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PriorityItemPayloadProperties":
        return self._props


class PriorityItemPayloadViewer(PriorityItemPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PriorityItemPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def itemId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("itemId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def priority(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priority"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    


class PrivateIntelligenceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PrivateIntelligence")
        self._properties: typing.Set[str] = set([  "clientId",  "currentRead",  "observations",  "coachPrivateNotes",  "lastUpdated",  ])
        self._props = PrivateIntelligenceProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PrivateIntelligenceProperties":
        return self._props


class PrivateIntelligenceViewer(PrivateIntelligenceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PrivateIntelligenceProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def currentRead(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("currentRead"))
    
    @property
    def observations(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("observations"))
    
    @property
    def coachPrivateNotes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachPrivateNotes"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class ProfileScrapeRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ProfileScrapeRequest")
        self._properties: typing.Set[str] = set([  "urls",  "linkedInUrl",  "websiteUrl",  ])
        self._props = ProfileScrapeRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ProfileScrapeRequestProperties":
        return self._props


class ProfileScrapeRequestViewer(ProfileScrapeRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ProfileScrapeRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def urls(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("urls"))
    
    @property
    def linkedInUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("linkedInUrl"))
    
    @property
    def websiteUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("websiteUrl"))
    
    


class ProfileScrapeResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ProfileScrapeResponse")
        self._properties: typing.Set[str] = set([  "success",  "profiles",  "mergedProfile",  "error",  ])
        self._props = ProfileScrapeResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ProfileScrapeResponseProperties":
        return self._props


class ProfileScrapeResponseViewer(ProfileScrapeResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ProfileScrapeResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def profiles(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("profiles"))
    
    @property
    def mergedProfile(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("mergedProfile"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class ResolvedContextAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResolvedContext")
        self._properties: typing.Set[str] = set([  "clientId",  "clientName",  "sessionId",  "sessionDate",  "confidence",  ])
        self._props = ResolvedContextProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResolvedContextProperties":
        return self._props


class ResolvedContextViewer(ResolvedContextAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResolvedContextProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    


class ResourceEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResourceEventPayload")
        self._properties: typing.Set[str] = set([  "resourceId",  "clientId",  "type",  "title",  "action",  ])
        self._props = ResourceEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResourceEventPayloadProperties":
        return self._props


class ResourceEventPayloadViewer(ResourceEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResourceEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def resourceId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("resourceId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    


class ResourceItemAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResourceItem")
        self._properties: typing.Set[str] = set([  "id",  "clientId",  "coachId",  "type",  "title",  "description",  "fileUrl",  "externalUrl",  "thumbnailUrl",  "tags",  "metadata",  "createdAt",  "updatedAt",  ])
        self._props = ResourceItemProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResourceItemProperties":
        return self._props


class ResourceItemViewer(ResourceItemAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResourceItemProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def fileUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fileUrl"))
    
    @property
    def externalUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("externalUrl"))
    
    @property
    def thumbnailUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("thumbnailUrl"))
    
    @property
    def tags(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tags"))
    
    @property
    def metadata(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("metadata"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    @property
    def updatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedAt"))
    
    


class ResourceListDataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResourceListData")
        self._properties: typing.Set[str] = set([  "items",  "total",  "page",  "pageSize",  "nextPage",  ])
        self._props = ResourceListDataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResourceListDataProperties":
        return self._props


class ResourceListDataViewer(ResourceListDataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResourceListDataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def total(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def pageSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageSize"))
    
    @property
    def nextPage(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("nextPage"))
    
    


class ResourceMetadataAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResourceMetadata")
        self._properties: typing.Set[str] = set([  "fileSize",  "mimeType",  "originalName",  "linkTitle",  "linkDescription",  "linkImage",  ])
        self._props = ResourceMetadataProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResourceMetadataProperties":
        return self._props


class ResourceMetadataViewer(ResourceMetadataAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ResourceMetadataProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def fileSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fileSize"))
    
    @property
    def mimeType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("mimeType"))
    
    @property
    def originalName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("originalName"))
    
    @property
    def linkTitle(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("linkTitle"))
    
    @property
    def linkDescription(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("linkDescription"))
    
    @property
    def linkImage(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("linkImage"))
    
    


class ScheduledMessageAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessage")
        self._properties: typing.Set[str] = set([  "id",  "coachId",  "coachName",  "clientId",  "clientName",  "clientEmail",  "sessionId",  "sessionDate",  "templateUsed",  "channel",  "subject",  "body",  "scheduledFor",  "aiSuggestedTime",  "aiSuggestionReason",  "status",  "approvedAt",  "reviewedAt",  "sentAt",  "cancelledAt",  "cancellationReason",  "deliveryAttempts",  "lastDeliveryError",  "externalMessageId",  "transparencyIndicator",  "transparencyDisplayName",  "canEdit",  "canCancel",  "canSend",  "createdAt",  "updatedAt",  ])
        self._props = ScheduledMessageProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessageProperties":
        return self._props


class ScheduledMessageViewer(ScheduledMessageAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessageProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def coachName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachName"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def clientEmail(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientEmail"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def templateUsed(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("templateUsed"))
    
    @property
    def channel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("channel"))
    
    @property
    def subject(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subject"))
    
    @property
    def body(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("body"))
    
    @property
    def scheduledFor(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledFor"))
    
    @property
    def aiSuggestedTime(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("aiSuggestedTime"))
    
    @property
    def aiSuggestionReason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("aiSuggestionReason"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def approvedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("approvedAt"))
    
    @property
    def reviewedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("reviewedAt"))
    
    @property
    def sentAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sentAt"))
    
    @property
    def cancelledAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cancelledAt"))
    
    @property
    def cancellationReason(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("cancellationReason"))
    
    @property
    def deliveryAttempts(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("deliveryAttempts"))
    
    @property
    def lastDeliveryError(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastDeliveryError"))
    
    @property
    def externalMessageId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("externalMessageId"))
    
    @property
    def transparencyIndicator(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transparencyIndicator"))
    
    @property
    def transparencyDisplayName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transparencyDisplayName"))
    
    @property
    def canEdit(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("canEdit"))
    
    @property
    def canCancel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("canCancel"))
    
    @property
    def canSend(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("canSend"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    @property
    def updatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedAt"))
    
    


class ScheduledMessageAuditEntryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessageAuditEntry")
        self._properties: typing.Set[str] = set([  "id",  "messageId",  "action",  "actorId",  "actorName",  "details",  "createdAt",  ])
        self._props = ScheduledMessageAuditEntryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessageAuditEntryProperties":
        return self._props


class ScheduledMessageAuditEntryViewer(ScheduledMessageAuditEntryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessageAuditEntryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def messageId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("messageId"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def actorId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actorId"))
    
    @property
    def actorName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("actorName"))
    
    @property
    def details(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("details"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    


class ScheduledMessageEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessageEventPayload")
        self._properties: typing.Set[str] = set([  "messageId",  "clientId",  "clientName",  "channel",  "subject",  "scheduledFor",  "status",  "previousStatus",  ])
        self._props = ScheduledMessageEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessageEventPayloadProperties":
        return self._props


class ScheduledMessageEventPayloadViewer(ScheduledMessageEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessageEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def messageId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("messageId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def channel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("channel"))
    
    @property
    def subject(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subject"))
    
    @property
    def scheduledFor(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledFor"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def previousStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("previousStatus"))
    
    


class ScheduledMessageFilterAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessageFilter")
        self._properties: typing.Set[str] = set([  "status",  "channel",  "clientId",  "sessionId",  "fromDate",  "toDate",  ])
        self._props = ScheduledMessageFilterProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessageFilterProperties":
        return self._props


class ScheduledMessageFilterViewer(ScheduledMessageFilterAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessageFilterProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def channel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("channel"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def fromDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fromDate"))
    
    @property
    def toDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("toDate"))
    
    


class ScheduledMessageListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessageList")
        self._properties: typing.Set[str] = set([  "items",  "total",  "page",  "pageSize",  "hasNext",  ])
        self._props = ScheduledMessageListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessageListProperties":
        return self._props


class ScheduledMessageListViewer(ScheduledMessageListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessageListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def total(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def pageSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageSize"))
    
    @property
    def hasNext(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("hasNext"))
    
    


class ScheduledMessagePreferencesAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScheduledMessagePreferences")
        self._properties: typing.Set[str] = set([  "preSendReviewEnabled",  "preSendReviewMinutes",  "autoCancelIfClientResponds",  "defaultChannel",  "createdAt",  "updatedAt",  ])
        self._props = ScheduledMessagePreferencesProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScheduledMessagePreferencesProperties":
        return self._props


class ScheduledMessagePreferencesViewer(ScheduledMessagePreferencesAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScheduledMessagePreferencesProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def preSendReviewEnabled(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preSendReviewEnabled"))
    
    @property
    def preSendReviewMinutes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preSendReviewMinutes"))
    
    @property
    def autoCancelIfClientResponds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("autoCancelIfClientResponds"))
    
    @property
    def defaultChannel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("defaultChannel"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    @property
    def updatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedAt"))
    
    


class ScrapedCoachProfileAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ScrapedCoachProfile")
        self._properties: typing.Set[str] = set([  "source",  "sourceUrl",  "name",  "title",  "bio",  "certifications",  "specialties",  "yearsExperience",  "photoUrl",  "contactEmail",  "scrapedAt",  "confidence",  ])
        self._props = ScrapedCoachProfileProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ScrapedCoachProfileProperties":
        return self._props


class ScrapedCoachProfileViewer(ScrapedCoachProfileAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ScrapedCoachProfileProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    @property
    def sourceUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sourceUrl"))
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def bio(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("bio"))
    
    @property
    def certifications(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("certifications"))
    
    @property
    def specialties(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("specialties"))
    
    @property
    def yearsExperience(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("yearsExperience"))
    
    @property
    def photoUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("photoUrl"))
    
    @property
    def contactEmail(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contactEmail"))
    
    @property
    def scrapedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scrapedAt"))
    
    @property
    def confidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence"))
    
    


class SessionContextAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionContext")
        self._properties: typing.Set[str] = set([  "id",  "clientId",  "clientName",  "scheduledAt",  "status",  "t15Summary",  "notes",  "transcript",  "runningNotes",  ])
        self._props = SessionContextProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionContextProperties":
        return self._props


class SessionContextViewer(SessionContextAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionContextProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def scheduledAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledAt"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def t15Summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("t15Summary"))
    
    @property
    def notes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notes"))
    
    @property
    def transcript(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transcript"))
    
    @property
    def runningNotes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("runningNotes"))
    
    


class SessionEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionEventPayload")
        self._properties: typing.Set[str] = set([  "sessionId",  "clientId",  "clientName",  "status",  "scheduledAt",  ])
        self._props = SessionEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionEventPayloadProperties":
        return self._props


class SessionEventPayloadViewer(SessionEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def scheduledAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledAt"))
    
    


class SessionNotesDocumentAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesDocument")
        self._properties: typing.Set[str] = set([  "id",  "sessionId",  "clientId",  "clientName",  "sessionDate",  "sessionDuration",  "sections",  "summary",  "keyInsights",  "followUpDate",  "generatedAt",  "lastUpdatedAt",  "status",  "version",  ])
        self._props = SessionNotesDocumentProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesDocumentProperties":
        return self._props


class SessionNotesDocumentViewer(SessionNotesDocumentAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesDocumentProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def sessionDuration(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDuration"))
    
    @property
    def sections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sections"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def keyInsights(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("keyInsights"))
    
    @property
    def followUpDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("followUpDate"))
    
    @property
    def generatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generatedAt"))
    
    @property
    def lastUpdatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdatedAt"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def version(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("version"))
    
    


class SessionNotesEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesEventPayload")
        self._properties: typing.Set[str] = set([  "notesId",  "sessionId",  "clientId",  "clientName",  "sessionDate",  "action",  "status",  "previousStatus",  "sectionsCompleted",  "totalSections",  ])
        self._props = SessionNotesEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesEventPayloadProperties":
        return self._props


class SessionNotesEventPayloadViewer(SessionNotesEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def notesId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notesId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def previousStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("previousStatus"))
    
    @property
    def sectionsCompleted(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sectionsCompleted"))
    
    @property
    def totalSections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSections"))
    
    


class SessionNotesFilterAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesFilter")
        self._properties: typing.Set[str] = set([  "clientId",  "status",  "fromDate",  "toDate",  "searchQuery",  ])
        self._props = SessionNotesFilterProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesFilterProperties":
        return self._props


class SessionNotesFilterViewer(SessionNotesFilterAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesFilterProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def fromDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fromDate"))
    
    @property
    def toDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("toDate"))
    
    @property
    def searchQuery(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("searchQuery"))
    
    


class SessionNotesFinalizeRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesFinalizeRequest")
        self._properties: typing.Set[str] = set([  "notesId",  "shareWithCoachee",  "personalizedMessage",  ])
        self._props = SessionNotesFinalizeRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesFinalizeRequestProperties":
        return self._props


class SessionNotesFinalizeRequestViewer(SessionNotesFinalizeRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesFinalizeRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def notesId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notesId"))
    
    @property
    def shareWithCoachee(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("shareWithCoachee"))
    
    @property
    def personalizedMessage(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("personalizedMessage"))
    
    


class SessionNotesFinalizeResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesFinalizeResponse")
        self._properties: typing.Set[str] = set([  "success",  "status",  "sharedAt",  "error",  ])
        self._props = SessionNotesFinalizeResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesFinalizeResponseProperties":
        return self._props


class SessionNotesFinalizeResponseViewer(SessionNotesFinalizeResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesFinalizeResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def sharedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sharedAt"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class SessionNotesListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesList")
        self._properties: typing.Set[str] = set([  "items",  "total",  "page",  "pageSize",  ])
        self._props = SessionNotesListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesListProperties":
        return self._props


class SessionNotesListViewer(SessionNotesListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def total(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def pageSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageSize"))
    
    


class SessionNotesRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesRequest")
        self._properties: typing.Set[str] = set([  "sessionId",  "clientId",  "transcript",  "coachRunningNotes",  "includeSections",  "regenerate",  ])
        self._props = SessionNotesRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesRequestProperties":
        return self._props


class SessionNotesRequestViewer(SessionNotesRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def transcript(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("transcript"))
    
    @property
    def coachRunningNotes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachRunningNotes"))
    
    @property
    def includeSections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("includeSections"))
    
    @property
    def regenerate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("regenerate"))
    
    


class SessionNotesResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesResponse")
        self._properties: typing.Set[str] = set([  "success",  "document",  "error",  "warnings",  "generationTimeMs",  ])
        self._props = SessionNotesResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesResponseProperties":
        return self._props


class SessionNotesResponseViewer(SessionNotesResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def document(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("document"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    @property
    def warnings(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("warnings"))
    
    @property
    def generationTimeMs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generationTimeMs"))
    
    


class SessionNotesSummaryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionNotesSummary")
        self._properties: typing.Set[str] = set([  "id",  "sessionId",  "clientId",  "clientName",  "sessionDate",  "status",  "completedSections",  "totalSections",  "summary",  "generatedAt",  ])
        self._props = SessionNotesSummaryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionNotesSummaryProperties":
        return self._props


class SessionNotesSummaryViewer(SessionNotesSummaryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionNotesSummaryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("status"))
    
    @property
    def completedSections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completedSections"))
    
    @property
    def totalSections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSections"))
    
    @property
    def summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("summary"))
    
    @property
    def generatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generatedAt"))
    
    


class SessionSectionContentAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionSectionContent")
        self._properties: typing.Set[str] = set([  "section",  "title",  "content",  "bulletPoints",  "aiGenerated",  "coachEdited",  "lastEditedAt",  ])
        self._props = SessionSectionContentProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionSectionContentProperties":
        return self._props


class SessionSectionContentViewer(SessionSectionContentAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionSectionContentProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def section(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("section"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def bulletPoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("bulletPoints"))
    
    @property
    def aiGenerated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("aiGenerated"))
    
    @property
    def coachEdited(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachEdited"))
    
    @property
    def lastEditedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastEditedAt"))
    
    


class SessionSectionUpdateRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionSectionUpdateRequest")
        self._properties: typing.Set[str] = set([  "notesId",  "section",  "content",  "bulletPoints",  "markAsEdited",  ])
        self._props = SessionSectionUpdateRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionSectionUpdateRequestProperties":
        return self._props


class SessionSectionUpdateRequestViewer(SessionSectionUpdateRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionSectionUpdateRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def notesId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("notesId"))
    
    @property
    def section(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("section"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def bulletPoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("bulletPoints"))
    
    @property
    def markAsEdited(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("markAsEdited"))
    
    


class SessionSectionUpdateResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SessionSectionUpdateResponse")
        self._properties: typing.Set[str] = set([  "success",  "updatedSection",  "error",  ])
        self._props = SessionSectionUpdateResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SessionSectionUpdateResponseProperties":
        return self._props


class SessionSectionUpdateResponseViewer(SessionSectionUpdateResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SessionSectionUpdateResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def updatedSection(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedSection"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class StateHistoryEntryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StateHistoryEntry")
        self._properties: typing.Set[str] = set([  "id",  "userId",  "page",  "clientId",  "sessionId",  "source",  "createdAt",  ])
        self._props = StateHistoryEntryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StateHistoryEntryProperties":
        return self._props


class StateHistoryEntryViewer(StateHistoryEntryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StateHistoryEntryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def userId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("userId"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    @property
    def createdAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("createdAt"))
    
    


class StateHistoryQueryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StateHistoryQuery")
        self._properties: typing.Set[str] = set([  "userId",  "fromDate",  "toDate",  "limit",  ])
        self._props = StateHistoryQueryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StateHistoryQueryProperties":
        return self._props


class StateHistoryQueryViewer(StateHistoryQueryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StateHistoryQueryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def userId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("userId"))
    
    @property
    def fromDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("fromDate"))
    
    @property
    def toDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("toDate"))
    
    @property
    def limit(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("limit"))
    
    


class StateUpdateRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StateUpdateRequest")
        self._properties: typing.Set[str] = set([  "page",  "clientId",  "sessionId",  "availableActions",  "navigationOptions",  "source",  ])
        self._props = StateUpdateRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StateUpdateRequestProperties":
        return self._props


class StateUpdateRequestViewer(StateUpdateRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StateUpdateRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def availableActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("availableActions"))
    
    @property
    def navigationOptions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("navigationOptions"))
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    


class StateUpdateResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StateUpdateResponse")
        self._properties: typing.Set[str] = set([  "success",  "stateId",  ])
        self._props = StateUpdateResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StateUpdateResponseProperties":
        return self._props


class StateUpdateResponseViewer(StateUpdateResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class StateUpdateResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def stateId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("stateId"))
    
    


class SuggestedActionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SuggestedAction")
        self._properties: typing.Set[str] = set([  "tool",  "label",  "description",  "parameters",  "requiresConfirmation",  ])
        self._props = SuggestedActionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SuggestedActionProperties":
        return self._props


class SuggestedActionViewer(SuggestedActionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class SuggestedActionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def tool(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tool"))
    
    @property
    def label(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("label"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def requiresConfirmation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requiresConfirmation"))
    
    


class T15PrepDocumentAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("T15PrepDocument")
        self._properties: typing.Set[str] = set([  "id",  "sessionId",  "clientId",  "clientName",  "scheduledAt",  "sections",  "overallReadiness",  "generatedAt",  "lastUpdatedAt",  "version",  ])
        self._props = T15PrepDocumentProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "T15PrepDocumentProperties":
        return self._props


class T15PrepDocumentViewer(T15PrepDocumentAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class T15PrepDocumentProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def scheduledAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledAt"))
    
    @property
    def sections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sections"))
    
    @property
    def overallReadiness(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overallReadiness"))
    
    @property
    def generatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generatedAt"))
    
    @property
    def lastUpdatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdatedAt"))
    
    @property
    def version(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("version"))
    
    


class T15PrepEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("T15PrepEventPayload")
        self._properties: typing.Set[str] = set([  "prepId",  "sessionId",  "clientId",  "clientName",  "scheduledAt",  "action",  "sectionsCompleted",  "totalSections",  "overallReadiness",  ])
        self._props = T15PrepEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "T15PrepEventPayloadProperties":
        return self._props


class T15PrepEventPayloadViewer(T15PrepEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class T15PrepEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def prepId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("prepId"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def scheduledAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledAt"))
    
    @property
    def action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("action"))
    
    @property
    def sectionsCompleted(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sectionsCompleted"))
    
    @property
    def totalSections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSections"))
    
    @property
    def overallReadiness(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overallReadiness"))
    
    


class T15PrepListAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("T15PrepList")
        self._properties: typing.Set[str] = set([  "items",  "total",  "page",  "pageSize",  ])
        self._props = T15PrepListProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "T15PrepListProperties":
        return self._props


class T15PrepListViewer(T15PrepListAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class T15PrepListProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def items(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("items"))
    
    @property
    def total(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total"))
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def pageSize(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("pageSize"))
    
    


class T15PrepRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("T15PrepRequest")
        self._properties: typing.Set[str] = set([  "sessionId",  "clientId",  "includeSections",  "regenerate",  "focusAreas",  ])
        self._props = T15PrepRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "T15PrepRequestProperties":
        return self._props


class T15PrepRequestViewer(T15PrepRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class T15PrepRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def includeSections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("includeSections"))
    
    @property
    def regenerate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("regenerate"))
    
    @property
    def focusAreas(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("focusAreas"))
    
    


class T15PrepResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("T15PrepResponse")
        self._properties: typing.Set[str] = set([  "success",  "document",  "error",  "warnings",  "generationTimeMs",  ])
        self._props = T15PrepResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "T15PrepResponseProperties":
        return self._props


class T15PrepResponseViewer(T15PrepResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class T15PrepResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def document(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("document"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    @property
    def warnings(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("warnings"))
    
    @property
    def generationTimeMs(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generationTimeMs"))
    
    


class T15PrepSummaryAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("T15PrepSummary")
        self._properties: typing.Set[str] = set([  "id",  "sessionId",  "clientId",  "clientName",  "scheduledAt",  "generatedAt",  "completedSections",  "totalSections",  "overallReadiness",  ])
        self._props = T15PrepSummaryProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "T15PrepSummaryProperties":
        return self._props


class T15PrepSummaryViewer(T15PrepSummaryAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class T15PrepSummaryProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def scheduledAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledAt"))
    
    @property
    def generatedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("generatedAt"))
    
    @property
    def completedSections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("completedSections"))
    
    @property
    def totalSections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSections"))
    
    @property
    def overallReadiness(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overallReadiness"))
    
    


class T15SectionContentAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("T15SectionContent")
        self._properties: typing.Set[str] = set([  "section",  "title",  "content",  "bulletPoints",  "priority",  "aiConfidence",  ])
        self._props = T15SectionContentProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "T15SectionContentProperties":
        return self._props


class T15SectionContentViewer(T15SectionContentAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class T15SectionContentProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def section(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("section"))
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def bulletPoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("bulletPoints"))
    
    @property
    def priority(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("priority"))
    
    @property
    def aiConfidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("aiConfidence"))
    
    


class T15SectionUpdateRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("T15SectionUpdateRequest")
        self._properties: typing.Set[str] = set([  "prepId",  "section",  "content",  "bulletPoints",  "coachNotes",  ])
        self._props = T15SectionUpdateRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "T15SectionUpdateRequestProperties":
        return self._props


class T15SectionUpdateRequestViewer(T15SectionUpdateRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class T15SectionUpdateRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def prepId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("prepId"))
    
    @property
    def section(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("section"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def bulletPoints(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("bulletPoints"))
    
    @property
    def coachNotes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachNotes"))
    
    


class T15SectionUpdateResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("T15SectionUpdateResponse")
        self._properties: typing.Set[str] = set([  "success",  "updatedSection",  "error",  ])
        self._props = T15SectionUpdateResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "T15SectionUpdateResponseProperties":
        return self._props


class T15SectionUpdateResponseViewer(T15SectionUpdateResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class T15SectionUpdateResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def updatedSection(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("updatedSection"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class TonePreferenceAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TonePreference")
        self._properties: typing.Set[str] = set([  "tone",  "weight",  ])
        self._props = TonePreferenceProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TonePreferenceProperties":
        return self._props


class TonePreferenceViewer(TonePreferenceAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TonePreferenceProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def tone(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tone"))
    
    @property
    def weight(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("weight"))
    
    


class ToolDefinitionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ToolDefinition")
        self._properties: typing.Set[str] = set([  "name",  "description",  "parameters",  "requiresConfirmation",  "outputType",  ])
        self._props = ToolDefinitionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ToolDefinitionProperties":
        return self._props


class ToolDefinitionViewer(ToolDefinitionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ToolDefinitionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def parameters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("parameters"))
    
    @property
    def requiresConfirmation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requiresConfirmation"))
    
    @property
    def outputType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("outputType"))
    
    


class ToolParameterAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ToolParameter")
        self._properties: typing.Set[str] = set([  "name",  "type",  "description",  "required",  "default",  ])
        self._props = ToolParameterProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ToolParameterProperties":
        return self._props


class ToolParameterViewer(ToolParameterAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ToolParameterProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("name"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def required(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("required"))
    
    @property
    def default(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("default"))
    
    


class TransparentMessageAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TransparentMessage")
        self._properties: typing.Set[str] = set([  "content",  "indicator",  "coachName",  "approvedAt",  ])
        self._props = TransparentMessageProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TransparentMessageProperties":
        return self._props


class TransparentMessageViewer(TransparentMessageAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TransparentMessageProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def indicator(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("indicator"))
    
    @property
    def coachName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachName"))
    
    @property
    def approvedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("approvedAt"))
    
    


class UpdatePreferencesRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdatePreferencesRequest")
        self._properties: typing.Set[str] = set([  "preSendReviewEnabled",  "preSendReviewMinutes",  "autoCancelIfClientResponds",  "defaultChannel",  ])
        self._props = UpdatePreferencesRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdatePreferencesRequestProperties":
        return self._props


class UpdatePreferencesRequestViewer(UpdatePreferencesRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UpdatePreferencesRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def preSendReviewEnabled(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preSendReviewEnabled"))
    
    @property
    def preSendReviewMinutes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("preSendReviewMinutes"))
    
    @property
    def autoCancelIfClientResponds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("autoCancelIfClientResponds"))
    
    @property
    def defaultChannel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("defaultChannel"))
    
    


class UpdateResourceRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdateResourceRequest")
        self._properties: typing.Set[str] = set([  "title",  "description",  "tags",  "externalUrl",  ])
        self._props = UpdateResourceRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdateResourceRequestProperties":
        return self._props


class UpdateResourceRequestViewer(UpdateResourceRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UpdateResourceRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def title(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("title"))
    
    @property
    def description(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("description"))
    
    @property
    def tags(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tags"))
    
    @property
    def externalUrl(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("externalUrl"))
    
    


class UpdateScheduledMessageRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdateScheduledMessageRequest")
        self._properties: typing.Set[str] = set([  "subject",  "body",  "scheduledFor",  "channel",  ])
        self._props = UpdateScheduledMessageRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdateScheduledMessageRequestProperties":
        return self._props


class UpdateScheduledMessageRequestViewer(UpdateScheduledMessageRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UpdateScheduledMessageRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def subject(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subject"))
    
    @property
    def body(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("body"))
    
    @property
    def scheduledFor(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("scheduledFor"))
    
    @property
    def channel(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("channel"))
    
    


class UserActiveStateAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UserActiveState")
        self._properties: typing.Set[str] = set([  "page",  "clientId",  "clientName",  "sessionId",  "sessionDate",  "availableActions",  "navigationOptions",  "source",  "lastUpdated",  ])
        self._props = UserActiveStateProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UserActiveStateProperties":
        return self._props


class UserActiveStateViewer(UserActiveStateAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class UserActiveStateProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def page(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("page"))
    
    @property
    def clientId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientId"))
    
    @property
    def clientName(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("clientName"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def sessionDate(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionDate"))
    
    @property
    def availableActions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("availableActions"))
    
    @property
    def navigationOptions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("navigationOptions"))
    
    @property
    def source(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("source"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class VoiceCorrectionAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceCorrection")
        self._properties: typing.Set[str] = set([  "id",  "originalContent",  "editedContent",  "editType",  "coachFeedback",  "contentType",  "sessionId",  "timestamp",  ])
        self._props = VoiceCorrectionProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceCorrectionProperties":
        return self._props


class VoiceCorrectionViewer(VoiceCorrectionAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceCorrectionProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def originalContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("originalContent"))
    
    @property
    def editedContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editedContent"))
    
    @property
    def editType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editType"))
    
    @property
    def coachFeedback(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachFeedback"))
    
    @property
    def contentType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contentType"))
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def timestamp(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timestamp"))
    
    


class VoiceCorrectionRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceCorrectionRequest")
        self._properties: typing.Set[str] = set([  "sessionId",  "originalContent",  "editedContent",  "editType",  "coachFeedback",  "contentType",  ])
        self._props = VoiceCorrectionRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceCorrectionRequestProperties":
        return self._props


class VoiceCorrectionRequestViewer(VoiceCorrectionRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceCorrectionRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def sessionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sessionId"))
    
    @property
    def originalContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("originalContent"))
    
    @property
    def editedContent(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editedContent"))
    
    @property
    def editType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("editType"))
    
    @property
    def coachFeedback(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachFeedback"))
    
    @property
    def contentType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contentType"))
    
    


class VoiceCorrectionResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceCorrectionResponse")
        self._properties: typing.Set[str] = set([  "success",  "voiceConfidenceAfter",  "improvementNote",  "correctionId",  ])
        self._props = VoiceCorrectionResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceCorrectionResponseProperties":
        return self._props


class VoiceCorrectionResponseViewer(VoiceCorrectionResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceCorrectionResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def voiceConfidenceAfter(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceConfidenceAfter"))
    
    @property
    def improvementNote(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("improvementNote"))
    
    @property
    def correctionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("correctionId"))
    
    


class VoiceEventPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceEventPayload")
        self._properties: typing.Set[str] = set([  "correctionId",  "voiceConfidence",  "contentType",  ])
        self._props = VoiceEventPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceEventPayloadProperties":
        return self._props


class VoiceEventPayloadViewer(VoiceEventPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceEventPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def correctionId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("correctionId"))
    
    @property
    def voiceConfidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceConfidence"))
    
    @property
    def contentType(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("contentType"))
    
    


class VoiceProfileAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceProfile")
        self._properties: typing.Set[str] = set([  "coachId",  "voiceConfidence",  "totalCorrections",  "vocabularyPatterns",  "avoidPatterns",  "tonePreferences",  "recentEdits",  "lastTrainedAt",  ])
        self._props = VoiceProfileProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceProfileProperties":
        return self._props


class VoiceProfileViewer(VoiceProfileAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceProfileProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def voiceConfidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceConfidence"))
    
    @property
    def totalCorrections(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalCorrections"))
    
    @property
    def vocabularyPatterns(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("vocabularyPatterns"))
    
    @property
    def avoidPatterns(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("avoidPatterns"))
    
    @property
    def tonePreferences(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tonePreferences"))
    
    @property
    def recentEdits(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recentEdits"))
    
    @property
    def lastTrainedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastTrainedAt"))
    
    


class VoiceProfileConfigAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceProfileConfig")
        self._properties: typing.Set[str] = set([  "coachId",  "minSamplesRequired",  "currentSampleCount",  "sampleTypes",  "trainingStatus",  "estimatedConfidence",  "canStartTraining",  "lastUpdated",  ])
        self._props = VoiceProfileConfigProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceProfileConfigProperties":
        return self._props


class VoiceProfileConfigViewer(VoiceProfileConfigAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceProfileConfigProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def minSamplesRequired(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("minSamplesRequired"))
    
    @property
    def currentSampleCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("currentSampleCount"))
    
    @property
    def sampleTypes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sampleTypes"))
    
    @property
    def trainingStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("trainingStatus"))
    
    @property
    def estimatedConfidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("estimatedConfidence"))
    
    @property
    def canStartTraining(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("canStartTraining"))
    
    @property
    def lastUpdated(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("lastUpdated"))
    
    


class VoiceSampleAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceSample")
        self._properties: typing.Set[str] = set([  "id",  "coachId",  "type",  "content",  "context",  "isPreferred",  "submittedAt",  "processedAt",  "processingStatus",  ])
        self._props = VoiceSampleProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceSampleProperties":
        return self._props


class VoiceSampleViewer(VoiceSampleAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceSampleProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def id(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("id"))
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def isPreferred(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("isPreferred"))
    
    @property
    def submittedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("submittedAt"))
    
    @property
    def processedAt(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("processedAt"))
    
    @property
    def processingStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("processingStatus"))
    
    


class VoiceSampleInputAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceSampleInput")
        self._properties: typing.Set[str] = set([  "type",  "content",  "context",  "isPreferred",  ])
        self._props = VoiceSampleInputProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceSampleInputProperties":
        return self._props


class VoiceSampleInputViewer(VoiceSampleInputAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceSampleInputProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    @property
    def content(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("content"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def isPreferred(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("isPreferred"))
    
    


class VoiceSampleSubmitRequestAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceSampleSubmitRequest")
        self._properties: typing.Set[str] = set([  "samples",  ])
        self._props = VoiceSampleSubmitRequestProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceSampleSubmitRequestProperties":
        return self._props


class VoiceSampleSubmitRequestViewer(VoiceSampleSubmitRequestAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceSampleSubmitRequestProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def samples(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("samples"))
    
    


class VoiceSampleSubmitResponseAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceSampleSubmitResponse")
        self._properties: typing.Set[str] = set([  "success",  "submittedCount",  "sampleIds",  "voiceProfileStatus",  "minimumSamplesRequired",  "currentSampleCount",  "error",  ])
        self._props = VoiceSampleSubmitResponseProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceSampleSubmitResponseProperties":
        return self._props


class VoiceSampleSubmitResponseViewer(VoiceSampleSubmitResponseAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceSampleSubmitResponseProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def success(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success"))
    
    @property
    def submittedCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("submittedCount"))
    
    @property
    def sampleIds(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sampleIds"))
    
    @property
    def voiceProfileStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceProfileStatus"))
    
    @property
    def minimumSamplesRequired(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("minimumSamplesRequired"))
    
    @property
    def currentSampleCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("currentSampleCount"))
    
    @property
    def error(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("error"))
    
    


class VoiceSamplesPayloadAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("VoiceSamplesPayload")
        self._properties: typing.Set[str] = set([  "coachId",  "sampleCount",  "totalSamples",  "sampleTypes",  "voiceProfileStatus",  ])
        self._props = VoiceSamplesPayloadProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "VoiceSamplesPayloadProperties":
        return self._props


class VoiceSamplesPayloadViewer(VoiceSamplesPayloadAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class VoiceSamplesPayloadProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def coachId(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("coachId"))
    
    @property
    def sampleCount(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sampleCount"))
    
    @property
    def totalSamples(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("totalSamples"))
    
    @property
    def sampleTypes(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("sampleTypes"))
    
    @property
    def voiceProfileStatus(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("voiceProfileStatus"))
    
    

