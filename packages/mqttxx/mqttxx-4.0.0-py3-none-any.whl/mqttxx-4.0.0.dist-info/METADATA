Metadata-Version: 2.1
Name: mqttxx
Version: 4.0.0
Summary: 基于 aiomqtt 的高级 MQTT 客户端和 RPC 框架
Author: MQTTX Team
License: MIT
Keywords: mqtt,rpc,async,iot,messaging
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: aiomqtt <3.0.0,>=2.0.0
Requires-Dist: loguru >=0.7.0
Provides-Extra: dev
Requires-Dist: pytest ; extra == 'dev'
Requires-Dist: pytest-asyncio ; extra == 'dev'
Requires-Dist: pytest-rich ; extra == 'dev'
Requires-Dist: pydantic ; extra == 'dev'
Requires-Dist: ruff ; extra == 'dev'
Requires-Dist: build ; extra == 'dev'
Requires-Dist: twine ; extra == 'dev'

# MQTTX

[![PyPI version](https://img.shields.io/badge/version-4.0.0-blue.svg)](https://pypi.org/project/mqttxx/)
[![Python](https://img.shields.io/badge/python-3.10+-blue.svg)](https://www.python.org/downloads/)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)

基于 [aiomqtt](https://github.com/sbtinstruments/aiomqtt) 的高级 MQTT 5.0 客户端和 RPC 框架。

## 核心特性

- ✅ **纯 async/await** - 无回调，代码清晰
- ✅ **MQTT 5.0 原生** - 使用 ResponseTopic/CorrelationData，符合协议标准
- ✅ **双向对等 RPC** - 自动订阅、超时管理、离线检测
- ✅ **Event Channel** - 高吞吐事件广播，支持通配符订阅
- ✅ **自动重连** - 订阅队列化，断线重连
- ✅ **基础认证** - 用户名/密码认证
- ✅ **完善异常系统** - 统一错误码、清晰的异常层次

---

## 目录

- [MQTT 5.0 原生支持](#mqtt-50-原生支持)
- [安装](#安装)
- [快速开始](#快速开始)
  - [MQTT 基础用法](#1-mqtt-基础用法)
  - [RPC 调用](#2-rpc-调用)
  - [Event Channel（事件广播）](#3-event-channel事件广播)
- [API 速查](#api-速查)
- [配置对象](#配置对象)
- [异常系统](#异常系统)
- [版本变更](#版本变更)
- [开发](#开发)
- [常见问题](#常见问题)

---

## MQTT 5.0 原生支持

**mqttx 4.0.0 全面使用 MQTT 5.0 原生字段**，充分利用协议标准特性。

### RPC 协议设计

使用 MQTT 5.0 原生字段实现请求-响应模式：

| 元数据 | MQTT 5.0 字段 | 说明 |
|--------|--------------|------|
| 响应主题 | ResponseTopic | `reply_to`，指定响应接收地址 |
| 关联数据 | CorrelationData | `request_id`，匹配请求和响应 |
| 调用者 ID | UserProperty | `caller_id`，应用级元数据 |

### 消息格式

**RPC 请求（MQTT 5.0）**：
```
Properties:
  ResponseTopic: "rpc/r/client_123"
  CorrelationData: "uuid-string"
  UserProperty: [("caller_id", "client_456")]

Payload:
{
  "method": "get_status",
  "params": {"id": 123}
}
```

**RPC 响应（MQTT 5.0）**：
```
Properties:
  CorrelationData: "uuid-string"

Payload:
{
  "result": {"status": "online"}
}
```

### 优势

- ✅ **协议标准化** - 符合 MQTT 5.0 规范
- ✅ **Payload 纯净** - 只包含业务数据
- ✅ **元数据分离** - 协议级字段与业务数据分离
- ✅ **离线检测** - 通过 PUBACK 原因码识别无订阅者

### 详细文档

查看 [MQTT 5.0 新特性详解](docs/mqtt5_features.md) 了解：
- 14 个核心新特性的详细说明
- 使用场景和最佳实践
- mqttx 对各特性的支持状态

---

## 安装

```bash
pip install mqttxx
```

**要求**:
- Python >= 3.10
- aiomqtt >= 2.0.0
- loguru >= 0.7.0
- paho-mqtt >= 2.0.0

---

## 快速开始

### 1. MQTT 基础用法

```python
import asyncio
from mqttxx import MQTTClient, MQTTConfig

async def main():
    config = MQTTConfig(
        broker_host="localhost",
        broker_port=1883,
        client_id="device_123"
    )

    async with MQTTClient(config) as client:
        # 订阅主题
        def on_message(topic, payload, properties):
            from mqttxx.properties import extract_payload
            data = extract_payload(payload)
            print(f"{topic}: {data}")

        client.subscribe("sensors/#", on_message)

        # 发布消息
        from mqttxx.properties import encode_payload_with_properties
        payload, properties = encode_payload_with_properties(
            {"value": 25.5, "unit": "C"}
        )
        await client.publish("sensors/temperature", payload, properties)

        await asyncio.sleep(60)

asyncio.run(main())
```

---

### 2. RPC 调用

**mqttx RPC 使用自动订阅和懒加载机制**，无需手动配置响应主题。

#### 边缘设备

```python
from mqttxx import MQTTClient, MQTTConfig, RPCManager

async def edge_device():
    config = MQTTConfig(
        broker_host="localhost",
        client_id="device_123"
    )

    async with MQTTClient(config) as client:
        # 响应主题自动生成为 rpc/r/device_123
        rpc = RPCManager(client)

        # 注册本地方法
        @rpc.register("get_status")
        async def get_status(params):
            return {"status": "online", "cpu": 45.2}

        # 调用云端服务（自动订阅 + 自动注入 reply_to）
        config = await rpc.call("cloud/config-service", "get_config")
        print(config)

        await asyncio.sleep(60)
```

#### 云端服务

```python
from mqttxx import MQTTClient, MQTTConfig, RPCManager

async def cloud_service():
    config = MQTTConfig(
        broker_host="localhost",
        client_id="config-service"
    )

    async with MQTTClient(config) as client:
        # 响应主题自动生成为 rpc/r/config-service
        rpc = RPCManager(client)

        @rpc.register("get_config")
        async def get_config(params):
            return {"update_interval": 60, "servers": ["s1", "s2"]}

        # 调用边缘设备
        status = await rpc.call("device_123", "get_status")
        print(status)

        await asyncio.sleep(60)
```

**自动行为**：
- 响应主题：`rpc/r/{client_id}`（自动生成）
- 自动订阅：首次调用时自动订阅响应主题（懒加载）
- 自动注入：调用时自动注入 `reply_to` 和 `caller_id`
- 离线检测：PUBACK 原因码 0x10 时快速失败

---

### 3. Event Channel（事件广播）

**Event Channel 是高吞吐、低耦合、无返回值的事件广播通道**。

```python
from mqttxx import MQTTClient, MQTTConfig, EventChannelManager, EventMessage

async def main():
    config = MQTTConfig(broker_host="localhost", client_id="device_001")

    async with MQTTClient(config) as client:
        events = EventChannelManager(client)

        # 订阅事件（支持通配符）
        @events.subscribe("sensors/+/temperature")
        async def on_temperature(topic, data, properties):
            print(f"[温度] {topic}: {data}")

        # 发布结构化事件
        await events.publish(
            "sensors/room1/temperature",
            EventMessage(
                event_type="temperature.changed",
                data={"value": 25.5, "unit": "C"},
                source="sensor_001"
            )
        )

        # 发布原始消息
        await events.publish(
            "sensors/room1/humidity",
            {"value": 60.2, "unit": "%"}
        )

        await asyncio.sleep(60)

asyncio.run(main())
```

**Event Channel vs RPC**：

| 特性 | Event Channel | RPC |
|------|--------------|-----|
| 模式 | 发布-订阅（Pub-Sub） | 请求-响应（Request-Response） |
| 通信 | 单向，一对多广播 | 双向，点对点 |
| 返回值 | ❌ 无返回值 | ✅ 等待返回结果 |
| 用途 | 高频事件流、监控数据 | 远程方法调用、配置查询 |
| 通配符 | ✅ 支持 `+/#` | ❌ 精确匹配 |

---

## API 速查

### MQTTClient

```python
class MQTTClient:
    def __init__(self, config: MQTTConfig)
    async def __aenter__(self) -> MQTTClient
    async def __aexit__(self, *args)
    async def subscribe(self, topic: str, handler: Callable) -> None
    async def publish(self, topic: str, payload: bytes, properties) -> None

    @property
    def is_connected(self) -> bool
```

### RPCManager

```python
class RPCManager:
    def __init__(self, client: MQTTClient)

    @property
    def my_topic: str  # 响应主题（自动生成，只读）

    def register(self, method_name: str)  # 装饰器
    def unregister(self, method_name: str) -> None

    async def call(
        self,
        topic: str,        # 目标 topic
        method: str,       # 方法名
        params: Any = None,
        timeout: float = 30.0,
    ) -> Any
```

### EventChannelManager

```python
class EventChannelManager:
    def __init__(self, client: MQTTClient, auto_import: bool = True)

    def subscribe(
        self,
        pattern: str,           # MQTT topic 模式（支持通配符 +/#）
        handler: Optional[EventHandler] = None
    ) -> Callable  # 装饰器或直接注册

    def unsubscribe(self, pattern: str, handler: EventHandler) -> None

    async def publish(
        self,
        topic: str,
        message: EventMessage | dict | Any,
        qos: int = 0
    ) -> None
```

### Properties 工具

```python
from mqttxx.properties import (
    encode_payload_with_properties,  # 编码 payload + User Properties
    extract_payload,                  # 从 payload 提取数据
    get_property,                     # 获取单个 User Property
)
```

---

## 配置对象

### MQTTConfig

```python
@dataclass
class MQTTConfig:
    broker_host: str
    broker_port: int = 1883
    client_id: str = ""                    # 空字符串 = 自动生成
    keepalive: int = 60
    username: Optional[str] = None
    password: Optional[str] = None
    protocol: int = MQTTv5                 # MQTT 5.0
    clean_start: Union[bool, int] = MQTT_CLEAN_START_FIRST_ONLY
    reconnect: ReconnectConfig = field(default_factory=ReconnectConfig)
    max_queued_messages: int = 0           # 0 = 无限
```

### ReconnectConfig

```python
@dataclass
class ReconnectConfig:
    enabled: bool = True
    interval: int = 5                      # 初始重连间隔（秒）
    max_attempts: int = 0                  # 0 = 无限重试
    backoff_multiplier: float = 1.5        # 指数退避倍数
    max_interval: int = 60                 # 最大重连间隔（秒）
```

---

## 异常系统

```python
# 基础异常
class MQTTXError(Exception)
class MessageError(MQTTXError)
class RPCError(MQTTXError)

# RPC 异常
class RPCTimeoutError(MQTTXError)            # RPC 调用超时
class RPCRemoteError(MQTTXError)             # 远程方法执行失败

# 错误码
class ErrorCode(IntEnum):
    NOT_CONNECTED = 1001
    RPC_TIMEOUT = 3002
    # ... 更多错误码见源码
```

**使用示例**：

```python
from mqttxx import RPCTimeoutError, RPCRemoteError

try:
    result = await rpc.call("topic", "method", timeout=5)
except RPCTimeoutError:
    print("调用超时")
except RPCRemoteError as e:
    print(f"远程方法执行失败: {e}")
```

---

## 版本变更

### v4.0.0（当前版本）

**重大升级：MQTT 5.0 原生字段**

1. **RPC 协议重构** - 使用 MQTT 5.0 原生字段
   - `ResponseTopic` 替代 User Properties 存储 `reply_to`
   - `CorrelationData` 替代 User Properties 存储 `request_id`
   - Payload 纯净，只包含业务数据

2. **架构简化**
   - ✅ 移除 RPC 权限控制（`auth_callback`）
   - ✅ 移除消息队列架构，改用直接并发处理
   - ✅ 新增 `mqttxx.properties` 模块（MQTT 5.0 Properties 工具）

3. **自动订阅增强**
   - 响应主题自动生成为 `rpc/r/{client_id}`
   - 首次调用时懒加载订阅
   - 离线检测（PUBACK 原因码 0x10）

**迁移指南（从 v3.x）**：

RPC 调用保持兼容，无需修改代码：

```python
# v3.x 和 v4.0.0 代码相同
rpc = RPCManager(client)
result = await rpc.call("cloud/server", "get_config")
```

内部实现已升级为 MQTT 5.0 原生字段，享受标准化优势。

---

### v2.0.0 重大变更

从 v2.0.0 开始，完全重写为基于 aiomqtt（纯 async/await），**不兼容** v0.x.x（gmqtt）。

**主要变化：**
- ✅ aiomqtt 替代 gmqtt
- ✅ 原生 dataclass 替代 python-box（性能提升 6 倍）
- ✅ 新增约定式 RPC（自动订阅 + 自动注入 reply_to）
- ✅ 新增 TLS/SSL 支持

---

## 开发

```bash
# 克隆项目
git clone <repository-url>
cd mqttx

# 安装开发依赖
pip install -e ".[dev]"

# 运行测试
pytest tests/ -v

# 代码检查和格式化
make lint    # 代码检查
make format  # 代码格式化
```

---

## 常见问题

### Q: 如何处理断线重连？

A: MQTTClient 默认启用自动重连，配置参数在 `ReconnectConfig` 中：

```python
config = MQTTConfig(
    broker_host="localhost",
    reconnect=ReconnectConfig(
        enabled=True,
        interval=5,           # 初始重连间隔
        max_attempts=0,       # 0 = 无限重试
        backoff_multiplier=1.5,
        max_interval=60
    )
)
```

### Q: RPC 调用超时了怎么办？

A: 捕获 `RPCTimeoutError` 异常并处理：

```python
from mqttxx import RPCTimeoutError

try:
    result = await rpc.call("topic", "method", timeout=5)
except RPCTimeoutError:
    print("RPC 调用超时，请检查远程服务是否在线")
```

### Q: RPC 如何检测对方离线？

A: v4.0.0 使用 MQTT 5.0 PUBACK 原因码检测无订阅者：

- 原因码 `0x10`（No matching subscribers）→ 快速失败
- 1 秒内返回 `RPCTimeoutError`，无需等待完整超时

### Q: 如何实现双向认证（mTLS）？

A: 配置 TLS 证书和密钥：

```python
config = MQTTConfig(
    broker_host="secure.mqtt.example.com",
    broker_port=8883,
    tls=TLSConfig(
        enabled=True,
        ca_certs=Path("ca.crt"),
        certfile=Path("client.crt"),
        keyfile=Path("client.key"),
    )
)
```

### Q: RPC 和 Event Channel 如何选择？

A:
- **RPC**: 需要返回值的远程方法调用（配置查询、命令执行）
- **Event Channel**: 高频事件流、监控数据（温度、湿度、心跳）

两者可以同时使用：

```python
rpc = RPCManager(client)
events = EventChannelManager(client)

# RPC: 获取配置（需要返回值）
config = await rpc.call("server/config", "get_config")

# Event: 发布心跳（无返回值）
await events.publish(
    "device/heartbeat",
    EventMessage(event_type="heartbeat", data={"cpu": 45.2})
)
```

---

## 示例项目

查看 [examples/](examples/) 目录获取完整示例：

- **conventional_rpc_generic.py** - RPC 完整示例
- **event_channel_basic.py** - Event Channel 基础示例
- **rpc_event_mixed.py** - RPC 和 Event Channel 混合使用

---

## License

MIT
