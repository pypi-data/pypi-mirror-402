# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fb_xnnpack

import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from flatbuffers.table import Table
from typing import Optional
np = import_numpy()

class XNNDatatype(object):
    # Invalid data type. Valid Values never have this datatype.
    xnn_datatype_invalid = 0
    # IEEE754 single-precision floating-point.
    xnn_datatype_fp32 = 1
    # IEEE754 half-precision floating-point.
    xnn_datatype_fp16 = 2
    # Quantized 8-bit signed integer with shared per-Value quantization parameters.
    xnn_datatype_qint8 = 3
    # Quantized 8-bit unsigned integer with shared per-Value quantization parameters.
    xnn_datatype_quint8 = 4
    # Quantized 32-bit signed integer with shared per-Value quantization parameters.
    xnn_datatype_qint32 = 5
    # Quantized 8-bit signed integer with shared per-channel quantization parameters.
    xnn_datatype_qcint8 = 6
    # Quantized 32-bit signed integer with shared per-channel quantization parameters.
    xnn_datatype_qcint32 = 7
    # Quantized 4-bit signed integer with shared per-channel quantization parameters.
    xnn_datatype_qcint4 = 8
    # Dynamically quantized 8-bit signed integer with per-batch quantization parameters.
    xnn_datatype_qdint8 = 9
    # Quantized 4-bit signed integer with shared blockwise quantization parameters.
    xnn_datatype_qbint4 = 10
    # Dynamically quantized 8-bit signed integers packed with their per-row
    # quantization parameters.
    xnn_datatype_qpint8 = 11
    # 32-bit signed integers.
    xnn_datatype_int32 = 12
    # IEEE754 single-precision packed floating-point.
    xnn_datatype_pfp32 = 13
    # BFloat16, i.e. the upper 16 bits of a float32.
    xnn_datatype_bf16 = 14


class XNNQuantParams(object):
    NONE = 0
    PerChannelQuant = 1
    PerTensorQuant = 2
    PerTokenDynamicQuant = 3
    PerChannelGroupQuant = 4

def XnnquantParamsCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == XNNQuantParams.PerChannelQuant:
        return PerChannelQuantT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNNQuantParams.PerTensorQuant:
        return PerTensorQuantT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNNQuantParams.PerTokenDynamicQuant:
        return PerTokenDynamicQuantT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNNQuantParams.PerChannelGroupQuant:
        return PerChannelGroupQuantT.InitFromBuf(table.Bytes, table.Pos)
    return None


class XNodeUnion(object):
    NONE = 0
    XNNAdd = 1
    XNNFullyConnected = 2
    XNNSoftmax = 3
    XNNSigmoid = 4
    XNNStaticTranspose = 5
    XNNClamp = 6
    XNNConv2d = 7
    XNNDiv = 8
    XNNStaticResizeBilinear2D = 9
    XNNStaticConstantPad = 10
    XNNAvgPooling2d = 11
    XNNMinimum = 12
    XNNDepthwiseConv2d = 13
    XNNMaxPooling2d = 14
    XNNMultiply = 15
    XNNSubtract = 16
    XNNFloor = 17
    XNNConvert = 18
    XNNGlobalAvgPooling2d = 19
    XNNStaticReshape = 20
    XNNArgMaxPooling2d = 21
    XNNSquareRoot = 22
    XNNCeiling = 23
    XNNHardswish = 24
    XNNLeakyReLU = 25
    XNNMaximum = 26
    XNNNegate = 27
    XNNSquare = 28
    XNNELU = 29
    XNNAbs = 30
    XNNPReLU = 31
    XNNConcatenate2 = 32
    XNNConcatenate3 = 33
    XNNConcatenate4 = 34
    XNNStaticSlice = 35
    XNNScaledDotProductAttention = 36
    XNNBatchMatrixMultiply = 37
    XNNConcatenate5 = 38
    XNNConvTranspose2d = 39
    XNNReciprocalSquareRoot = 40
    XNNLog = 41
    XNNGelu = 42
    XNNTanh = 43
    XNNExp = 44

def XnodeUnionCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == XNodeUnion.XNNAdd:
        return _XNNNode2x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNFullyConnected:
        return XNNFullyConnectedT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNSoftmax:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNSigmoid:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNStaticTranspose:
        return XNNStaticTransposeT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNClamp:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNConv2d:
        return _XNNNodeConvT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNDiv:
        return _XNNNode2x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNStaticResizeBilinear2D:
        return XNNStaticResizeBilinear2DT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNStaticConstantPad:
        return XNNStaticConstantPadT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNAvgPooling2d:
        return _XNNPooling2DT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNMinimum:
        return _XNNNode2x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNDepthwiseConv2d:
        return _XNNNodeConvT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNMaxPooling2d:
        return _XNNPooling2DT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNMultiply:
        return _XNNNode2x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNSubtract:
        return _XNNNode2x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNFloor:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNConvert:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNGlobalAvgPooling2d:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNStaticReshape:
        return XNNStaticReshapeT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNArgMaxPooling2d:
        return XNNArgMaxPooling2dT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNSquareRoot:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNCeiling:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNHardswish:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNLeakyReLU:
        return XNNLeakyReLUT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNMaximum:
        return _XNNNode2x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNNegate:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNSquare:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNELU:
        return XNNELUT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNAbs:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNPReLU:
        return _XNNNode2x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNConcatenate2:
        return _XNNCatT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNConcatenate3:
        return _XNNCatT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNConcatenate4:
        return _XNNCatT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNStaticSlice:
        return XNNStaticSliceT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNScaledDotProductAttention:
        return XNNScaledDotProductAttentionT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNBatchMatrixMultiply:
        return _XNNNode2x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNConcatenate5:
        return _XNNCatT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNConvTranspose2d:
        return _XNNNodeConvT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNReciprocalSquareRoot:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNLog:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNGelu:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNTanh:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XNodeUnion.XNNExp:
        return _XNNNode1x1T.InitFromBuf(table.Bytes, table.Pos)
    return None


class XValueUnion(object):
    NONE = 0
    XNNTensorValue = 1
    XNNQuantizedTensorValue = 2

def XvalueUnionCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == XValueUnion.XNNTensorValue:
        return XNNTensorValueT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == XValueUnion.XNNQuantizedTensorValue:
        return XNNQuantizedTensorValueT.InitFromBuf(table.Bytes, table.Pos)
    return None


class Buffer(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Buffer()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBuffer(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def BufferBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # Buffer
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

def BufferStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def BufferEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class BufferT(object):

    # BufferT
    def __init__(
        self,
    ):
        pass

    @classmethod
    def InitFromBuf(cls, buf, pos):
        buffer = Buffer()
        buffer.Init(buf, pos)
        return cls.InitFromObj(buffer)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, buffer):
        x = BufferT()
        x._UnPack(buffer)
        return x

    # BufferT
    def _UnPack(self, buffer):
        if buffer is None:
            return

    # BufferT
    def Pack(self, builder):
        BufferStart(builder)
        buffer = BufferEnd(builder)
        return buffer


class PerChannelGroupQuant(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = PerChannelGroupQuant()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsPerChannelGroupQuant(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def PerChannelGroupQuantBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # PerChannelGroupQuant
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # PerChannelGroupQuant
    def Scale(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # PerChannelGroupQuant
    def ScaleAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # PerChannelGroupQuant
    def ScaleLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # PerChannelGroupQuant
    def ScaleIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # PerChannelGroupQuant
    def ChannelDim(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # PerChannelGroupQuant
    def GroupSize(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # PerChannelGroupQuant
    def ScaleBufferIdx(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # PerChannelGroupQuant
    def NumScales(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def PerChannelGroupQuantStart(builder: flatbuffers.Builder):
    builder.StartObject(6)

def PerChannelGroupQuantAddScale(builder: flatbuffers.Builder, scale: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(scale), 0)

def PerChannelGroupQuantStartScaleVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def PerChannelGroupQuantAddChannelDim(builder: flatbuffers.Builder, channelDim: int):
    builder.PrependInt32Slot(1, channelDim, 0)

def PerChannelGroupQuantAddGroupSize(builder: flatbuffers.Builder, groupSize: int):
    builder.PrependInt32Slot(2, groupSize, 0)

def PerChannelGroupQuantAddScaleBufferIdx(builder: flatbuffers.Builder, scaleBufferIdx: int):
    builder.PrependUint32Slot(4, scaleBufferIdx, 0)

def PerChannelGroupQuantAddNumScales(builder: flatbuffers.Builder, numScales: int):
    builder.PrependUint32Slot(5, numScales, 0)

def PerChannelGroupQuantEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class PerChannelGroupQuantT(object):

    # PerChannelGroupQuantT
    def __init__(
        self,
        scale = None,
        channelDim = 0,
        groupSize = 0,
        scaleBufferIdx = 0,
        numScales = 0,
    ):
        self.scale = scale  # type: Optional[List[float]]
        self.channelDim = channelDim  # type: int
        self.groupSize = groupSize  # type: int
        self.scaleBufferIdx = scaleBufferIdx  # type: int
        self.numScales = numScales  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        perChannelGroupQuant = PerChannelGroupQuant()
        perChannelGroupQuant.Init(buf, pos)
        return cls.InitFromObj(perChannelGroupQuant)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, perChannelGroupQuant):
        x = PerChannelGroupQuantT()
        x._UnPack(perChannelGroupQuant)
        return x

    # PerChannelGroupQuantT
    def _UnPack(self, perChannelGroupQuant):
        if perChannelGroupQuant is None:
            return
        if not perChannelGroupQuant.ScaleIsNone():
            if np is None:
                self.scale = []
                for i in range(perChannelGroupQuant.ScaleLength()):
                    self.scale.append(perChannelGroupQuant.Scale(i))
            else:
                self.scale = perChannelGroupQuant.ScaleAsNumpy()
        self.channelDim = perChannelGroupQuant.ChannelDim()
        self.groupSize = perChannelGroupQuant.GroupSize()
        self.scaleBufferIdx = perChannelGroupQuant.ScaleBufferIdx()
        self.numScales = perChannelGroupQuant.NumScales()

    # PerChannelGroupQuantT
    def Pack(self, builder):
        if self.scale is not None:
            if np is not None and type(self.scale) is np.ndarray:
                scale = builder.CreateNumpyVector(self.scale)
            else:
                PerChannelGroupQuantStartScaleVector(builder, len(self.scale))
                for i in reversed(range(len(self.scale))):
                    builder.PrependFloat32(self.scale[i])
                scale = builder.EndVector()
        PerChannelGroupQuantStart(builder)
        if self.scale is not None:
            PerChannelGroupQuantAddScale(builder, scale)
        PerChannelGroupQuantAddChannelDim(builder, self.channelDim)
        PerChannelGroupQuantAddGroupSize(builder, self.groupSize)
        PerChannelGroupQuantAddScaleBufferIdx(builder, self.scaleBufferIdx)
        PerChannelGroupQuantAddNumScales(builder, self.numScales)
        perChannelGroupQuant = PerChannelGroupQuantEnd(builder)
        return perChannelGroupQuant


class PerChannelQuant(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = PerChannelQuant()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsPerChannelQuant(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def PerChannelQuantBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # PerChannelQuant
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # PerChannelQuant
    def Scale(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # PerChannelQuant
    def ScaleAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # PerChannelQuant
    def ScaleLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # PerChannelQuant
    def ScaleIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # PerChannelQuant
    def ChannelDim(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # PerChannelQuant
    def ScaleBufferIdx(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # PerChannelQuant
    def NumScales(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def PerChannelQuantStart(builder: flatbuffers.Builder):
    builder.StartObject(4)

def PerChannelQuantAddScale(builder: flatbuffers.Builder, scale: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(scale), 0)

def PerChannelQuantStartScaleVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def PerChannelQuantAddChannelDim(builder: flatbuffers.Builder, channelDim: int):
    builder.PrependInt32Slot(1, channelDim, 0)

def PerChannelQuantAddScaleBufferIdx(builder: flatbuffers.Builder, scaleBufferIdx: int):
    builder.PrependUint32Slot(2, scaleBufferIdx, 0)

def PerChannelQuantAddNumScales(builder: flatbuffers.Builder, numScales: int):
    builder.PrependUint32Slot(3, numScales, 0)

def PerChannelQuantEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class PerChannelQuantT(object):

    # PerChannelQuantT
    def __init__(
        self,
        scale = None,
        channelDim = 0,
        scaleBufferIdx = 0,
        numScales = 0,
    ):
        self.scale = scale  # type: Optional[List[float]]
        self.channelDim = channelDim  # type: int
        self.scaleBufferIdx = scaleBufferIdx  # type: int
        self.numScales = numScales  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        perChannelQuant = PerChannelQuant()
        perChannelQuant.Init(buf, pos)
        return cls.InitFromObj(perChannelQuant)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, perChannelQuant):
        x = PerChannelQuantT()
        x._UnPack(perChannelQuant)
        return x

    # PerChannelQuantT
    def _UnPack(self, perChannelQuant):
        if perChannelQuant is None:
            return
        if not perChannelQuant.ScaleIsNone():
            if np is None:
                self.scale = []
                for i in range(perChannelQuant.ScaleLength()):
                    self.scale.append(perChannelQuant.Scale(i))
            else:
                self.scale = perChannelQuant.ScaleAsNumpy()
        self.channelDim = perChannelQuant.ChannelDim()
        self.scaleBufferIdx = perChannelQuant.ScaleBufferIdx()
        self.numScales = perChannelQuant.NumScales()

    # PerChannelQuantT
    def Pack(self, builder):
        if self.scale is not None:
            if np is not None and type(self.scale) is np.ndarray:
                scale = builder.CreateNumpyVector(self.scale)
            else:
                PerChannelQuantStartScaleVector(builder, len(self.scale))
                for i in reversed(range(len(self.scale))):
                    builder.PrependFloat32(self.scale[i])
                scale = builder.EndVector()
        PerChannelQuantStart(builder)
        if self.scale is not None:
            PerChannelQuantAddScale(builder, scale)
        PerChannelQuantAddChannelDim(builder, self.channelDim)
        PerChannelQuantAddScaleBufferIdx(builder, self.scaleBufferIdx)
        PerChannelQuantAddNumScales(builder, self.numScales)
        perChannelQuant = PerChannelQuantEnd(builder)
        return perChannelQuant


class PerTokenDynamicQuant(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = PerTokenDynamicQuant()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsPerTokenDynamicQuant(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def PerTokenDynamicQuantBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # PerTokenDynamicQuant
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # PerTokenDynamicQuant
    def NumNonbatchDims(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def PerTokenDynamicQuantStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def PerTokenDynamicQuantAddNumNonbatchDims(builder: flatbuffers.Builder, numNonbatchDims: int):
    builder.PrependInt32Slot(0, numNonbatchDims, 0)

def PerTokenDynamicQuantEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class PerTokenDynamicQuantT(object):

    # PerTokenDynamicQuantT
    def __init__(
        self,
        numNonbatchDims = 0,
    ):
        self.numNonbatchDims = numNonbatchDims  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        perTokenDynamicQuant = PerTokenDynamicQuant()
        perTokenDynamicQuant.Init(buf, pos)
        return cls.InitFromObj(perTokenDynamicQuant)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, perTokenDynamicQuant):
        x = PerTokenDynamicQuantT()
        x._UnPack(perTokenDynamicQuant)
        return x

    # PerTokenDynamicQuantT
    def _UnPack(self, perTokenDynamicQuant):
        if perTokenDynamicQuant is None:
            return
        self.numNonbatchDims = perTokenDynamicQuant.NumNonbatchDims()

    # PerTokenDynamicQuantT
    def Pack(self, builder):
        PerTokenDynamicQuantStart(builder)
        PerTokenDynamicQuantAddNumNonbatchDims(builder, self.numNonbatchDims)
        perTokenDynamicQuant = PerTokenDynamicQuantEnd(builder)
        return perTokenDynamicQuant


class PerTensorQuant(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = PerTensorQuant()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsPerTensorQuant(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def PerTensorQuantBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # PerTensorQuant
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # PerTensorQuant
    def Scale(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # PerTensorQuant
    def ZeroPoint(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def PerTensorQuantStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def PerTensorQuantAddScale(builder: flatbuffers.Builder, scale: float):
    builder.PrependFloat32Slot(0, scale, 0.0)

def PerTensorQuantAddZeroPoint(builder: flatbuffers.Builder, zeroPoint: int):
    builder.PrependInt32Slot(1, zeroPoint, 0)

def PerTensorQuantEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class PerTensorQuantT(object):

    # PerTensorQuantT
    def __init__(
        self,
        scale = 0.0,
        zeroPoint = 0,
    ):
        self.scale = scale  # type: float
        self.zeroPoint = zeroPoint  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        perTensorQuant = PerTensorQuant()
        perTensorQuant.Init(buf, pos)
        return cls.InitFromObj(perTensorQuant)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, perTensorQuant):
        x = PerTensorQuantT()
        x._UnPack(perTensorQuant)
        return x

    # PerTensorQuantT
    def _UnPack(self, perTensorQuant):
        if perTensorQuant is None:
            return
        self.scale = perTensorQuant.Scale()
        self.zeroPoint = perTensorQuant.ZeroPoint()

    # PerTensorQuantT
    def Pack(self, builder):
        PerTensorQuantStart(builder)
        PerTensorQuantAddScale(builder, self.scale)
        PerTensorQuantAddZeroPoint(builder, self.zeroPoint)
        perTensorQuant = PerTensorQuantEnd(builder)
        return perTensorQuant


class XNNTensorValue(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNTensorValue()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNTensorValue(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNTensorValueBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNTensorValue
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNTensorValue
    def Datatype(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

    # XNNTensorValue
    def NumDims(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNTensorValue
    def Dims(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # XNNTensorValue
    def DimsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # XNNTensorValue
    def DimsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNTensorValue
    def DimsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # XNNTensorValue
    def ConstantBufferIdx(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNTensorValue
    def ExternalId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNTensorValue
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNTensorValue
    def IdOut(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def XNNTensorValueStart(builder: flatbuffers.Builder):
    builder.StartObject(7)

def XNNTensorValueAddDatatype(builder: flatbuffers.Builder, datatype: int):
    builder.PrependInt16Slot(0, datatype, 0)

def XNNTensorValueAddNumDims(builder: flatbuffers.Builder, numDims: int):
    builder.PrependUint32Slot(1, numDims, 0)

def XNNTensorValueAddDims(builder: flatbuffers.Builder, dims: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(dims), 0)

def XNNTensorValueStartDimsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNTensorValueAddConstantBufferIdx(builder: flatbuffers.Builder, constantBufferIdx: int):
    builder.PrependUint32Slot(3, constantBufferIdx, 0)

def XNNTensorValueAddExternalId(builder: flatbuffers.Builder, externalId: int):
    builder.PrependUint32Slot(4, externalId, 0)

def XNNTensorValueAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(5, flags, 0)

def XNNTensorValueAddIdOut(builder: flatbuffers.Builder, idOut: int):
    builder.PrependUint32Slot(6, idOut, 0)

def XNNTensorValueEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class XNNTensorValueT(object):

    # XNNTensorValueT
    def __init__(
        self,
        datatype = 0,
        numDims = 0,
        dims = None,
        constantBufferIdx = 0,
        externalId = 0,
        flags = 0,
        idOut = 0,
    ):
        self.datatype = datatype  # type: int
        self.numDims = numDims  # type: int
        self.dims = dims  # type: Optional[List[int]]
        self.constantBufferIdx = constantBufferIdx  # type: int
        self.externalId = externalId  # type: int
        self.flags = flags  # type: int
        self.idOut = idOut  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnntensorValue = XNNTensorValue()
        xnntensorValue.Init(buf, pos)
        return cls.InitFromObj(xnntensorValue)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnntensorValue):
        x = XNNTensorValueT()
        x._UnPack(xnntensorValue)
        return x

    # XNNTensorValueT
    def _UnPack(self, xnntensorValue):
        if xnntensorValue is None:
            return
        self.datatype = xnntensorValue.Datatype()
        self.numDims = xnntensorValue.NumDims()
        if not xnntensorValue.DimsIsNone():
            if np is None:
                self.dims = []
                for i in range(xnntensorValue.DimsLength()):
                    self.dims.append(xnntensorValue.Dims(i))
            else:
                self.dims = xnntensorValue.DimsAsNumpy()
        self.constantBufferIdx = xnntensorValue.ConstantBufferIdx()
        self.externalId = xnntensorValue.ExternalId()
        self.flags = xnntensorValue.Flags()
        self.idOut = xnntensorValue.IdOut()

    # XNNTensorValueT
    def Pack(self, builder):
        if self.dims is not None:
            if np is not None and type(self.dims) is np.ndarray:
                dims = builder.CreateNumpyVector(self.dims)
            else:
                XNNTensorValueStartDimsVector(builder, len(self.dims))
                for i in reversed(range(len(self.dims))):
                    builder.PrependUint32(self.dims[i])
                dims = builder.EndVector()
        XNNTensorValueStart(builder)
        XNNTensorValueAddDatatype(builder, self.datatype)
        XNNTensorValueAddNumDims(builder, self.numDims)
        if self.dims is not None:
            XNNTensorValueAddDims(builder, dims)
        XNNTensorValueAddConstantBufferIdx(builder, self.constantBufferIdx)
        XNNTensorValueAddExternalId(builder, self.externalId)
        XNNTensorValueAddFlags(builder, self.flags)
        XNNTensorValueAddIdOut(builder, self.idOut)
        xnntensorValue = XNNTensorValueEnd(builder)
        return xnntensorValue


class XNNQuantizedTensorValue(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNQuantizedTensorValue()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNQuantizedTensorValue(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNQuantizedTensorValueBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNQuantizedTensorValue
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNQuantizedTensorValue
    def TensorValue(self) -> Optional[XNNTensorValue]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = XNNTensorValue()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # XNNQuantizedTensorValue
    def QuantParamsType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # XNNQuantizedTensorValue
    def QuantParams(self) -> Optional[flatbuffers.table.Table]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def XNNQuantizedTensorValueStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def XNNQuantizedTensorValueAddTensorValue(builder: flatbuffers.Builder, tensorValue: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(tensorValue), 0)

def XNNQuantizedTensorValueAddQuantParamsType(builder: flatbuffers.Builder, quantParamsType: int):
    builder.PrependUint8Slot(1, quantParamsType, 0)

def XNNQuantizedTensorValueAddQuantParams(builder: flatbuffers.Builder, quantParams: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(quantParams), 0)

def XNNQuantizedTensorValueEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import Optional, Union
except:
    pass

class XNNQuantizedTensorValueT(object):

    # XNNQuantizedTensorValueT
    def __init__(
        self,
        tensorValue = None,
        quantParamsType = 0,
        quantParams = None,
    ):
        self.tensorValue = tensorValue  # type: Optional[XNNTensorValueT]
        self.quantParamsType = quantParamsType  # type: int
        self.quantParams = quantParams  # type: Union[None, 'PerChannelQuantT', 'PerTensorQuantT', 'PerTokenDynamicQuantT', 'PerChannelGroupQuantT']

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnnquantizedTensorValue = XNNQuantizedTensorValue()
        xnnquantizedTensorValue.Init(buf, pos)
        return cls.InitFromObj(xnnquantizedTensorValue)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnnquantizedTensorValue):
        x = XNNQuantizedTensorValueT()
        x._UnPack(xnnquantizedTensorValue)
        return x

    # XNNQuantizedTensorValueT
    def _UnPack(self, xnnquantizedTensorValue):
        if xnnquantizedTensorValue is None:
            return
        if xnnquantizedTensorValue.TensorValue() is not None:
            self.tensorValue = XNNTensorValueT.InitFromObj(xnnquantizedTensorValue.TensorValue())
        self.quantParamsType = xnnquantizedTensorValue.QuantParamsType()
        self.quantParams = XNNQuantParamsCreator(self.quantParamsType, xnnquantizedTensorValue.QuantParams())

    # XNNQuantizedTensorValueT
    def Pack(self, builder):
        if self.tensorValue is not None:
            tensorValue = self.tensorValue.Pack(builder)
        if self.quantParams is not None:
            quantParams = self.quantParams.Pack(builder)
        XNNQuantizedTensorValueStart(builder)
        if self.tensorValue is not None:
            XNNQuantizedTensorValueAddTensorValue(builder, tensorValue)
        XNNQuantizedTensorValueAddQuantParamsType(builder, self.quantParamsType)
        if self.quantParams is not None:
            XNNQuantizedTensorValueAddQuantParams(builder, quantParams)
        xnnquantizedTensorValue = XNNQuantizedTensorValueEnd(builder)
        return xnnquantizedTensorValue


class OutputMinMax(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = OutputMinMax()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsOutputMinMax(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def OutputMinMaxBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # OutputMinMax
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # OutputMinMax
    def OutputMin(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # OutputMinMax
    def OutputMax(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def OutputMinMaxStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def OutputMinMaxAddOutputMin(builder: flatbuffers.Builder, outputMin: float):
    builder.PrependFloat32Slot(0, outputMin, 0.0)

def OutputMinMaxAddOutputMax(builder: flatbuffers.Builder, outputMax: float):
    builder.PrependFloat32Slot(1, outputMax, 0.0)

def OutputMinMaxEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class OutputMinMaxT(object):

    # OutputMinMaxT
    def __init__(
        self,
        outputMin = 0.0,
        outputMax = 0.0,
    ):
        self.outputMin = outputMin  # type: float
        self.outputMax = outputMax  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        outputMinMax = OutputMinMax()
        outputMinMax.Init(buf, pos)
        return cls.InitFromObj(outputMinMax)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, outputMinMax):
        x = OutputMinMaxT()
        x._UnPack(outputMinMax)
        return x

    # OutputMinMaxT
    def _UnPack(self, outputMinMax):
        if outputMinMax is None:
            return
        self.outputMin = outputMinMax.OutputMin()
        self.outputMax = outputMinMax.OutputMax()

    # OutputMinMaxT
    def Pack(self, builder):
        OutputMinMaxStart(builder)
        OutputMinMaxAddOutputMin(builder, self.outputMin)
        OutputMinMaxAddOutputMax(builder, self.outputMax)
        outputMinMax = OutputMinMaxEnd(builder)
        return outputMinMax


class XNode(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNode()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNode(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNodeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNode
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNode
    def XnodeUnionType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # XNode
    def XnodeUnion(self) -> Optional[flatbuffers.table.Table]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

    # XNode
    def DebugHandle(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNode
    def OutputMinMax(self) -> Optional[OutputMinMax]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = OutputMinMax()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def XNodeStart(builder: flatbuffers.Builder):
    builder.StartObject(4)

def XNodeAddXnodeUnionType(builder: flatbuffers.Builder, xnodeUnionType: int):
    builder.PrependUint8Slot(0, xnodeUnionType, 0)

def XNodeAddXnodeUnion(builder: flatbuffers.Builder, xnodeUnion: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(xnodeUnion), 0)

def XNodeAddDebugHandle(builder: flatbuffers.Builder, debugHandle: int):
    builder.PrependUint32Slot(2, debugHandle, 0)

def XNodeAddOutputMinMax(builder: flatbuffers.Builder, outputMinMax: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(outputMinMax), 0)

def XNodeEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import Optional, Union
except:
    pass

class XNodeT(object):

    # XNodeT
    def __init__(
        self,
        xnodeUnionType = 0,
        xnodeUnion = None,
        debugHandle = 0,
        outputMinMax = None,
    ):
        self.xnodeUnionType = xnodeUnionType  # type: int
        self.xnodeUnion = xnodeUnion  # type: Union[None, '_XNNNode2x1T', 'XNNFullyConnectedT', '_XNNNode1x1T', '_XNNNode1x1T', 'XNNStaticTransposeT', '_XNNNode1x1T', '_XNNNodeConvT', '_XNNNode2x1T', 'XNNStaticResizeBilinear2DT', 'XNNStaticConstantPadT', '_XNNPooling2DT', '_XNNNode2x1T', '_XNNNodeConvT', '_XNNPooling2DT', '_XNNNode2x1T', '_XNNNode2x1T', '_XNNNode1x1T', '_XNNNode1x1T', '_XNNNode1x1T', 'XNNStaticReshapeT', 'XNNArgMaxPooling2dT', '_XNNNode1x1T', '_XNNNode1x1T', '_XNNNode1x1T', 'XNNLeakyReLUT', '_XNNNode2x1T', '_XNNNode1x1T', '_XNNNode1x1T', 'XNNELUT', '_XNNNode1x1T', '_XNNNode2x1T', '_XNNCatT', '_XNNCatT', '_XNNCatT', 'XNNStaticSliceT', 'XNNScaledDotProductAttentionT', '_XNNNode2x1T', '_XNNCatT', '_XNNNodeConvT', '_XNNNode1x1T', '_XNNNode1x1T', '_XNNNode1x1T', '_XNNNode1x1T', '_XNNNode1x1T']
        self.debugHandle = debugHandle  # type: int
        self.outputMinMax = outputMinMax  # type: Optional[OutputMinMaxT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnode = XNode()
        xnode.Init(buf, pos)
        return cls.InitFromObj(xnode)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnode):
        x = XNodeT()
        x._UnPack(xnode)
        return x

    # XNodeT
    def _UnPack(self, xnode):
        if xnode is None:
            return
        self.xnodeUnionType = xnode.XnodeUnionType()
        self.xnodeUnion = XNodeUnionCreator(self.xnodeUnionType, xnode.XnodeUnion())
        self.debugHandle = xnode.DebugHandle()
        if xnode.OutputMinMax() is not None:
            self.outputMinMax = OutputMinMaxT.InitFromObj(xnode.OutputMinMax())

    # XNodeT
    def Pack(self, builder):
        if self.xnodeUnion is not None:
            xnodeUnion = self.xnodeUnion.Pack(builder)
        if self.outputMinMax is not None:
            outputMinMax = self.outputMinMax.Pack(builder)
        XNodeStart(builder)
        XNodeAddXnodeUnionType(builder, self.xnodeUnionType)
        if self.xnodeUnion is not None:
            XNodeAddXnodeUnion(builder, xnodeUnion)
        XNodeAddDebugHandle(builder, self.debugHandle)
        if self.outputMinMax is not None:
            XNodeAddOutputMinMax(builder, outputMinMax)
        xnode = XNodeEnd(builder)
        return xnode


class XValue(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XValue()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXValue(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XValueBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XValue
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XValue
    def XvalueUnionType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # XValue
    def XvalueUnion(self) -> Optional[flatbuffers.table.Table]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def XValueStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def XValueAddXvalueUnionType(builder: flatbuffers.Builder, xvalueUnionType: int):
    builder.PrependUint8Slot(0, xvalueUnionType, 0)

def XValueAddXvalueUnion(builder: flatbuffers.Builder, xvalueUnion: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(xvalueUnion), 0)

def XValueEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import Union
except:
    pass

class XValueT(object):

    # XValueT
    def __init__(
        self,
        xvalueUnionType = 0,
        xvalueUnion = None,
    ):
        self.xvalueUnionType = xvalueUnionType  # type: int
        self.xvalueUnion = xvalueUnion  # type: Union[None, 'XNNTensorValueT', 'XNNQuantizedTensorValueT']

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xvalue = XValue()
        xvalue.Init(buf, pos)
        return cls.InitFromObj(xvalue)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xvalue):
        x = XValueT()
        x._UnPack(xvalue)
        return x

    # XValueT
    def _UnPack(self, xvalue):
        if xvalue is None:
            return
        self.xvalueUnionType = xvalue.XvalueUnionType()
        self.xvalueUnion = XValueUnionCreator(self.xvalueUnionType, xvalue.XvalueUnion())

    # XValueT
    def Pack(self, builder):
        if self.xvalueUnion is not None:
            xvalueUnion = self.xvalueUnion.Pack(builder)
        XValueStart(builder)
        XValueAddXvalueUnionType(builder, self.xvalueUnionType)
        if self.xvalueUnion is not None:
            XValueAddXvalueUnion(builder, xvalueUnion)
        xvalue = XValueEnd(builder)
        return xvalue


class XNNStaticTranspose(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNStaticTranspose()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNStaticTranspose(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNStaticTransposeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNStaticTranspose
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNStaticTranspose
    def NumDims(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticTranspose
    def Perm(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # XNNStaticTranspose
    def PermAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # XNNStaticTranspose
    def PermLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNStaticTranspose
    def PermIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # XNNStaticTranspose
    def InputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticTranspose
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticTranspose
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def XNNStaticTransposeStart(builder: flatbuffers.Builder):
    builder.StartObject(5)

def XNNStaticTransposeAddNumDims(builder: flatbuffers.Builder, numDims: int):
    builder.PrependUint32Slot(0, numDims, 0)

def XNNStaticTransposeAddPerm(builder: flatbuffers.Builder, perm: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(perm), 0)

def XNNStaticTransposeStartPermVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNStaticTransposeAddInputId(builder: flatbuffers.Builder, inputId: int):
    builder.PrependUint32Slot(2, inputId, 0)

def XNNStaticTransposeAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(3, outputId, 0)

def XNNStaticTransposeAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(4, flags, 0)

def XNNStaticTransposeEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class XNNStaticTransposeT(object):

    # XNNStaticTransposeT
    def __init__(
        self,
        numDims = 0,
        perm = None,
        inputId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.numDims = numDims  # type: int
        self.perm = perm  # type: Optional[List[int]]
        self.inputId = inputId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnnstaticTranspose = XNNStaticTranspose()
        xnnstaticTranspose.Init(buf, pos)
        return cls.InitFromObj(xnnstaticTranspose)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnnstaticTranspose):
        x = XNNStaticTransposeT()
        x._UnPack(xnnstaticTranspose)
        return x

    # XNNStaticTransposeT
    def _UnPack(self, xnnstaticTranspose):
        if xnnstaticTranspose is None:
            return
        self.numDims = xnnstaticTranspose.NumDims()
        if not xnnstaticTranspose.PermIsNone():
            if np is None:
                self.perm = []
                for i in range(xnnstaticTranspose.PermLength()):
                    self.perm.append(xnnstaticTranspose.Perm(i))
            else:
                self.perm = xnnstaticTranspose.PermAsNumpy()
        self.inputId = xnnstaticTranspose.InputId()
        self.outputId = xnnstaticTranspose.OutputId()
        self.flags = xnnstaticTranspose.Flags()

    # XNNStaticTransposeT
    def Pack(self, builder):
        if self.perm is not None:
            if np is not None and type(self.perm) is np.ndarray:
                perm = builder.CreateNumpyVector(self.perm)
            else:
                XNNStaticTransposeStartPermVector(builder, len(self.perm))
                for i in reversed(range(len(self.perm))):
                    builder.PrependUint32(self.perm[i])
                perm = builder.EndVector()
        XNNStaticTransposeStart(builder)
        XNNStaticTransposeAddNumDims(builder, self.numDims)
        if self.perm is not None:
            XNNStaticTransposeAddPerm(builder, perm)
        XNNStaticTransposeAddInputId(builder, self.inputId)
        XNNStaticTransposeAddOutputId(builder, self.outputId)
        XNNStaticTransposeAddFlags(builder, self.flags)
        xnnstaticTranspose = XNNStaticTransposeEnd(builder)
        return xnnstaticTranspose


class XNNStaticResizeBilinear2D(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNStaticResizeBilinear2D()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNStaticResizeBilinear2D(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNStaticResizeBilinear2DBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNStaticResizeBilinear2D
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNStaticResizeBilinear2D
    def NewHeight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticResizeBilinear2D
    def NewWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticResizeBilinear2D
    def InputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticResizeBilinear2D
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticResizeBilinear2D
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def XNNStaticResizeBilinear2DStart(builder: flatbuffers.Builder):
    builder.StartObject(5)

def XNNStaticResizeBilinear2DAddNewHeight(builder: flatbuffers.Builder, newHeight: int):
    builder.PrependUint32Slot(0, newHeight, 0)

def XNNStaticResizeBilinear2DAddNewWidth(builder: flatbuffers.Builder, newWidth: int):
    builder.PrependUint32Slot(1, newWidth, 0)

def XNNStaticResizeBilinear2DAddInputId(builder: flatbuffers.Builder, inputId: int):
    builder.PrependUint32Slot(2, inputId, 0)

def XNNStaticResizeBilinear2DAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(3, outputId, 0)

def XNNStaticResizeBilinear2DAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(4, flags, 0)

def XNNStaticResizeBilinear2DEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class XNNStaticResizeBilinear2DT(object):

    # XNNStaticResizeBilinear2DT
    def __init__(
        self,
        newHeight = 0,
        newWidth = 0,
        inputId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.newHeight = newHeight  # type: int
        self.newWidth = newWidth  # type: int
        self.inputId = inputId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnnstaticResizeBilinear2D = XNNStaticResizeBilinear2D()
        xnnstaticResizeBilinear2D.Init(buf, pos)
        return cls.InitFromObj(xnnstaticResizeBilinear2D)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnnstaticResizeBilinear2D):
        x = XNNStaticResizeBilinear2DT()
        x._UnPack(xnnstaticResizeBilinear2D)
        return x

    # XNNStaticResizeBilinear2DT
    def _UnPack(self, xnnstaticResizeBilinear2D):
        if xnnstaticResizeBilinear2D is None:
            return
        self.newHeight = xnnstaticResizeBilinear2D.NewHeight()
        self.newWidth = xnnstaticResizeBilinear2D.NewWidth()
        self.inputId = xnnstaticResizeBilinear2D.InputId()
        self.outputId = xnnstaticResizeBilinear2D.OutputId()
        self.flags = xnnstaticResizeBilinear2D.Flags()

    # XNNStaticResizeBilinear2DT
    def Pack(self, builder):
        XNNStaticResizeBilinear2DStart(builder)
        XNNStaticResizeBilinear2DAddNewHeight(builder, self.newHeight)
        XNNStaticResizeBilinear2DAddNewWidth(builder, self.newWidth)
        XNNStaticResizeBilinear2DAddInputId(builder, self.inputId)
        XNNStaticResizeBilinear2DAddOutputId(builder, self.outputId)
        XNNStaticResizeBilinear2DAddFlags(builder, self.flags)
        xnnstaticResizeBilinear2D = XNNStaticResizeBilinear2DEnd(builder)
        return xnnstaticResizeBilinear2D


class XNNStaticConstantPad(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNStaticConstantPad()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNStaticConstantPad(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNStaticConstantPadBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNStaticConstantPad
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNStaticConstantPad
    def PrePaddings(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # XNNStaticConstantPad
    def PrePaddingsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # XNNStaticConstantPad
    def PrePaddingsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNStaticConstantPad
    def PrePaddingsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # XNNStaticConstantPad
    def PostPaddings(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # XNNStaticConstantPad
    def PostPaddingsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # XNNStaticConstantPad
    def PostPaddingsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNStaticConstantPad
    def PostPaddingsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # XNNStaticConstantPad
    def PaddingValue(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # XNNStaticConstantPad
    def InputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticConstantPad
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticConstantPad
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def XNNStaticConstantPadStart(builder: flatbuffers.Builder):
    builder.StartObject(6)

def XNNStaticConstantPadAddPrePaddings(builder: flatbuffers.Builder, prePaddings: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(prePaddings), 0)

def XNNStaticConstantPadStartPrePaddingsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNStaticConstantPadAddPostPaddings(builder: flatbuffers.Builder, postPaddings: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(postPaddings), 0)

def XNNStaticConstantPadStartPostPaddingsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNStaticConstantPadAddPaddingValue(builder: flatbuffers.Builder, paddingValue: float):
    builder.PrependFloat32Slot(2, paddingValue, 0.0)

def XNNStaticConstantPadAddInputId(builder: flatbuffers.Builder, inputId: int):
    builder.PrependUint32Slot(3, inputId, 0)

def XNNStaticConstantPadAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(4, outputId, 0)

def XNNStaticConstantPadAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(5, flags, 0)

def XNNStaticConstantPadEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class XNNStaticConstantPadT(object):

    # XNNStaticConstantPadT
    def __init__(
        self,
        prePaddings = None,
        postPaddings = None,
        paddingValue = 0.0,
        inputId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.prePaddings = prePaddings  # type: Optional[List[int]]
        self.postPaddings = postPaddings  # type: Optional[List[int]]
        self.paddingValue = paddingValue  # type: float
        self.inputId = inputId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnnstaticConstantPad = XNNStaticConstantPad()
        xnnstaticConstantPad.Init(buf, pos)
        return cls.InitFromObj(xnnstaticConstantPad)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnnstaticConstantPad):
        x = XNNStaticConstantPadT()
        x._UnPack(xnnstaticConstantPad)
        return x

    # XNNStaticConstantPadT
    def _UnPack(self, xnnstaticConstantPad):
        if xnnstaticConstantPad is None:
            return
        if not xnnstaticConstantPad.PrePaddingsIsNone():
            if np is None:
                self.prePaddings = []
                for i in range(xnnstaticConstantPad.PrePaddingsLength()):
                    self.prePaddings.append(xnnstaticConstantPad.PrePaddings(i))
            else:
                self.prePaddings = xnnstaticConstantPad.PrePaddingsAsNumpy()
        if not xnnstaticConstantPad.PostPaddingsIsNone():
            if np is None:
                self.postPaddings = []
                for i in range(xnnstaticConstantPad.PostPaddingsLength()):
                    self.postPaddings.append(xnnstaticConstantPad.PostPaddings(i))
            else:
                self.postPaddings = xnnstaticConstantPad.PostPaddingsAsNumpy()
        self.paddingValue = xnnstaticConstantPad.PaddingValue()
        self.inputId = xnnstaticConstantPad.InputId()
        self.outputId = xnnstaticConstantPad.OutputId()
        self.flags = xnnstaticConstantPad.Flags()

    # XNNStaticConstantPadT
    def Pack(self, builder):
        if self.prePaddings is not None:
            if np is not None and type(self.prePaddings) is np.ndarray:
                prePaddings = builder.CreateNumpyVector(self.prePaddings)
            else:
                XNNStaticConstantPadStartPrePaddingsVector(builder, len(self.prePaddings))
                for i in reversed(range(len(self.prePaddings))):
                    builder.PrependUint32(self.prePaddings[i])
                prePaddings = builder.EndVector()
        if self.postPaddings is not None:
            if np is not None and type(self.postPaddings) is np.ndarray:
                postPaddings = builder.CreateNumpyVector(self.postPaddings)
            else:
                XNNStaticConstantPadStartPostPaddingsVector(builder, len(self.postPaddings))
                for i in reversed(range(len(self.postPaddings))):
                    builder.PrependUint32(self.postPaddings[i])
                postPaddings = builder.EndVector()
        XNNStaticConstantPadStart(builder)
        if self.prePaddings is not None:
            XNNStaticConstantPadAddPrePaddings(builder, prePaddings)
        if self.postPaddings is not None:
            XNNStaticConstantPadAddPostPaddings(builder, postPaddings)
        XNNStaticConstantPadAddPaddingValue(builder, self.paddingValue)
        XNNStaticConstantPadAddInputId(builder, self.inputId)
        XNNStaticConstantPadAddOutputId(builder, self.outputId)
        XNNStaticConstantPadAddFlags(builder, self.flags)
        xnnstaticConstantPad = XNNStaticConstantPadEnd(builder)
        return xnnstaticConstantPad


class _XNNNode2x1(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = _XNNNode2x1()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAs_XNNNode2x1(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def _XNNNode2x1BufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # _XNNNode2x1
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # _XNNNode2x1
    def Input1Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNode2x1
    def Input2Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNode2x1
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNode2x1
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def _XNNNode2x1Start(builder: flatbuffers.Builder):
    builder.StartObject(4)

def _XNNNode2x1AddInput1Id(builder: flatbuffers.Builder, input1Id: int):
    builder.PrependUint32Slot(0, input1Id, 0)

def _XNNNode2x1AddInput2Id(builder: flatbuffers.Builder, input2Id: int):
    builder.PrependUint32Slot(1, input2Id, 0)

def _XNNNode2x1AddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(2, outputId, 0)

def _XNNNode2x1AddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(3, flags, 0)

def _XNNNode2x1End(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class _XNNNode2x1T(object):

    # _XNNNode2x1T
    def __init__(
        self,
        input1Id = 0,
        input2Id = 0,
        outputId = 0,
        flags = 0,
    ):
        self.input1Id = input1Id  # type: int
        self.input2Id = input2Id  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        _Xnnnode2x1 = _XNNNode2x1()
        _Xnnnode2x1.Init(buf, pos)
        return cls.InitFromObj(_Xnnnode2x1)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, _Xnnnode2x1):
        x = _XNNNode2x1T()
        x._UnPack(_Xnnnode2x1)
        return x

    # _XNNNode2x1T
    def _UnPack(self, _Xnnnode2x1):
        if _Xnnnode2x1 is None:
            return
        self.input1Id = _Xnnnode2x1.Input1Id()
        self.input2Id = _Xnnnode2x1.Input2Id()
        self.outputId = _Xnnnode2x1.OutputId()
        self.flags = _Xnnnode2x1.Flags()

    # _XNNNode2x1T
    def Pack(self, builder):
        _XNNNode2x1Start(builder)
        _XNNNode2x1AddInput1Id(builder, self.input1Id)
        _XNNNode2x1AddInput2Id(builder, self.input2Id)
        _XNNNode2x1AddOutputId(builder, self.outputId)
        _XNNNode2x1AddFlags(builder, self.flags)
        _Xnnnode2x1 = _XNNNode2x1End(builder)
        return _Xnnnode2x1


class _XNNNode1x1(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = _XNNNode1x1()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAs_XNNNode1x1(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def _XNNNode1x1BufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # _XNNNode1x1
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # _XNNNode1x1
    def InputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNode1x1
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNode1x1
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def _XNNNode1x1Start(builder: flatbuffers.Builder):
    builder.StartObject(3)

def _XNNNode1x1AddInputId(builder: flatbuffers.Builder, inputId: int):
    builder.PrependUint32Slot(0, inputId, 0)

def _XNNNode1x1AddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(1, outputId, 0)

def _XNNNode1x1AddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(2, flags, 0)

def _XNNNode1x1End(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class _XNNNode1x1T(object):

    # _XNNNode1x1T
    def __init__(
        self,
        inputId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.inputId = inputId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        _Xnnnode1x1 = _XNNNode1x1()
        _Xnnnode1x1.Init(buf, pos)
        return cls.InitFromObj(_Xnnnode1x1)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, _Xnnnode1x1):
        x = _XNNNode1x1T()
        x._UnPack(_Xnnnode1x1)
        return x

    # _XNNNode1x1T
    def _UnPack(self, _Xnnnode1x1):
        if _Xnnnode1x1 is None:
            return
        self.inputId = _Xnnnode1x1.InputId()
        self.outputId = _Xnnnode1x1.OutputId()
        self.flags = _Xnnnode1x1.Flags()

    # _XNNNode1x1T
    def Pack(self, builder):
        _XNNNode1x1Start(builder)
        _XNNNode1x1AddInputId(builder, self.inputId)
        _XNNNode1x1AddOutputId(builder, self.outputId)
        _XNNNode1x1AddFlags(builder, self.flags)
        _Xnnnode1x1 = _XNNNode1x1End(builder)
        return _Xnnnode1x1


class _XNNCat(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = _XNNCat()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAs_XNNCat(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def _XNNCatBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # _XNNCat
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # _XNNCat
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNCat
    def Input1Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNCat
    def Input2Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNCat
    def Input3Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNCat
    def Input4Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNCat
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNCat
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNCat
    def Input5Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def _XNNCatStart(builder: flatbuffers.Builder):
    builder.StartObject(8)

def _XNNCatAddAxis(builder: flatbuffers.Builder, axis: int):
    builder.PrependUint32Slot(0, axis, 0)

def _XNNCatAddInput1Id(builder: flatbuffers.Builder, input1Id: int):
    builder.PrependUint32Slot(1, input1Id, 0)

def _XNNCatAddInput2Id(builder: flatbuffers.Builder, input2Id: int):
    builder.PrependUint32Slot(2, input2Id, 0)

def _XNNCatAddInput3Id(builder: flatbuffers.Builder, input3Id: int):
    builder.PrependUint32Slot(3, input3Id, 0)

def _XNNCatAddInput4Id(builder: flatbuffers.Builder, input4Id: int):
    builder.PrependUint32Slot(4, input4Id, 0)

def _XNNCatAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(5, outputId, 0)

def _XNNCatAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(6, flags, 0)

def _XNNCatAddInput5Id(builder: flatbuffers.Builder, input5Id: int):
    builder.PrependUint32Slot(7, input5Id, 0)

def _XNNCatEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class _XNNCatT(object):

    # _XNNCatT
    def __init__(
        self,
        axis = 0,
        input1Id = 0,
        input2Id = 0,
        input3Id = 0,
        input4Id = 0,
        outputId = 0,
        flags = 0,
        input5Id = 0,
    ):
        self.axis = axis  # type: int
        self.input1Id = input1Id  # type: int
        self.input2Id = input2Id  # type: int
        self.input3Id = input3Id  # type: int
        self.input4Id = input4Id  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int
        self.input5Id = input5Id  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        _Xnncat = _XNNCat()
        _Xnncat.Init(buf, pos)
        return cls.InitFromObj(_Xnncat)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, _Xnncat):
        x = _XNNCatT()
        x._UnPack(_Xnncat)
        return x

    # _XNNCatT
    def _UnPack(self, _Xnncat):
        if _Xnncat is None:
            return
        self.axis = _Xnncat.Axis()
        self.input1Id = _Xnncat.Input1Id()
        self.input2Id = _Xnncat.Input2Id()
        self.input3Id = _Xnncat.Input3Id()
        self.input4Id = _Xnncat.Input4Id()
        self.outputId = _Xnncat.OutputId()
        self.flags = _Xnncat.Flags()
        self.input5Id = _Xnncat.Input5Id()

    # _XNNCatT
    def Pack(self, builder):
        _XNNCatStart(builder)
        _XNNCatAddAxis(builder, self.axis)
        _XNNCatAddInput1Id(builder, self.input1Id)
        _XNNCatAddInput2Id(builder, self.input2Id)
        _XNNCatAddInput3Id(builder, self.input3Id)
        _XNNCatAddInput4Id(builder, self.input4Id)
        _XNNCatAddOutputId(builder, self.outputId)
        _XNNCatAddFlags(builder, self.flags)
        _XNNCatAddInput5Id(builder, self.input5Id)
        _Xnncat = _XNNCatEnd(builder)
        return _Xnncat


class XNNELU(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNELU()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNELU(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNELUBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNELU
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNELU
    def Alpha(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # XNNELU
    def InputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNELU
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNELU
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def XNNELUStart(builder: flatbuffers.Builder):
    builder.StartObject(4)

def XNNELUAddAlpha(builder: flatbuffers.Builder, alpha: float):
    builder.PrependFloat32Slot(0, alpha, 0.0)

def XNNELUAddInputId(builder: flatbuffers.Builder, inputId: int):
    builder.PrependUint32Slot(1, inputId, 0)

def XNNELUAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(2, outputId, 0)

def XNNELUAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(3, flags, 0)

def XNNELUEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class XNNELUT(object):

    # XNNELUT
    def __init__(
        self,
        alpha = 0.0,
        inputId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.alpha = alpha  # type: float
        self.inputId = inputId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnnelu = XNNELU()
        xnnelu.Init(buf, pos)
        return cls.InitFromObj(xnnelu)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnnelu):
        x = XNNELUT()
        x._UnPack(xnnelu)
        return x

    # XNNELUT
    def _UnPack(self, xnnelu):
        if xnnelu is None:
            return
        self.alpha = xnnelu.Alpha()
        self.inputId = xnnelu.InputId()
        self.outputId = xnnelu.OutputId()
        self.flags = xnnelu.Flags()

    # XNNELUT
    def Pack(self, builder):
        XNNELUStart(builder)
        XNNELUAddAlpha(builder, self.alpha)
        XNNELUAddInputId(builder, self.inputId)
        XNNELUAddOutputId(builder, self.outputId)
        XNNELUAddFlags(builder, self.flags)
        xnnelu = XNNELUEnd(builder)
        return xnnelu


class XNNFullyConnected(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNFullyConnected()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNFullyConnected(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNFullyConnectedBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNFullyConnected
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNFullyConnected
    def Input1Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNFullyConnected
    def FilterId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNFullyConnected
    def BiasId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNFullyConnected
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNFullyConnected
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def XNNFullyConnectedStart(builder: flatbuffers.Builder):
    builder.StartObject(5)

def XNNFullyConnectedAddInput1Id(builder: flatbuffers.Builder, input1Id: int):
    builder.PrependUint32Slot(0, input1Id, 0)

def XNNFullyConnectedAddFilterId(builder: flatbuffers.Builder, filterId: int):
    builder.PrependUint32Slot(1, filterId, 0)

def XNNFullyConnectedAddBiasId(builder: flatbuffers.Builder, biasId: int):
    builder.PrependUint32Slot(2, biasId, 0)

def XNNFullyConnectedAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(3, outputId, 0)

def XNNFullyConnectedAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(4, flags, 0)

def XNNFullyConnectedEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class XNNFullyConnectedT(object):

    # XNNFullyConnectedT
    def __init__(
        self,
        input1Id = 0,
        filterId = 0,
        biasId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.input1Id = input1Id  # type: int
        self.filterId = filterId  # type: int
        self.biasId = biasId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnnfullyConnected = XNNFullyConnected()
        xnnfullyConnected.Init(buf, pos)
        return cls.InitFromObj(xnnfullyConnected)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnnfullyConnected):
        x = XNNFullyConnectedT()
        x._UnPack(xnnfullyConnected)
        return x

    # XNNFullyConnectedT
    def _UnPack(self, xnnfullyConnected):
        if xnnfullyConnected is None:
            return
        self.input1Id = xnnfullyConnected.Input1Id()
        self.filterId = xnnfullyConnected.FilterId()
        self.biasId = xnnfullyConnected.BiasId()
        self.outputId = xnnfullyConnected.OutputId()
        self.flags = xnnfullyConnected.Flags()

    # XNNFullyConnectedT
    def Pack(self, builder):
        XNNFullyConnectedStart(builder)
        XNNFullyConnectedAddInput1Id(builder, self.input1Id)
        XNNFullyConnectedAddFilterId(builder, self.filterId)
        XNNFullyConnectedAddBiasId(builder, self.biasId)
        XNNFullyConnectedAddOutputId(builder, self.outputId)
        XNNFullyConnectedAddFlags(builder, self.flags)
        xnnfullyConnected = XNNFullyConnectedEnd(builder)
        return xnnfullyConnected


class _XNNNodeConv(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = _XNNNodeConv()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAs_XNNNodeConv(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def _XNNNodeConvBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # _XNNNodeConv
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # _XNNNodeConv
    def PaddingTop(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def PaddingRight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def PaddingBottom(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def PaddingLeft(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def KernelHeight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def KernelWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def SubsamplingHeight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def SubsamplingWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def DilationHeight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def DilationWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def GroupInputChannels(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def GroupOutputChannels(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def Groups(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def AdjustmentHeight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def AdjustmentWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def Input1Id(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def FilterId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def BiasId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNNodeConv
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def _XNNNodeConvStart(builder: flatbuffers.Builder):
    builder.StartObject(20)

def _XNNNodeConvAddPaddingTop(builder: flatbuffers.Builder, paddingTop: int):
    builder.PrependUint32Slot(0, paddingTop, 0)

def _XNNNodeConvAddPaddingRight(builder: flatbuffers.Builder, paddingRight: int):
    builder.PrependUint32Slot(1, paddingRight, 0)

def _XNNNodeConvAddPaddingBottom(builder: flatbuffers.Builder, paddingBottom: int):
    builder.PrependUint32Slot(2, paddingBottom, 0)

def _XNNNodeConvAddPaddingLeft(builder: flatbuffers.Builder, paddingLeft: int):
    builder.PrependUint32Slot(3, paddingLeft, 0)

def _XNNNodeConvAddKernelHeight(builder: flatbuffers.Builder, kernelHeight: int):
    builder.PrependUint32Slot(4, kernelHeight, 0)

def _XNNNodeConvAddKernelWidth(builder: flatbuffers.Builder, kernelWidth: int):
    builder.PrependUint32Slot(5, kernelWidth, 0)

def _XNNNodeConvAddSubsamplingHeight(builder: flatbuffers.Builder, subsamplingHeight: int):
    builder.PrependUint32Slot(6, subsamplingHeight, 0)

def _XNNNodeConvAddSubsamplingWidth(builder: flatbuffers.Builder, subsamplingWidth: int):
    builder.PrependUint32Slot(7, subsamplingWidth, 0)

def _XNNNodeConvAddDilationHeight(builder: flatbuffers.Builder, dilationHeight: int):
    builder.PrependUint32Slot(8, dilationHeight, 0)

def _XNNNodeConvAddDilationWidth(builder: flatbuffers.Builder, dilationWidth: int):
    builder.PrependUint32Slot(9, dilationWidth, 0)

def _XNNNodeConvAddGroupInputChannels(builder: flatbuffers.Builder, groupInputChannels: int):
    builder.PrependUint32Slot(10, groupInputChannels, 0)

def _XNNNodeConvAddGroupOutputChannels(builder: flatbuffers.Builder, groupOutputChannels: int):
    builder.PrependUint32Slot(11, groupOutputChannels, 0)

def _XNNNodeConvAddGroups(builder: flatbuffers.Builder, groups: int):
    builder.PrependUint32Slot(12, groups, 0)

def _XNNNodeConvAddAdjustmentHeight(builder: flatbuffers.Builder, adjustmentHeight: int):
    builder.PrependUint32Slot(13, adjustmentHeight, 0)

def _XNNNodeConvAddAdjustmentWidth(builder: flatbuffers.Builder, adjustmentWidth: int):
    builder.PrependUint32Slot(14, adjustmentWidth, 0)

def _XNNNodeConvAddInput1Id(builder: flatbuffers.Builder, input1Id: int):
    builder.PrependUint32Slot(15, input1Id, 0)

def _XNNNodeConvAddFilterId(builder: flatbuffers.Builder, filterId: int):
    builder.PrependUint32Slot(16, filterId, 0)

def _XNNNodeConvAddBiasId(builder: flatbuffers.Builder, biasId: int):
    builder.PrependUint32Slot(17, biasId, 0)

def _XNNNodeConvAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(18, outputId, 0)

def _XNNNodeConvAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(19, flags, 0)

def _XNNNodeConvEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class _XNNNodeConvT(object):

    # _XNNNodeConvT
    def __init__(
        self,
        paddingTop = 0,
        paddingRight = 0,
        paddingBottom = 0,
        paddingLeft = 0,
        kernelHeight = 0,
        kernelWidth = 0,
        subsamplingHeight = 0,
        subsamplingWidth = 0,
        dilationHeight = 0,
        dilationWidth = 0,
        groupInputChannels = 0,
        groupOutputChannels = 0,
        groups = 0,
        adjustmentHeight = 0,
        adjustmentWidth = 0,
        input1Id = 0,
        filterId = 0,
        biasId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.paddingTop = paddingTop  # type: int
        self.paddingRight = paddingRight  # type: int
        self.paddingBottom = paddingBottom  # type: int
        self.paddingLeft = paddingLeft  # type: int
        self.kernelHeight = kernelHeight  # type: int
        self.kernelWidth = kernelWidth  # type: int
        self.subsamplingHeight = subsamplingHeight  # type: int
        self.subsamplingWidth = subsamplingWidth  # type: int
        self.dilationHeight = dilationHeight  # type: int
        self.dilationWidth = dilationWidth  # type: int
        self.groupInputChannels = groupInputChannels  # type: int
        self.groupOutputChannels = groupOutputChannels  # type: int
        self.groups = groups  # type: int
        self.adjustmentHeight = adjustmentHeight  # type: int
        self.adjustmentWidth = adjustmentWidth  # type: int
        self.input1Id = input1Id  # type: int
        self.filterId = filterId  # type: int
        self.biasId = biasId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        _XnnnodeConv = _XNNNodeConv()
        _XnnnodeConv.Init(buf, pos)
        return cls.InitFromObj(_XnnnodeConv)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, _XnnnodeConv):
        x = _XNNNodeConvT()
        x._UnPack(_XnnnodeConv)
        return x

    # _XNNNodeConvT
    def _UnPack(self, _XnnnodeConv):
        if _XnnnodeConv is None:
            return
        self.paddingTop = _XnnnodeConv.PaddingTop()
        self.paddingRight = _XnnnodeConv.PaddingRight()
        self.paddingBottom = _XnnnodeConv.PaddingBottom()
        self.paddingLeft = _XnnnodeConv.PaddingLeft()
        self.kernelHeight = _XnnnodeConv.KernelHeight()
        self.kernelWidth = _XnnnodeConv.KernelWidth()
        self.subsamplingHeight = _XnnnodeConv.SubsamplingHeight()
        self.subsamplingWidth = _XnnnodeConv.SubsamplingWidth()
        self.dilationHeight = _XnnnodeConv.DilationHeight()
        self.dilationWidth = _XnnnodeConv.DilationWidth()
        self.groupInputChannels = _XnnnodeConv.GroupInputChannels()
        self.groupOutputChannels = _XnnnodeConv.GroupOutputChannels()
        self.groups = _XnnnodeConv.Groups()
        self.adjustmentHeight = _XnnnodeConv.AdjustmentHeight()
        self.adjustmentWidth = _XnnnodeConv.AdjustmentWidth()
        self.input1Id = _XnnnodeConv.Input1Id()
        self.filterId = _XnnnodeConv.FilterId()
        self.biasId = _XnnnodeConv.BiasId()
        self.outputId = _XnnnodeConv.OutputId()
        self.flags = _XnnnodeConv.Flags()

    # _XNNNodeConvT
    def Pack(self, builder):
        _XNNNodeConvStart(builder)
        _XNNNodeConvAddPaddingTop(builder, self.paddingTop)
        _XNNNodeConvAddPaddingRight(builder, self.paddingRight)
        _XNNNodeConvAddPaddingBottom(builder, self.paddingBottom)
        _XNNNodeConvAddPaddingLeft(builder, self.paddingLeft)
        _XNNNodeConvAddKernelHeight(builder, self.kernelHeight)
        _XNNNodeConvAddKernelWidth(builder, self.kernelWidth)
        _XNNNodeConvAddSubsamplingHeight(builder, self.subsamplingHeight)
        _XNNNodeConvAddSubsamplingWidth(builder, self.subsamplingWidth)
        _XNNNodeConvAddDilationHeight(builder, self.dilationHeight)
        _XNNNodeConvAddDilationWidth(builder, self.dilationWidth)
        _XNNNodeConvAddGroupInputChannels(builder, self.groupInputChannels)
        _XNNNodeConvAddGroupOutputChannels(builder, self.groupOutputChannels)
        _XNNNodeConvAddGroups(builder, self.groups)
        _XNNNodeConvAddAdjustmentHeight(builder, self.adjustmentHeight)
        _XNNNodeConvAddAdjustmentWidth(builder, self.adjustmentWidth)
        _XNNNodeConvAddInput1Id(builder, self.input1Id)
        _XNNNodeConvAddFilterId(builder, self.filterId)
        _XNNNodeConvAddBiasId(builder, self.biasId)
        _XNNNodeConvAddOutputId(builder, self.outputId)
        _XNNNodeConvAddFlags(builder, self.flags)
        _XnnnodeConv = _XNNNodeConvEnd(builder)
        return _XnnnodeConv


class _XNNPooling2D(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = _XNNPooling2D()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAs_XNNPooling2D(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def _XNNPooling2DBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # _XNNPooling2D
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # _XNNPooling2D
    def PaddingTop(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def PaddingRight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def PaddingBottom(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def PaddingLeft(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def PoolingHeight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def PoolingWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def StrideHeight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def StrideWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def DilationHeight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def DilationWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def InputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # _XNNPooling2D
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def _XNNPooling2DStart(builder: flatbuffers.Builder):
    builder.StartObject(13)

def _XNNPooling2DAddPaddingTop(builder: flatbuffers.Builder, paddingTop: int):
    builder.PrependUint32Slot(0, paddingTop, 0)

def _XNNPooling2DAddPaddingRight(builder: flatbuffers.Builder, paddingRight: int):
    builder.PrependUint32Slot(1, paddingRight, 0)

def _XNNPooling2DAddPaddingBottom(builder: flatbuffers.Builder, paddingBottom: int):
    builder.PrependUint32Slot(2, paddingBottom, 0)

def _XNNPooling2DAddPaddingLeft(builder: flatbuffers.Builder, paddingLeft: int):
    builder.PrependUint32Slot(3, paddingLeft, 0)

def _XNNPooling2DAddPoolingHeight(builder: flatbuffers.Builder, poolingHeight: int):
    builder.PrependUint32Slot(4, poolingHeight, 0)

def _XNNPooling2DAddPoolingWidth(builder: flatbuffers.Builder, poolingWidth: int):
    builder.PrependUint32Slot(5, poolingWidth, 0)

def _XNNPooling2DAddStrideHeight(builder: flatbuffers.Builder, strideHeight: int):
    builder.PrependUint32Slot(6, strideHeight, 0)

def _XNNPooling2DAddStrideWidth(builder: flatbuffers.Builder, strideWidth: int):
    builder.PrependUint32Slot(7, strideWidth, 0)

def _XNNPooling2DAddDilationHeight(builder: flatbuffers.Builder, dilationHeight: int):
    builder.PrependUint32Slot(8, dilationHeight, 0)

def _XNNPooling2DAddDilationWidth(builder: flatbuffers.Builder, dilationWidth: int):
    builder.PrependUint32Slot(9, dilationWidth, 0)

def _XNNPooling2DAddInputId(builder: flatbuffers.Builder, inputId: int):
    builder.PrependUint32Slot(10, inputId, 0)

def _XNNPooling2DAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(11, outputId, 0)

def _XNNPooling2DAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(12, flags, 0)

def _XNNPooling2DEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class _XNNPooling2DT(object):

    # _XNNPooling2DT
    def __init__(
        self,
        paddingTop = 0,
        paddingRight = 0,
        paddingBottom = 0,
        paddingLeft = 0,
        poolingHeight = 0,
        poolingWidth = 0,
        strideHeight = 0,
        strideWidth = 0,
        dilationHeight = 0,
        dilationWidth = 0,
        inputId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.paddingTop = paddingTop  # type: int
        self.paddingRight = paddingRight  # type: int
        self.paddingBottom = paddingBottom  # type: int
        self.paddingLeft = paddingLeft  # type: int
        self.poolingHeight = poolingHeight  # type: int
        self.poolingWidth = poolingWidth  # type: int
        self.strideHeight = strideHeight  # type: int
        self.strideWidth = strideWidth  # type: int
        self.dilationHeight = dilationHeight  # type: int
        self.dilationWidth = dilationWidth  # type: int
        self.inputId = inputId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        _Xnnpooling2D = _XNNPooling2D()
        _Xnnpooling2D.Init(buf, pos)
        return cls.InitFromObj(_Xnnpooling2D)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, _Xnnpooling2D):
        x = _XNNPooling2DT()
        x._UnPack(_Xnnpooling2D)
        return x

    # _XNNPooling2DT
    def _UnPack(self, _Xnnpooling2D):
        if _Xnnpooling2D is None:
            return
        self.paddingTop = _Xnnpooling2D.PaddingTop()
        self.paddingRight = _Xnnpooling2D.PaddingRight()
        self.paddingBottom = _Xnnpooling2D.PaddingBottom()
        self.paddingLeft = _Xnnpooling2D.PaddingLeft()
        self.poolingHeight = _Xnnpooling2D.PoolingHeight()
        self.poolingWidth = _Xnnpooling2D.PoolingWidth()
        self.strideHeight = _Xnnpooling2D.StrideHeight()
        self.strideWidth = _Xnnpooling2D.StrideWidth()
        self.dilationHeight = _Xnnpooling2D.DilationHeight()
        self.dilationWidth = _Xnnpooling2D.DilationWidth()
        self.inputId = _Xnnpooling2D.InputId()
        self.outputId = _Xnnpooling2D.OutputId()
        self.flags = _Xnnpooling2D.Flags()

    # _XNNPooling2DT
    def Pack(self, builder):
        _XNNPooling2DStart(builder)
        _XNNPooling2DAddPaddingTop(builder, self.paddingTop)
        _XNNPooling2DAddPaddingRight(builder, self.paddingRight)
        _XNNPooling2DAddPaddingBottom(builder, self.paddingBottom)
        _XNNPooling2DAddPaddingLeft(builder, self.paddingLeft)
        _XNNPooling2DAddPoolingHeight(builder, self.poolingHeight)
        _XNNPooling2DAddPoolingWidth(builder, self.poolingWidth)
        _XNNPooling2DAddStrideHeight(builder, self.strideHeight)
        _XNNPooling2DAddStrideWidth(builder, self.strideWidth)
        _XNNPooling2DAddDilationHeight(builder, self.dilationHeight)
        _XNNPooling2DAddDilationWidth(builder, self.dilationWidth)
        _XNNPooling2DAddInputId(builder, self.inputId)
        _XNNPooling2DAddOutputId(builder, self.outputId)
        _XNNPooling2DAddFlags(builder, self.flags)
        _Xnnpooling2D = _XNNPooling2DEnd(builder)
        return _Xnnpooling2D


class XNNStaticReshape(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNStaticReshape()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNStaticReshape(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNStaticReshapeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNStaticReshape
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNStaticReshape
    def NumDims(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticReshape
    def NewShape(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # XNNStaticReshape
    def NewShapeAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # XNNStaticReshape
    def NewShapeLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNStaticReshape
    def NewShapeIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # XNNStaticReshape
    def InputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticReshape
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticReshape
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def XNNStaticReshapeStart(builder: flatbuffers.Builder):
    builder.StartObject(5)

def XNNStaticReshapeAddNumDims(builder: flatbuffers.Builder, numDims: int):
    builder.PrependUint32Slot(0, numDims, 0)

def XNNStaticReshapeAddNewShape(builder: flatbuffers.Builder, newShape: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(newShape), 0)

def XNNStaticReshapeStartNewShapeVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNStaticReshapeAddInputId(builder: flatbuffers.Builder, inputId: int):
    builder.PrependUint32Slot(2, inputId, 0)

def XNNStaticReshapeAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(3, outputId, 0)

def XNNStaticReshapeAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(4, flags, 0)

def XNNStaticReshapeEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class XNNStaticReshapeT(object):

    # XNNStaticReshapeT
    def __init__(
        self,
        numDims = 0,
        newShape = None,
        inputId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.numDims = numDims  # type: int
        self.newShape = newShape  # type: Optional[List[int]]
        self.inputId = inputId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnnstaticReshape = XNNStaticReshape()
        xnnstaticReshape.Init(buf, pos)
        return cls.InitFromObj(xnnstaticReshape)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnnstaticReshape):
        x = XNNStaticReshapeT()
        x._UnPack(xnnstaticReshape)
        return x

    # XNNStaticReshapeT
    def _UnPack(self, xnnstaticReshape):
        if xnnstaticReshape is None:
            return
        self.numDims = xnnstaticReshape.NumDims()
        if not xnnstaticReshape.NewShapeIsNone():
            if np is None:
                self.newShape = []
                for i in range(xnnstaticReshape.NewShapeLength()):
                    self.newShape.append(xnnstaticReshape.NewShape(i))
            else:
                self.newShape = xnnstaticReshape.NewShapeAsNumpy()
        self.inputId = xnnstaticReshape.InputId()
        self.outputId = xnnstaticReshape.OutputId()
        self.flags = xnnstaticReshape.Flags()

    # XNNStaticReshapeT
    def Pack(self, builder):
        if self.newShape is not None:
            if np is not None and type(self.newShape) is np.ndarray:
                newShape = builder.CreateNumpyVector(self.newShape)
            else:
                XNNStaticReshapeStartNewShapeVector(builder, len(self.newShape))
                for i in reversed(range(len(self.newShape))):
                    builder.PrependUint32(self.newShape[i])
                newShape = builder.EndVector()
        XNNStaticReshapeStart(builder)
        XNNStaticReshapeAddNumDims(builder, self.numDims)
        if self.newShape is not None:
            XNNStaticReshapeAddNewShape(builder, newShape)
        XNNStaticReshapeAddInputId(builder, self.inputId)
        XNNStaticReshapeAddOutputId(builder, self.outputId)
        XNNStaticReshapeAddFlags(builder, self.flags)
        xnnstaticReshape = XNNStaticReshapeEnd(builder)
        return xnnstaticReshape


class XNNStaticSlice(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNStaticSlice()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNStaticSlice(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNStaticSliceBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNStaticSlice
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNStaticSlice
    def NumDims(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticSlice
    def Offsets(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # XNNStaticSlice
    def OffsetsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # XNNStaticSlice
    def OffsetsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNStaticSlice
    def OffsetsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # XNNStaticSlice
    def Sizes(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # XNNStaticSlice
    def SizesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # XNNStaticSlice
    def SizesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNStaticSlice
    def SizesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # XNNStaticSlice
    def InputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticSlice
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNStaticSlice
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def XNNStaticSliceStart(builder: flatbuffers.Builder):
    builder.StartObject(6)

def XNNStaticSliceAddNumDims(builder: flatbuffers.Builder, numDims: int):
    builder.PrependUint32Slot(0, numDims, 0)

def XNNStaticSliceAddOffsets(builder: flatbuffers.Builder, offsets: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(offsets), 0)

def XNNStaticSliceStartOffsetsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNStaticSliceAddSizes(builder: flatbuffers.Builder, sizes: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(sizes), 0)

def XNNStaticSliceStartSizesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNStaticSliceAddInputId(builder: flatbuffers.Builder, inputId: int):
    builder.PrependUint32Slot(3, inputId, 0)

def XNNStaticSliceAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(4, outputId, 0)

def XNNStaticSliceAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(5, flags, 0)

def XNNStaticSliceEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class XNNStaticSliceT(object):

    # XNNStaticSliceT
    def __init__(
        self,
        numDims = 0,
        offsets = None,
        sizes = None,
        inputId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.numDims = numDims  # type: int
        self.offsets = offsets  # type: Optional[List[int]]
        self.sizes = sizes  # type: Optional[List[int]]
        self.inputId = inputId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnnstaticSlice = XNNStaticSlice()
        xnnstaticSlice.Init(buf, pos)
        return cls.InitFromObj(xnnstaticSlice)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnnstaticSlice):
        x = XNNStaticSliceT()
        x._UnPack(xnnstaticSlice)
        return x

    # XNNStaticSliceT
    def _UnPack(self, xnnstaticSlice):
        if xnnstaticSlice is None:
            return
        self.numDims = xnnstaticSlice.NumDims()
        if not xnnstaticSlice.OffsetsIsNone():
            if np is None:
                self.offsets = []
                for i in range(xnnstaticSlice.OffsetsLength()):
                    self.offsets.append(xnnstaticSlice.Offsets(i))
            else:
                self.offsets = xnnstaticSlice.OffsetsAsNumpy()
        if not xnnstaticSlice.SizesIsNone():
            if np is None:
                self.sizes = []
                for i in range(xnnstaticSlice.SizesLength()):
                    self.sizes.append(xnnstaticSlice.Sizes(i))
            else:
                self.sizes = xnnstaticSlice.SizesAsNumpy()
        self.inputId = xnnstaticSlice.InputId()
        self.outputId = xnnstaticSlice.OutputId()
        self.flags = xnnstaticSlice.Flags()

    # XNNStaticSliceT
    def Pack(self, builder):
        if self.offsets is not None:
            if np is not None and type(self.offsets) is np.ndarray:
                offsets = builder.CreateNumpyVector(self.offsets)
            else:
                XNNStaticSliceStartOffsetsVector(builder, len(self.offsets))
                for i in reversed(range(len(self.offsets))):
                    builder.PrependUint32(self.offsets[i])
                offsets = builder.EndVector()
        if self.sizes is not None:
            if np is not None and type(self.sizes) is np.ndarray:
                sizes = builder.CreateNumpyVector(self.sizes)
            else:
                XNNStaticSliceStartSizesVector(builder, len(self.sizes))
                for i in reversed(range(len(self.sizes))):
                    builder.PrependUint32(self.sizes[i])
                sizes = builder.EndVector()
        XNNStaticSliceStart(builder)
        XNNStaticSliceAddNumDims(builder, self.numDims)
        if self.offsets is not None:
            XNNStaticSliceAddOffsets(builder, offsets)
        if self.sizes is not None:
            XNNStaticSliceAddSizes(builder, sizes)
        XNNStaticSliceAddInputId(builder, self.inputId)
        XNNStaticSliceAddOutputId(builder, self.outputId)
        XNNStaticSliceAddFlags(builder, self.flags)
        xnnstaticSlice = XNNStaticSliceEnd(builder)
        return xnnstaticSlice


class XNNScaledDotProductAttention(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNScaledDotProductAttention()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNScaledDotProductAttention(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNScaledDotProductAttentionBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNScaledDotProductAttention
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNScaledDotProductAttention
    def QueryId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNScaledDotProductAttention
    def KeyId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNScaledDotProductAttention
    def ValueId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNScaledDotProductAttention
    def ScaleId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNScaledDotProductAttention
    def MaskId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNScaledDotProductAttention
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNScaledDotProductAttention
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def XNNScaledDotProductAttentionStart(builder: flatbuffers.Builder):
    builder.StartObject(7)

def XNNScaledDotProductAttentionAddQueryId(builder: flatbuffers.Builder, queryId: int):
    builder.PrependUint32Slot(0, queryId, 0)

def XNNScaledDotProductAttentionAddKeyId(builder: flatbuffers.Builder, keyId: int):
    builder.PrependUint32Slot(1, keyId, 0)

def XNNScaledDotProductAttentionAddValueId(builder: flatbuffers.Builder, valueId: int):
    builder.PrependUint32Slot(2, valueId, 0)

def XNNScaledDotProductAttentionAddScaleId(builder: flatbuffers.Builder, scaleId: int):
    builder.PrependUint32Slot(3, scaleId, 0)

def XNNScaledDotProductAttentionAddMaskId(builder: flatbuffers.Builder, maskId: int):
    builder.PrependUint32Slot(4, maskId, 0)

def XNNScaledDotProductAttentionAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(5, outputId, 0)

def XNNScaledDotProductAttentionAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(6, flags, 0)

def XNNScaledDotProductAttentionEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class XNNScaledDotProductAttentionT(object):

    # XNNScaledDotProductAttentionT
    def __init__(
        self,
        queryId = 0,
        keyId = 0,
        valueId = 0,
        scaleId = 0,
        maskId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.queryId = queryId  # type: int
        self.keyId = keyId  # type: int
        self.valueId = valueId  # type: int
        self.scaleId = scaleId  # type: int
        self.maskId = maskId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnnscaledDotProductAttention = XNNScaledDotProductAttention()
        xnnscaledDotProductAttention.Init(buf, pos)
        return cls.InitFromObj(xnnscaledDotProductAttention)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnnscaledDotProductAttention):
        x = XNNScaledDotProductAttentionT()
        x._UnPack(xnnscaledDotProductAttention)
        return x

    # XNNScaledDotProductAttentionT
    def _UnPack(self, xnnscaledDotProductAttention):
        if xnnscaledDotProductAttention is None:
            return
        self.queryId = xnnscaledDotProductAttention.QueryId()
        self.keyId = xnnscaledDotProductAttention.KeyId()
        self.valueId = xnnscaledDotProductAttention.ValueId()
        self.scaleId = xnnscaledDotProductAttention.ScaleId()
        self.maskId = xnnscaledDotProductAttention.MaskId()
        self.outputId = xnnscaledDotProductAttention.OutputId()
        self.flags = xnnscaledDotProductAttention.Flags()

    # XNNScaledDotProductAttentionT
    def Pack(self, builder):
        XNNScaledDotProductAttentionStart(builder)
        XNNScaledDotProductAttentionAddQueryId(builder, self.queryId)
        XNNScaledDotProductAttentionAddKeyId(builder, self.keyId)
        XNNScaledDotProductAttentionAddValueId(builder, self.valueId)
        XNNScaledDotProductAttentionAddScaleId(builder, self.scaleId)
        XNNScaledDotProductAttentionAddMaskId(builder, self.maskId)
        XNNScaledDotProductAttentionAddOutputId(builder, self.outputId)
        XNNScaledDotProductAttentionAddFlags(builder, self.flags)
        xnnscaledDotProductAttention = XNNScaledDotProductAttentionEnd(builder)
        return xnnscaledDotProductAttention


class XNNArgMaxPooling2d(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNArgMaxPooling2d()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNArgMaxPooling2d(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNArgMaxPooling2dBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNArgMaxPooling2d
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNArgMaxPooling2d
    def PaddingTop(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNArgMaxPooling2d
    def PaddingRight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNArgMaxPooling2d
    def PaddingBottom(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNArgMaxPooling2d
    def PaddingLeft(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNArgMaxPooling2d
    def PoolingHeight(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNArgMaxPooling2d
    def PoolingWidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNArgMaxPooling2d
    def InputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNArgMaxPooling2d
    def OutputValueId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNArgMaxPooling2d
    def OutputIndexId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNArgMaxPooling2d
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def XNNArgMaxPooling2dStart(builder: flatbuffers.Builder):
    builder.StartObject(10)

def XNNArgMaxPooling2dAddPaddingTop(builder: flatbuffers.Builder, paddingTop: int):
    builder.PrependUint32Slot(0, paddingTop, 0)

def XNNArgMaxPooling2dAddPaddingRight(builder: flatbuffers.Builder, paddingRight: int):
    builder.PrependUint32Slot(1, paddingRight, 0)

def XNNArgMaxPooling2dAddPaddingBottom(builder: flatbuffers.Builder, paddingBottom: int):
    builder.PrependUint32Slot(2, paddingBottom, 0)

def XNNArgMaxPooling2dAddPaddingLeft(builder: flatbuffers.Builder, paddingLeft: int):
    builder.PrependUint32Slot(3, paddingLeft, 0)

def XNNArgMaxPooling2dAddPoolingHeight(builder: flatbuffers.Builder, poolingHeight: int):
    builder.PrependUint32Slot(4, poolingHeight, 0)

def XNNArgMaxPooling2dAddPoolingWidth(builder: flatbuffers.Builder, poolingWidth: int):
    builder.PrependUint32Slot(5, poolingWidth, 0)

def XNNArgMaxPooling2dAddInputId(builder: flatbuffers.Builder, inputId: int):
    builder.PrependUint32Slot(6, inputId, 0)

def XNNArgMaxPooling2dAddOutputValueId(builder: flatbuffers.Builder, outputValueId: int):
    builder.PrependUint32Slot(7, outputValueId, 0)

def XNNArgMaxPooling2dAddOutputIndexId(builder: flatbuffers.Builder, outputIndexId: int):
    builder.PrependUint32Slot(8, outputIndexId, 0)

def XNNArgMaxPooling2dAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(9, flags, 0)

def XNNArgMaxPooling2dEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class XNNArgMaxPooling2dT(object):

    # XNNArgMaxPooling2dT
    def __init__(
        self,
        paddingTop = 0,
        paddingRight = 0,
        paddingBottom = 0,
        paddingLeft = 0,
        poolingHeight = 0,
        poolingWidth = 0,
        inputId = 0,
        outputValueId = 0,
        outputIndexId = 0,
        flags = 0,
    ):
        self.paddingTop = paddingTop  # type: int
        self.paddingRight = paddingRight  # type: int
        self.paddingBottom = paddingBottom  # type: int
        self.paddingLeft = paddingLeft  # type: int
        self.poolingHeight = poolingHeight  # type: int
        self.poolingWidth = poolingWidth  # type: int
        self.inputId = inputId  # type: int
        self.outputValueId = outputValueId  # type: int
        self.outputIndexId = outputIndexId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnnargMaxPooling2d = XNNArgMaxPooling2d()
        xnnargMaxPooling2d.Init(buf, pos)
        return cls.InitFromObj(xnnargMaxPooling2d)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnnargMaxPooling2d):
        x = XNNArgMaxPooling2dT()
        x._UnPack(xnnargMaxPooling2d)
        return x

    # XNNArgMaxPooling2dT
    def _UnPack(self, xnnargMaxPooling2d):
        if xnnargMaxPooling2d is None:
            return
        self.paddingTop = xnnargMaxPooling2d.PaddingTop()
        self.paddingRight = xnnargMaxPooling2d.PaddingRight()
        self.paddingBottom = xnnargMaxPooling2d.PaddingBottom()
        self.paddingLeft = xnnargMaxPooling2d.PaddingLeft()
        self.poolingHeight = xnnargMaxPooling2d.PoolingHeight()
        self.poolingWidth = xnnargMaxPooling2d.PoolingWidth()
        self.inputId = xnnargMaxPooling2d.InputId()
        self.outputValueId = xnnargMaxPooling2d.OutputValueId()
        self.outputIndexId = xnnargMaxPooling2d.OutputIndexId()
        self.flags = xnnargMaxPooling2d.Flags()

    # XNNArgMaxPooling2dT
    def Pack(self, builder):
        XNNArgMaxPooling2dStart(builder)
        XNNArgMaxPooling2dAddPaddingTop(builder, self.paddingTop)
        XNNArgMaxPooling2dAddPaddingRight(builder, self.paddingRight)
        XNNArgMaxPooling2dAddPaddingBottom(builder, self.paddingBottom)
        XNNArgMaxPooling2dAddPaddingLeft(builder, self.paddingLeft)
        XNNArgMaxPooling2dAddPoolingHeight(builder, self.poolingHeight)
        XNNArgMaxPooling2dAddPoolingWidth(builder, self.poolingWidth)
        XNNArgMaxPooling2dAddInputId(builder, self.inputId)
        XNNArgMaxPooling2dAddOutputValueId(builder, self.outputValueId)
        XNNArgMaxPooling2dAddOutputIndexId(builder, self.outputIndexId)
        XNNArgMaxPooling2dAddFlags(builder, self.flags)
        xnnargMaxPooling2d = XNNArgMaxPooling2dEnd(builder)
        return xnnargMaxPooling2d


class XNNLeakyReLU(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNLeakyReLU()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNLeakyReLU(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNLeakyReLUBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNLeakyReLU
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNLeakyReLU
    def NegativeSlope(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # XNNLeakyReLU
    def InputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNLeakyReLU
    def OutputId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNLeakyReLU
    def Flags(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def XNNLeakyReLUStart(builder: flatbuffers.Builder):
    builder.StartObject(4)

def XNNLeakyReLUAddNegativeSlope(builder: flatbuffers.Builder, negativeSlope: float):
    builder.PrependFloat32Slot(0, negativeSlope, 0.0)

def XNNLeakyReLUAddInputId(builder: flatbuffers.Builder, inputId: int):
    builder.PrependUint32Slot(1, inputId, 0)

def XNNLeakyReLUAddOutputId(builder: flatbuffers.Builder, outputId: int):
    builder.PrependUint32Slot(2, outputId, 0)

def XNNLeakyReLUAddFlags(builder: flatbuffers.Builder, flags: int):
    builder.PrependUint32Slot(3, flags, 0)

def XNNLeakyReLUEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class XNNLeakyReLUT(object):

    # XNNLeakyReLUT
    def __init__(
        self,
        negativeSlope = 0.0,
        inputId = 0,
        outputId = 0,
        flags = 0,
    ):
        self.negativeSlope = negativeSlope  # type: float
        self.inputId = inputId  # type: int
        self.outputId = outputId  # type: int
        self.flags = flags  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnnleakyReLu = XNNLeakyReLU()
        xnnleakyReLu.Init(buf, pos)
        return cls.InitFromObj(xnnleakyReLu)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnnleakyReLu):
        x = XNNLeakyReLUT()
        x._UnPack(xnnleakyReLu)
        return x

    # XNNLeakyReLUT
    def _UnPack(self, xnnleakyReLu):
        if xnnleakyReLu is None:
            return
        self.negativeSlope = xnnleakyReLu.NegativeSlope()
        self.inputId = xnnleakyReLu.InputId()
        self.outputId = xnnleakyReLu.OutputId()
        self.flags = xnnleakyReLu.Flags()

    # XNNLeakyReLUT
    def Pack(self, builder):
        XNNLeakyReLUStart(builder)
        XNNLeakyReLUAddNegativeSlope(builder, self.negativeSlope)
        XNNLeakyReLUAddInputId(builder, self.inputId)
        XNNLeakyReLUAddOutputId(builder, self.outputId)
        XNNLeakyReLUAddFlags(builder, self.flags)
        xnnleakyReLu = XNNLeakyReLUEnd(builder)
        return xnnleakyReLu


class ConstantDataOffset(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ConstantDataOffset()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsConstantDataOffset(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ConstantDataOffsetBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # ConstantDataOffset
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ConstantDataOffset
    def Offset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # ConstantDataOffset
    def Size(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # ConstantDataOffset
    def NamedKey(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def ConstantDataOffsetStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def ConstantDataOffsetAddOffset(builder: flatbuffers.Builder, offset: int):
    builder.PrependUint64Slot(0, offset, 0)

def ConstantDataOffsetAddSize(builder: flatbuffers.Builder, size: int):
    builder.PrependUint64Slot(1, size, 0)

def ConstantDataOffsetAddNamedKey(builder: flatbuffers.Builder, namedKey: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(namedKey), 0)

def ConstantDataOffsetEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class ConstantDataOffsetT(object):

    # ConstantDataOffsetT
    def __init__(
        self,
        offset = 0,
        size = 0,
        namedKey = None,
    ):
        self.offset = offset  # type: int
        self.size = size  # type: int
        self.namedKey = namedKey  # type: Optional[str]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        constantDataOffset = ConstantDataOffset()
        constantDataOffset.Init(buf, pos)
        return cls.InitFromObj(constantDataOffset)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, constantDataOffset):
        x = ConstantDataOffsetT()
        x._UnPack(constantDataOffset)
        return x

    # ConstantDataOffsetT
    def _UnPack(self, constantDataOffset):
        if constantDataOffset is None:
            return
        self.offset = constantDataOffset.Offset()
        self.size = constantDataOffset.Size()
        self.namedKey = constantDataOffset.NamedKey()

    # ConstantDataOffsetT
    def Pack(self, builder):
        if self.namedKey is not None:
            namedKey = builder.CreateString(self.namedKey)
        ConstantDataOffsetStart(builder)
        ConstantDataOffsetAddOffset(builder, self.offset)
        ConstantDataOffsetAddSize(builder, self.size)
        if self.namedKey is not None:
            ConstantDataOffsetAddNamedKey(builder, namedKey)
        constantDataOffset = ConstantDataOffsetEnd(builder)
        return constantDataOffset


class XNNGraph(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = XNNGraph()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsXNNGraph(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def XNNGraphBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x58\x4E\x30\x31", size_prefixed=size_prefixed)

    # XNNGraph
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # XNNGraph
    def Version(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # XNNGraph
    def Xnodes(self, j: int) -> Optional[XNode]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = XNode()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # XNNGraph
    def XnodesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNGraph
    def XnodesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # XNNGraph
    def Xvalues(self, j: int) -> Optional[XValue]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = XValue()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # XNNGraph
    def XvaluesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNGraph
    def XvaluesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # XNNGraph
    def NumExterns(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # XNNGraph
    def InputIds(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # XNNGraph
    def InputIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # XNNGraph
    def InputIdsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNGraph
    def InputIdsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # XNNGraph
    def OutputIds(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # XNNGraph
    def OutputIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # XNNGraph
    def OutputIdsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNGraph
    def OutputIdsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # XNNGraph
    def ConstantData(self, j: int) -> Optional[ConstantDataOffset]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = ConstantDataOffset()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # XNNGraph
    def ConstantDataLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # XNNGraph
    def ConstantDataIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

def XNNGraphStart(builder: flatbuffers.Builder):
    builder.StartObject(9)

def XNNGraphAddVersion(builder: flatbuffers.Builder, version: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(version), 0)

def XNNGraphAddXnodes(builder: flatbuffers.Builder, xnodes: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(xnodes), 0)

def XNNGraphStartXnodesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNGraphAddXvalues(builder: flatbuffers.Builder, xvalues: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(xvalues), 0)

def XNNGraphStartXvaluesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNGraphAddNumExterns(builder: flatbuffers.Builder, numExterns: int):
    builder.PrependUint32Slot(3, numExterns, 0)

def XNNGraphAddInputIds(builder: flatbuffers.Builder, inputIds: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(inputIds), 0)

def XNNGraphStartInputIdsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNGraphAddOutputIds(builder: flatbuffers.Builder, outputIds: int):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(outputIds), 0)

def XNNGraphStartOutputIdsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNGraphAddConstantData(builder: flatbuffers.Builder, constantData: int):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(constantData), 0)

def XNNGraphStartConstantDataVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def XNNGraphEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class XNNGraphT(object):

    # XNNGraphT
    def __init__(
        self,
        version = None,
        xnodes = None,
        xvalues = None,
        numExterns = 0,
        inputIds = None,
        outputIds = None,
        constantData = None,
    ):
        self.version = version  # type: Optional[str]
        self.xnodes = xnodes  # type: Optional[List[XNodeT]]
        self.xvalues = xvalues  # type: Optional[List[XValueT]]
        self.numExterns = numExterns  # type: int
        self.inputIds = inputIds  # type: Optional[List[int]]
        self.outputIds = outputIds  # type: Optional[List[int]]
        self.constantData = constantData  # type: Optional[List[ConstantDataOffsetT]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        xnngraph = XNNGraph()
        xnngraph.Init(buf, pos)
        return cls.InitFromObj(xnngraph)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, xnngraph):
        x = XNNGraphT()
        x._UnPack(xnngraph)
        return x

    # XNNGraphT
    def _UnPack(self, xnngraph):
        if xnngraph is None:
            return
        self.version = xnngraph.Version()
        if not xnngraph.XnodesIsNone():
            self.xnodes = []
            for i in range(xnngraph.XnodesLength()):
                if xnngraph.Xnodes(i) is None:
                    self.xnodes.append(None)
                else:
                    xNode_ = XNodeT.InitFromObj(xnngraph.Xnodes(i))
                    self.xnodes.append(xNode_)
        if not xnngraph.XvaluesIsNone():
            self.xvalues = []
            for i in range(xnngraph.XvaluesLength()):
                if xnngraph.Xvalues(i) is None:
                    self.xvalues.append(None)
                else:
                    xValue_ = XValueT.InitFromObj(xnngraph.Xvalues(i))
                    self.xvalues.append(xValue_)
        self.numExterns = xnngraph.NumExterns()
        if not xnngraph.InputIdsIsNone():
            if np is None:
                self.inputIds = []
                for i in range(xnngraph.InputIdsLength()):
                    self.inputIds.append(xnngraph.InputIds(i))
            else:
                self.inputIds = xnngraph.InputIdsAsNumpy()
        if not xnngraph.OutputIdsIsNone():
            if np is None:
                self.outputIds = []
                for i in range(xnngraph.OutputIdsLength()):
                    self.outputIds.append(xnngraph.OutputIds(i))
            else:
                self.outputIds = xnngraph.OutputIdsAsNumpy()
        if not xnngraph.ConstantDataIsNone():
            self.constantData = []
            for i in range(xnngraph.ConstantDataLength()):
                if xnngraph.ConstantData(i) is None:
                    self.constantData.append(None)
                else:
                    constantDataOffset_ = ConstantDataOffsetT.InitFromObj(xnngraph.ConstantData(i))
                    self.constantData.append(constantDataOffset_)

    # XNNGraphT
    def Pack(self, builder):
        if self.version is not None:
            version = builder.CreateString(self.version)
        if self.xnodes is not None:
            xnodeslist = []
            for i in range(len(self.xnodes)):
                xnodeslist.append(self.xnodes[i].Pack(builder))
            XNNGraphStartXnodesVector(builder, len(self.xnodes))
            for i in reversed(range(len(self.xnodes))):
                builder.PrependUOffsetTRelative(xnodeslist[i])
            xnodes = builder.EndVector()
        if self.xvalues is not None:
            xvalueslist = []
            for i in range(len(self.xvalues)):
                xvalueslist.append(self.xvalues[i].Pack(builder))
            XNNGraphStartXvaluesVector(builder, len(self.xvalues))
            for i in reversed(range(len(self.xvalues))):
                builder.PrependUOffsetTRelative(xvalueslist[i])
            xvalues = builder.EndVector()
        if self.inputIds is not None:
            if np is not None and type(self.inputIds) is np.ndarray:
                inputIds = builder.CreateNumpyVector(self.inputIds)
            else:
                XNNGraphStartInputIdsVector(builder, len(self.inputIds))
                for i in reversed(range(len(self.inputIds))):
                    builder.PrependUint32(self.inputIds[i])
                inputIds = builder.EndVector()
        if self.outputIds is not None:
            if np is not None and type(self.outputIds) is np.ndarray:
                outputIds = builder.CreateNumpyVector(self.outputIds)
            else:
                XNNGraphStartOutputIdsVector(builder, len(self.outputIds))
                for i in reversed(range(len(self.outputIds))):
                    builder.PrependUint32(self.outputIds[i])
                outputIds = builder.EndVector()
        if self.constantData is not None:
            constantDatalist = []
            for i in range(len(self.constantData)):
                constantDatalist.append(self.constantData[i].Pack(builder))
            XNNGraphStartConstantDataVector(builder, len(self.constantData))
            for i in reversed(range(len(self.constantData))):
                builder.PrependUOffsetTRelative(constantDatalist[i])
            constantData = builder.EndVector()
        XNNGraphStart(builder)
        if self.version is not None:
            XNNGraphAddVersion(builder, version)
        if self.xnodes is not None:
            XNNGraphAddXnodes(builder, xnodes)
        if self.xvalues is not None:
            XNNGraphAddXvalues(builder, xvalues)
        XNNGraphAddNumExterns(builder, self.numExterns)
        if self.inputIds is not None:
            XNNGraphAddInputIds(builder, inputIds)
        if self.outputIds is not None:
            XNNGraphAddOutputIds(builder, outputIds)
        if self.constantData is not None:
            XNNGraphAddConstantData(builder, constantData)
        xnngraph = XNNGraphEnd(builder)
        return xnngraph


