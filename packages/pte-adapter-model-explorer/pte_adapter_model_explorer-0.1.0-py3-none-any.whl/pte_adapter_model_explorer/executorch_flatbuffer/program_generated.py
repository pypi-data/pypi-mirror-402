# automatically generated by the FlatBuffers compiler, do not modify

# namespace: executorch_flatbuffer

import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from flatbuffers.table import Table
from typing import Optional
np = import_numpy()

class TensorShapeDynamism(object):
    STATIC = 0
    DYNAMIC_BOUND = 1
    DYNAMIC_UNBOUND = 2


class TensorDataLocation(object):
    SEGMENT = 0
    EXTERNAL = 1


class KernelTypes(object):
    NONE = 0
    Null = 1
    Int = 2
    Bool = 3
    Double = 4
    Tensor = 5
    String = 6
    IntList = 7
    DoubleList = 8
    BoolList = 9
    TensorList = 10
    OptionalTensorList = 11

def KernelTypesCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == KernelTypes.Null:
        return NullT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == KernelTypes.Int:
        return IntT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == KernelTypes.Bool:
        return BoolT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == KernelTypes.Double:
        return DoubleT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == KernelTypes.Tensor:
        return TensorT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == KernelTypes.String:
        return StringT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == KernelTypes.IntList:
        return IntListT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == KernelTypes.DoubleList:
        return DoubleListT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == KernelTypes.BoolList:
        return BoolListT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == KernelTypes.TensorList:
        return TensorListT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == KernelTypes.OptionalTensorList:
        return OptionalTensorListT.InitFromBuf(table.Bytes, table.Pos)
    return None


class InstructionArguments(object):
    NONE = 0
    KernelCall = 1
    DelegateCall = 2
    MoveCall = 3
    JumpFalseCall = 4
    FreeCall = 5

def InstructionArgumentsCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == InstructionArguments.KernelCall:
        return KernelCallT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == InstructionArguments.DelegateCall:
        return DelegateCallT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == InstructionArguments.MoveCall:
        return MoveCallT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == InstructionArguments.JumpFalseCall:
        return JumpFalseCallT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == InstructionArguments.FreeCall:
        return FreeCallT.InitFromBuf(table.Bytes, table.Pos)
    return None


class DataLocation(object):
    INLINE = 0
    SEGMENT = 1


class ContainerMetadata(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ContainerMetadata()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsContainerMetadata(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ContainerMetadataBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # ContainerMetadata
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ContainerMetadata
    def EncodedInpStr(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # ContainerMetadata
    def EncodedOutStr(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def ContainerMetadataStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def ContainerMetadataAddEncodedInpStr(builder: flatbuffers.Builder, encodedInpStr: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(encodedInpStr), 0)

def ContainerMetadataAddEncodedOutStr(builder: flatbuffers.Builder, encodedOutStr: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(encodedOutStr), 0)

def ContainerMetadataEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class ContainerMetadataT(object):

    # ContainerMetadataT
    def __init__(
        self,
        encodedInpStr = None,
        encodedOutStr = None,
    ):
        self.encodedInpStr = encodedInpStr  # type: Optional[str]
        self.encodedOutStr = encodedOutStr  # type: Optional[str]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        containerMetadata = ContainerMetadata()
        containerMetadata.Init(buf, pos)
        return cls.InitFromObj(containerMetadata)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, containerMetadata):
        x = ContainerMetadataT()
        x._UnPack(containerMetadata)
        return x

    # ContainerMetadataT
    def _UnPack(self, containerMetadata):
        if containerMetadata is None:
            return
        self.encodedInpStr = containerMetadata.EncodedInpStr()
        self.encodedOutStr = containerMetadata.EncodedOutStr()

    # ContainerMetadataT
    def Pack(self, builder):
        if self.encodedInpStr is not None:
            encodedInpStr = builder.CreateString(self.encodedInpStr)
        if self.encodedOutStr is not None:
            encodedOutStr = builder.CreateString(self.encodedOutStr)
        ContainerMetadataStart(builder)
        if self.encodedInpStr is not None:
            ContainerMetadataAddEncodedInpStr(builder, encodedInpStr)
        if self.encodedOutStr is not None:
            ContainerMetadataAddEncodedOutStr(builder, encodedOutStr)
        containerMetadata = ContainerMetadataEnd(builder)
        return containerMetadata


class Null(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Null()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsNull(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def NullBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Null
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

def NullStart(builder: flatbuffers.Builder):
    builder.StartObject(0)

def NullEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class NullT(object):

    # NullT
    def __init__(
        self,
    ):
        pass

    @classmethod
    def InitFromBuf(cls, buf, pos):
        null = Null()
        null.Init(buf, pos)
        return cls.InitFromObj(null)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, null):
        x = NullT()
        x._UnPack(null)
        return x

    # NullT
    def _UnPack(self, null):
        if null is None:
            return

    # NullT
    def Pack(self, builder):
        NullStart(builder)
        null = NullEnd(builder)
        return null


class AllocationDetails(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AllocationDetails()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAllocationDetails(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def AllocationDetailsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # AllocationDetails
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # AllocationDetails
    def MemoryId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # AllocationDetails
    def MemoryOffsetLow(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # AllocationDetails
    def MemoryOffsetHigh(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def AllocationDetailsStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def AllocationDetailsAddMemoryId(builder: flatbuffers.Builder, memoryId: int):
    builder.PrependUint32Slot(0, memoryId, 0)

def AllocationDetailsAddMemoryOffsetLow(builder: flatbuffers.Builder, memoryOffsetLow: int):
    builder.PrependUint32Slot(1, memoryOffsetLow, 0)

def AllocationDetailsAddMemoryOffsetHigh(builder: flatbuffers.Builder, memoryOffsetHigh: int):
    builder.PrependUint32Slot(2, memoryOffsetHigh, 0)

def AllocationDetailsEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class AllocationDetailsT(object):

    # AllocationDetailsT
    def __init__(
        self,
        memoryId = 0,
        memoryOffsetLow = 0,
        memoryOffsetHigh = 0,
    ):
        self.memoryId = memoryId  # type: int
        self.memoryOffsetLow = memoryOffsetLow  # type: int
        self.memoryOffsetHigh = memoryOffsetHigh  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        allocationDetails = AllocationDetails()
        allocationDetails.Init(buf, pos)
        return cls.InitFromObj(allocationDetails)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, allocationDetails):
        x = AllocationDetailsT()
        x._UnPack(allocationDetails)
        return x

    # AllocationDetailsT
    def _UnPack(self, allocationDetails):
        if allocationDetails is None:
            return
        self.memoryId = allocationDetails.MemoryId()
        self.memoryOffsetLow = allocationDetails.MemoryOffsetLow()
        self.memoryOffsetHigh = allocationDetails.MemoryOffsetHigh()

    # AllocationDetailsT
    def Pack(self, builder):
        AllocationDetailsStart(builder)
        AllocationDetailsAddMemoryId(builder, self.memoryId)
        AllocationDetailsAddMemoryOffsetLow(builder, self.memoryOffsetLow)
        AllocationDetailsAddMemoryOffsetHigh(builder, self.memoryOffsetHigh)
        allocationDetails = AllocationDetailsEnd(builder)
        return allocationDetails


class ExtraTensorInfo(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ExtraTensorInfo()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsExtraTensorInfo(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ExtraTensorInfoBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # ExtraTensorInfo
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ExtraTensorInfo
    def MutableDataSegmentsIdx(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # ExtraTensorInfo
    def FullyQualifiedName(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # ExtraTensorInfo
    def Location(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def ExtraTensorInfoStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def ExtraTensorInfoAddMutableDataSegmentsIdx(builder: flatbuffers.Builder, mutableDataSegmentsIdx: int):
    builder.PrependUint64Slot(0, mutableDataSegmentsIdx, 0)

def ExtraTensorInfoAddFullyQualifiedName(builder: flatbuffers.Builder, fullyQualifiedName: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(fullyQualifiedName), 0)

def ExtraTensorInfoAddLocation(builder: flatbuffers.Builder, location: int):
    builder.PrependInt8Slot(2, location, 0)

def ExtraTensorInfoEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class ExtraTensorInfoT(object):

    # ExtraTensorInfoT
    def __init__(
        self,
        mutableDataSegmentsIdx = 0,
        fullyQualifiedName = None,
        location = 0,
    ):
        self.mutableDataSegmentsIdx = mutableDataSegmentsIdx  # type: int
        self.fullyQualifiedName = fullyQualifiedName  # type: Optional[str]
        self.location = location  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        extraTensorInfo = ExtraTensorInfo()
        extraTensorInfo.Init(buf, pos)
        return cls.InitFromObj(extraTensorInfo)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, extraTensorInfo):
        x = ExtraTensorInfoT()
        x._UnPack(extraTensorInfo)
        return x

    # ExtraTensorInfoT
    def _UnPack(self, extraTensorInfo):
        if extraTensorInfo is None:
            return
        self.mutableDataSegmentsIdx = extraTensorInfo.MutableDataSegmentsIdx()
        self.fullyQualifiedName = extraTensorInfo.FullyQualifiedName()
        self.location = extraTensorInfo.Location()

    # ExtraTensorInfoT
    def Pack(self, builder):
        if self.fullyQualifiedName is not None:
            fullyQualifiedName = builder.CreateString(self.fullyQualifiedName)
        ExtraTensorInfoStart(builder)
        ExtraTensorInfoAddMutableDataSegmentsIdx(builder, self.mutableDataSegmentsIdx)
        if self.fullyQualifiedName is not None:
            ExtraTensorInfoAddFullyQualifiedName(builder, fullyQualifiedName)
        ExtraTensorInfoAddLocation(builder, self.location)
        extraTensorInfo = ExtraTensorInfoEnd(builder)
        return extraTensorInfo


class Tensor(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Tensor()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTensor(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def TensorBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Tensor
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Tensor
    def ScalarType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Tensor
    def StorageOffset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Tensor
    def Sizes(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Tensor
    def SizesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Tensor
    def SizesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Tensor
    def SizesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Tensor
    def DimOrder(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Tensor
    def DimOrderAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Tensor
    def DimOrderLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Tensor
    def DimOrderIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Tensor
    def RequiresGrad(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Tensor
    def DataBufferIdx(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # Tensor
    def AllocationInfo(self) -> Optional[AllocationDetails]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = AllocationDetails()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Tensor
    def Layout(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Tensor
    def ShapeDynamism(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Tensor
    def ExtraTensorInfo(self) -> Optional[ExtraTensorInfo]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = ExtraTensorInfo()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def TensorStart(builder: flatbuffers.Builder):
    builder.StartObject(10)

def TensorAddScalarType(builder: flatbuffers.Builder, scalarType: int):
    builder.PrependInt8Slot(0, scalarType, 0)

def TensorAddStorageOffset(builder: flatbuffers.Builder, storageOffset: int):
    builder.PrependInt32Slot(1, storageOffset, 0)

def TensorAddSizes(builder: flatbuffers.Builder, sizes: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(sizes), 0)

def TensorStartSizesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def TensorAddDimOrder(builder: flatbuffers.Builder, dimOrder: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(dimOrder), 0)

def TensorStartDimOrderVector(builder, numElems: int) -> int:
    return builder.StartVector(1, numElems, 1)

def TensorAddRequiresGrad(builder: flatbuffers.Builder, requiresGrad: bool):
    builder.PrependBoolSlot(4, requiresGrad, 0)

def TensorAddDataBufferIdx(builder: flatbuffers.Builder, dataBufferIdx: int):
    builder.PrependUint32Slot(5, dataBufferIdx, 0)

def TensorAddAllocationInfo(builder: flatbuffers.Builder, allocationInfo: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(allocationInfo), 0)

def TensorAddLayout(builder: flatbuffers.Builder, layout: int):
    builder.PrependInt8Slot(7, layout, 0)

def TensorAddShapeDynamism(builder: flatbuffers.Builder, shapeDynamism: int):
    builder.PrependInt8Slot(8, shapeDynamism, 0)

def TensorAddExtraTensorInfo(builder: flatbuffers.Builder, extraTensorInfo: int):
    builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(extraTensorInfo), 0)

def TensorEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List, Optional
except:
    pass

class TensorT(object):

    # TensorT
    def __init__(
        self,
        scalarType = 0,
        storageOffset = 0,
        sizes = None,
        dimOrder = None,
        requiresGrad = False,
        dataBufferIdx = 0,
        allocationInfo = None,
        layout = 0,
        shapeDynamism = 0,
        extraTensorInfo = None,
    ):
        self.scalarType = scalarType  # type: int
        self.storageOffset = storageOffset  # type: int
        self.sizes = sizes  # type: Optional[List[int]]
        self.dimOrder = dimOrder  # type: Optional[List[int]]
        self.requiresGrad = requiresGrad  # type: bool
        self.dataBufferIdx = dataBufferIdx  # type: int
        self.allocationInfo = allocationInfo  # type: Optional[AllocationDetailsT]
        self.layout = layout  # type: int
        self.shapeDynamism = shapeDynamism  # type: int
        self.extraTensorInfo = extraTensorInfo  # type: Optional[ExtraTensorInfoT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        tensor = Tensor()
        tensor.Init(buf, pos)
        return cls.InitFromObj(tensor)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, tensor):
        x = TensorT()
        x._UnPack(tensor)
        return x

    # TensorT
    def _UnPack(self, tensor):
        if tensor is None:
            return
        self.scalarType = tensor.ScalarType()
        self.storageOffset = tensor.StorageOffset()
        if not tensor.SizesIsNone():
            if np is None:
                self.sizes = []
                for i in range(tensor.SizesLength()):
                    self.sizes.append(tensor.Sizes(i))
            else:
                self.sizes = tensor.SizesAsNumpy()
        if not tensor.DimOrderIsNone():
            if np is None:
                self.dimOrder = []
                for i in range(tensor.DimOrderLength()):
                    self.dimOrder.append(tensor.DimOrder(i))
            else:
                self.dimOrder = tensor.DimOrderAsNumpy()
        self.requiresGrad = tensor.RequiresGrad()
        self.dataBufferIdx = tensor.DataBufferIdx()
        if tensor.AllocationInfo() is not None:
            self.allocationInfo = AllocationDetailsT.InitFromObj(tensor.AllocationInfo())
        self.layout = tensor.Layout()
        self.shapeDynamism = tensor.ShapeDynamism()
        if tensor.ExtraTensorInfo() is not None:
            self.extraTensorInfo = ExtraTensorInfoT.InitFromObj(tensor.ExtraTensorInfo())

    # TensorT
    def Pack(self, builder):
        if self.sizes is not None:
            if np is not None and type(self.sizes) is np.ndarray:
                sizes = builder.CreateNumpyVector(self.sizes)
            else:
                TensorStartSizesVector(builder, len(self.sizes))
                for i in reversed(range(len(self.sizes))):
                    builder.PrependInt32(self.sizes[i])
                sizes = builder.EndVector()
        if self.dimOrder is not None:
            if np is not None and type(self.dimOrder) is np.ndarray:
                dimOrder = builder.CreateNumpyVector(self.dimOrder)
            else:
                TensorStartDimOrderVector(builder, len(self.dimOrder))
                for i in reversed(range(len(self.dimOrder))):
                    builder.PrependUint8(self.dimOrder[i])
                dimOrder = builder.EndVector()
        if self.allocationInfo is not None:
            allocationInfo = self.allocationInfo.Pack(builder)
        if self.extraTensorInfo is not None:
            extraTensorInfo = self.extraTensorInfo.Pack(builder)
        TensorStart(builder)
        TensorAddScalarType(builder, self.scalarType)
        TensorAddStorageOffset(builder, self.storageOffset)
        if self.sizes is not None:
            TensorAddSizes(builder, sizes)
        if self.dimOrder is not None:
            TensorAddDimOrder(builder, dimOrder)
        TensorAddRequiresGrad(builder, self.requiresGrad)
        TensorAddDataBufferIdx(builder, self.dataBufferIdx)
        if self.allocationInfo is not None:
            TensorAddAllocationInfo(builder, allocationInfo)
        TensorAddLayout(builder, self.layout)
        TensorAddShapeDynamism(builder, self.shapeDynamism)
        if self.extraTensorInfo is not None:
            TensorAddExtraTensorInfo(builder, extraTensorInfo)
        tensor = TensorEnd(builder)
        return tensor


class Int(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Int()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsInt(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def IntBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Int
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Int
    def IntVal(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

def IntStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def IntAddIntVal(builder: flatbuffers.Builder, intVal: int):
    builder.PrependInt64Slot(0, intVal, 0)

def IntEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class IntT(object):

    # IntT
    def __init__(
        self,
        intVal = 0,
    ):
        self.intVal = intVal  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        int = Int()
        int.Init(buf, pos)
        return cls.InitFromObj(int)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, int):
        x = IntT()
        x._UnPack(int)
        return x

    # IntT
    def _UnPack(self, int):
        if int is None:
            return
        self.intVal = int.IntVal()

    # IntT
    def Pack(self, builder):
        IntStart(builder)
        IntAddIntVal(builder, self.intVal)
        int = IntEnd(builder)
        return int


class Bool(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Bool()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBool(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def BoolBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Bool
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Bool
    def BoolVal(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def BoolStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def BoolAddBoolVal(builder: flatbuffers.Builder, boolVal: bool):
    builder.PrependBoolSlot(0, boolVal, 0)

def BoolEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class BoolT(object):

    # BoolT
    def __init__(
        self,
        boolVal = False,
    ):
        self.boolVal = boolVal  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        bool = Bool()
        bool.Init(buf, pos)
        return cls.InitFromObj(bool)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, bool):
        x = BoolT()
        x._UnPack(bool)
        return x

    # BoolT
    def _UnPack(self, bool):
        if bool is None:
            return
        self.boolVal = bool.BoolVal()

    # BoolT
    def Pack(self, builder):
        BoolStart(builder)
        BoolAddBoolVal(builder, self.boolVal)
        bool = BoolEnd(builder)
        return bool


class Double(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Double()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDouble(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def DoubleBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Double
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Double
    def DoubleVal(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

def DoubleStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def DoubleAddDoubleVal(builder: flatbuffers.Builder, doubleVal: float):
    builder.PrependFloat64Slot(0, doubleVal, 0.0)

def DoubleEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class DoubleT(object):

    # DoubleT
    def __init__(
        self,
        doubleVal = 0.0,
    ):
        self.doubleVal = doubleVal  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        double = Double()
        double.Init(buf, pos)
        return cls.InitFromObj(double)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, double):
        x = DoubleT()
        x._UnPack(double)
        return x

    # DoubleT
    def _UnPack(self, double):
        if double is None:
            return
        self.doubleVal = double.DoubleVal()

    # DoubleT
    def Pack(self, builder):
        DoubleStart(builder)
        DoubleAddDoubleVal(builder, self.doubleVal)
        double = DoubleEnd(builder)
        return double


class String(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = String()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsString(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def StringBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # String
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # String
    def StringVal(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def StringStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def StringAddStringVal(builder: flatbuffers.Builder, stringVal: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(stringVal), 0)

def StringEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class StringT(object):

    # StringT
    def __init__(
        self,
        stringVal = None,
    ):
        self.stringVal = stringVal  # type: Optional[str]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        string = String()
        string.Init(buf, pos)
        return cls.InitFromObj(string)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, string):
        x = StringT()
        x._UnPack(string)
        return x

    # StringT
    def _UnPack(self, string):
        if string is None:
            return
        self.stringVal = string.StringVal()

    # StringT
    def Pack(self, builder):
        if self.stringVal is not None:
            stringVal = builder.CreateString(self.stringVal)
        StringStart(builder)
        if self.stringVal is not None:
            StringAddStringVal(builder, stringVal)
        string = StringEnd(builder)
        return string


class IntList(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = IntList()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsIntList(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def IntListBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # IntList
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # IntList
    def Items(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # IntList
    def ItemsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # IntList
    def ItemsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # IntList
    def ItemsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def IntListStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def IntListAddItems(builder: flatbuffers.Builder, items: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(items), 0)

def IntListStartItemsVector(builder, numElems: int) -> int:
    return builder.StartVector(8, numElems, 8)

def IntListEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class IntListT(object):

    # IntListT
    def __init__(
        self,
        items = None,
    ):
        self.items = items  # type: Optional[List[int]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        intList = IntList()
        intList.Init(buf, pos)
        return cls.InitFromObj(intList)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, intList):
        x = IntListT()
        x._UnPack(intList)
        return x

    # IntListT
    def _UnPack(self, intList):
        if intList is None:
            return
        if not intList.ItemsIsNone():
            if np is None:
                self.items = []
                for i in range(intList.ItemsLength()):
                    self.items.append(intList.Items(i))
            else:
                self.items = intList.ItemsAsNumpy()

    # IntListT
    def Pack(self, builder):
        if self.items is not None:
            if np is not None and type(self.items) is np.ndarray:
                items = builder.CreateNumpyVector(self.items)
            else:
                IntListStartItemsVector(builder, len(self.items))
                for i in reversed(range(len(self.items))):
                    builder.PrependInt64(self.items[i])
                items = builder.EndVector()
        IntListStart(builder)
        if self.items is not None:
            IntListAddItems(builder, items)
        intList = IntListEnd(builder)
        return intList


class DoubleList(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = DoubleList()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDoubleList(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def DoubleListBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # DoubleList
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # DoubleList
    def Items(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # DoubleList
    def ItemsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float64Flags, o)
        return 0

    # DoubleList
    def ItemsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # DoubleList
    def ItemsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def DoubleListStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def DoubleListAddItems(builder: flatbuffers.Builder, items: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(items), 0)

def DoubleListStartItemsVector(builder, numElems: int) -> int:
    return builder.StartVector(8, numElems, 8)

def DoubleListEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class DoubleListT(object):

    # DoubleListT
    def __init__(
        self,
        items = None,
    ):
        self.items = items  # type: Optional[List[float]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        doubleList = DoubleList()
        doubleList.Init(buf, pos)
        return cls.InitFromObj(doubleList)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, doubleList):
        x = DoubleListT()
        x._UnPack(doubleList)
        return x

    # DoubleListT
    def _UnPack(self, doubleList):
        if doubleList is None:
            return
        if not doubleList.ItemsIsNone():
            if np is None:
                self.items = []
                for i in range(doubleList.ItemsLength()):
                    self.items.append(doubleList.Items(i))
            else:
                self.items = doubleList.ItemsAsNumpy()

    # DoubleListT
    def Pack(self, builder):
        if self.items is not None:
            if np is not None and type(self.items) is np.ndarray:
                items = builder.CreateNumpyVector(self.items)
            else:
                DoubleListStartItemsVector(builder, len(self.items))
                for i in reversed(range(len(self.items))):
                    builder.PrependFloat64(self.items[i])
                items = builder.EndVector()
        DoubleListStart(builder)
        if self.items is not None:
            DoubleListAddItems(builder, items)
        doubleList = DoubleListEnd(builder)
        return doubleList


class BoolList(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BoolList()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBoolList(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def BoolListBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # BoolList
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # BoolList
    def Items(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.BoolFlags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # BoolList
    def ItemsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.BoolFlags, o)
        return 0

    # BoolList
    def ItemsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # BoolList
    def ItemsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def BoolListStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def BoolListAddItems(builder: flatbuffers.Builder, items: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(items), 0)

def BoolListStartItemsVector(builder, numElems: int) -> int:
    return builder.StartVector(1, numElems, 1)

def BoolListEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class BoolListT(object):

    # BoolListT
    def __init__(
        self,
        items = None,
    ):
        self.items = items  # type: Optional[List[bool]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        boolList = BoolList()
        boolList.Init(buf, pos)
        return cls.InitFromObj(boolList)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, boolList):
        x = BoolListT()
        x._UnPack(boolList)
        return x

    # BoolListT
    def _UnPack(self, boolList):
        if boolList is None:
            return
        if not boolList.ItemsIsNone():
            if np is None:
                self.items = []
                for i in range(boolList.ItemsLength()):
                    self.items.append(boolList.Items(i))
            else:
                self.items = boolList.ItemsAsNumpy()

    # BoolListT
    def Pack(self, builder):
        if self.items is not None:
            if np is not None and type(self.items) is np.ndarray:
                items = builder.CreateNumpyVector(self.items)
            else:
                BoolListStartItemsVector(builder, len(self.items))
                for i in reversed(range(len(self.items))):
                    builder.PrependBool(self.items[i])
                items = builder.EndVector()
        BoolListStart(builder)
        if self.items is not None:
            BoolListAddItems(builder, items)
        boolList = BoolListEnd(builder)
        return boolList


class TensorList(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TensorList()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTensorList(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def TensorListBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # TensorList
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TensorList
    def Items(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # TensorList
    def ItemsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # TensorList
    def ItemsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TensorList
    def ItemsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def TensorListStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def TensorListAddItems(builder: flatbuffers.Builder, items: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(items), 0)

def TensorListStartItemsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def TensorListEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class TensorListT(object):

    # TensorListT
    def __init__(
        self,
        items = None,
    ):
        self.items = items  # type: Optional[List[int]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        tensorList = TensorList()
        tensorList.Init(buf, pos)
        return cls.InitFromObj(tensorList)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, tensorList):
        x = TensorListT()
        x._UnPack(tensorList)
        return x

    # TensorListT
    def _UnPack(self, tensorList):
        if tensorList is None:
            return
        if not tensorList.ItemsIsNone():
            if np is None:
                self.items = []
                for i in range(tensorList.ItemsLength()):
                    self.items.append(tensorList.Items(i))
            else:
                self.items = tensorList.ItemsAsNumpy()

    # TensorListT
    def Pack(self, builder):
        if self.items is not None:
            if np is not None and type(self.items) is np.ndarray:
                items = builder.CreateNumpyVector(self.items)
            else:
                TensorListStartItemsVector(builder, len(self.items))
                for i in reversed(range(len(self.items))):
                    builder.PrependInt32(self.items[i])
                items = builder.EndVector()
        TensorListStart(builder)
        if self.items is not None:
            TensorListAddItems(builder, items)
        tensorList = TensorListEnd(builder)
        return tensorList


class OptionalTensorList(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = OptionalTensorList()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsOptionalTensorList(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def OptionalTensorListBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # OptionalTensorList
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # OptionalTensorList
    def Items(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # OptionalTensorList
    def ItemsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # OptionalTensorList
    def ItemsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # OptionalTensorList
    def ItemsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def OptionalTensorListStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def OptionalTensorListAddItems(builder: flatbuffers.Builder, items: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(items), 0)

def OptionalTensorListStartItemsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def OptionalTensorListEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class OptionalTensorListT(object):

    # OptionalTensorListT
    def __init__(
        self,
        items = None,
    ):
        self.items = items  # type: Optional[List[int]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        optionalTensorList = OptionalTensorList()
        optionalTensorList.Init(buf, pos)
        return cls.InitFromObj(optionalTensorList)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, optionalTensorList):
        x = OptionalTensorListT()
        x._UnPack(optionalTensorList)
        return x

    # OptionalTensorListT
    def _UnPack(self, optionalTensorList):
        if optionalTensorList is None:
            return
        if not optionalTensorList.ItemsIsNone():
            if np is None:
                self.items = []
                for i in range(optionalTensorList.ItemsLength()):
                    self.items.append(optionalTensorList.Items(i))
            else:
                self.items = optionalTensorList.ItemsAsNumpy()

    # OptionalTensorListT
    def Pack(self, builder):
        if self.items is not None:
            if np is not None and type(self.items) is np.ndarray:
                items = builder.CreateNumpyVector(self.items)
            else:
                OptionalTensorListStartItemsVector(builder, len(self.items))
                for i in reversed(range(len(self.items))):
                    builder.PrependInt32(self.items[i])
                items = builder.EndVector()
        OptionalTensorListStart(builder)
        if self.items is not None:
            OptionalTensorListAddItems(builder, items)
        optionalTensorList = OptionalTensorListEnd(builder)
        return optionalTensorList


class EValue(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = EValue()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsEValue(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def EValueBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # EValue
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # EValue
    def ValType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # EValue
    def Val(self) -> Optional[flatbuffers.table.Table]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def EValueStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def EValueAddValType(builder: flatbuffers.Builder, valType: int):
    builder.PrependUint8Slot(0, valType, 0)

def EValueAddVal(builder: flatbuffers.Builder, val: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(val), 0)

def EValueEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import Union
except:
    pass

class EValueT(object):

    # EValueT
    def __init__(
        self,
        valType = 0,
        val = None,
    ):
        self.valType = valType  # type: int
        self.val = val  # type: Union[None, 'NullT', 'IntT', 'BoolT', 'DoubleT', 'TensorT', 'StringT', 'IntListT', 'DoubleListT', 'BoolListT', 'TensorListT', 'OptionalTensorListT']

    @classmethod
    def InitFromBuf(cls, buf, pos):
        evalue = EValue()
        evalue.Init(buf, pos)
        return cls.InitFromObj(evalue)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, evalue):
        x = EValueT()
        x._UnPack(evalue)
        return x

    # EValueT
    def _UnPack(self, evalue):
        if evalue is None:
            return
        self.valType = evalue.ValType()
        self.val = KernelTypesCreator(self.valType, evalue.Val())

    # EValueT
    def Pack(self, builder):
        if self.val is not None:
            val = self.val.Pack(builder)
        EValueStart(builder)
        EValueAddValType(builder, self.valType)
        if self.val is not None:
            EValueAddVal(builder, val)
        evalue = EValueEnd(builder)
        return evalue


class Operator(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Operator()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsOperator(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def OperatorBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Operator
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Operator
    def Name(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Operator
    def Overload(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def OperatorStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def OperatorAddName(builder: flatbuffers.Builder, name: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def OperatorAddOverload(builder: flatbuffers.Builder, overload: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(overload), 0)

def OperatorEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class OperatorT(object):

    # OperatorT
    def __init__(
        self,
        name = None,
        overload = None,
    ):
        self.name = name  # type: Optional[str]
        self.overload = overload  # type: Optional[str]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        operator = Operator()
        operator.Init(buf, pos)
        return cls.InitFromObj(operator)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, operator):
        x = OperatorT()
        x._UnPack(operator)
        return x

    # OperatorT
    def _UnPack(self, operator):
        if operator is None:
            return
        self.name = operator.Name()
        self.overload = operator.Overload()

    # OperatorT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.overload is not None:
            overload = builder.CreateString(self.overload)
        OperatorStart(builder)
        if self.name is not None:
            OperatorAddName(builder, name)
        if self.overload is not None:
            OperatorAddOverload(builder, overload)
        operator = OperatorEnd(builder)
        return operator


class KernelCall(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = KernelCall()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsKernelCall(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def KernelCallBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # KernelCall
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # KernelCall
    def OpIndex(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # KernelCall
    def Args(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # KernelCall
    def ArgsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # KernelCall
    def ArgsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # KernelCall
    def ArgsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

def KernelCallStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def KernelCallAddOpIndex(builder: flatbuffers.Builder, opIndex: int):
    builder.PrependInt32Slot(0, opIndex, 0)

def KernelCallAddArgs(builder: flatbuffers.Builder, args: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(args), 0)

def KernelCallStartArgsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def KernelCallEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class KernelCallT(object):

    # KernelCallT
    def __init__(
        self,
        opIndex = 0,
        args = None,
    ):
        self.opIndex = opIndex  # type: int
        self.args = args  # type: Optional[List[int]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        kernelCall = KernelCall()
        kernelCall.Init(buf, pos)
        return cls.InitFromObj(kernelCall)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, kernelCall):
        x = KernelCallT()
        x._UnPack(kernelCall)
        return x

    # KernelCallT
    def _UnPack(self, kernelCall):
        if kernelCall is None:
            return
        self.opIndex = kernelCall.OpIndex()
        if not kernelCall.ArgsIsNone():
            if np is None:
                self.args = []
                for i in range(kernelCall.ArgsLength()):
                    self.args.append(kernelCall.Args(i))
            else:
                self.args = kernelCall.ArgsAsNumpy()

    # KernelCallT
    def Pack(self, builder):
        if self.args is not None:
            if np is not None and type(self.args) is np.ndarray:
                args = builder.CreateNumpyVector(self.args)
            else:
                KernelCallStartArgsVector(builder, len(self.args))
                for i in reversed(range(len(self.args))):
                    builder.PrependInt32(self.args[i])
                args = builder.EndVector()
        KernelCallStart(builder)
        KernelCallAddOpIndex(builder, self.opIndex)
        if self.args is not None:
            KernelCallAddArgs(builder, args)
        kernelCall = KernelCallEnd(builder)
        return kernelCall


class DelegateCall(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = DelegateCall()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDelegateCall(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def DelegateCallBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # DelegateCall
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # DelegateCall
    def DelegateIndex(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # DelegateCall
    def Args(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # DelegateCall
    def ArgsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # DelegateCall
    def ArgsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # DelegateCall
    def ArgsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

def DelegateCallStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def DelegateCallAddDelegateIndex(builder: flatbuffers.Builder, delegateIndex: int):
    builder.PrependInt32Slot(0, delegateIndex, 0)

def DelegateCallAddArgs(builder: flatbuffers.Builder, args: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(args), 0)

def DelegateCallStartArgsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def DelegateCallEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class DelegateCallT(object):

    # DelegateCallT
    def __init__(
        self,
        delegateIndex = 0,
        args = None,
    ):
        self.delegateIndex = delegateIndex  # type: int
        self.args = args  # type: Optional[List[int]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        delegateCall = DelegateCall()
        delegateCall.Init(buf, pos)
        return cls.InitFromObj(delegateCall)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, delegateCall):
        x = DelegateCallT()
        x._UnPack(delegateCall)
        return x

    # DelegateCallT
    def _UnPack(self, delegateCall):
        if delegateCall is None:
            return
        self.delegateIndex = delegateCall.DelegateIndex()
        if not delegateCall.ArgsIsNone():
            if np is None:
                self.args = []
                for i in range(delegateCall.ArgsLength()):
                    self.args.append(delegateCall.Args(i))
            else:
                self.args = delegateCall.ArgsAsNumpy()

    # DelegateCallT
    def Pack(self, builder):
        if self.args is not None:
            if np is not None and type(self.args) is np.ndarray:
                args = builder.CreateNumpyVector(self.args)
            else:
                DelegateCallStartArgsVector(builder, len(self.args))
                for i in reversed(range(len(self.args))):
                    builder.PrependInt32(self.args[i])
                args = builder.EndVector()
        DelegateCallStart(builder)
        DelegateCallAddDelegateIndex(builder, self.delegateIndex)
        if self.args is not None:
            DelegateCallAddArgs(builder, args)
        delegateCall = DelegateCallEnd(builder)
        return delegateCall


class MoveCall(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MoveCall()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMoveCall(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def MoveCallBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # MoveCall
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # MoveCall
    def MoveFrom(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # MoveCall
    def MoveTo(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def MoveCallStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def MoveCallAddMoveFrom(builder: flatbuffers.Builder, moveFrom: int):
    builder.PrependInt32Slot(0, moveFrom, 0)

def MoveCallAddMoveTo(builder: flatbuffers.Builder, moveTo: int):
    builder.PrependInt32Slot(1, moveTo, 0)

def MoveCallEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class MoveCallT(object):

    # MoveCallT
    def __init__(
        self,
        moveFrom = 0,
        moveTo = 0,
    ):
        self.moveFrom = moveFrom  # type: int
        self.moveTo = moveTo  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        moveCall = MoveCall()
        moveCall.Init(buf, pos)
        return cls.InitFromObj(moveCall)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, moveCall):
        x = MoveCallT()
        x._UnPack(moveCall)
        return x

    # MoveCallT
    def _UnPack(self, moveCall):
        if moveCall is None:
            return
        self.moveFrom = moveCall.MoveFrom()
        self.moveTo = moveCall.MoveTo()

    # MoveCallT
    def Pack(self, builder):
        MoveCallStart(builder)
        MoveCallAddMoveFrom(builder, self.moveFrom)
        MoveCallAddMoveTo(builder, self.moveTo)
        moveCall = MoveCallEnd(builder)
        return moveCall


class JumpFalseCall(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = JumpFalseCall()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsJumpFalseCall(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def JumpFalseCallBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # JumpFalseCall
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # JumpFalseCall
    def CondValueIndex(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # JumpFalseCall
    def DestinationInstruction(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def JumpFalseCallStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def JumpFalseCallAddCondValueIndex(builder: flatbuffers.Builder, condValueIndex: int):
    builder.PrependInt32Slot(0, condValueIndex, 0)

def JumpFalseCallAddDestinationInstruction(builder: flatbuffers.Builder, destinationInstruction: int):
    builder.PrependInt32Slot(1, destinationInstruction, 0)

def JumpFalseCallEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class JumpFalseCallT(object):

    # JumpFalseCallT
    def __init__(
        self,
        condValueIndex = 0,
        destinationInstruction = 0,
    ):
        self.condValueIndex = condValueIndex  # type: int
        self.destinationInstruction = destinationInstruction  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        jumpFalseCall = JumpFalseCall()
        jumpFalseCall.Init(buf, pos)
        return cls.InitFromObj(jumpFalseCall)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, jumpFalseCall):
        x = JumpFalseCallT()
        x._UnPack(jumpFalseCall)
        return x

    # JumpFalseCallT
    def _UnPack(self, jumpFalseCall):
        if jumpFalseCall is None:
            return
        self.condValueIndex = jumpFalseCall.CondValueIndex()
        self.destinationInstruction = jumpFalseCall.DestinationInstruction()

    # JumpFalseCallT
    def Pack(self, builder):
        JumpFalseCallStart(builder)
        JumpFalseCallAddCondValueIndex(builder, self.condValueIndex)
        JumpFalseCallAddDestinationInstruction(builder, self.destinationInstruction)
        jumpFalseCall = JumpFalseCallEnd(builder)
        return jumpFalseCall


class FreeCall(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = FreeCall()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFreeCall(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def FreeCallBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # FreeCall
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # FreeCall
    def ValueIndex(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def FreeCallStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def FreeCallAddValueIndex(builder: flatbuffers.Builder, valueIndex: int):
    builder.PrependInt32Slot(0, valueIndex, 0)

def FreeCallEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class FreeCallT(object):

    # FreeCallT
    def __init__(
        self,
        valueIndex = 0,
    ):
        self.valueIndex = valueIndex  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        freeCall = FreeCall()
        freeCall.Init(buf, pos)
        return cls.InitFromObj(freeCall)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, freeCall):
        x = FreeCallT()
        x._UnPack(freeCall)
        return x

    # FreeCallT
    def _UnPack(self, freeCall):
        if freeCall is None:
            return
        self.valueIndex = freeCall.ValueIndex()

    # FreeCallT
    def Pack(self, builder):
        FreeCallStart(builder)
        FreeCallAddValueIndex(builder, self.valueIndex)
        freeCall = FreeCallEnd(builder)
        return freeCall


class Instruction(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Instruction()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsInstruction(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def InstructionBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Instruction
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Instruction
    def InstrArgsType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # Instruction
    def InstrArgs(self) -> Optional[flatbuffers.table.Table]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def InstructionStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def InstructionAddInstrArgsType(builder: flatbuffers.Builder, instrArgsType: int):
    builder.PrependUint8Slot(0, instrArgsType, 0)

def InstructionAddInstrArgs(builder: flatbuffers.Builder, instrArgs: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(instrArgs), 0)

def InstructionEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import Union
except:
    pass

class InstructionT(object):

    # InstructionT
    def __init__(
        self,
        instrArgsType = 0,
        instrArgs = None,
    ):
        self.instrArgsType = instrArgsType  # type: int
        self.instrArgs = instrArgs  # type: Union[None, 'KernelCallT', 'DelegateCallT', 'MoveCallT', 'JumpFalseCallT', 'FreeCallT']

    @classmethod
    def InitFromBuf(cls, buf, pos):
        instruction = Instruction()
        instruction.Init(buf, pos)
        return cls.InitFromObj(instruction)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, instruction):
        x = InstructionT()
        x._UnPack(instruction)
        return x

    # InstructionT
    def _UnPack(self, instruction):
        if instruction is None:
            return
        self.instrArgsType = instruction.InstrArgsType()
        self.instrArgs = InstructionArgumentsCreator(self.instrArgsType, instruction.InstrArgs())

    # InstructionT
    def Pack(self, builder):
        if self.instrArgs is not None:
            instrArgs = self.instrArgs.Pack(builder)
        InstructionStart(builder)
        InstructionAddInstrArgsType(builder, self.instrArgsType)
        if self.instrArgs is not None:
            InstructionAddInstrArgs(builder, instrArgs)
        instruction = InstructionEnd(builder)
        return instruction


class Frame(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Frame()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFrame(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def FrameBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Frame
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Frame
    def Filename(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Frame
    def Lineno(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Frame
    def Name(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Frame
    def Context(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def FrameStart(builder: flatbuffers.Builder):
    builder.StartObject(4)

def FrameAddFilename(builder: flatbuffers.Builder, filename: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(filename), 0)

def FrameAddLineno(builder: flatbuffers.Builder, lineno: int):
    builder.PrependInt32Slot(1, lineno, 0)

def FrameAddName(builder: flatbuffers.Builder, name: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def FrameAddContext(builder: flatbuffers.Builder, context: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(context), 0)

def FrameEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class FrameT(object):

    # FrameT
    def __init__(
        self,
        filename = None,
        lineno = 0,
        name = None,
        context = None,
    ):
        self.filename = filename  # type: Optional[str]
        self.lineno = lineno  # type: int
        self.name = name  # type: Optional[str]
        self.context = context  # type: Optional[str]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        frame = Frame()
        frame.Init(buf, pos)
        return cls.InitFromObj(frame)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, frame):
        x = FrameT()
        x._UnPack(frame)
        return x

    # FrameT
    def _UnPack(self, frame):
        if frame is None:
            return
        self.filename = frame.Filename()
        self.lineno = frame.Lineno()
        self.name = frame.Name()
        self.context = frame.Context()

    # FrameT
    def Pack(self, builder):
        if self.filename is not None:
            filename = builder.CreateString(self.filename)
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.context is not None:
            context = builder.CreateString(self.context)
        FrameStart(builder)
        if self.filename is not None:
            FrameAddFilename(builder, filename)
        FrameAddLineno(builder, self.lineno)
        if self.name is not None:
            FrameAddName(builder, name)
        if self.context is not None:
            FrameAddContext(builder, context)
        frame = FrameEnd(builder)
        return frame


class FrameList(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = FrameList()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFrameList(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def FrameListBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # FrameList
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # FrameList
    def Items(self, j: int) -> Optional[Frame]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Frame()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # FrameList
    def ItemsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # FrameList
    def ItemsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def FrameListStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def FrameListAddItems(builder: flatbuffers.Builder, items: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(items), 0)

def FrameListStartItemsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def FrameListEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class FrameListT(object):

    # FrameListT
    def __init__(
        self,
        items = None,
    ):
        self.items = items  # type: Optional[List[FrameT]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        frameList = FrameList()
        frameList.Init(buf, pos)
        return cls.InitFromObj(frameList)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, frameList):
        x = FrameListT()
        x._UnPack(frameList)
        return x

    # FrameListT
    def _UnPack(self, frameList):
        if frameList is None:
            return
        if not frameList.ItemsIsNone():
            self.items = []
            for i in range(frameList.ItemsLength()):
                if frameList.Items(i) is None:
                    self.items.append(None)
                else:
                    frame_ = FrameT.InitFromObj(frameList.Items(i))
                    self.items.append(frame_)

    # FrameListT
    def Pack(self, builder):
        if self.items is not None:
            itemslist = []
            for i in range(len(self.items)):
                itemslist.append(self.items[i].Pack(builder))
            FrameListStartItemsVector(builder, len(self.items))
            for i in reversed(range(len(self.items))):
                builder.PrependUOffsetTRelative(itemslist[i])
            items = builder.EndVector()
        FrameListStart(builder)
        if self.items is not None:
            FrameListAddItems(builder, items)
        frameList = FrameListEnd(builder)
        return frameList


class BackendDelegateDataReference(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BackendDelegateDataReference()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBackendDelegateDataReference(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def BackendDelegateDataReferenceBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # BackendDelegateDataReference
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # BackendDelegateDataReference
    def Location(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # BackendDelegateDataReference
    def Index(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def BackendDelegateDataReferenceStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def BackendDelegateDataReferenceAddLocation(builder: flatbuffers.Builder, location: int):
    builder.PrependInt8Slot(0, location, 0)

def BackendDelegateDataReferenceAddIndex(builder: flatbuffers.Builder, index: int):
    builder.PrependUint32Slot(1, index, 0)

def BackendDelegateDataReferenceEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class BackendDelegateDataReferenceT(object):

    # BackendDelegateDataReferenceT
    def __init__(
        self,
        location = 0,
        index = 0,
    ):
        self.location = location  # type: int
        self.index = index  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        backendDelegateDataReference = BackendDelegateDataReference()
        backendDelegateDataReference.Init(buf, pos)
        return cls.InitFromObj(backendDelegateDataReference)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, backendDelegateDataReference):
        x = BackendDelegateDataReferenceT()
        x._UnPack(backendDelegateDataReference)
        return x

    # BackendDelegateDataReferenceT
    def _UnPack(self, backendDelegateDataReference):
        if backendDelegateDataReference is None:
            return
        self.location = backendDelegateDataReference.Location()
        self.index = backendDelegateDataReference.Index()

    # BackendDelegateDataReferenceT
    def Pack(self, builder):
        BackendDelegateDataReferenceStart(builder)
        BackendDelegateDataReferenceAddLocation(builder, self.location)
        BackendDelegateDataReferenceAddIndex(builder, self.index)
        backendDelegateDataReference = BackendDelegateDataReferenceEnd(builder)
        return backendDelegateDataReference


class CompileSpec(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CompileSpec()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsCompileSpec(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def CompileSpecBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # CompileSpec
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # CompileSpec
    def Key(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # CompileSpec
    def Value(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # CompileSpec
    def ValueAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # CompileSpec
    def ValueLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # CompileSpec
    def ValueIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

def CompileSpecStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def CompileSpecAddKey(builder: flatbuffers.Builder, key: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(key), 0)

def CompileSpecAddValue(builder: flatbuffers.Builder, value: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0)

def CompileSpecStartValueVector(builder, numElems: int) -> int:
    return builder.StartVector(1, numElems, 1)

def CompileSpecEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class CompileSpecT(object):

    # CompileSpecT
    def __init__(
        self,
        key = None,
        value = None,
    ):
        self.key = key  # type: Optional[str]
        self.value = value  # type: Optional[List[int]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        compileSpec = CompileSpec()
        compileSpec.Init(buf, pos)
        return cls.InitFromObj(compileSpec)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, compileSpec):
        x = CompileSpecT()
        x._UnPack(compileSpec)
        return x

    # CompileSpecT
    def _UnPack(self, compileSpec):
        if compileSpec is None:
            return
        self.key = compileSpec.Key()
        if not compileSpec.ValueIsNone():
            if np is None:
                self.value = []
                for i in range(compileSpec.ValueLength()):
                    self.value.append(compileSpec.Value(i))
            else:
                self.value = compileSpec.ValueAsNumpy()

    # CompileSpecT
    def Pack(self, builder):
        if self.key is not None:
            key = builder.CreateString(self.key)
        if self.value is not None:
            if np is not None and type(self.value) is np.ndarray:
                value = builder.CreateNumpyVector(self.value)
            else:
                CompileSpecStartValueVector(builder, len(self.value))
                for i in reversed(range(len(self.value))):
                    builder.PrependUint8(self.value[i])
                value = builder.EndVector()
        CompileSpecStart(builder)
        if self.key is not None:
            CompileSpecAddKey(builder, key)
        if self.value is not None:
            CompileSpecAddValue(builder, value)
        compileSpec = CompileSpecEnd(builder)
        return compileSpec


class BackendDelegate(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BackendDelegate()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBackendDelegate(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def BackendDelegateBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # BackendDelegate
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # BackendDelegate
    def Id(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # BackendDelegate
    def Processed(self) -> Optional[BackendDelegateDataReference]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = BackendDelegateDataReference()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # BackendDelegate
    def CompileSpecs(self, j: int) -> Optional[CompileSpec]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = CompileSpec()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # BackendDelegate
    def CompileSpecsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # BackendDelegate
    def CompileSpecsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

def BackendDelegateStart(builder: flatbuffers.Builder):
    builder.StartObject(3)

def BackendDelegateAddId(builder: flatbuffers.Builder, id: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(id), 0)

def BackendDelegateAddProcessed(builder: flatbuffers.Builder, processed: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(processed), 0)

def BackendDelegateAddCompileSpecs(builder: flatbuffers.Builder, compileSpecs: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(compileSpecs), 0)

def BackendDelegateStartCompileSpecsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def BackendDelegateEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List, Optional
except:
    pass

class BackendDelegateT(object):

    # BackendDelegateT
    def __init__(
        self,
        id = None,
        processed = None,
        compileSpecs = None,
    ):
        self.id = id  # type: Optional[str]
        self.processed = processed  # type: Optional[BackendDelegateDataReferenceT]
        self.compileSpecs = compileSpecs  # type: Optional[List[CompileSpecT]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        backendDelegate = BackendDelegate()
        backendDelegate.Init(buf, pos)
        return cls.InitFromObj(backendDelegate)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, backendDelegate):
        x = BackendDelegateT()
        x._UnPack(backendDelegate)
        return x

    # BackendDelegateT
    def _UnPack(self, backendDelegate):
        if backendDelegate is None:
            return
        self.id = backendDelegate.Id()
        if backendDelegate.Processed() is not None:
            self.processed = BackendDelegateDataReferenceT.InitFromObj(backendDelegate.Processed())
        if not backendDelegate.CompileSpecsIsNone():
            self.compileSpecs = []
            for i in range(backendDelegate.CompileSpecsLength()):
                if backendDelegate.CompileSpecs(i) is None:
                    self.compileSpecs.append(None)
                else:
                    compileSpec_ = CompileSpecT.InitFromObj(backendDelegate.CompileSpecs(i))
                    self.compileSpecs.append(compileSpec_)

    # BackendDelegateT
    def Pack(self, builder):
        if self.id is not None:
            id = builder.CreateString(self.id)
        if self.processed is not None:
            processed = self.processed.Pack(builder)
        if self.compileSpecs is not None:
            compileSpecslist = []
            for i in range(len(self.compileSpecs)):
                compileSpecslist.append(self.compileSpecs[i].Pack(builder))
            BackendDelegateStartCompileSpecsVector(builder, len(self.compileSpecs))
            for i in reversed(range(len(self.compileSpecs))):
                builder.PrependUOffsetTRelative(compileSpecslist[i])
            compileSpecs = builder.EndVector()
        BackendDelegateStart(builder)
        if self.id is not None:
            BackendDelegateAddId(builder, id)
        if self.processed is not None:
            BackendDelegateAddProcessed(builder, processed)
        if self.compileSpecs is not None:
            BackendDelegateAddCompileSpecs(builder, compileSpecs)
        backendDelegate = BackendDelegateEnd(builder)
        return backendDelegate


class Chain(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Chain()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsChain(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ChainBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Chain
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Chain
    def Inputs(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Chain
    def InputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Chain
    def InputsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Chain
    def InputsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Chain
    def Outputs(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Chain
    def OutputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Chain
    def OutputsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Chain
    def OutputsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Chain
    def Instructions(self, j: int) -> Optional[Instruction]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Instruction()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Chain
    def InstructionsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Chain
    def InstructionsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Chain
    def Stacktrace(self, j: int) -> Optional[FrameList]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = FrameList()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Chain
    def StacktraceLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Chain
    def StacktraceIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def ChainStart(builder: flatbuffers.Builder):
    builder.StartObject(4)

def ChainAddInputs(builder: flatbuffers.Builder, inputs: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(inputs), 0)

def ChainStartInputsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ChainAddOutputs(builder: flatbuffers.Builder, outputs: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(outputs), 0)

def ChainStartOutputsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ChainAddInstructions(builder: flatbuffers.Builder, instructions: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(instructions), 0)

def ChainStartInstructionsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ChainAddStacktrace(builder: flatbuffers.Builder, stacktrace: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(stacktrace), 0)

def ChainStartStacktraceVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ChainEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class ChainT(object):

    # ChainT
    def __init__(
        self,
        inputs = None,
        outputs = None,
        instructions = None,
        stacktrace = None,
    ):
        self.inputs = inputs  # type: Optional[List[int]]
        self.outputs = outputs  # type: Optional[List[int]]
        self.instructions = instructions  # type: Optional[List[InstructionT]]
        self.stacktrace = stacktrace  # type: Optional[List[FrameListT]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        chain = Chain()
        chain.Init(buf, pos)
        return cls.InitFromObj(chain)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, chain):
        x = ChainT()
        x._UnPack(chain)
        return x

    # ChainT
    def _UnPack(self, chain):
        if chain is None:
            return
        if not chain.InputsIsNone():
            if np is None:
                self.inputs = []
                for i in range(chain.InputsLength()):
                    self.inputs.append(chain.Inputs(i))
            else:
                self.inputs = chain.InputsAsNumpy()
        if not chain.OutputsIsNone():
            if np is None:
                self.outputs = []
                for i in range(chain.OutputsLength()):
                    self.outputs.append(chain.Outputs(i))
            else:
                self.outputs = chain.OutputsAsNumpy()
        if not chain.InstructionsIsNone():
            self.instructions = []
            for i in range(chain.InstructionsLength()):
                if chain.Instructions(i) is None:
                    self.instructions.append(None)
                else:
                    instruction_ = InstructionT.InitFromObj(chain.Instructions(i))
                    self.instructions.append(instruction_)
        if not chain.StacktraceIsNone():
            self.stacktrace = []
            for i in range(chain.StacktraceLength()):
                if chain.Stacktrace(i) is None:
                    self.stacktrace.append(None)
                else:
                    frameList_ = FrameListT.InitFromObj(chain.Stacktrace(i))
                    self.stacktrace.append(frameList_)

    # ChainT
    def Pack(self, builder):
        if self.inputs is not None:
            if np is not None and type(self.inputs) is np.ndarray:
                inputs = builder.CreateNumpyVector(self.inputs)
            else:
                ChainStartInputsVector(builder, len(self.inputs))
                for i in reversed(range(len(self.inputs))):
                    builder.PrependInt32(self.inputs[i])
                inputs = builder.EndVector()
        if self.outputs is not None:
            if np is not None and type(self.outputs) is np.ndarray:
                outputs = builder.CreateNumpyVector(self.outputs)
            else:
                ChainStartOutputsVector(builder, len(self.outputs))
                for i in reversed(range(len(self.outputs))):
                    builder.PrependInt32(self.outputs[i])
                outputs = builder.EndVector()
        if self.instructions is not None:
            instructionslist = []
            for i in range(len(self.instructions)):
                instructionslist.append(self.instructions[i].Pack(builder))
            ChainStartInstructionsVector(builder, len(self.instructions))
            for i in reversed(range(len(self.instructions))):
                builder.PrependUOffsetTRelative(instructionslist[i])
            instructions = builder.EndVector()
        if self.stacktrace is not None:
            stacktracelist = []
            for i in range(len(self.stacktrace)):
                stacktracelist.append(self.stacktrace[i].Pack(builder))
            ChainStartStacktraceVector(builder, len(self.stacktrace))
            for i in reversed(range(len(self.stacktrace))):
                builder.PrependUOffsetTRelative(stacktracelist[i])
            stacktrace = builder.EndVector()
        ChainStart(builder)
        if self.inputs is not None:
            ChainAddInputs(builder, inputs)
        if self.outputs is not None:
            ChainAddOutputs(builder, outputs)
        if self.instructions is not None:
            ChainAddInstructions(builder, instructions)
        if self.stacktrace is not None:
            ChainAddStacktrace(builder, stacktrace)
        chain = ChainEnd(builder)
        return chain


class ExecutionPlan(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ExecutionPlan()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsExecutionPlan(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ExecutionPlanBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # ExecutionPlan
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ExecutionPlan
    def Name(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # ExecutionPlan
    def ContainerMetaType(self) -> Optional[ContainerMetadata]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = ContainerMetadata()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ExecutionPlan
    def Values(self, j: int) -> Optional[EValue]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = EValue()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ExecutionPlan
    def ValuesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def ValuesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # ExecutionPlan
    def Inputs(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ExecutionPlan
    def InputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # ExecutionPlan
    def InputsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def InputsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # ExecutionPlan
    def Outputs(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ExecutionPlan
    def OutputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # ExecutionPlan
    def OutputsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def OutputsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # ExecutionPlan
    def Chains(self, j: int) -> Optional[Chain]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Chain()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ExecutionPlan
    def ChainsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def ChainsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # ExecutionPlan
    def Operators(self, j: int) -> Optional[Operator]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Operator()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ExecutionPlan
    def OperatorsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def OperatorsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # ExecutionPlan
    def Delegates(self, j: int) -> Optional[BackendDelegate]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = BackendDelegate()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # ExecutionPlan
    def DelegatesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def DelegatesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # ExecutionPlan
    def NonConstBufferSizes(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # ExecutionPlan
    def NonConstBufferSizesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int64Flags, o)
        return 0

    # ExecutionPlan
    def NonConstBufferSizesLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ExecutionPlan
    def NonConstBufferSizesIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

def ExecutionPlanStart(builder: flatbuffers.Builder):
    builder.StartObject(9)

def ExecutionPlanAddName(builder: flatbuffers.Builder, name: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)

def ExecutionPlanAddContainerMetaType(builder: flatbuffers.Builder, containerMetaType: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(containerMetaType), 0)

def ExecutionPlanAddValues(builder: flatbuffers.Builder, values: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(values), 0)

def ExecutionPlanStartValuesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ExecutionPlanAddInputs(builder: flatbuffers.Builder, inputs: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(inputs), 0)

def ExecutionPlanStartInputsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ExecutionPlanAddOutputs(builder: flatbuffers.Builder, outputs: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(outputs), 0)

def ExecutionPlanStartOutputsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ExecutionPlanAddChains(builder: flatbuffers.Builder, chains: int):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(chains), 0)

def ExecutionPlanStartChainsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ExecutionPlanAddOperators(builder: flatbuffers.Builder, operators: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(operators), 0)

def ExecutionPlanStartOperatorsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ExecutionPlanAddDelegates(builder: flatbuffers.Builder, delegates: int):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(delegates), 0)

def ExecutionPlanStartDelegatesVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ExecutionPlanAddNonConstBufferSizes(builder: flatbuffers.Builder, nonConstBufferSizes: int):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(nonConstBufferSizes), 0)

def ExecutionPlanStartNonConstBufferSizesVector(builder, numElems: int) -> int:
    return builder.StartVector(8, numElems, 8)

def ExecutionPlanEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List, Optional
except:
    pass

class ExecutionPlanT(object):

    # ExecutionPlanT
    def __init__(
        self,
        name = None,
        containerMetaType = None,
        values = None,
        inputs = None,
        outputs = None,
        chains = None,
        operators = None,
        delegates = None,
        nonConstBufferSizes = None,
    ):
        self.name = name  # type: Optional[str]
        self.containerMetaType = containerMetaType  # type: Optional[ContainerMetadataT]
        self.values = values  # type: Optional[List[EValueT]]
        self.inputs = inputs  # type: Optional[List[int]]
        self.outputs = outputs  # type: Optional[List[int]]
        self.chains = chains  # type: Optional[List[ChainT]]
        self.operators = operators  # type: Optional[List[OperatorT]]
        self.delegates = delegates  # type: Optional[List[BackendDelegateT]]
        self.nonConstBufferSizes = nonConstBufferSizes  # type: Optional[List[int]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        executionPlan = ExecutionPlan()
        executionPlan.Init(buf, pos)
        return cls.InitFromObj(executionPlan)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, executionPlan):
        x = ExecutionPlanT()
        x._UnPack(executionPlan)
        return x

    # ExecutionPlanT
    def _UnPack(self, executionPlan):
        if executionPlan is None:
            return
        self.name = executionPlan.Name()
        if executionPlan.ContainerMetaType() is not None:
            self.containerMetaType = ContainerMetadataT.InitFromObj(executionPlan.ContainerMetaType())
        if not executionPlan.ValuesIsNone():
            self.values = []
            for i in range(executionPlan.ValuesLength()):
                if executionPlan.Values(i) is None:
                    self.values.append(None)
                else:
                    eValue_ = EValueT.InitFromObj(executionPlan.Values(i))
                    self.values.append(eValue_)
        if not executionPlan.InputsIsNone():
            if np is None:
                self.inputs = []
                for i in range(executionPlan.InputsLength()):
                    self.inputs.append(executionPlan.Inputs(i))
            else:
                self.inputs = executionPlan.InputsAsNumpy()
        if not executionPlan.OutputsIsNone():
            if np is None:
                self.outputs = []
                for i in range(executionPlan.OutputsLength()):
                    self.outputs.append(executionPlan.Outputs(i))
            else:
                self.outputs = executionPlan.OutputsAsNumpy()
        if not executionPlan.ChainsIsNone():
            self.chains = []
            for i in range(executionPlan.ChainsLength()):
                if executionPlan.Chains(i) is None:
                    self.chains.append(None)
                else:
                    chain_ = ChainT.InitFromObj(executionPlan.Chains(i))
                    self.chains.append(chain_)
        if not executionPlan.OperatorsIsNone():
            self.operators = []
            for i in range(executionPlan.OperatorsLength()):
                if executionPlan.Operators(i) is None:
                    self.operators.append(None)
                else:
                    operator_ = OperatorT.InitFromObj(executionPlan.Operators(i))
                    self.operators.append(operator_)
        if not executionPlan.DelegatesIsNone():
            self.delegates = []
            for i in range(executionPlan.DelegatesLength()):
                if executionPlan.Delegates(i) is None:
                    self.delegates.append(None)
                else:
                    backendDelegate_ = BackendDelegateT.InitFromObj(executionPlan.Delegates(i))
                    self.delegates.append(backendDelegate_)
        if not executionPlan.NonConstBufferSizesIsNone():
            if np is None:
                self.nonConstBufferSizes = []
                for i in range(executionPlan.NonConstBufferSizesLength()):
                    self.nonConstBufferSizes.append(executionPlan.NonConstBufferSizes(i))
            else:
                self.nonConstBufferSizes = executionPlan.NonConstBufferSizesAsNumpy()

    # ExecutionPlanT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.containerMetaType is not None:
            containerMetaType = self.containerMetaType.Pack(builder)
        if self.values is not None:
            valueslist = []
            for i in range(len(self.values)):
                valueslist.append(self.values[i].Pack(builder))
            ExecutionPlanStartValuesVector(builder, len(self.values))
            for i in reversed(range(len(self.values))):
                builder.PrependUOffsetTRelative(valueslist[i])
            values = builder.EndVector()
        if self.inputs is not None:
            if np is not None and type(self.inputs) is np.ndarray:
                inputs = builder.CreateNumpyVector(self.inputs)
            else:
                ExecutionPlanStartInputsVector(builder, len(self.inputs))
                for i in reversed(range(len(self.inputs))):
                    builder.PrependInt32(self.inputs[i])
                inputs = builder.EndVector()
        if self.outputs is not None:
            if np is not None and type(self.outputs) is np.ndarray:
                outputs = builder.CreateNumpyVector(self.outputs)
            else:
                ExecutionPlanStartOutputsVector(builder, len(self.outputs))
                for i in reversed(range(len(self.outputs))):
                    builder.PrependInt32(self.outputs[i])
                outputs = builder.EndVector()
        if self.chains is not None:
            chainslist = []
            for i in range(len(self.chains)):
                chainslist.append(self.chains[i].Pack(builder))
            ExecutionPlanStartChainsVector(builder, len(self.chains))
            for i in reversed(range(len(self.chains))):
                builder.PrependUOffsetTRelative(chainslist[i])
            chains = builder.EndVector()
        if self.operators is not None:
            operatorslist = []
            for i in range(len(self.operators)):
                operatorslist.append(self.operators[i].Pack(builder))
            ExecutionPlanStartOperatorsVector(builder, len(self.operators))
            for i in reversed(range(len(self.operators))):
                builder.PrependUOffsetTRelative(operatorslist[i])
            operators = builder.EndVector()
        if self.delegates is not None:
            delegateslist = []
            for i in range(len(self.delegates)):
                delegateslist.append(self.delegates[i].Pack(builder))
            ExecutionPlanStartDelegatesVector(builder, len(self.delegates))
            for i in reversed(range(len(self.delegates))):
                builder.PrependUOffsetTRelative(delegateslist[i])
            delegates = builder.EndVector()
        if self.nonConstBufferSizes is not None:
            if np is not None and type(self.nonConstBufferSizes) is np.ndarray:
                nonConstBufferSizes = builder.CreateNumpyVector(self.nonConstBufferSizes)
            else:
                ExecutionPlanStartNonConstBufferSizesVector(builder, len(self.nonConstBufferSizes))
                for i in reversed(range(len(self.nonConstBufferSizes))):
                    builder.PrependInt64(self.nonConstBufferSizes[i])
                nonConstBufferSizes = builder.EndVector()
        ExecutionPlanStart(builder)
        if self.name is not None:
            ExecutionPlanAddName(builder, name)
        if self.containerMetaType is not None:
            ExecutionPlanAddContainerMetaType(builder, containerMetaType)
        if self.values is not None:
            ExecutionPlanAddValues(builder, values)
        if self.inputs is not None:
            ExecutionPlanAddInputs(builder, inputs)
        if self.outputs is not None:
            ExecutionPlanAddOutputs(builder, outputs)
        if self.chains is not None:
            ExecutionPlanAddChains(builder, chains)
        if self.operators is not None:
            ExecutionPlanAddOperators(builder, operators)
        if self.delegates is not None:
            ExecutionPlanAddDelegates(builder, delegates)
        if self.nonConstBufferSizes is not None:
            ExecutionPlanAddNonConstBufferSizes(builder, nonConstBufferSizes)
        executionPlan = ExecutionPlanEnd(builder)
        return executionPlan


class Buffer(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Buffer()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBuffer(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def BufferBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Buffer
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Buffer
    def Storage(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Buffer
    def StorageAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Buffer
    def StorageLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Buffer
    def StorageIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def BufferStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def BufferAddStorage(builder: flatbuffers.Builder, storage: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(storage), 0)

def BufferStartStorageVector(builder, numElems: int) -> int:
    return builder.StartVector(1, numElems, 1)

def BufferEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class BufferT(object):

    # BufferT
    def __init__(
        self,
        storage = None,
    ):
        self.storage = storage  # type: Optional[List[int]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        buffer = Buffer()
        buffer.Init(buf, pos)
        return cls.InitFromObj(buffer)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, buffer):
        x = BufferT()
        x._UnPack(buffer)
        return x

    # BufferT
    def _UnPack(self, buffer):
        if buffer is None:
            return
        if not buffer.StorageIsNone():
            if np is None:
                self.storage = []
                for i in range(buffer.StorageLength()):
                    self.storage.append(buffer.Storage(i))
            else:
                self.storage = buffer.StorageAsNumpy()

    # BufferT
    def Pack(self, builder):
        if self.storage is not None:
            if np is not None and type(self.storage) is np.ndarray:
                storage = builder.CreateNumpyVector(self.storage)
            else:
                BufferStartStorageVector(builder, len(self.storage))
                for i in reversed(range(len(self.storage))):
                    builder.PrependUint8(self.storage[i])
                storage = builder.EndVector()
        BufferStart(builder)
        if self.storage is not None:
            BufferAddStorage(builder, storage)
        buffer = BufferEnd(builder)
        return buffer


class BackendDelegateInlineData(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BackendDelegateInlineData()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBackendDelegateInlineData(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def BackendDelegateInlineDataBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # BackendDelegateInlineData
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # BackendDelegateInlineData
    def Data(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # BackendDelegateInlineData
    def DataAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # BackendDelegateInlineData
    def DataLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # BackendDelegateInlineData
    def DataIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def BackendDelegateInlineDataStart(builder: flatbuffers.Builder):
    builder.StartObject(1)

def BackendDelegateInlineDataAddData(builder: flatbuffers.Builder, data: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)

def BackendDelegateInlineDataStartDataVector(builder, numElems: int) -> int:
    return builder.StartVector(1, numElems, 1)

def BackendDelegateInlineDataEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class BackendDelegateInlineDataT(object):

    # BackendDelegateInlineDataT
    def __init__(
        self,
        data = None,
    ):
        self.data = data  # type: Optional[List[int]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        backendDelegateInlineData = BackendDelegateInlineData()
        backendDelegateInlineData.Init(buf, pos)
        return cls.InitFromObj(backendDelegateInlineData)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, backendDelegateInlineData):
        x = BackendDelegateInlineDataT()
        x._UnPack(backendDelegateInlineData)
        return x

    # BackendDelegateInlineDataT
    def _UnPack(self, backendDelegateInlineData):
        if backendDelegateInlineData is None:
            return
        if not backendDelegateInlineData.DataIsNone():
            if np is None:
                self.data = []
                for i in range(backendDelegateInlineData.DataLength()):
                    self.data.append(backendDelegateInlineData.Data(i))
            else:
                self.data = backendDelegateInlineData.DataAsNumpy()

    # BackendDelegateInlineDataT
    def Pack(self, builder):
        if self.data is not None:
            if np is not None and type(self.data) is np.ndarray:
                data = builder.CreateNumpyVector(self.data)
            else:
                BackendDelegateInlineDataStartDataVector(builder, len(self.data))
                for i in reversed(range(len(self.data))):
                    builder.PrependUint8(self.data[i])
                data = builder.EndVector()
        BackendDelegateInlineDataStart(builder)
        if self.data is not None:
            BackendDelegateInlineDataAddData(builder, data)
        backendDelegateInlineData = BackendDelegateInlineDataEnd(builder)
        return backendDelegateInlineData


class DataSegment(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = DataSegment()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDataSegment(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def DataSegmentBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # DataSegment
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # DataSegment
    def Offset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # DataSegment
    def Size(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

def DataSegmentStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def DataSegmentAddOffset(builder: flatbuffers.Builder, offset: int):
    builder.PrependUint64Slot(0, offset, 0)

def DataSegmentAddSize(builder: flatbuffers.Builder, size: int):
    builder.PrependUint64Slot(1, size, 0)

def DataSegmentEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class DataSegmentT(object):

    # DataSegmentT
    def __init__(
        self,
        offset = 0,
        size = 0,
    ):
        self.offset = offset  # type: int
        self.size = size  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        dataSegment = DataSegment()
        dataSegment.Init(buf, pos)
        return cls.InitFromObj(dataSegment)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, dataSegment):
        x = DataSegmentT()
        x._UnPack(dataSegment)
        return x

    # DataSegmentT
    def _UnPack(self, dataSegment):
        if dataSegment is None:
            return
        self.offset = dataSegment.Offset()
        self.size = dataSegment.Size()

    # DataSegmentT
    def Pack(self, builder):
        DataSegmentStart(builder)
        DataSegmentAddOffset(builder, self.offset)
        DataSegmentAddSize(builder, self.size)
        dataSegment = DataSegmentEnd(builder)
        return dataSegment


class SubsegmentOffsets(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SubsegmentOffsets()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSubsegmentOffsets(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def SubsegmentOffsetsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # SubsegmentOffsets
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SubsegmentOffsets
    def SegmentIndex(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # SubsegmentOffsets
    def Offsets(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 8))
        return 0

    # SubsegmentOffsets
    def OffsetsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint64Flags, o)
        return 0

    # SubsegmentOffsets
    def OffsetsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SubsegmentOffsets
    def OffsetsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

def SubsegmentOffsetsStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def SubsegmentOffsetsAddSegmentIndex(builder: flatbuffers.Builder, segmentIndex: int):
    builder.PrependUint32Slot(0, segmentIndex, 0)

def SubsegmentOffsetsAddOffsets(builder: flatbuffers.Builder, offsets: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(offsets), 0)

def SubsegmentOffsetsStartOffsetsVector(builder, numElems: int) -> int:
    return builder.StartVector(8, numElems, 8)

def SubsegmentOffsetsEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class SubsegmentOffsetsT(object):

    # SubsegmentOffsetsT
    def __init__(
        self,
        segmentIndex = 0,
        offsets = None,
    ):
        self.segmentIndex = segmentIndex  # type: int
        self.offsets = offsets  # type: Optional[List[int]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        subsegmentOffsets = SubsegmentOffsets()
        subsegmentOffsets.Init(buf, pos)
        return cls.InitFromObj(subsegmentOffsets)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, subsegmentOffsets):
        x = SubsegmentOffsetsT()
        x._UnPack(subsegmentOffsets)
        return x

    # SubsegmentOffsetsT
    def _UnPack(self, subsegmentOffsets):
        if subsegmentOffsets is None:
            return
        self.segmentIndex = subsegmentOffsets.SegmentIndex()
        if not subsegmentOffsets.OffsetsIsNone():
            if np is None:
                self.offsets = []
                for i in range(subsegmentOffsets.OffsetsLength()):
                    self.offsets.append(subsegmentOffsets.Offsets(i))
            else:
                self.offsets = subsegmentOffsets.OffsetsAsNumpy()

    # SubsegmentOffsetsT
    def Pack(self, builder):
        if self.offsets is not None:
            if np is not None and type(self.offsets) is np.ndarray:
                offsets = builder.CreateNumpyVector(self.offsets)
            else:
                SubsegmentOffsetsStartOffsetsVector(builder, len(self.offsets))
                for i in reversed(range(len(self.offsets))):
                    builder.PrependUint64(self.offsets[i])
                offsets = builder.EndVector()
        SubsegmentOffsetsStart(builder)
        SubsegmentOffsetsAddSegmentIndex(builder, self.segmentIndex)
        if self.offsets is not None:
            SubsegmentOffsetsAddOffsets(builder, offsets)
        subsegmentOffsets = SubsegmentOffsetsEnd(builder)
        return subsegmentOffsets


class NamedData(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = NamedData()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsNamedData(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def NamedDataBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # NamedData
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # NamedData
    def Key(self) -> Optional[str]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # NamedData
    def SegmentIndex(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def NamedDataStart(builder: flatbuffers.Builder):
    builder.StartObject(2)

def NamedDataAddKey(builder: flatbuffers.Builder, key: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(key), 0)

def NamedDataAddSegmentIndex(builder: flatbuffers.Builder, segmentIndex: int):
    builder.PrependUint32Slot(1, segmentIndex, 0)

def NamedDataEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()



class NamedDataT(object):

    # NamedDataT
    def __init__(
        self,
        key = None,
        segmentIndex = 0,
    ):
        self.key = key  # type: Optional[str]
        self.segmentIndex = segmentIndex  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        namedData = NamedData()
        namedData.Init(buf, pos)
        return cls.InitFromObj(namedData)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, namedData):
        x = NamedDataT()
        x._UnPack(namedData)
        return x

    # NamedDataT
    def _UnPack(self, namedData):
        if namedData is None:
            return
        self.key = namedData.Key()
        self.segmentIndex = namedData.SegmentIndex()

    # NamedDataT
    def Pack(self, builder):
        if self.key is not None:
            key = builder.CreateString(self.key)
        NamedDataStart(builder)
        if self.key is not None:
            NamedDataAddKey(builder, key)
        NamedDataAddSegmentIndex(builder, self.segmentIndex)
        namedData = NamedDataEnd(builder)
        return namedData


class Program(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Program()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsProgram(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ProgramBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x45\x54\x31\x32", size_prefixed=size_prefixed)

    # Program
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Program
    def Version(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # Program
    def ExecutionPlan(self, j: int) -> Optional[ExecutionPlan]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = ExecutionPlan()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def ExecutionPlanLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def ExecutionPlanIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Program
    def ConstantBuffer(self, j: int) -> Optional[Buffer]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Buffer()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def ConstantBufferLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def ConstantBufferIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Program
    def BackendDelegateData(self, j: int) -> Optional[BackendDelegateInlineData]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = BackendDelegateInlineData()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def BackendDelegateDataLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def BackendDelegateDataIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Program
    def Segments(self, j: int) -> Optional[DataSegment]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = DataSegment()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def SegmentsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def SegmentsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # Program
    def ConstantSegment(self) -> Optional[SubsegmentOffsets]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = SubsegmentOffsets()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def MutableDataSegments(self, j: int) -> Optional[SubsegmentOffsets]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = SubsegmentOffsets()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def MutableDataSegmentsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def MutableDataSegmentsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        return o == 0

    # Program
    def NamedData(self, j: int) -> Optional[NamedData]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = NamedData()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Program
    def NamedDataLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Program
    def NamedDataIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

def ProgramStart(builder: flatbuffers.Builder):
    builder.StartObject(8)

def ProgramAddVersion(builder: flatbuffers.Builder, version: int):
    builder.PrependUint32Slot(0, version, 0)

def ProgramAddExecutionPlan(builder: flatbuffers.Builder, executionPlan: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(executionPlan), 0)

def ProgramStartExecutionPlanVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ProgramAddConstantBuffer(builder: flatbuffers.Builder, constantBuffer: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(constantBuffer), 0)

def ProgramStartConstantBufferVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ProgramAddBackendDelegateData(builder: flatbuffers.Builder, backendDelegateData: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(backendDelegateData), 0)

def ProgramStartBackendDelegateDataVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ProgramAddSegments(builder: flatbuffers.Builder, segments: int):
    builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(segments), 0)

def ProgramStartSegmentsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ProgramAddConstantSegment(builder: flatbuffers.Builder, constantSegment: int):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(constantSegment), 0)

def ProgramAddMutableDataSegments(builder: flatbuffers.Builder, mutableDataSegments: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(mutableDataSegments), 0)

def ProgramStartMutableDataSegmentsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ProgramAddNamedData(builder: flatbuffers.Builder, namedData: int):
    builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(namedData), 0)

def ProgramStartNamedDataVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def ProgramEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()


try:
    from typing import List, Optional
except:
    pass

class ProgramT(object):

    # ProgramT
    def __init__(
        self,
        version = 0,
        executionPlan = None,
        constantBuffer = None,
        backendDelegateData = None,
        segments = None,
        constantSegment = None,
        mutableDataSegments = None,
        namedData = None,
    ):
        self.version = version  # type: int
        self.executionPlan = executionPlan  # type: Optional[List[ExecutionPlanT]]
        self.constantBuffer = constantBuffer  # type: Optional[List[BufferT]]
        self.backendDelegateData = backendDelegateData  # type: Optional[List[BackendDelegateInlineDataT]]
        self.segments = segments  # type: Optional[List[DataSegmentT]]
        self.constantSegment = constantSegment  # type: Optional[SubsegmentOffsetsT]
        self.mutableDataSegments = mutableDataSegments  # type: Optional[List[SubsegmentOffsetsT]]
        self.namedData = namedData  # type: Optional[List[NamedDataT]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        program = Program()
        program.Init(buf, pos)
        return cls.InitFromObj(program)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, program):
        x = ProgramT()
        x._UnPack(program)
        return x

    # ProgramT
    def _UnPack(self, program):
        if program is None:
            return
        self.version = program.Version()
        if not program.ExecutionPlanIsNone():
            self.executionPlan = []
            for i in range(program.ExecutionPlanLength()):
                if program.ExecutionPlan(i) is None:
                    self.executionPlan.append(None)
                else:
                    executionPlan_ = ExecutionPlanT.InitFromObj(program.ExecutionPlan(i))
                    self.executionPlan.append(executionPlan_)
        if not program.ConstantBufferIsNone():
            self.constantBuffer = []
            for i in range(program.ConstantBufferLength()):
                if program.ConstantBuffer(i) is None:
                    self.constantBuffer.append(None)
                else:
                    buffer_ = BufferT.InitFromObj(program.ConstantBuffer(i))
                    self.constantBuffer.append(buffer_)
        if not program.BackendDelegateDataIsNone():
            self.backendDelegateData = []
            for i in range(program.BackendDelegateDataLength()):
                if program.BackendDelegateData(i) is None:
                    self.backendDelegateData.append(None)
                else:
                    backendDelegateInlineData_ = BackendDelegateInlineDataT.InitFromObj(program.BackendDelegateData(i))
                    self.backendDelegateData.append(backendDelegateInlineData_)
        if not program.SegmentsIsNone():
            self.segments = []
            for i in range(program.SegmentsLength()):
                if program.Segments(i) is None:
                    self.segments.append(None)
                else:
                    dataSegment_ = DataSegmentT.InitFromObj(program.Segments(i))
                    self.segments.append(dataSegment_)
        if program.ConstantSegment() is not None:
            self.constantSegment = SubsegmentOffsetsT.InitFromObj(program.ConstantSegment())
        if not program.MutableDataSegmentsIsNone():
            self.mutableDataSegments = []
            for i in range(program.MutableDataSegmentsLength()):
                if program.MutableDataSegments(i) is None:
                    self.mutableDataSegments.append(None)
                else:
                    subsegmentOffsets_ = SubsegmentOffsetsT.InitFromObj(program.MutableDataSegments(i))
                    self.mutableDataSegments.append(subsegmentOffsets_)
        if not program.NamedDataIsNone():
            self.namedData = []
            for i in range(program.NamedDataLength()):
                if program.NamedData(i) is None:
                    self.namedData.append(None)
                else:
                    namedData_ = NamedDataT.InitFromObj(program.NamedData(i))
                    self.namedData.append(namedData_)

    # ProgramT
    def Pack(self, builder):
        if self.executionPlan is not None:
            executionPlanlist = []
            for i in range(len(self.executionPlan)):
                executionPlanlist.append(self.executionPlan[i].Pack(builder))
            ProgramStartExecutionPlanVector(builder, len(self.executionPlan))
            for i in reversed(range(len(self.executionPlan))):
                builder.PrependUOffsetTRelative(executionPlanlist[i])
            executionPlan = builder.EndVector()
        if self.constantBuffer is not None:
            constantBufferlist = []
            for i in range(len(self.constantBuffer)):
                constantBufferlist.append(self.constantBuffer[i].Pack(builder))
            ProgramStartConstantBufferVector(builder, len(self.constantBuffer))
            for i in reversed(range(len(self.constantBuffer))):
                builder.PrependUOffsetTRelative(constantBufferlist[i])
            constantBuffer = builder.EndVector()
        if self.backendDelegateData is not None:
            backendDelegateDatalist = []
            for i in range(len(self.backendDelegateData)):
                backendDelegateDatalist.append(self.backendDelegateData[i].Pack(builder))
            ProgramStartBackendDelegateDataVector(builder, len(self.backendDelegateData))
            for i in reversed(range(len(self.backendDelegateData))):
                builder.PrependUOffsetTRelative(backendDelegateDatalist[i])
            backendDelegateData = builder.EndVector()
        if self.segments is not None:
            segmentslist = []
            for i in range(len(self.segments)):
                segmentslist.append(self.segments[i].Pack(builder))
            ProgramStartSegmentsVector(builder, len(self.segments))
            for i in reversed(range(len(self.segments))):
                builder.PrependUOffsetTRelative(segmentslist[i])
            segments = builder.EndVector()
        if self.constantSegment is not None:
            constantSegment = self.constantSegment.Pack(builder)
        if self.mutableDataSegments is not None:
            mutableDataSegmentslist = []
            for i in range(len(self.mutableDataSegments)):
                mutableDataSegmentslist.append(self.mutableDataSegments[i].Pack(builder))
            ProgramStartMutableDataSegmentsVector(builder, len(self.mutableDataSegments))
            for i in reversed(range(len(self.mutableDataSegments))):
                builder.PrependUOffsetTRelative(mutableDataSegmentslist[i])
            mutableDataSegments = builder.EndVector()
        if self.namedData is not None:
            namedDatalist = []
            for i in range(len(self.namedData)):
                namedDatalist.append(self.namedData[i].Pack(builder))
            ProgramStartNamedDataVector(builder, len(self.namedData))
            for i in reversed(range(len(self.namedData))):
                builder.PrependUOffsetTRelative(namedDatalist[i])
            namedData = builder.EndVector()
        ProgramStart(builder)
        ProgramAddVersion(builder, self.version)
        if self.executionPlan is not None:
            ProgramAddExecutionPlan(builder, executionPlan)
        if self.constantBuffer is not None:
            ProgramAddConstantBuffer(builder, constantBuffer)
        if self.backendDelegateData is not None:
            ProgramAddBackendDelegateData(builder, backendDelegateData)
        if self.segments is not None:
            ProgramAddSegments(builder, segments)
        if self.constantSegment is not None:
            ProgramAddConstantSegment(builder, constantSegment)
        if self.mutableDataSegments is not None:
            ProgramAddMutableDataSegments(builder, mutableDataSegments)
        if self.namedData is not None:
            ProgramAddNamedData(builder, namedData)
        program = ProgramEnd(builder)
        return program


