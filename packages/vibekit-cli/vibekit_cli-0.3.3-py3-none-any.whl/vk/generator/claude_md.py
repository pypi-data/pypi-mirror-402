"""
CLAUDE.md generator for Claude Code integration.

Generates a comprehensive CLAUDE.md file from project configuration that
Claude Code reads to understand project context, rules, and current work.

Data sources:
- Project data (.vk/): config, sprints, roadmap, tasks
- Claude config (.claude/): rules, patterns, agents, tools, workflows, hooks
"""

from datetime import datetime
from pathlib import Path
from typing import Optional

import yaml


class ClaudeMdGenerator:
    """
    Generator for CLAUDE.md file.

    Reads configuration from both directories:
    - .vk/ for project data (config, sprints, roadmap, tasks)
    - .claude/ for Claude configuration (rules, patterns, agents, tools)

    Generates a unified CLAUDE.md that Claude Code uses for project context.

    Usage:
        generator = ClaudeMdGenerator(project_root)
        generator.generate()
    """

    def __init__(self, project_root: Optional[Path] = None):
        """
        Initialize generator.

        Args:
            project_root: Root directory of the project (default: cwd)
        """
        self.project_root = project_root or Path.cwd()
        self.vk_dir = self.project_root / ".vk"  # Project data
        self.claude_dir = self.project_root / ".claude"  # Claude config
        self.output_file = self.project_root / "CLAUDE.md"

    def generate(self) -> Path:
        """
        Generate CLAUDE.md from .claude/ configuration.

        Returns:
            Path to generated CLAUDE.md file
        """
        content = self._build_content()
        self.output_file.write_text(content)
        return self.output_file

    def _build_content(self) -> str:
        """Build complete CLAUDE.md content with optimized section order."""
        sections = [
            self._generate_header(),
            self._generate_project_section(),          # 1. Project overview first
            self._generate_current_focus_section(),    # 2. What to work on now
            self._generate_sprint_section(),           # 3. Sprint context
            self._generate_roadmap_section(),          # 4. Roadmap (if exists)
            self._generate_rules_section(),            # 5. Coding guidelines
            self._generate_patterns_section(),         # 6. Code patterns (filtered)
            self._generate_agents_section(),           # 7. Available agents
            self._generate_workflows_section(),        # 8. Automation workflows
            self._generate_tools_section(),            # 9. Tool configuration
            self._generate_context_files_section(),    # 10. Deep-dive references
            self._generate_quick_actions_section(),    # 11. Quick commands
            self._generate_footer(),
        ]

        return "\n\n".join(filter(None, sections))

    def _generate_header(self) -> str:
        """Generate header section."""
        project_name = self._get_project_name()
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")

        return f"""# Project: {project_name}

> Auto-generated by VibeKit on {timestamp}
> DO NOT EDIT MANUALLY - Run `vk pull` to update

This file provides Claude Code with project context, rules, and current sprint information.
Follow the guidelines and rules defined here when working on this project."""

    def _generate_current_focus_section(self) -> str:
        """Generate current focus from INDEX.yaml - stateless awareness."""
        index_file = self.vk_dir / "INDEX.yaml"
        if not index_file.exists():
            # Fallback to sprint-based logic
            return self._generate_current_focus_section_legacy()

        try:
            index = yaml.safe_load(index_file.read_text())

            sprint = index.get('sprint', {})
            tasks = index.get('tasks', {})
            next_task = index.get('next', {})

            if not sprint.get('id'):
                return ""

            lines = ["## Current Focus"]
            lines.append(f"\n**Sprint**: {sprint.get('id', 'Unknown')} ({sprint.get('progress', 0)}% complete)")
            lines.append(f"**Active Tasks**: {tasks.get('active', 0)}")

            if next_task.get('task'):
                lines.append(f"**Next Task**: `{next_task.get('task', 'None')}` @ `{next_task.get('path', 'N/A')}`")

            lines.append("\n### Quick Commands")
            lines.append("\n```bash")
            lines.append(f"vk start {next_task.get('task', '<task_id>')}  # Start next task")
            lines.append("vk status                                       # Check progress")
            lines.append("vk done                                         # Complete current task")
            lines.append("```")

            return "\n".join(lines)
        except Exception:
            return ""

    def _generate_current_focus_section_legacy(self) -> str:
        """
        Generate dynamic "Current Focus" section (legacy, sprint-based).

        Shows sprint goal and top priority tasks to give Claude
        immediate context about what the team is working on.
        """
        sprint = self._load_sprint()
        if not sprint:
            return ""

        lines = ["## ðŸŽ¯ Current Focus"]

        # Sprint goal
        goal = sprint.get("goal")
        if goal:
            lines.append(f"\n**Sprint Goal**: {goal}")

        # Get all tasks and find priority ones
        all_tasks = []
        for req in sprint.get("requirements", []):
            for task in req.get("tasks", []):
                task_copy = dict(task)
                task_copy["requirement_title"] = req.get("title", "")
                task_copy["requirement_priority"] = req.get("priority", "medium")
                all_tasks.append(task_copy)

        # Sort by status (in_progress first) then by priority
        status_order = {"in_progress": 0, "pending": 1, "blocked": 2, "completed": 3}
        priority_order = {"high": 0, "medium": 1, "low": 2}

        sorted_tasks = sorted(
            all_tasks,
            key=lambda t: (
                status_order.get(t.get("status", "pending"), 1),
                priority_order.get(t.get("priority", t.get("requirement_priority", "medium")), 1),
            ),
        )

        # Show top 5 non-completed tasks
        active_tasks = [t for t in sorted_tasks if t.get("status") != "completed"][:5]

        if active_tasks:
            lines.append("\n**Priority Tasks**:")
            for task in active_tasks:
                status = task.get("status", "pending")
                status_indicator = {
                    "in_progress": "ðŸ”„",
                    "pending": "â³",
                    "blocked": "ðŸš«",
                }.get(status, "â³")

                task_id = task.get("task_id", "TASK")
                title = task.get("title", "Untitled")
                lines.append(f"- {status_indicator} `{task_id}`: {title}")

        # In-progress task context
        in_progress = [t for t in all_tasks if t.get("status") == "in_progress"]
        if in_progress:
            current = in_progress[0]
            task_id = current.get("task_id", "")
            lines.append(f"\n**Currently Working On**: `{task_id}`")

            # Check if task file exists for deep context
            task_file = self.vk_dir / "tasks" / "in-progress" / f"{task_id}.yaml"
            if task_file.exists():
                lines.append(f"_Read `.vk/tasks/in-progress/{task_id}.yaml` for full task context_")

        return "\n".join(lines)

    def _generate_context_files_section(self) -> str:
        """
        Generate hybrid context files section.

        Provides Claude with references to detailed files for deep dives,
        while keeping CLAUDE.md focused on essential context.
        """
        lines = ["## ðŸ“ Context Files"]
        lines.append("\nFor detailed context, read these files as needed:")

        # Build list of available context files
        context_files = []

        # Root-level project files (most important - add first)
        project_md = self.project_root / "PROJECT.md"
        if project_md.exists():
            context_files.append(
                ("Project Overview", "PROJECT.md", "Living requirements document")
            )

        # Stateless navigation hub (low-token, high-value)
        index_yaml = self.vk_dir / "INDEX.yaml"
        if index_yaml.exists():
            context_files.append(
                ("Navigation Hub", ".vk/INDEX.yaml", "Master navigation (~100 tokens)")
            )

        # Human-readable state summary
        state_md = self.vk_dir / "STATE.md"
        if state_md.exists():
            context_files.append(
                ("State Summary", ".vk/STATE.md", "Human-readable sprint/task overview")
            )

        # Sprint context (project data in .vk/)
        sprint_file = self.vk_dir / "sprints" / "current.yaml"
        if sprint_file.exists():
            context_files.append(
                ("Sprint Details", ".vk/sprints/current.yaml", "Full sprint with all tasks")
            )

        # Rules (Claude config in .claude/)
        rules_dir = self.claude_dir / "rules"
        if rules_dir.exists():
            if (rules_dir / "security.md").exists():
                context_files.append(
                    ("Security Rules", ".claude/rules/security.md", "Complete security guidelines")
                )
            if (rules_dir / "coding_standards.md").exists():
                context_files.append(
                    ("Coding Standards", ".claude/rules/coding_standards.md", "Full coding rules")
                )
            # Check for generated rules
            generated_dir = rules_dir / "generated"
            if generated_dir.exists() and any(generated_dir.glob("*.md")):
                context_files.append(
                    (
                        "AI-Generated Rules",
                        ".claude/rules/generated/",
                        "Project-specific rules from objectives",
                    )
                )

        # Patterns (Claude config in .claude/)
        patterns_dir = self.claude_dir / "patterns"
        if patterns_dir.exists():
            learned_dir = patterns_dir / "learned"
            if learned_dir.exists() and any(learned_dir.glob("*.md")):
                context_files.append(
                    (
                        "Learned Patterns",
                        ".claude/patterns/learned/",
                        "Patterns extracted from codebase",
                    )
                )
            if any(patterns_dir.glob("*.md")):
                context_files.append(
                    ("Code Patterns", ".claude/patterns/", "Established code patterns to follow")
                )

        # Codebase docs (Claude config in .claude/)
        codebase_dir = self.claude_dir / "codebase"
        if codebase_dir.exists():
            if (codebase_dir / "INDEX.md").exists():
                context_files.append(
                    ("Codebase Index", ".claude/codebase/INDEX.md", "Quick file/component lookup")
                )
            if (codebase_dir / "WHERE_TO_PUT.md").exists():
                context_files.append(
                    (
                        "Where to Put Code",
                        ".claude/codebase/WHERE_TO_PUT.md",
                        "Feature placement guide",
                    )
                )
            if (codebase_dir / "CONVENTIONS.md").exists():
                context_files.append(
                    (
                        "Conventions",
                        ".claude/codebase/CONVENTIONS.md",
                        "Naming and style conventions",
                    )
                )

        # Task plans (executable task specs)
        plans_dir = self.vk_dir / "plans" / "ready"
        if plans_dir.exists() and any(plans_dir.glob("*.md")):
            context_files.append(
                ("Task Plans", ".vk/plans/ready/", "Executable task specifications")
            )

        # Context optimization files (Claude config in .claude/)
        if (self.claude_dir / "context-mini.yaml").exists():
            context_files.append(
                ("Mini Context", ".claude/context-mini.yaml", "Lightweight context (~800 tokens)")
            )

        if not context_files:
            return ""

        # Format as table
        lines.append("\n| File | Purpose |")
        lines.append("|------|---------|")
        for _name, path, purpose in context_files:
            lines.append(f"| `{path}` | {purpose} |")

        lines.append("\n_Read these files when you need deeper context for a specific area._")

        return "\n".join(lines)

    def _generate_project_section(self) -> str:
        """Generate project overview section."""
        config = self._load_config()
        if not config:
            return ""

        lines = ["## Project Overview"]

        if config.get("description"):
            lines.append(f"\n{config['description']}")

        # Tech stack
        tech_stack = config.get("tech_stack", {})
        if tech_stack:
            lines.append("\n### Tech Stack")
            if tech_stack.get("languages"):
                lines.append(f"- **Languages**: {', '.join(tech_stack['languages'])}")
            if tech_stack.get("frameworks"):
                lines.append(f"- **Frameworks**: {', '.join(tech_stack['frameworks'])}")
            if tech_stack.get("databases"):
                lines.append(f"- **Databases**: {', '.join(tech_stack['databases'])}")
            if tech_stack.get("tools"):
                lines.append(f"- **Tools**: {', '.join(tech_stack['tools'])}")

        # Objectives
        objectives = config.get("objectives", [])
        if objectives:
            lines.append("\n### Objectives")
            for obj in objectives:
                lines.append(f"- {obj}")

        # Success criteria
        criteria = config.get("success_criteria", [])
        if criteria:
            lines.append("\n### Success Criteria")
            for crit in criteria:
                lines.append(f"- {crit}")

        return "\n".join(lines)

    def _generate_roadmap_section(self) -> str:
        """Generate project roadmap section."""
        roadmap = self._load_roadmap()
        if not roadmap:
            return ""

        lines = ["## Project Roadmap"]

        # Find current phase
        current_phase = None
        for phase in roadmap:
            if phase.get("status") == "in_progress":
                current_phase = phase
                break

        if current_phase:
            lines.append(
                f"\n**Current Phase**: Phase {current_phase.get('phase_number', '')} - {current_phase.get('name', '')} (In Progress)"
            )
            if current_phase.get("target_date"):
                lines.append(
                    f"**Target**: {current_phase['target_date'][:10] if isinstance(current_phase['target_date'], str) else current_phase['target_date']}"
                )

        lines.append("\n### Phases")
        for phase in roadmap:
            status = phase.get("status", "planned")
            if status == "completed":
                status_mark = "[x]"
            elif status == "in_progress":
                status_mark = "[~]"
            else:
                status_mark = "[ ]"

            phase_line = (
                f"{phase.get('phase_number', '')}. {status_mark} **{phase.get('name', '')}**"
            )
            if status == "completed":
                phase_line += " - Completed"
            elif status == "in_progress":
                phase_line += " - In Progress"
                if phase.get("target_date"):
                    target = (
                        phase["target_date"][:10]
                        if isinstance(phase["target_date"], str)
                        else phase["target_date"]
                    )
                    phase_line += f" (Target: {target})"
            else:
                phase_line += " - Planned"

            lines.append(phase_line)

            # Show milestones for current phase
            if status == "in_progress" and phase.get("milestones"):
                for m in phase["milestones"]:
                    m_status = "[x]" if m.get("completed") else "[ ]"
                    lines.append(f"   - {m_status} {m.get('name', '')}")

        return "\n".join(lines)

    def _generate_sprint_section(self) -> str:
        """Generate current sprint section with acceptance criteria and dependencies."""
        sprint = self._load_sprint()
        if not sprint:
            return ""

        lines = [f"## Current Sprint: {sprint.get('name', 'Unnamed Sprint')}"]

        if sprint.get("goal"):
            lines.append(f"\n**Goal**: {sprint['goal']}")

        if sprint.get("status"):
            lines.append(f"**Status**: {sprint['status']}")

        # Date range
        if sprint.get("start_date") or sprint.get("end_date"):
            start = sprint.get("start_date", "TBD")
            end = sprint.get("end_date", "TBD")
            lines.append(f"**Duration**: {start} - {end}")

        # Build task ID to task mapping for dependency resolution
        all_tasks = {}
        for req in sprint.get("requirements", []):
            for task in req.get("tasks", []):
                task_id = task.get("task_id", "")
                if task_id:
                    all_tasks[task_id] = task

        # Requirements and tasks
        requirements = sprint.get("requirements", [])
        if requirements:
            lines.append("\n### Priority Tasks")

            # Sort by priority
            priority_order = {"high": 0, "medium": 1, "low": 2}
            sorted_reqs = sorted(
                requirements, key=lambda r: priority_order.get(r.get("priority", "medium"), 1)
            )

            for req in sorted_reqs:
                status_emoji = self._get_status_emoji(req.get("status", "pending"))
                priority_label = req.get("priority", "medium").upper()
                lines.append(
                    f"\n#### {status_emoji} [{req.get('requirement_id', 'REQ')}] "
                    f"{req.get('title', 'Untitled')} ({priority_label})"
                )

                if req.get("description"):
                    lines.append(f"\n{req['description']}")

                # Tasks
                tasks = req.get("tasks", [])
                if tasks:
                    lines.append("\n**Tasks:**")
                    for task in tasks:
                        task_id = task.get('task_id', 'TASK')
                        task_status = self._get_status_emoji(task.get("status", "pending"))
                        task_line = f"- {task_status} `{task_id}`: {task.get('title', 'Untitled')}"

                        # Add estimate if available
                        estimate = task.get("estimate")
                        if estimate:
                            task_line += f" ({estimate} pts)"

                        lines.append(task_line)

                        # Show dependencies if available
                        dependencies = task.get("dependencies", [])
                        if dependencies:
                            dep_str = ", ".join(f"`{d}`" for d in dependencies[:3])
                            if len(dependencies) > 3:
                                dep_str += f" (+{len(dependencies) - 3})"
                            lines.append(f"  - _Blocked by_: {dep_str}")

                        # Show acceptance criteria if available (for in_progress or pending tasks)
                        status = task.get("status", "pending")
                        acceptance_criteria = task.get("acceptance_criteria", [])
                        if acceptance_criteria and status in ("pending", "in_progress"):
                            lines.append("  - _Acceptance Criteria_:")
                            for criterion in acceptance_criteria[:5]:  # Limit to 5
                                lines.append(f"    - [ ] {criterion}")

                        # Show files likely to be modified if available
                        files_likely = task.get("files_likely", [])
                        if files_likely and status in ("pending", "in_progress"):
                            files_str = ", ".join(f"`{f}`" for f in files_likely[:3])
                            if len(files_likely) > 3:
                                files_str += f" (+{len(files_likely) - 3})"
                            lines.append(f"  - _Files_: {files_str}")

        return "\n".join(lines)

    def _generate_rules_section(self) -> str:
        """Generate project rules section."""
        rules_dir = self.claude_dir / "rules"  # Claude config
        if not rules_dir.exists():
            return ""

        lines = ["## Project Rules"]

        # Coding standards
        coding_file = rules_dir / "coding_standards.md"
        if coding_file.exists():
            content = self._extract_rules_content(coding_file)
            if content:
                lines.append("\n### Coding Standards")
                lines.append(content)

        # Architecture rules
        arch_file = rules_dir / "architecture.md"
        if arch_file.exists():
            content = self._extract_rules_content(arch_file)
            if content:
                lines.append("\n### Architecture Rules")
                lines.append(content)

        # Security rules
        security_file = rules_dir / "security.md"
        if security_file.exists():
            content = self._extract_rules_content(security_file)
            if content:
                lines.append("\n### Security Rules")
                lines.append(content)

        # Testing rules
        testing_file = rules_dir / "testing.md"
        if testing_file.exists():
            content = self._extract_rules_content(testing_file)
            if content:
                lines.append("\n### Testing Rules")
                lines.append(content)

        return "\n".join(lines) if len(lines) > 1 else ""

    def _generate_patterns_section(self) -> str:
        """Generate code patterns section, filtered by project's tech stack."""
        patterns_dir = self.claude_dir / "patterns"  # Claude config
        if not patterns_dir.exists():
            return ""

        pattern_files = list(patterns_dir.glob("*.md"))
        if not pattern_files:
            return ""

        # Get project languages for filtering
        config = self._load_config()
        languages = []
        frameworks = []
        if config:
            tech_stack = config.get("tech_stack", {})
            languages = [l.lower() for l in tech_stack.get("languages", [])]
            frameworks = [f.lower() for f in tech_stack.get("frameworks", [])]

        # Language-specific patterns - only show if project uses that language
        LANG_SPECIFIC_PATTERNS = {
            "go-patterns": ["go", "golang"],
            "rust-patterns": ["rust"],
            "vue-patterns": ["vue", "vue 3", "vue.js"],
            "python-patterns": ["python"],
            "react-patterns": ["react", "react.js", "next.js", "nextjs"],
            "java-patterns": ["java", "kotlin"],
            "csharp-patterns": ["c#", "csharp", "f#", "fsharp", ".net"],
        }

        lines = ["## Code Patterns"]
        lines.append("\nFollow these established patterns when writing code:")

        for pattern_file in sorted(pattern_files):
            pattern_name = pattern_file.stem

            # Check if this is a language-specific pattern
            if pattern_name in LANG_SPECIFIC_PATTERNS:
                required_langs = LANG_SPECIFIC_PATTERNS[pattern_name]
                # Check if any required language matches project's languages or frameworks
                has_match = any(
                    req in languages or req in frameworks
                    for req in required_langs
                )
                if not has_match:
                    continue  # Skip irrelevant language-specific pattern

            content = pattern_file.read_text()
            # Extract title from first line
            first_line = content.split("\n")[0] if content else ""
            title = (
                first_line.replace("# ", "") if first_line.startswith("#") else pattern_file.stem
            )

            lines.append(f"\n### {title}")
            lines.append(f"See: `.claude/patterns/{pattern_file.name}`")

            # Extract short description (second paragraph or first non-header line)
            content_lines = content.split("\n")
            for line in content_lines[1:]:
                stripped = line.strip()
                if stripped and not stripped.startswith("#") and not stripped.startswith("**"):
                    lines.append(f"\n_{stripped[:100]}{'...' if len(stripped) > 100 else ''}_")
                    break

        return "\n".join(lines) if len(lines) > 1 else ""

    def _generate_tools_section(self) -> str:
        """Generate tools configuration section."""
        tools_dir = self.claude_dir / "tools"  # Claude config
        if not tools_dir.exists():
            return ""

        lines = ["## Tools"]

        # LSP configuration
        lsp_file = tools_dir / "lsp.yaml"
        if lsp_file.exists():
            lsp = self._load_yaml(lsp_file)
            if lsp and lsp.get("enabled", True):
                lines.append("\n### LSP Configuration")
                if lsp.get("languages"):
                    lines.append(f"- **Languages**: {', '.join(lsp['languages'])}")
                if lsp.get("symbol_operations"):
                    lines.append("- **Symbol Operations**: Enabled")
                if lsp.get("auto_import"):
                    lines.append("- **Auto-Import**: Enabled")

        # Linters
        linters_file = tools_dir / "linters.yaml"
        if linters_file.exists():
            linters = self._load_yaml(linters_file)
            if linters:
                linter_entries = []
                for linter in linters:
                    name = linter.get("name", "").strip()
                    # Skip linters with empty names
                    if linter.get("enabled", True) and name:
                        linter_entries.append(f"- **{name}**: Enabled")
                if linter_entries:
                    lines.append("\n### Linters")
                    lines.extend(linter_entries)

        # Quality gates
        gates_file = tools_dir / "quality_gates.yaml"
        if gates_file.exists():
            gates = self._load_yaml(gates_file)
            if gates:
                lines.append("\n### Quality Gates")
                lines.append("The following checks must pass before commit:")
                for gate in gates:
                    if gate.get("enabled", True):
                        required = " (REQUIRED)" if gate.get("required") else ""
                        lines.append(f"- {gate.get('name', 'Unknown')}{required}")

        return "\n".join(lines) if len(lines) > 1 else ""

    def _generate_agents_section(self) -> str:
        """Generate agents section with full Claude Code format."""
        agents_dir = self.claude_dir / "agents"  # Claude config
        if not agents_dir.exists():
            return ""

        # Collect all agents from both .md and .yaml files
        agents = []

        # Load .md files (Claude Code format with YAML frontmatter)
        for agent_file in sorted(agents_dir.glob("*.md")):
            agent = self._load_agent_md(agent_file)
            if agent:
                agents.append({
                    "name": agent.get("name", agent_file.stem),
                    "model": agent.get("model", "sonnet"),
                    "description": agent.get("description", ""),
                    "tools": agent.get("tools", []),
                    "when_to_use": agent.get("when_to_use", ""),
                })

        # Also load legacy .yaml files for backwards compat
        for agent_file in sorted(agents_dir.glob("*.yaml")):
            agent = self._load_yaml(agent_file)
            if agent and agent.get("enabled", True):
                agents.append({
                    "name": agent.get("name", agent_file.stem),
                    "model": agent.get("model", "sonnet"),
                    "description": agent.get("description", ""),
                    "tools": agent.get("tools", []),
                    "when_to_use": agent.get("when_to_use", ""),
                })

        if not agents:
            return ""

        lines = ["## Agents"]
        lines.append("\nWhen executing tasks, use these configured agents:")

        # Create comprehensive table
        lines.append("\n| Agent | Model | Tools | Description |")
        lines.append("|-------|-------|-------|-------------|")

        for agent in agents:
            name = f"`{agent['name']}`"
            model = agent['model']

            # Format tools list
            tools = agent.get('tools', [])
            if isinstance(tools, list) and tools:
                tools_str = ", ".join(tools[:4])  # Limit to first 4 tools
                if len(tools) > 4:
                    tools_str += f" (+{len(tools) - 4})"
            elif isinstance(tools, str):
                tools_str = tools
            else:
                tools_str = "_default_"

            # Use when_to_use or truncate description
            desc = agent.get('when_to_use') or agent.get('description', '')
            desc = desc[:60] + "..." if len(desc) > 60 else desc

            lines.append(f"| {name} | {model} | {tools_str} | {desc} |")

        return "\n".join(lines)

    def _load_agent_md(self, path: Path) -> Optional[dict]:
        """Load agent from .md file with YAML frontmatter."""
        try:
            content = path.read_text()
            if content.startswith("---"):
                parts = content.split("---", 2)
                if len(parts) >= 3:
                    return yaml.safe_load(parts[1])
        except Exception:
            pass
        return None

    def _generate_workflows_section(self) -> str:
        """Generate automation workflows section."""
        workflows_dir = self.claude_dir / "workflows"  # Claude config
        if not workflows_dir.exists():
            return ""

        workflow_files = list(workflows_dir.glob("*.yaml"))
        if not workflow_files:
            return ""

        workflow_entries = []

        for workflow_file in sorted(workflow_files):
            workflow = self._load_yaml(workflow_file)
            if not workflow or not workflow.get("enabled", True):
                continue

            name = workflow.get("name", workflow_file.stem)
            description = (workflow.get("description") or "").strip()
            trigger = workflow.get("trigger") or workflow.get("triggers")
            steps = workflow.get("steps", [])

            # Skip workflows with no description AND no trigger (empty entries)
            if not description and not trigger:
                continue

            entry_lines = [f"\n### {name}"]

            if description:
                entry_lines.append(description)

            # Show trigger if available
            if trigger:
                if isinstance(trigger, list):
                    trigger = ", ".join(trigger)
                entry_lines.append(f"\n**Trigger**: `{trigger}`")

            # Show steps if available
            if steps:
                entry_lines.append("\n**Steps**:")
                for i, step in enumerate(steps, 1):
                    if isinstance(step, dict):
                        step_name = step.get("name", f"Step {i}")
                        entry_lines.append(f"{i}. {step_name}")
                    else:
                        entry_lines.append(f"{i}. {step}")

            workflow_entries.extend(entry_lines)

        if not workflow_entries:
            return ""

        lines = ["## Automation Workflows"]
        lines.append("\nAutomated workflows that run at specific triggers:")
        lines.extend(workflow_entries)

        return "\n".join(lines)

    def _generate_quick_actions_section(self) -> str:
        """Generate quick actions based on detected project type."""
        config = self._load_config()

        # Try to get commands from config
        test_cmd = "pytest"
        lint_cmd = "ruff check ."
        build_cmd = None

        if config:
            project_settings = config.get("project", {})
            test_cmd = project_settings.get("test_command", test_cmd)
            lint_cmd = project_settings.get("lint_command", lint_cmd)
            build_cmd = project_settings.get("build_command")

            # Also check tech stack for better defaults
            tech = config.get("tech_stack", {})
            languages = tech.get("languages", [])

            # Override defaults based on detected language
            if "TypeScript" in languages or "JavaScript" in languages:
                if test_cmd == "pytest":
                    test_cmd = "npm test"
                if lint_cmd == "ruff check .":
                    lint_cmd = "npm run lint"
            elif "Go" in languages:
                if test_cmd == "pytest":
                    test_cmd = "go test ./..."
                if lint_cmd == "ruff check .":
                    lint_cmd = "golangci-lint run"
            elif "Rust" in languages:
                if test_cmd == "pytest":
                    test_cmd = "cargo test"
                if lint_cmd == "ruff check .":
                    lint_cmd = "cargo clippy"
            elif "Java" in languages or "Kotlin" in languages:
                # Check for Gradle vs Maven
                tools_list = tech.get("tools", [])
                if any("gradle" in t.lower() for t in tools_list):
                    if test_cmd == "pytest":
                        test_cmd = "./gradlew test"
                    if lint_cmd == "ruff check .":
                        lint_cmd = "./gradlew check"
                else:  # Maven (default)
                    if test_cmd == "pytest":
                        test_cmd = "mvn test"
                    if lint_cmd == "ruff check .":
                        lint_cmd = "mvn checkstyle:check"
            elif "C#" in languages or any(l in languages for l in ["F#", "CSharp", "FSharp"]):
                if test_cmd == "pytest":
                    test_cmd = "dotnet test"
                if lint_cmd == "ruff check .":
                    lint_cmd = "dotnet build"

        lines = ["## Quick Actions"]
        lines.append("\n| Action | Command |")
        lines.append("|--------|---------|")
        lines.append(f"| Run tests | `{test_cmd}` |")
        lines.append(f"| Lint code | `{lint_cmd}` |")
        if build_cmd:
            lines.append(f"| Build | `{build_cmd}` |")
        lines.append("| Sync config | `vk pull` |")
        lines.append("| Push updates | `vk push` |")
        lines.append("| View status | `vk status` |")
        lines.append("| Open dashboard | `vk open` |")

        return "\n".join(lines)

    def _generate_footer(self) -> str:
        """Generate footer section."""
        return """---

*Generated by [VibeKit](https://vkcli.com) - Configure in SaaS, execute locally*"""

    # ========================================================================
    # Helper Methods
    # ========================================================================

    def _get_project_name(self) -> str:
        """Get project name from config or folder name."""
        config = self._load_config()
        if config and config.get("name"):
            return config["name"]
        return self.project_root.name

    def _load_config(self) -> Optional[dict]:
        """Load project config from .vk/config.yaml."""
        config_file = self.vk_dir / "config.yaml"
        if not config_file.exists():
            return None
        return self._load_yaml(config_file)

    def _load_sprint(self) -> Optional[dict]:
        """Load current sprint from .vk/sprints/current.yaml."""
        sprint_file = self.vk_dir / "sprints" / "current.yaml"
        if not sprint_file.exists():
            return None
        return self._load_yaml(sprint_file)

    def _load_roadmap(self) -> Optional[list]:
        """Load roadmap phases from .vk/roadmap/phases.yaml."""
        roadmap_file = self.vk_dir / "roadmap" / "phases.yaml"
        if not roadmap_file.exists():
            return None
        data = self._load_yaml(roadmap_file)
        return data if isinstance(data, list) else None

    def _load_yaml(self, path: Path) -> Optional[dict]:
        """Load YAML file safely."""
        try:
            with open(path) as f:
                return yaml.safe_load(f)
        except Exception:
            return None

    def _extract_rules_content(self, path: Path) -> str:
        """Extract rules content from markdown file, removing the header."""
        try:
            content = path.read_text()
            # Skip the first heading line
            lines = content.strip().split("\n")
            if lines and lines[0].startswith("#"):
                lines = lines[1:]
            return "\n".join(lines).strip()
        except Exception:
            return ""

    def _get_status_emoji(self, status: str) -> str:
        """Get emoji for task/requirement status."""
        status_emojis = {
            "pending": "[ ]",
            "in_progress": "[~]",
            "completed": "[x]",
            "blocked": "[!]",
        }
        return status_emojis.get(status.lower(), "[ ]")
