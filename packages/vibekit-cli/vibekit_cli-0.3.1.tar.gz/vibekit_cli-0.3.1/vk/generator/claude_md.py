"""
CLAUDE.md generator for Claude Code integration.

Generates a comprehensive CLAUDE.md file from project configuration that
Claude Code reads to understand project context, rules, and current work.

Data sources:
- Project data (.vk/): config, sprints, roadmap, tasks
- Claude config (.claude/): rules, patterns, agents, tools, workflows, hooks
"""

from datetime import datetime
from pathlib import Path
from typing import Optional

import yaml


class ClaudeMdGenerator:
    """
    Generator for CLAUDE.md file.

    Reads configuration from both directories:
    - .vk/ for project data (config, sprints, roadmap, tasks)
    - .claude/ for Claude configuration (rules, patterns, agents, tools)

    Generates a unified CLAUDE.md that Claude Code uses for project context.

    Usage:
        generator = ClaudeMdGenerator(project_root)
        generator.generate()
    """

    def __init__(self, project_root: Optional[Path] = None):
        """
        Initialize generator.

        Args:
            project_root: Root directory of the project (default: cwd)
        """
        self.project_root = project_root or Path.cwd()
        self.vk_dir = self.project_root / ".vk"  # Project data
        self.claude_dir = self.project_root / ".claude"  # Claude config
        self.output_file = self.project_root / "CLAUDE.md"

    def generate(self) -> Path:
        """
        Generate CLAUDE.md from .claude/ configuration.

        Returns:
            Path to generated CLAUDE.md file
        """
        content = self._build_content()
        self.output_file.write_text(content)
        return self.output_file

    def _build_content(self) -> str:
        """Build complete CLAUDE.md content."""
        sections = [
            self._generate_header(),
            self._generate_current_focus_section(),  # NEW: Dynamic focus section
            self._generate_config_status_section(),
            self._generate_project_section(),
            self._generate_roadmap_section(),
            self._generate_sprint_section(),
            self._generate_rules_section(),
            self._generate_context_files_section(),  # NEW: Hybrid file references
            self._generate_patterns_section(),
            self._generate_tools_section(),
            self._generate_agents_section(),
            self._generate_workflows_section(),
            self._generate_agent_routing_section(),
            self._generate_agent_delegation_section(),  # NEW: Agent delegation graph
            self._generate_quick_actions_section(),
            self._generate_footer(),
        ]

        return "\n\n".join(filter(None, sections))

    def _generate_header(self) -> str:
        """Generate header section."""
        project_name = self._get_project_name()
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")

        return f"""# Project: {project_name}

> Auto-generated by VibeKit on {timestamp}
> DO NOT EDIT MANUALLY - Run `vk pull` to update

This file provides Claude Code with project context, rules, and current sprint information.
Follow the guidelines and rules defined here when working on this project."""

    def _generate_current_focus_section(self) -> str:
        """Generate current focus from INDEX.yaml - stateless awareness."""
        index_file = self.vk_dir / "INDEX.yaml"
        if not index_file.exists():
            # Fallback to sprint-based logic
            return self._generate_current_focus_section_legacy()

        try:
            index = yaml.safe_load(index_file.read_text())

            sprint = index.get('sprint', {})
            tasks = index.get('tasks', {})
            next_task = index.get('next', {})

            if not sprint.get('id'):
                return ""

            lines = ["## Current Focus"]
            lines.append(f"\n**Sprint**: {sprint.get('id', 'Unknown')} ({sprint.get('progress', 0)}% complete)")
            lines.append(f"**Active Tasks**: {tasks.get('active', 0)}")

            if next_task.get('task'):
                lines.append(f"**Next Task**: `{next_task.get('task', 'None')}` @ `{next_task.get('path', 'N/A')}`")

            lines.append("\n### Quick Commands")
            lines.append("\n```bash")
            lines.append(f"vk start {next_task.get('task', '<task_id>')}  # Start next task")
            lines.append("vk status                                       # Check progress")
            lines.append("vk done                                         # Complete current task")
            lines.append("```")

            return "\n".join(lines)
        except Exception:
            return ""

    def _generate_current_focus_section_legacy(self) -> str:
        """
        Generate dynamic "Current Focus" section (legacy, sprint-based).

        Shows sprint goal and top priority tasks to give Claude
        immediate context about what the team is working on.
        """
        sprint = self._load_sprint()
        if not sprint:
            return ""

        lines = ["## ðŸŽ¯ Current Focus"]

        # Sprint goal
        goal = sprint.get("goal")
        if goal:
            lines.append(f"\n**Sprint Goal**: {goal}")

        # Get all tasks and find priority ones
        all_tasks = []
        for req in sprint.get("requirements", []):
            for task in req.get("tasks", []):
                task_copy = dict(task)
                task_copy["requirement_title"] = req.get("title", "")
                task_copy["requirement_priority"] = req.get("priority", "medium")
                all_tasks.append(task_copy)

        # Sort by status (in_progress first) then by priority
        status_order = {"in_progress": 0, "pending": 1, "blocked": 2, "completed": 3}
        priority_order = {"high": 0, "medium": 1, "low": 2}

        sorted_tasks = sorted(
            all_tasks,
            key=lambda t: (
                status_order.get(t.get("status", "pending"), 1),
                priority_order.get(t.get("priority", t.get("requirement_priority", "medium")), 1),
            ),
        )

        # Show top 5 non-completed tasks
        active_tasks = [t for t in sorted_tasks if t.get("status") != "completed"][:5]

        if active_tasks:
            lines.append("\n**Priority Tasks**:")
            for task in active_tasks:
                status = task.get("status", "pending")
                status_indicator = {
                    "in_progress": "ðŸ”„",
                    "pending": "â³",
                    "blocked": "ðŸš«",
                }.get(status, "â³")

                task_id = task.get("task_id", "TASK")
                title = task.get("title", "Untitled")
                lines.append(f"- {status_indicator} `{task_id}`: {title}")

        # In-progress task context
        in_progress = [t for t in all_tasks if t.get("status") == "in_progress"]
        if in_progress:
            current = in_progress[0]
            task_id = current.get("task_id", "")
            lines.append(f"\n**Currently Working On**: `{task_id}`")

            # Check if task file exists for deep context
            task_file = self.vk_dir / "tasks" / "in-progress" / f"{task_id}.yaml"
            if task_file.exists():
                lines.append(f"_Read `.vk/tasks/in-progress/{task_id}.yaml` for full task context_")

        return "\n".join(lines)

    def _generate_context_files_section(self) -> str:
        """
        Generate hybrid context files section.

        Provides Claude with references to detailed files for deep dives,
        while keeping CLAUDE.md focused on essential context.
        """
        lines = ["## ðŸ“ Context Files"]
        lines.append("\nFor detailed context, read these files as needed:")

        # Build list of available context files
        context_files = []

        # Sprint context (project data in .vk/)
        sprint_file = self.vk_dir / "sprints" / "current.yaml"
        if sprint_file.exists():
            context_files.append(
                ("Sprint Details", ".vk/sprints/current.yaml", "Full sprint with all tasks")
            )

        # Rules (Claude config in .claude/)
        rules_dir = self.claude_dir / "rules"
        if rules_dir.exists():
            if (rules_dir / "security.md").exists():
                context_files.append(
                    ("Security Rules", ".claude/rules/security.md", "Complete security guidelines")
                )
            if (rules_dir / "coding_standards.md").exists():
                context_files.append(
                    ("Coding Standards", ".claude/rules/coding_standards.md", "Full coding rules")
                )
            # Check for generated rules
            generated_dir = rules_dir / "generated"
            if generated_dir.exists() and any(generated_dir.glob("*.md")):
                context_files.append(
                    (
                        "AI-Generated Rules",
                        ".claude/rules/generated/",
                        "Project-specific rules from objectives",
                    )
                )

        # Patterns (Claude config in .claude/)
        patterns_dir = self.claude_dir / "patterns"
        if patterns_dir.exists():
            learned_dir = patterns_dir / "learned"
            if learned_dir.exists() and any(learned_dir.glob("*.md")):
                context_files.append(
                    (
                        "Learned Patterns",
                        ".claude/patterns/learned/",
                        "Patterns extracted from codebase",
                    )
                )
            if any(patterns_dir.glob("*.md")):
                context_files.append(
                    ("Code Patterns", ".claude/patterns/", "Established code patterns to follow")
                )

        # Codebase docs (Claude config in .claude/)
        codebase_dir = self.claude_dir / "codebase"
        if codebase_dir.exists():
            if (codebase_dir / "INDEX.md").exists():
                context_files.append(
                    ("Codebase Index", ".claude/codebase/INDEX.md", "Quick file/component lookup")
                )
            if (codebase_dir / "WHERE_TO_PUT.md").exists():
                context_files.append(
                    (
                        "Where to Put Code",
                        ".claude/codebase/WHERE_TO_PUT.md",
                        "Feature placement guide",
                    )
                )
            if (codebase_dir / "CONVENTIONS.md").exists():
                context_files.append(
                    (
                        "Conventions",
                        ".claude/codebase/CONVENTIONS.md",
                        "Naming and style conventions",
                    )
                )

        # Context optimization files (Claude config in .claude/)
        if (self.claude_dir / "context-mini.yaml").exists():
            context_files.append(
                ("Mini Context", ".claude/context-mini.yaml", "Lightweight context (~800 tokens)")
            )

        if not context_files:
            return ""

        # Format as table
        lines.append("\n| File | Purpose |")
        lines.append("|------|---------|")
        for _name, path, purpose in context_files:
            lines.append(f"| `{path}` | {purpose} |")

        lines.append("\n_Read these files when you need deeper context for a specific area._")

        return "\n".join(lines)

    def _generate_config_status_section(self) -> str:
        """Generate configuration status section showing what's set up vs needs setup."""
        config = self._load_config()
        sprint = self._load_sprint()
        agents_dir = self.claude_dir / "agents"  # Claude config
        patterns_dir = self.claude_dir / "patterns"  # Claude config

        checks = [
            (
                "Tech Stack",
                bool(config and config.get("tech_stack", {}).get("languages")),
            ),
            ("Sprint & Tasks", bool(sprint)),
            (
                "Agents",
                agents_dir.exists()
                and (any(agents_dir.glob("*.md")) or any(agents_dir.glob("*.yaml"))),
            ),
            ("Rules", self._has_rules()),
            (
                "Patterns",
                patterns_dir.exists() and any(patterns_dir.glob("*.md")),
            ),
        ]

        lines = ["## Configuration Status", ""]
        for name, configured in checks:
            status = "[x]" if configured else "[ ]"
            lines.append(f"- {status} {name}")

        # Show setup hint if not fully configured
        if not all(c[1] for c in checks):
            lines.append("\n> Configure at vkcli.com or run `vk open`")

        return "\n".join(lines)

    def _has_rules(self) -> bool:
        """Check if any rules are configured."""
        rules_dir = self.claude_dir / "rules"  # Claude config
        if not rules_dir.exists():
            return False

        for rule_file in rules_dir.glob("*.md"):
            content = rule_file.read_text().strip()
            # Check if it has actual rules (not just header or empty message)
            if content and "_No rules configured" not in content:
                rule_lines = [line for line in content.split("\n") if line.strip().startswith("-")]
                if rule_lines:
                    return True
        return False

    def _generate_project_section(self) -> str:
        """Generate project overview section."""
        config = self._load_config()
        if not config:
            return ""

        lines = ["## Project Overview"]

        if config.get("description"):
            lines.append(f"\n{config['description']}")

        # Tech stack
        tech_stack = config.get("tech_stack", {})
        if tech_stack:
            lines.append("\n### Tech Stack")
            if tech_stack.get("languages"):
                lines.append(f"- **Languages**: {', '.join(tech_stack['languages'])}")
            if tech_stack.get("frameworks"):
                lines.append(f"- **Frameworks**: {', '.join(tech_stack['frameworks'])}")
            if tech_stack.get("databases"):
                lines.append(f"- **Databases**: {', '.join(tech_stack['databases'])}")
            if tech_stack.get("tools"):
                lines.append(f"- **Tools**: {', '.join(tech_stack['tools'])}")

        # Objectives
        objectives = config.get("objectives", [])
        if objectives:
            lines.append("\n### Objectives")
            for obj in objectives:
                lines.append(f"- {obj}")

        # Success criteria
        criteria = config.get("success_criteria", [])
        if criteria:
            lines.append("\n### Success Criteria")
            for crit in criteria:
                lines.append(f"- {crit}")

        return "\n".join(lines)

    def _generate_roadmap_section(self) -> str:
        """Generate project roadmap section."""
        roadmap = self._load_roadmap()
        if not roadmap:
            return ""

        lines = ["## Project Roadmap"]

        # Find current phase
        current_phase = None
        for phase in roadmap:
            if phase.get("status") == "in_progress":
                current_phase = phase
                break

        if current_phase:
            lines.append(
                f"\n**Current Phase**: Phase {current_phase.get('phase_number', '')} - {current_phase.get('name', '')} (In Progress)"
            )
            if current_phase.get("target_date"):
                lines.append(
                    f"**Target**: {current_phase['target_date'][:10] if isinstance(current_phase['target_date'], str) else current_phase['target_date']}"
                )

        lines.append("\n### Phases")
        for phase in roadmap:
            status = phase.get("status", "planned")
            if status == "completed":
                status_mark = "[x]"
            elif status == "in_progress":
                status_mark = "[~]"
            else:
                status_mark = "[ ]"

            phase_line = (
                f"{phase.get('phase_number', '')}. {status_mark} **{phase.get('name', '')}**"
            )
            if status == "completed":
                phase_line += " - Completed"
            elif status == "in_progress":
                phase_line += " - In Progress"
                if phase.get("target_date"):
                    target = (
                        phase["target_date"][:10]
                        if isinstance(phase["target_date"], str)
                        else phase["target_date"]
                    )
                    phase_line += f" (Target: {target})"
            else:
                phase_line += " - Planned"

            lines.append(phase_line)

            # Show milestones for current phase
            if status == "in_progress" and phase.get("milestones"):
                for m in phase["milestones"]:
                    m_status = "[x]" if m.get("completed") else "[ ]"
                    lines.append(f"   - {m_status} {m.get('name', '')}")

        return "\n".join(lines)

    def _generate_sprint_section(self) -> str:
        """Generate current sprint section."""
        sprint = self._load_sprint()
        if not sprint:
            return ""

        lines = [f"## Current Sprint: {sprint.get('name', 'Unnamed Sprint')}"]

        if sprint.get("goal"):
            lines.append(f"\n**Goal**: {sprint['goal']}")

        if sprint.get("status"):
            lines.append(f"**Status**: {sprint['status']}")

        # Date range
        if sprint.get("start_date") or sprint.get("end_date"):
            start = sprint.get("start_date", "TBD")
            end = sprint.get("end_date", "TBD")
            lines.append(f"**Duration**: {start} - {end}")

        # Requirements and tasks
        requirements = sprint.get("requirements", [])
        if requirements:
            lines.append("\n### Priority Tasks")

            # Sort by priority
            priority_order = {"high": 0, "medium": 1, "low": 2}
            sorted_reqs = sorted(
                requirements, key=lambda r: priority_order.get(r.get("priority", "medium"), 1)
            )

            for req in sorted_reqs:
                status_emoji = self._get_status_emoji(req.get("status", "pending"))
                priority_label = req.get("priority", "medium").upper()
                lines.append(
                    f"\n#### {status_emoji} [{req.get('requirement_id', 'REQ')}] "
                    f"{req.get('title', 'Untitled')} ({priority_label})"
                )

                if req.get("description"):
                    lines.append(f"\n{req['description']}")

                # Tasks
                tasks = req.get("tasks", [])
                if tasks:
                    lines.append("\n**Tasks:**")
                    for task in tasks:
                        task_status = self._get_status_emoji(task.get("status", "pending"))
                        task_line = f"- {task_status} `{task.get('task_id', 'TASK')}`: {task.get('title', 'Untitled')}"

                        # Add estimate if available
                        estimate = task.get("estimate")
                        if estimate:
                            task_line += f" ({estimate} pts)"

                        lines.append(task_line)

        return "\n".join(lines)

    def _generate_rules_section(self) -> str:
        """Generate project rules section."""
        rules_dir = self.claude_dir / "rules"  # Claude config
        if not rules_dir.exists():
            return ""

        lines = ["## Project Rules"]

        # Coding standards
        coding_file = rules_dir / "coding_standards.md"
        if coding_file.exists():
            content = self._extract_rules_content(coding_file)
            if content:
                lines.append("\n### Coding Standards")
                lines.append(content)

        # Architecture rules
        arch_file = rules_dir / "architecture.md"
        if arch_file.exists():
            content = self._extract_rules_content(arch_file)
            if content:
                lines.append("\n### Architecture Rules")
                lines.append(content)

        # Security rules
        security_file = rules_dir / "security.md"
        if security_file.exists():
            content = self._extract_rules_content(security_file)
            if content:
                lines.append("\n### Security Rules")
                lines.append(content)

        # Testing rules
        testing_file = rules_dir / "testing.md"
        if testing_file.exists():
            content = self._extract_rules_content(testing_file)
            if content:
                lines.append("\n### Testing Rules")
                lines.append(content)

        return "\n".join(lines) if len(lines) > 1 else ""

    def _generate_patterns_section(self) -> str:
        """Generate code patterns section."""
        patterns_dir = self.claude_dir / "patterns"  # Claude config
        if not patterns_dir.exists():
            return ""

        pattern_files = list(patterns_dir.glob("*.md"))
        if not pattern_files:
            return ""

        lines = ["## Code Patterns"]
        lines.append("\nFollow these established patterns when writing code:")

        for pattern_file in sorted(pattern_files):
            content = pattern_file.read_text()
            # Extract title from first line
            first_line = content.split("\n")[0] if content else ""
            title = (
                first_line.replace("# ", "") if first_line.startswith("#") else pattern_file.stem
            )

            lines.append(f"\n### {title}")
            lines.append(f"See: `.claude/patterns/{pattern_file.name}`")

            # Extract short description (second paragraph or first non-header line)
            content_lines = content.split("\n")
            for line in content_lines[1:]:
                stripped = line.strip()
                if stripped and not stripped.startswith("#") and not stripped.startswith("**"):
                    lines.append(f"\n_{stripped[:100]}{'...' if len(stripped) > 100 else ''}_")
                    break

        return "\n".join(lines) if len(lines) > 1 else ""

    def _generate_tools_section(self) -> str:
        """Generate tools configuration section."""
        tools_dir = self.claude_dir / "tools"  # Claude config
        if not tools_dir.exists():
            return ""

        lines = ["## Tools"]

        # LSP configuration
        lsp_file = tools_dir / "lsp.yaml"
        if lsp_file.exists():
            lsp = self._load_yaml(lsp_file)
            if lsp and lsp.get("enabled", True):
                lines.append("\n### LSP Configuration")
                if lsp.get("languages"):
                    lines.append(f"- **Languages**: {', '.join(lsp['languages'])}")
                if lsp.get("symbol_operations"):
                    lines.append("- **Symbol Operations**: Enabled")
                if lsp.get("auto_import"):
                    lines.append("- **Auto-Import**: Enabled")

        # Linters
        linters_file = tools_dir / "linters.yaml"
        if linters_file.exists():
            linters = self._load_yaml(linters_file)
            if linters:
                lines.append("\n### Linters")
                for linter in linters:
                    if linter.get("enabled", True):
                        lines.append(f"- **{linter.get('name', 'Unknown')}**: Enabled")

        # Quality gates
        gates_file = tools_dir / "quality_gates.yaml"
        if gates_file.exists():
            gates = self._load_yaml(gates_file)
            if gates:
                lines.append("\n### Quality Gates")
                lines.append("The following checks must pass before commit:")
                for gate in gates:
                    if gate.get("enabled", True):
                        required = " (REQUIRED)" if gate.get("required") else ""
                        lines.append(f"- {gate.get('name', 'Unknown')}{required}")

        return "\n".join(lines) if len(lines) > 1 else ""

    def _generate_agents_section(self) -> str:
        """Generate agents configuration section."""
        agents_dir = self.claude_dir / "agents"  # Claude config
        if not agents_dir.exists():
            return ""

        lines = ["## Agents"]

        # Load .md files (Claude Code format with YAML frontmatter)
        for agent_file in agents_dir.glob("*.md"):
            agent = self._load_agent_md(agent_file)
            if agent:
                lines.append(f"\n### {agent.get('name', agent_file.stem)}")
                if agent.get("description"):
                    lines.append(agent["description"])
                if agent.get("tools"):
                    lines.append(f"\n**Tools**: {agent['tools']}")
                if agent.get("model") and agent["model"] != "sonnet":
                    lines.append(f"**Model**: {agent['model']}")

        # Also load legacy .yaml files for backwards compat
        for agent_file in agents_dir.glob("*.yaml"):
            agent = self._load_yaml(agent_file)
            if agent and agent.get("enabled", True):
                lines.append(f"\n### {agent.get('name', agent_file.stem)}")
                if agent.get("description"):
                    lines.append(agent["description"])
                if agent.get("triggers"):
                    lines.append(f"\n**Triggers**: {', '.join(agent['triggers'])}")
                if agent.get("rules"):
                    lines.append("\n**Rules**:")
                    for rule in agent["rules"]:
                        lines.append(f"- {rule}")

        return "\n".join(lines) if len(lines) > 1 else ""

    def _load_agent_md(self, path: Path) -> Optional[dict]:
        """Load agent from .md file with YAML frontmatter."""
        try:
            content = path.read_text()
            if content.startswith("---"):
                parts = content.split("---", 2)
                if len(parts) >= 3:
                    return yaml.safe_load(parts[1])
        except Exception:
            pass
        return None

    def _generate_workflows_section(self) -> str:
        """Generate automation workflows section."""
        workflows_dir = self.claude_dir / "workflows"  # Claude config
        if not workflows_dir.exists():
            return ""

        workflow_files = list(workflows_dir.glob("*.yaml"))
        if not workflow_files:
            return ""

        lines = ["## Automation Workflows"]
        lines.append("\nAutomated workflows that run at specific triggers:")

        for workflow_file in sorted(workflow_files):
            workflow = self._load_yaml(workflow_file)
            if not workflow or not workflow.get("enabled", True):
                continue

            name = workflow.get("name", workflow_file.stem)
            lines.append(f"\n### {name}")

            if workflow.get("description"):
                lines.append(workflow["description"])

            # Show trigger if available
            trigger = workflow.get("trigger") or workflow.get("triggers")
            if trigger:
                if isinstance(trigger, list):
                    trigger = ", ".join(trigger)
                lines.append(f"\n**Trigger**: `{trigger}`")

            # Show steps if available
            steps = workflow.get("steps", [])
            if steps:
                lines.append("\n**Steps**:")
                for i, step in enumerate(steps, 1):
                    if isinstance(step, dict):
                        step_name = step.get("name", f"Step {i}")
                        lines.append(f"{i}. {step_name}")
                    else:
                        lines.append(f"{i}. {step}")

        return "\n".join(lines) if len(lines) > 2 else ""

    def _generate_agent_delegation_section(self) -> str:
        """Generate agent delegation graph from INDEX.yaml."""
        index_file = self.vk_dir / "INDEX.yaml"
        if not index_file.exists():
            return ""

        try:
            index = yaml.safe_load(index_file.read_text())

            agents = index.get('agents', {}).get('available', [])
            if not agents:
                return ""

            content = ["\n## Agent Delegation Graph"]
            content.append("\n| Agent | Purpose | Delegates To |")
            content.append("|-------|---------|--------------|")

            for agent in agents:
                name = agent.get('name', 'Unknown')
                purpose = agent.get('purpose', '')[:40]
                delegates = ", ".join(agent.get('delegates_to', [])) or "_none_"
                content.append(f"| {name} | {purpose} | {delegates} |")

            return "\n".join(content)
        except Exception:
            return ""

    def _generate_agent_routing_section(self) -> str:
        """Generate intelligent agent routing guide section - only if agents exist."""
        # Only generate if agents are configured
        agents_dir = self.claude_dir / "agents"  # Claude config
        if not agents_dir.exists():
            return ""

        has_agents = any(agents_dir.glob("*.md")) or any(agents_dir.glob("*.yaml"))
        if not has_agents:
            return ""

        # Load configured agents from .md files
        agents = []
        for agent_file in agents_dir.glob("*.md"):
            agent = self._load_agent_md(agent_file)
            if agent:
                agents.append(
                    {
                        "name": agent.get("name", agent_file.stem),
                        "model": agent.get("model", "sonnet"),
                        "description": agent.get("description", ""),
                        "when_to_use": agent.get("when_to_use", ""),
                        "triggers": agent.get("triggers", []),
                        "delegates_to": agent.get("delegates_to", []),
                    }
                )

        # Also load legacy .yaml files
        for agent_file in agents_dir.glob("*.yaml"):
            agent = self._load_yaml(agent_file)
            if agent and agent.get("enabled", True):
                agents.append(
                    {
                        "name": agent.get("name", agent_file.stem),
                        "model": agent.get("model", "sonnet"),
                        "description": agent.get("description", ""),
                        "when_to_use": agent.get("when_to_use", ""),
                        "triggers": agent.get("triggers", []),
                        "delegates_to": agent.get("delegates_to", []),
                    }
                )

        if not agents:
            return ""

        lines = ["## Agent Selection Guide"]
        lines.append("\nWhen executing tasks, use the configured agents:")
        lines.append("\n| Agent | Model | Use When |")
        lines.append("|-------|-------|----------|")

        for agent in agents:
            when_to_use = agent.get("when_to_use", "")
            if when_to_use:
                # Truncate to reasonable length
                when_text = when_to_use[:50] + "..." if len(when_to_use) > 50 else when_to_use
            else:
                # Fallback to description
                when_text = agent['description'][:50] + "..." if len(agent['description']) > 50 else agent['description']

            lines.append(
                f"| {agent['name']} | {agent['model']} | {when_text} |"
            )

        # Add delegation triggers section if any agent has triggers
        agents_with_triggers = [a for a in agents if a.get("triggers")]
        if agents_with_triggers:
            lines.append("\n### Delegation Triggers")
            lines.append("\nAutomatically delegate to these agents when:")
            lines.append("")
            for agent in agents_with_triggers:
                triggers = agent.get("triggers", [])
                if triggers:
                    lines.append(f"**{agent['name']}**:")
                    for trigger in triggers[:3]:  # Limit to 3 triggers
                        lines.append(f"- {trigger}")

        return "\n".join(lines)

    def _generate_quick_actions_section(self) -> str:
        """Generate quick actions based on detected project type."""
        config = self._load_config()

        # Try to get commands from config
        test_cmd = "pytest"
        lint_cmd = "ruff check ."
        build_cmd = None

        if config:
            project_settings = config.get("project", {})
            test_cmd = project_settings.get("test_command", test_cmd)
            lint_cmd = project_settings.get("lint_command", lint_cmd)
            build_cmd = project_settings.get("build_command")

            # Also check tech stack for better defaults
            tech = config.get("tech_stack", {})
            languages = tech.get("languages", [])

            # Override defaults based on detected language
            if "TypeScript" in languages or "JavaScript" in languages:
                if test_cmd == "pytest":
                    test_cmd = "npm test"
                if lint_cmd == "ruff check .":
                    lint_cmd = "npm run lint"
            elif "Go" in languages:
                if test_cmd == "pytest":
                    test_cmd = "go test ./..."
                if lint_cmd == "ruff check .":
                    lint_cmd = "golangci-lint run"
            elif "Rust" in languages:
                if test_cmd == "pytest":
                    test_cmd = "cargo test"
                if lint_cmd == "ruff check .":
                    lint_cmd = "cargo clippy"
            elif "Java" in languages or "Kotlin" in languages:
                # Check for Gradle vs Maven
                tools_list = tech.get("tools", [])
                if any("gradle" in t.lower() for t in tools_list):
                    if test_cmd == "pytest":
                        test_cmd = "./gradlew test"
                    if lint_cmd == "ruff check .":
                        lint_cmd = "./gradlew check"
                else:  # Maven (default)
                    if test_cmd == "pytest":
                        test_cmd = "mvn test"
                    if lint_cmd == "ruff check .":
                        lint_cmd = "mvn checkstyle:check"
            elif "C#" in languages or any(l in languages for l in ["F#", "CSharp", "FSharp"]):
                if test_cmd == "pytest":
                    test_cmd = "dotnet test"
                if lint_cmd == "ruff check .":
                    lint_cmd = "dotnet build"

        lines = ["## Quick Actions"]
        lines.append("\n| Action | Command |")
        lines.append("|--------|---------|")
        lines.append(f"| Run tests | `{test_cmd}` |")
        lines.append(f"| Lint code | `{lint_cmd}` |")
        if build_cmd:
            lines.append(f"| Build | `{build_cmd}` |")
        lines.append("| Sync config | `vk pull` |")
        lines.append("| Push updates | `vk push` |")
        lines.append("| View status | `vk status` |")
        lines.append("| Open dashboard | `vk open` |")

        return "\n".join(lines)

    def _generate_footer(self) -> str:
        """Generate footer section."""
        return """---

*Generated by [VibeKit](https://vkcli.com) - Configure in SaaS, execute locally*"""

    # ========================================================================
    # Helper Methods
    # ========================================================================

    def _get_project_name(self) -> str:
        """Get project name from config or folder name."""
        config = self._load_config()
        if config and config.get("name"):
            return config["name"]
        return self.project_root.name

    def _load_config(self) -> Optional[dict]:
        """Load project config from .vk/config.yaml."""
        config_file = self.vk_dir / "config.yaml"
        if not config_file.exists():
            return None
        return self._load_yaml(config_file)

    def _load_sprint(self) -> Optional[dict]:
        """Load current sprint from .vk/sprints/current.yaml."""
        sprint_file = self.vk_dir / "sprints" / "current.yaml"
        if not sprint_file.exists():
            return None
        return self._load_yaml(sprint_file)

    def _load_roadmap(self) -> Optional[list]:
        """Load roadmap phases from .vk/roadmap/phases.yaml."""
        roadmap_file = self.vk_dir / "roadmap" / "phases.yaml"
        if not roadmap_file.exists():
            return None
        data = self._load_yaml(roadmap_file)
        return data if isinstance(data, list) else None

    def _load_yaml(self, path: Path) -> Optional[dict]:
        """Load YAML file safely."""
        try:
            with open(path) as f:
                return yaml.safe_load(f)
        except Exception:
            return None

    def _extract_rules_content(self, path: Path) -> str:
        """Extract rules content from markdown file, removing the header."""
        try:
            content = path.read_text()
            # Skip the first heading line
            lines = content.strip().split("\n")
            if lines and lines[0].startswith("#"):
                lines = lines[1:]
            return "\n".join(lines).strip()
        except Exception:
            return ""

    def _get_status_emoji(self, status: str) -> str:
        """Get emoji for task/requirement status."""
        status_emojis = {
            "pending": "[ ]",
            "in_progress": "[~]",
            "completed": "[x]",
            "blocked": "[!]",
        }
        return status_emojis.get(status.lower(), "[ ]")
