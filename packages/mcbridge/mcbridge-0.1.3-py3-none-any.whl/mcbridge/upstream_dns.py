"""Helpers for discovering and persisting upstream DNS servers."""

from __future__ import annotations

import ipaddress
import os
import subprocess
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Mapping, Sequence

from .agent import AgentProcessResult
from .common import load_json, response_payload, save_json
from . import privileges
from .paths import CONFIG_DIR

UPSTREAM_DNS_JSON = CONFIG_DIR / "upstream_dns.json"
UPSTREAM_INTERFACE = os.environ.get("MCBRIDGE_UPSTREAM_INTERFACE", "wlan0")
RESOLV_CONF = Path("/etc/resolv.conf")
DEBOUNCE_SECONDS = int(os.environ.get("MCBRIDGE_DNS_DEBOUNCE_SECONDS", "10"))


@dataclass
class UpstreamDnsSnapshot:
    servers: list[str]
    source: Mapping[str, object] | None
    discovered_at: str | None
    last_checked_at: str | None
    last_changed_at: str | None
    assumptions: list[str]


@dataclass
class UpstreamDnsResult:
    payload: Mapping[str, Any]
    exit_code: int


def _utc_now() -> str:
    return datetime.now(timezone.utc).isoformat()


def _parse_iso8601(value: str | None) -> datetime | None:
    if not value:
        return None
    try:
        return datetime.fromisoformat(value)
    except ValueError:
        return None


def _is_ip_address(value: str) -> bool:
    try:
        ipaddress.ip_address(value)
    except ValueError:
        return False
    return True


def _is_loopback(value: str) -> bool:
    try:
        ip_value = ipaddress.ip_address(value)
    except ValueError:
        return False
    return bool(ip_value.is_loopback or ip_value.is_unspecified)


def _normalize_servers(raw_servers: Sequence[str]) -> list[str]:
    servers: list[str] = []
    for entry in raw_servers:
        server = entry.strip()
        if not server or not _is_ip_address(server) or _is_loopback(server):
            continue
        servers.append(server)
    return list(dict.fromkeys(servers))


def _run_command(command: Sequence[str]) -> subprocess.CompletedProcess[str] | AgentProcessResult:
    return privileges.sudo_run(list(command), check=False, text=True)


def _command_payload(command: Sequence[str], result: subprocess.CompletedProcess[str] | AgentProcessResult) -> dict[str, Any]:
    return {
        "command": " ".join(command),
        "stdout": result.stdout,
        "stderr": result.stderr,
        "returncode": result.returncode,
    }


def _parse_nmcli_dns(output: str) -> list[str]:
    servers: list[str] = []
    for line in output.splitlines():
        if ":" not in line:
            continue
        _, value = line.split(":", 1)
        servers.append(value.strip())
    return _normalize_servers(servers)


def _parse_resolvectl_dns(output: str, interface: str) -> list[str]:
    servers: list[str] = []
    for line in output.splitlines():
        stripped = line.strip()
        if not stripped:
            continue
        if stripped.startswith("Link") and f"({interface})" in stripped and ":" in stripped:
            _, values = stripped.split(":", 1)
            servers.extend(values.split())
            continue
        if stripped.lower().startswith("link") and f"({interface})" in stripped:
            parts = stripped.split()
            servers.extend(parts[3:])
    return _normalize_servers(servers)


def _parse_resolv_conf(contents: str) -> list[str]:
    servers: list[str] = []
    for line in contents.splitlines():
        stripped = line.strip()
        if not stripped or stripped.startswith("#"):
            continue
        parts = stripped.split()
        if len(parts) < 2 or parts[0] != "nameserver":
            continue
        servers.append(parts[1])
    return _normalize_servers(servers)


def _resolv_conf_authoritative(contents: str) -> tuple[bool, list[str]]:
    assumptions: list[str] = []
    lower_contents = contents.lower()
    indicators = (
        "generated by networkmanager",
        "generated by resolvconf",
        "generated by dhclient",
        "generated by dhcpcd",
        "managed by networkmanager",
    )
    for indicator in indicators:
        if indicator in lower_contents:
            assumptions.append(f"resolv.conf has DHCP provenance: {indicator}")
            return True, assumptions
    if "systemd-resolved" in lower_contents and "stub" in lower_contents:
        assumptions.append("resolv.conf indicates systemd-resolved stub; skipping")
    return False, assumptions


def _discover_via_nmcli(interface: str) -> tuple[list[str], dict[str, Any] | None]:
    commands = [
        ["nmcli", "-t", "-f", "IP4.DNS", "dev", "show", interface],
        ["nmcli", "dev", "show", interface],
    ]
    for command in commands:
        try:
            result = _run_command(command)
        except (FileNotFoundError, PermissionError) as exc:
            return [], {"error": str(exc), "command": " ".join(command)}
        if result.returncode != 0:
            return [], _command_payload(command, result)
        servers = _parse_nmcli_dns(result.stdout or "")
        if servers:
            return servers, _command_payload(command, result)
    return [], _command_payload(commands[-1], result)


def _discover_via_resolvectl(interface: str) -> tuple[list[str], dict[str, Any] | None]:
    command = ["resolvectl", "dns", interface]
    try:
        result = _run_command(command)
    except (FileNotFoundError, PermissionError) as exc:
        return [], {"error": str(exc), "command": " ".join(command)}
    if result.returncode != 0:
        return [], _command_payload(command, result)
    servers = _parse_resolvectl_dns(result.stdout or "", interface)
    return servers, _command_payload(command, result)


def _discover_via_resolv_conf() -> tuple[list[str], dict[str, Any] | None, list[str]]:
    assumptions: list[str] = []
    try:
        contents = RESOLV_CONF.read_text(encoding="utf-8")
    except FileNotFoundError as exc:
        return [], {"error": str(exc), "path": str(RESOLV_CONF)}, assumptions
    except OSError as exc:
        return [], {"error": str(exc), "path": str(RESOLV_CONF)}, assumptions

    authoritative, reasons = _resolv_conf_authoritative(contents)
    assumptions.extend(reasons)
    if not authoritative:
        return [], {"path": str(RESOLV_CONF), "authoritative": False}, assumptions

    servers = _parse_resolv_conf(contents)
    return servers, {"path": str(RESOLV_CONF), "authoritative": True}, assumptions


def discover_upstream_dns(interface: str) -> tuple[list[str], dict[str, Any], list[str]]:
    attempts: list[dict[str, Any]] = []
    assumptions: list[str] = []

    nmcli_servers, nmcli_meta = _discover_via_nmcli(interface)
    if nmcli_meta:
        attempts.append({"source": "nmcli", **nmcli_meta})
    if nmcli_servers:
        return nmcli_servers, {"provider": "nmcli", "interface": interface, "details": attempts[-1]}, assumptions

    resolvectl_servers, resolvectl_meta = _discover_via_resolvectl(interface)
    if resolvectl_meta:
        attempts.append({"source": "resolvectl", **resolvectl_meta})
    if resolvectl_servers:
        return (
            resolvectl_servers,
            {"provider": "resolvectl", "interface": interface, "details": attempts[-1]},
            assumptions,
        )

    resolv_servers, resolv_meta, resolv_assumptions = _discover_via_resolv_conf()
    assumptions.extend(resolv_assumptions)
    if resolv_meta:
        attempts.append({"source": "resolv.conf", **resolv_meta})
    if resolv_servers:
        return (
            resolv_servers,
            {"provider": "resolv.conf", "interface": interface, "details": attempts[-1]},
            assumptions,
        )

    return [], {"provider": "none", "interface": interface, "attempts": attempts}, assumptions


def load_upstream_dns(path: Path | None = None) -> UpstreamDnsSnapshot:
    config_path = path or UPSTREAM_DNS_JSON
    raw = load_json(config_path, default={})
    servers = _normalize_servers(raw.get("servers") or []) if isinstance(raw, Mapping) else []
    source = raw.get("source") if isinstance(raw, Mapping) else None
    discovered_at = raw.get("discovered_at") if isinstance(raw, Mapping) else None
    last_checked_at = raw.get("last_checked_at") if isinstance(raw, Mapping) else None
    last_changed_at = raw.get("last_changed_at") if isinstance(raw, Mapping) else None
    assumptions = list(raw.get("assumptions") or []) if isinstance(raw, Mapping) else []
    return UpstreamDnsSnapshot(
        servers=servers,
        source=source if isinstance(source, Mapping) else None,
        discovered_at=discovered_at,
        last_checked_at=last_checked_at,
        last_changed_at=last_changed_at,
        assumptions=[str(value) for value in assumptions if value],
    )


def refresh_upstream_dns(
    *,
    interface: str | None = None,
    debounce_seconds: int | None = None,
    apply: bool = False,
    debug_json: bool | None = None,
) -> UpstreamDnsResult:
    interface_name = interface or UPSTREAM_INTERFACE
    snapshot = load_upstream_dns()
    now = _utc_now()
    debounce = DEBOUNCE_SECONDS if debounce_seconds is None else debounce_seconds
    verbose = bool(debug_json)
    last_checked = _parse_iso8601(snapshot.last_checked_at)
    if last_checked and debounce > 0:
        elapsed = (datetime.now(timezone.utc) - last_checked).total_seconds()
        if elapsed < debounce:
            payload = {
                "status": "skipped",
                "reason": "debounced",
                "interface": interface_name,
                "debounce_seconds": debounce,
                "last_checked_at": snapshot.last_checked_at,
                "servers": snapshot.servers,
            }
            return UpstreamDnsResult(response_payload(payload, verbose=verbose), 0)

    servers, source, assumptions = discover_upstream_dns(interface_name)
    payload: dict[str, Any] = {
        "interface": interface_name,
        "servers": servers,
        "source": source,
        "assumptions": assumptions,
        "checked_at": now,
    }

    if not servers:
        payload.update(
            {
                "status": "warning",
                "message": "No upstream DNS servers discovered.",
                "stored_servers": snapshot.servers,
            }
        )
        return UpstreamDnsResult(response_payload(payload, verbose=verbose), 2)

    changed = servers != snapshot.servers
    last_changed_at = snapshot.last_changed_at
    if changed:
        last_changed_at = now
    updated_payload = {
        "servers": servers,
        "source": source,
        "discovered_at": now,
        "last_checked_at": now,
        "last_changed_at": last_changed_at,
        "assumptions": assumptions,
    }
    save_json(UPSTREAM_DNS_JSON, updated_payload)
    payload.update(
        {
            "status": "updated" if changed else "unchanged",
            "changed": changed,
            "path": str(UPSTREAM_DNS_JSON),
            "last_changed_at": last_changed_at,
        }
    )

    if apply and changed:
        from . import ap

        ap_result = ap.update(dry_run=False, force=True, debug_json=debug_json)
        payload["ap_update"] = ap_result.payload
        exit_code = ap_result.exit_code
    else:
        payload["ap_update"] = {"status": "skipped", "reason": "unchanged" if not changed else "disabled"}
        exit_code = 0

    return UpstreamDnsResult(response_payload(payload, verbose=verbose), exit_code)


__all__ = [
    "UPSTREAM_DNS_JSON",
    "UpstreamDnsResult",
    "UpstreamDnsSnapshot",
    "discover_upstream_dns",
    "load_upstream_dns",
    "refresh_upstream_dns",
]
