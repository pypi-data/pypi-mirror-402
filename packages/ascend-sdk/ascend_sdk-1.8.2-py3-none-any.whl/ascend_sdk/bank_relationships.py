"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from ascend_sdk import utils
from ascend_sdk._hooks import HookContext
from ascend_sdk.models import components, errors, operations
from ascend_sdk.types import OptionalNullable, UNSET
from ascend_sdk.utils.unmarshal_json_response import unmarshal_json_response
from jsonpath import JSONPath
from typing import Any, Dict, List, Mapping, Optional, Union


class BankRelationships(BaseSDK):
    def create_bank_relationship(
        self,
        *,
        account_id: str,
        bank_relationship_create: Union[
            components.BankRelationshipCreate,
            components.BankRelationshipCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsCreateBankRelationshipResponse:
        r"""Create Bank Relationship

        Creates a bank relationship.

        :param account_id: The account id.
        :param bank_relationship_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsCreateBankRelationshipRequest(
            account_id=account_id,
            bank_relationship_create=utils.get_pydantic_model(
                bank_relationship_create, components.BankRelationshipCreate
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/bankRelationships",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.bank_relationship_create,
                False,
                False,
                "json",
                components.BankRelationshipCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_CreateBankRelationship",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsCreateBankRelationshipResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsCreateBankRelationshipResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_bank_relationship_async(
        self,
        *,
        account_id: str,
        bank_relationship_create: Union[
            components.BankRelationshipCreate,
            components.BankRelationshipCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsCreateBankRelationshipResponse:
        r"""Create Bank Relationship

        Creates a bank relationship.

        :param account_id: The account id.
        :param bank_relationship_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsCreateBankRelationshipRequest(
            account_id=account_id,
            bank_relationship_create=utils.get_pydantic_model(
                bank_relationship_create, components.BankRelationshipCreate
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/bankRelationships",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.bank_relationship_create,
                False,
                False,
                "json",
                components.BankRelationshipCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_CreateBankRelationship",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsCreateBankRelationshipResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsCreateBankRelationshipResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def list_bank_relationships(
        self,
        *,
        account_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        state: Optional[operations.State] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[operations.BankRelationshipsListBankRelationshipsResponse]:
        r"""List Bank Relationships

        Lists bank relationships for an account.

        :param account_id: The account id.
        :param page_size: The maximum number of bank relationships to return. The service may return fewer than this value. If unspecified, at most 50 bank relationships will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :param page_token: A page token, received from a previous `ListBankRelationships` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListBankRelationships` must match the call that provided the page token.
        :param state: The state of bank relationships to filter by. Unspecified returns relationships of all states.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsListBankRelationshipsRequest(
            account_id=account_id,
            page_size=page_size,
            page_token=page_token,
            state=state,
        )

        req = self._build_request(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/bankRelationships",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_ListBankRelationships",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[
            operations.BankRelationshipsListBankRelationshipsResponse
        ]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])
            next_cursor = JSONPath("$.next_page_token").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_bank_relationships(
                account_id=account_id,
                page_size=page_size,
                page_token=next_cursor,
                state=state,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsListBankRelationshipsResponse(
                list_bank_relationships_response=unmarshal_json_response(
                    Optional[components.ListBankRelationshipsResponse], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsListBankRelationshipsResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_bank_relationships_async(
        self,
        *,
        account_id: str,
        page_size: Optional[int] = None,
        page_token: Optional[str] = None,
        state: Optional[operations.State] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[operations.BankRelationshipsListBankRelationshipsResponse]:
        r"""List Bank Relationships

        Lists bank relationships for an account.

        :param account_id: The account id.
        :param page_size: The maximum number of bank relationships to return. The service may return fewer than this value. If unspecified, at most 50 bank relationships will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.
        :param page_token: A page token, received from a previous `ListBankRelationships` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListBankRelationships` must match the call that provided the page token.
        :param state: The state of bank relationships to filter by. Unspecified returns relationships of all states.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsListBankRelationshipsRequest(
            account_id=account_id,
            page_size=page_size,
            page_token=page_token,
            state=state,
        )

        req = self._build_request_async(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/bankRelationships",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_ListBankRelationships",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[
            operations.BankRelationshipsListBankRelationshipsResponse
        ]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])
            next_cursor = JSONPath("$.next_page_token").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_bank_relationships(
                account_id=account_id,
                page_size=page_size,
                page_token=next_cursor,
                state=state,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsListBankRelationshipsResponse(
                list_bank_relationships_response=unmarshal_json_response(
                    Optional[components.ListBankRelationshipsResponse], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["400", "403"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsListBankRelationshipsResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
                next=next_func,
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def get_bank_relationship(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsGetBankRelationshipResponse:
        r"""Get Bank Relationship

        Gets an existing bank relationship.

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsGetBankRelationshipRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
        )

        req = self._build_request(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_GetBankRelationship",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsGetBankRelationshipResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsGetBankRelationshipResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_bank_relationship_async(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsGetBankRelationshipResponse:
        r"""Get Bank Relationship

        Gets an existing bank relationship.

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsGetBankRelationshipRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_GetBankRelationship",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsGetBankRelationshipResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsGetBankRelationshipResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def update_bank_relationship(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        bank_relationship_update: Union[
            components.BankRelationshipUpdate,
            components.BankRelationshipUpdateTypedDict,
        ],
        update_mask: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsUpdateBankRelationshipResponse:
        r"""Update Bank Relationship

        Updates an existing bank relationship.

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param bank_relationship_update:
        :param update_mask: The field of the bank relationship to update. Only `nickname` is supported.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsUpdateBankRelationshipRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
            update_mask=update_mask,
            bank_relationship_update=utils.get_pydantic_model(
                bank_relationship_update, components.BankRelationshipUpdate
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.bank_relationship_update,
                False,
                False,
                "json",
                components.BankRelationshipUpdate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_UpdateBankRelationship",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsUpdateBankRelationshipResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsUpdateBankRelationshipResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def update_bank_relationship_async(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        bank_relationship_update: Union[
            components.BankRelationshipUpdate,
            components.BankRelationshipUpdateTypedDict,
        ],
        update_mask: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsUpdateBankRelationshipResponse:
        r"""Update Bank Relationship

        Updates an existing bank relationship.

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param bank_relationship_update:
        :param update_mask: The field of the bank relationship to update. Only `nickname` is supported.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsUpdateBankRelationshipRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
            update_mask=update_mask,
            bank_relationship_update=utils.get_pydantic_model(
                bank_relationship_update, components.BankRelationshipUpdate
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.bank_relationship_update,
                False,
                False,
                "json",
                components.BankRelationshipUpdate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_UpdateBankRelationship",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsUpdateBankRelationshipResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsUpdateBankRelationshipResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def cancel_bank_relationship(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        cancel_bank_relationship_request_create: Union[
            components.CancelBankRelationshipRequestCreate,
            components.CancelBankRelationshipRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsCancelBankRelationshipResponse:
        r"""Cancel Bank Relationship

        Cancels an existing bank relationship.

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param cancel_bank_relationship_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsCancelBankRelationshipRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
            cancel_bank_relationship_request_create=utils.get_pydantic_model(
                cancel_bank_relationship_request_create,
                components.CancelBankRelationshipRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}:cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.cancel_bank_relationship_request_create,
                False,
                False,
                "json",
                components.CancelBankRelationshipRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_CancelBankRelationship",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsCancelBankRelationshipResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsCancelBankRelationshipResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def cancel_bank_relationship_async(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        cancel_bank_relationship_request_create: Union[
            components.CancelBankRelationshipRequestCreate,
            components.CancelBankRelationshipRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsCancelBankRelationshipResponse:
        r"""Cancel Bank Relationship

        Cancels an existing bank relationship.

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param cancel_bank_relationship_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsCancelBankRelationshipRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
            cancel_bank_relationship_request_create=utils.get_pydantic_model(
                cancel_bank_relationship_request_create,
                components.CancelBankRelationshipRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}:cancel",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.cancel_bank_relationship_request_create,
                False,
                False,
                "json",
                components.CancelBankRelationshipRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_CancelBankRelationship",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsCancelBankRelationshipResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsCancelBankRelationshipResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def verify_micro_deposits(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        verify_micro_deposits_request_create: Union[
            components.VerifyMicroDepositsRequestCreate,
            components.VerifyMicroDepositsRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsVerifyMicroDepositsResponse:
        r"""Verify Micro Deposits

        Verifies a pending bank relationship with the `MICRO_DEPOSIT` verification method. Successful verification of the micro deposit amounts will result in the relationship moving to the `APPROVED` state. The micro deposits will be taken back from the bank account.

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param verify_micro_deposits_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsVerifyMicroDepositsRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
            verify_micro_deposits_request_create=utils.get_pydantic_model(
                verify_micro_deposits_request_create,
                components.VerifyMicroDepositsRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}:verifyMicroDeposits",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.verify_micro_deposits_request_create,
                False,
                False,
                "json",
                components.VerifyMicroDepositsRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_VerifyMicroDeposits",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsVerifyMicroDepositsResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsVerifyMicroDepositsResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def verify_micro_deposits_async(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        verify_micro_deposits_request_create: Union[
            components.VerifyMicroDepositsRequestCreate,
            components.VerifyMicroDepositsRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsVerifyMicroDepositsResponse:
        r"""Verify Micro Deposits

        Verifies a pending bank relationship with the `MICRO_DEPOSIT` verification method. Successful verification of the micro deposit amounts will result in the relationship moving to the `APPROVED` state. The micro deposits will be taken back from the bank account.

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param verify_micro_deposits_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsVerifyMicroDepositsRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
            verify_micro_deposits_request_create=utils.get_pydantic_model(
                verify_micro_deposits_request_create,
                components.VerifyMicroDepositsRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}:verifyMicroDeposits",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.verify_micro_deposits_request_create,
                False,
                False,
                "json",
                components.VerifyMicroDepositsRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_VerifyMicroDeposits",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsVerifyMicroDepositsResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsVerifyMicroDepositsResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def reissue_micro_deposits(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        reissue_micro_deposits_request_create: Union[
            components.ReissueMicroDepositsRequestCreate,
            components.ReissueMicroDepositsRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsReissueMicroDepositsResponse:
        r"""Reissue Micro Deposits

        Reissues micro deposits after micro deposit verification has failed. The user should have received a message that new micro deposits should be reissued.

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param reissue_micro_deposits_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsReissueMicroDepositsRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
            reissue_micro_deposits_request_create=utils.get_pydantic_model(
                reissue_micro_deposits_request_create,
                components.ReissueMicroDepositsRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}:reissue",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.reissue_micro_deposits_request_create,
                False,
                False,
                "json",
                components.ReissueMicroDepositsRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_ReissueMicroDeposits",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsReissueMicroDepositsResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsReissueMicroDepositsResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def reissue_micro_deposits_async(
        self,
        *,
        account_id: str,
        bank_relationship_id: str,
        reissue_micro_deposits_request_create: Union[
            components.ReissueMicroDepositsRequestCreate,
            components.ReissueMicroDepositsRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsReissueMicroDepositsResponse:
        r"""Reissue Micro Deposits

        Reissues micro deposits after micro deposit verification has failed. The user should have received a message that new micro deposits should be reissued.

        :param account_id: The account id.
        :param bank_relationship_id: The bankRelationship id.
        :param reissue_micro_deposits_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsReissueMicroDepositsRequest(
            account_id=account_id,
            bank_relationship_id=bank_relationship_id,
            reissue_micro_deposits_request_create=utils.get_pydantic_model(
                reissue_micro_deposits_request_create,
                components.ReissueMicroDepositsRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/bankRelationships/{bankRelationship_id}:reissue",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.reissue_micro_deposits_request_create,
                False,
                False,
                "json",
                components.ReissueMicroDepositsRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_ReissueMicroDeposits",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsReissueMicroDepositsResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsReissueMicroDepositsResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    def reuse_bank_relationship(
        self,
        *,
        account_id: str,
        reuse_bank_relationship_request_create: Union[
            components.ReuseBankRelationshipRequestCreate,
            components.ReuseBankRelationshipRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsReuseBankRelationshipResponse:
        r"""Reuse Bank Relationship

        Reuses an existing bank relationship for a new account. The source bank relationship must be approved. The new account must be related to the parent account of the `source_bank_relationship`. The new relationship will be created with the `USE_EXISTING` verification method in place of the source bank relationship's verification method.

        :param account_id: The account id.
        :param reuse_bank_relationship_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsReuseBankRelationshipRequest(
            account_id=account_id,
            reuse_bank_relationship_request_create=utils.get_pydantic_model(
                reuse_bank_relationship_request_create,
                components.ReuseBankRelationshipRequestCreate,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/bankRelationships:reuse",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.reuse_bank_relationship_request_create,
                False,
                False,
                "json",
                components.ReuseBankRelationshipRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_ReuseBankRelationship",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsReuseBankRelationshipResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsReuseBankRelationshipResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)

    async def reuse_bank_relationship_async(
        self,
        *,
        account_id: str,
        reuse_bank_relationship_request_create: Union[
            components.ReuseBankRelationshipRequestCreate,
            components.ReuseBankRelationshipRequestCreateTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> operations.BankRelationshipsReuseBankRelationshipResponse:
        r"""Reuse Bank Relationship

        Reuses an existing bank relationship for a new account. The source bank relationship must be approved. The new account must be related to the parent account of the `source_bank_relationship`. The new relationship will be created with the `USE_EXISTING` verification method in place of the source bank relationship's verification method.

        :param account_id: The account id.
        :param reuse_bank_relationship_request_create:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = operations.BankRelationshipsReuseBankRelationshipRequest(
            account_id=account_id,
            reuse_bank_relationship_request_create=utils.get_pydantic_model(
                reuse_bank_relationship_request_create,
                components.ReuseBankRelationshipRequestCreate,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/transfers/v1/accounts/{account_id}/bankRelationships:reuse",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.reuse_bank_relationship_request_create,
                False,
                False,
                "json",
                components.ReuseBankRelationshipRequestCreate,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(500, 5000, 1.5, 15000), True
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["4XX", "5XX"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="BankRelationships_ReuseBankRelationship",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "403", "404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return operations.BankRelationshipsReuseBankRelationshipResponse(
                bank_relationship=unmarshal_json_response(
                    Optional[components.BankRelationship], http_res
                ),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )
        if utils.match_response(http_res, ["400", "403", "404"], "application/json"):
            response_data = unmarshal_json_response(errors.StatusData, http_res)
            raise errors.Status(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "application/json"):
            return operations.BankRelationshipsReuseBankRelationshipResponse(
                status=unmarshal_json_response(Optional[components.Status], http_res),
                http_meta=components.HTTPMetadata(request=req, response=http_res),
            )

        raise errors.SDKError("Unexpected response received", http_res)
