"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .bookingfee import BookingFee, BookingFeeTypedDict
from .bookinglot import BookingLot, BookingLotTypedDict
from .execution import Execution, ExecutionTypedDict
from ascend_sdk import utils
from ascend_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from ascend_sdk.utils import validate_open_enum
from enum import Enum
from pydantic import model_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class CompleteTradeResponseAssetType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Type of the asset being traded."""

    ASSET_TYPE_UNSPECIFIED = "ASSET_TYPE_UNSPECIFIED"
    EQUITY = "EQUITY"
    FIXED_INCOME = "FIXED_INCOME"


class CompleteTradeResponseBrokerCapacity(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Broker capacity for the trade."""

    CAPACITY_UNSPECIFIED = "CAPACITY_UNSPECIFIED"
    AGENCY = "AGENCY"
    PRINCIPAL = "PRINCIPAL"
    MIXED = "MIXED"


class CompleteTradeResponseIdentifierType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Identifier type for the asset being traded."""

    IDENTIFIER_TYPE_UNSPECIFIED = "IDENTIFIER_TYPE_UNSPECIFIED"
    ASSET_ID = "ASSET_ID"
    SYMBOL = "SYMBOL"
    CUSIP = "CUSIP"
    ISIN = "ISIN"


class CompleteTradeResponseLocalMarketTradeDateTypedDict(TypedDict):
    r"""Date field to support extended trading hours."""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class CompleteTradeResponseLocalMarketTradeDate(BaseModel):
    r"""Date field to support extended trading hours."""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class CompleteTradeResponseRouteType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Route type for the trade."""

    ROUTE_TYPE_UNSPECIFIED = "ROUTE_TYPE_UNSPECIFIED"
    DMA = "DMA"
    MNGD = "MNGD"
    QUIK = "QUIK"
    ALGO = "ALGO"
    AWAY = "AWAY"
    CORR = "CORR"
    BOATS = "BOATS"


class CompleteTradeResponseSettlementDateTypedDict(TypedDict):
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class CompleteTradeResponseSettlementDate(BaseModel):
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class CompleteTradeResponseSide(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Denotes if the trade is a SELL or a BUY."""

    SIDE_UNSPECIFIED = "SIDE_UNSPECIFIED"
    BUY = "BUY"
    SELL = "SELL"


class CompleteTradeResponseSideModifier(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Side modifier for the trade."""

    SIDE_MODIFIER_UNSPECIFIED = "SIDE_MODIFIER_UNSPECIFIED"
    SHORT = "SHORT"
    SHORT_EXEMPT = "SHORT_EXEMPT"
    SHORT_COVER = "SHORT_COVER"
    OPEN = "OPEN"
    CLOSE = "CLOSE"


class CompleteTradeResponseSpecialInstructions(str, Enum, metaclass=utils.OpenEnumMeta):
    SPECIAL_INSTRUCTIONS_UNSPECIFIED = "SPECIAL_INSTRUCTIONS_UNSPECIFIED"
    RULE_144 = "RULE_144"
    WITH_DIVIDEND = "WITH_DIVIDEND"
    WITH_RIGHTS = "WITH_RIGHTS"
    CLOSE_CONTRACT = "CLOSE_CONTRACT"
    COVER_SHORT = "COVER_SHORT"
    CROSS_TRADE = "CROSS_TRADE"
    OPEN_CONTRACT_COVERED = "OPEN_CONTRACT_COVERED"
    DISCRETION_EXERCISED = "DISCRETION_EXERCISED"
    DISCRETION_NOT_EXERCISED = "DISCRETION_NOT_EXERCISED"
    OPTION_ASSIGNMENT = "OPTION_ASSIGNMENT"
    EMPLOYEE_STOCK_OPTION = "EMPLOYEE_STOCK_OPTION"
    INVESTMENT_BANKING = "INVESTMENT_BANKING"
    BROKER_DEALER_ORDER = "BROKER_DEALER_ORDER"
    MAKE_MARKET_IN_SECURITY = "MAKE_MARKET_IN_SECURITY"
    MAKE_MARKET_SOLICITED = "MAKE_MARKET_SOLICITED"
    MAKE_MARKET_UNSOLICITED = "MAKE_MARKET_UNSOLICITED"
    CUSTOMER_DIRECTED = "CUSTOMER_DIRECTED"
    FULLY_REGISTERED = "FULLY_REGISTERED"
    OPEN_CONTRACT = "OPEN_CONTRACT"
    ODDLOT_DIFF_ON_REQUEST = "ODDLOT_DIFF_ON_REQUEST"
    PROSPECTUS_ENCLOSED = "PROSPECTUS_ENCLOSED"
    PROSPECTUS_SEPARATE_MAIL = "PROSPECTUS_SEPARATE_MAIL"
    SOLICITED = "SOLICITED"
    UNSOLICITED = "UNSOLICITED"
    X_DIVIDEND = "X_DIVIDEND"
    ACTING_AS_PRINCIPAL = "ACTING_AS_PRINCIPAL"
    AVERAGE_PRICE = "AVERAGE_PRICE"
    BROKER_LIQUIDATION = "BROKER_LIQUIDATION"
    COUPON_BOOKS = "COUPON_BOOKS"
    HAS_POSTAGE_FEE = "HAS_POSTAGE_FEE"
    INTERNET_ORDER = "INTERNET_ORDER"
    MARGIN_SELLOUT = "MARGIN_SELLOUT"
    MARKET_MAKERS_AS_PRINCIPAL = "MARKET_MAKERS_AS_PRINCIPAL"
    NEGATIVE_NET_PROCEED = "NEGATIVE_NET_PROCEED"
    PRE_FIG_INDICATOR = "PRE_FIG_INDICATOR"
    RISKLESS_PRINCIPAL_INSTRUCTION = "RISKLESS_PRINCIPAL_INSTRUCTION"
    SHORT_INSTRUCTION = "SHORT_INSTRUCTION"
    THIRD_MARKET = "THIRD_MARKET"
    SUPPRESS_MSRB_TRANSMISSION = "SUPPRESS_MSRB_TRANSMISSION"
    SUPPRESS_TRACE_REPORTING = "SUPPRESS_TRACE_REPORTING"
    SUPPRESS_EMAIL_NOTIFICATION = "SUPPRESS_EMAIL_NOTIFICATION"
    STOCK_REWARD = "STOCK_REWARD"
    SUPPRESS_REG_FEES = "SUPPRESS_REG_FEES"
    SUPPRESS_SEC_FEE = "SUPPRESS_SEC_FEE"
    SUPPRESS_TAF_FEE = "SUPPRESS_TAF_FEE"
    DIVIDEND_REINVESTMENT = "DIVIDEND_REINVESTMENT"


class CompleteTradeResponseVenue(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Exchange venue"""

    EXCHANGE_VENUE_UNSPECIFIED = "EXCHANGE_VENUE_UNSPECIFIED"
    AMEX = "AMEX"
    ARCA = "ARCA"
    BATS = "BATS"
    BATS_BYX = "BATS_BYX"
    BOSTON = "BOSTON"
    BOX = "BOX"
    BZX = "BZX"
    C2 = "C2"
    CBOE = "CBOE"
    CHICAGO = "CHICAGO"
    CINCINNATI = "CINCINNATI"
    EDGA = "EDGA"
    EDGX = "EDGX"
    EXCLEARING = "EXCLEARING"
    IEX = "IEX"
    ISE = "ISE"
    ISE_GEMINI = "ISE_GEMINI"
    MIAX = "MIAX"
    NASDAQ = "NASDAQ"
    NASDAQ_OMX_BX = "NASDAQ_OMX_BX"
    NYSE = "NYSE"
    PHLX = "PHLX"
    OTC = "OTC"
    QSR = "QSR"


class CompleteTradeResponseWhenIssued(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Denotes that this trade was either when_issued or when_distributed."""

    WHEN_ISSUED_TYPE_UNSPECIFIED = "WHEN_ISSUED_TYPE_UNSPECIFIED"
    WHEN_ISSUED = "WHEN_ISSUED"
    WHEN_DISTRIBUTED = "WHEN_DISTRIBUTED"


class TradeTypedDict(TypedDict):
    r"""The completed trade."""

    account_id: NotRequired[str]
    r"""A globally unique identifier referencing a single account."""
    activity_id: NotRequired[str]
    r"""The current activity_id of this trade in the Ledger."""
    additional_instructions: NotRequired[str]
    r"""Free form instructions that can be used to provide additional instructions (that are not captured by existing special instructions) and will be put on the trade confirm."""
    alternate_order_id: NotRequired[str]
    r"""Fractional support for market-makers' internal order ids."""
    asset_type: NotRequired[CompleteTradeResponseAssetType]
    r"""Type of the asset being traded."""
    broker_capacity: NotRequired[CompleteTradeResponseBrokerCapacity]
    r"""Broker capacity for the trade."""
    client_order_id: NotRequired[str]
    r"""The unique identifier that is associated with an order. Must be unique by date per trade per client."""
    executing_broker: NotRequired[str]
    r"""Executing broker of the trade."""
    executions: NotRequired[List[ExecutionTypedDict]]
    r"""The executions (sometimes referred to as partial-fills) that comprise the trade."""
    fees: NotRequired[List[BookingFeeTypedDict]]
    r"""Any client calculated fees associated with the trade. Only allowed if trade.open = false. Regulatory fees will be calculated automatically if they are not explicitly overwritten or suppressed."""
    identifier: NotRequired[str]
    r"""Identifier (of the type specified in `identifier_type`). Responses will supply the originally requested identifier."""
    identifier_type: NotRequired[CompleteTradeResponseIdentifierType]
    r"""Identifier type for the asset being traded."""
    issuing_region_code: NotRequired[str]
    r"""Unicode CLDR region code. Issuing Region Code is required for some `identifier_type`s, especially CUSIP."""
    local_market_trade_date: NotRequired[
        Nullable[CompleteTradeResponseLocalMarketTradeDateTypedDict]
    ]
    r"""Date field to support extended trading hours."""
    lot_matching_instructions: NotRequired[List[BookingLotTypedDict]]
    r"""One or many lot matching instructions for the trade."""
    mic_code: NotRequired[str]
    r"""Market Identifier Code"""
    name: NotRequired[str]
    r"""The resource name of the trade."""
    open: NotRequired[bool]
    r"""State of this trade's completeness in filling. True: trade is not done filling and can append more executions onto the trade False: trade is done filling and cannot append more executions onto the trade By default, trades are closed when they are created. An open trade can later be closed by calling the CompleteTrade endpoint. Additional executions can be appended to an open trade by calling the CreateExecution endpoint. Trades that are left open will be automatically closed nightly before Ledger's EOD."""
    order_id: NotRequired[str]
    r"""Street-level order id, unique by day per broker."""
    route_type: NotRequired[CompleteTradeResponseRouteType]
    r"""Route type for the trade."""
    settlement_date: NotRequired[Nullable[CompleteTradeResponseSettlementDateTypedDict]]
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""
    side: NotRequired[CompleteTradeResponseSide]
    r"""Denotes if the trade is a SELL or a BUY."""
    side_modifier: NotRequired[CompleteTradeResponseSideModifier]
    r"""Side modifier for the trade."""
    source_application: NotRequired[str]
    r"""The source of the submission."""
    special_instructions: NotRequired[List[CompleteTradeResponseSpecialInstructions]]
    r"""An enumerated list of values used to indicate certain attributes about a trade (E.g. DISCRETION_EXERCISED, BROKER_LIQUIDATION) and/or trigger downstream processing rules (e.g. SUPPRESS_TRACE_REPORTING)"""
    trade_id: NotRequired[str]
    r"""A ULID to uniquely identify the trade globally."""
    venue: NotRequired[CompleteTradeResponseVenue]
    r"""Exchange venue"""
    when_issued: NotRequired[CompleteTradeResponseWhenIssued]
    r"""Denotes that this trade was either when_issued or when_distributed."""


class Trade(BaseModel):
    r"""The completed trade."""

    account_id: Optional[str] = None
    r"""A globally unique identifier referencing a single account."""

    activity_id: Optional[str] = None
    r"""The current activity_id of this trade in the Ledger."""

    additional_instructions: Optional[str] = None
    r"""Free form instructions that can be used to provide additional instructions (that are not captured by existing special instructions) and will be put on the trade confirm."""

    alternate_order_id: Optional[str] = None
    r"""Fractional support for market-makers' internal order ids."""

    asset_type: Annotated[
        Optional[CompleteTradeResponseAssetType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Type of the asset being traded."""

    broker_capacity: Annotated[
        Optional[CompleteTradeResponseBrokerCapacity],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Broker capacity for the trade."""

    client_order_id: Optional[str] = None
    r"""The unique identifier that is associated with an order. Must be unique by date per trade per client."""

    executing_broker: Optional[str] = None
    r"""Executing broker of the trade."""

    executions: Optional[List[Execution]] = None
    r"""The executions (sometimes referred to as partial-fills) that comprise the trade."""

    fees: Optional[List[BookingFee]] = None
    r"""Any client calculated fees associated with the trade. Only allowed if trade.open = false. Regulatory fees will be calculated automatically if they are not explicitly overwritten or suppressed."""

    identifier: Optional[str] = None
    r"""Identifier (of the type specified in `identifier_type`). Responses will supply the originally requested identifier."""

    identifier_type: Annotated[
        Optional[CompleteTradeResponseIdentifierType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Identifier type for the asset being traded."""

    issuing_region_code: Optional[str] = None
    r"""Unicode CLDR region code. Issuing Region Code is required for some `identifier_type`s, especially CUSIP."""

    local_market_trade_date: OptionalNullable[
        CompleteTradeResponseLocalMarketTradeDate
    ] = UNSET
    r"""Date field to support extended trading hours."""

    lot_matching_instructions: Optional[List[BookingLot]] = None
    r"""One or many lot matching instructions for the trade."""

    mic_code: Optional[str] = None
    r"""Market Identifier Code"""

    name: Optional[str] = None
    r"""The resource name of the trade."""

    open: Optional[bool] = None
    r"""State of this trade's completeness in filling. True: trade is not done filling and can append more executions onto the trade False: trade is done filling and cannot append more executions onto the trade By default, trades are closed when they are created. An open trade can later be closed by calling the CompleteTrade endpoint. Additional executions can be appended to an open trade by calling the CreateExecution endpoint. Trades that are left open will be automatically closed nightly before Ledger's EOD."""

    order_id: Optional[str] = None
    r"""Street-level order id, unique by day per broker."""

    route_type: Annotated[
        Optional[CompleteTradeResponseRouteType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Route type for the trade."""

    settlement_date: OptionalNullable[CompleteTradeResponseSettlementDate] = UNSET
    r"""Defaults to T+1 for equities if this is not provided. Calculated by the execution's execution_time field in Eastern Time."""

    side: Annotated[
        Optional[CompleteTradeResponseSide], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Denotes if the trade is a SELL or a BUY."""

    side_modifier: Annotated[
        Optional[CompleteTradeResponseSideModifier],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Side modifier for the trade."""

    source_application: Optional[str] = None
    r"""The source of the submission."""

    special_instructions: Optional[
        List[
            Annotated[
                CompleteTradeResponseSpecialInstructions,
                PlainValidator(validate_open_enum(False)),
            ]
        ]
    ] = None
    r"""An enumerated list of values used to indicate certain attributes about a trade (E.g. DISCRETION_EXERCISED, BROKER_LIQUIDATION) and/or trigger downstream processing rules (e.g. SUPPRESS_TRACE_REPORTING)"""

    trade_id: Optional[str] = None
    r"""A ULID to uniquely identify the trade globally."""

    venue: Annotated[
        Optional[CompleteTradeResponseVenue], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Exchange venue"""

    when_issued: Annotated[
        Optional[CompleteTradeResponseWhenIssued],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Denotes that this trade was either when_issued or when_distributed."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "account_id",
            "activity_id",
            "additional_instructions",
            "alternate_order_id",
            "asset_type",
            "broker_capacity",
            "client_order_id",
            "executing_broker",
            "executions",
            "fees",
            "identifier",
            "identifier_type",
            "issuing_region_code",
            "local_market_trade_date",
            "lot_matching_instructions",
            "mic_code",
            "name",
            "open",
            "order_id",
            "route_type",
            "settlement_date",
            "side",
            "side_modifier",
            "source_application",
            "special_instructions",
            "trade_id",
            "venue",
            "when_issued",
        ]
        nullable_fields = ["local_market_trade_date", "settlement_date"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                k not in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CompleteTradeResponseTypedDict(TypedDict):
    r"""A response to the complete trade method."""

    trade: NotRequired[Nullable[TradeTypedDict]]
    r"""The completed trade."""


class CompleteTradeResponse(BaseModel):
    r"""A response to the complete trade method."""

    trade: OptionalNullable[Trade] = UNSET
    r"""The completed trade."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["trade"]
        nullable_fields = ["trade"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                k not in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
