"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .bondyield import BondYield, BondYieldTypedDict
from .bookingfee import BookingFee, BookingFeeTypedDict
from .bookinglot import BookingLot, BookingLotTypedDict
from ascend_sdk import utils
from ascend_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from ascend_sdk.utils import validate_open_enum
from datetime import datetime
from enum import Enum
from pydantic import model_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class TradeAllocationAccruedInterestAmountTypedDict(TypedDict):
    r"""The amount of interest that has been accrued in the issuing currency for a single instrument."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationAccruedInterestAmount(BaseModel):
    r"""The amount of interest that has been accrued in the issuing currency for a single instrument."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationAssetType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Type of the asset being traded."""

    ASSET_TYPE_UNSPECIFIED = "ASSET_TYPE_UNSPECIFIED"
    EQUITY = "EQUITY"
    FIXED_INCOME = "FIXED_INCOME"


class TradeAllocationBrokerCapacity(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Broker capacity for the trade."""

    CAPACITY_UNSPECIFIED = "CAPACITY_UNSPECIFIED"
    AGENCY = "AGENCY"
    PRINCIPAL = "PRINCIPAL"
    MIXED = "MIXED"


class TradeAllocationCommissionAmountTypedDict(TypedDict):
    r"""Commission amount of the trade allocation that will only be applied to the to_account_id."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationCommissionAmount(BaseModel):
    r"""Commission amount of the trade allocation that will only be applied to the to_account_id."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationGrossAmountTypedDict(TypedDict):
    r"""Gross amount is calculated by the Booking service by multiplying price and quantity and fixing it to 2 fractional precision. Optionally specifiable. If present, will override the gross_amount calculated above."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationGrossAmount(BaseModel):
    r"""Gross amount is calculated by the Booking service by multiplying price and quantity and fixing it to 2 fractional precision. Optionally specifiable. If present, will override the gross_amount calculated above."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationIdentifierType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Identifier type for the asset being traded."""

    IDENTIFIER_TYPE_UNSPECIFIED = "IDENTIFIER_TYPE_UNSPECIFIED"
    ASSET_ID = "ASSET_ID"
    SYMBOL = "SYMBOL"
    CUSIP = "CUSIP"
    ISIN = "ISIN"


class TradeAllocationPrevailingMarketPriceTypedDict(TypedDict):
    r"""The price for the instrument that is prevailing in the market. Required for FIXED_INCOME trade allocations when the broker_capacity is PRINCIPAL."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationPrevailingMarketPrice(BaseModel):
    r"""The price for the instrument that is prevailing in the market. Required for FIXED_INCOME trade allocations when the broker_capacity is PRINCIPAL."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationPriceTypedDict(TypedDict):
    r"""Price with requirement of 8 or less integral number and 8 or less fractional precision."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationPrice(BaseModel):
    r"""Price with requirement of 8 or less integral number and 8 or less fractional precision."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationPriceAdjustmentAmountTypedDict(TypedDict):
    r"""Total monetary value of the price_adjustment"""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationPriceAdjustmentAmount(BaseModel):
    r"""Total monetary value of the price_adjustment"""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationPriceAdjustmentType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of price adjustment being applied by the broker to the net price of the security."""

    PRICE_ADJUSTMENT_TYPE_UNSPECIFIED = "PRICE_ADJUSTMENT_TYPE_UNSPECIFIED"
    MARKUP = "MARKUP"
    MARKDOWN = "MARKDOWN"
    GROSS_CREDIT = "GROSS_CREDIT"


class TradeAllocationPriceAdjustmentTypedDict(TypedDict):
    r"""Price adjustment that will be applied to the net price of the security."""

    price_adjustment_amount: NotRequired[
        Nullable[TradeAllocationPriceAdjustmentAmountTypedDict]
    ]
    r"""Total monetary value of the price_adjustment"""
    price_adjustment_type: NotRequired[TradeAllocationPriceAdjustmentType]
    r"""The type of price adjustment being applied by the broker to the net price of the security."""


class TradeAllocationPriceAdjustment(BaseModel):
    r"""Price adjustment that will be applied to the net price of the security."""

    price_adjustment_amount: OptionalNullable[TradeAllocationPriceAdjustmentAmount] = (
        UNSET
    )
    r"""Total monetary value of the price_adjustment"""

    price_adjustment_type: Annotated[
        Optional[TradeAllocationPriceAdjustmentType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""The type of price adjustment being applied by the broker to the net price of the security."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["price_adjustment_amount", "price_adjustment_type"]
        nullable_fields = ["price_adjustment_amount"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                k not in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TradeAllocationQuantityTypedDict(TypedDict):
    r"""Quantity with requirement of 12 or less integral number and 5 or less fractional precision."""

    value: NotRequired[str]
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationQuantity(BaseModel):
    r"""Quantity with requirement of 12 or less integral number and 5 or less fractional precision."""

    value: Optional[str] = None
    r"""The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details"""


class TradeAllocationSettlementDateTypedDict(TypedDict):
    r"""Defaults to T+1 for equities if this is not provided. Calculated using the execution_time field in Eastern Time."""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class TradeAllocationSettlementDate(BaseModel):
    r"""Defaults to T+1 for equities if this is not provided. Calculated using the execution_time field in Eastern Time."""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class TradeAllocationSideModifier(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Side modifier for the trade allocation."""

    SIDE_MODIFIER_UNSPECIFIED = "SIDE_MODIFIER_UNSPECIFIED"
    SHORT = "SHORT"
    SHORT_EXEMPT = "SHORT_EXEMPT"
    SHORT_COVER = "SHORT_COVER"
    OPEN = "OPEN"
    CLOSE = "CLOSE"


class TradeAllocationSpecialInstructions(str, Enum, metaclass=utils.OpenEnumMeta):
    SPECIAL_INSTRUCTIONS_UNSPECIFIED = "SPECIAL_INSTRUCTIONS_UNSPECIFIED"
    RULE_144 = "RULE_144"
    WITH_DIVIDEND = "WITH_DIVIDEND"
    WITH_RIGHTS = "WITH_RIGHTS"
    CLOSE_CONTRACT = "CLOSE_CONTRACT"
    COVER_SHORT = "COVER_SHORT"
    CROSS_TRADE = "CROSS_TRADE"
    OPEN_CONTRACT_COVERED = "OPEN_CONTRACT_COVERED"
    DISCRETION_EXERCISED = "DISCRETION_EXERCISED"
    DISCRETION_NOT_EXERCISED = "DISCRETION_NOT_EXERCISED"
    OPTION_ASSIGNMENT = "OPTION_ASSIGNMENT"
    EMPLOYEE_STOCK_OPTION = "EMPLOYEE_STOCK_OPTION"
    INVESTMENT_BANKING = "INVESTMENT_BANKING"
    BROKER_DEALER_ORDER = "BROKER_DEALER_ORDER"
    MAKE_MARKET_IN_SECURITY = "MAKE_MARKET_IN_SECURITY"
    MAKE_MARKET_SOLICITED = "MAKE_MARKET_SOLICITED"
    MAKE_MARKET_UNSOLICITED = "MAKE_MARKET_UNSOLICITED"
    CUSTOMER_DIRECTED = "CUSTOMER_DIRECTED"
    FULLY_REGISTERED = "FULLY_REGISTERED"
    OPEN_CONTRACT = "OPEN_CONTRACT"
    ODDLOT_DIFF_ON_REQUEST = "ODDLOT_DIFF_ON_REQUEST"
    PROSPECTUS_ENCLOSED = "PROSPECTUS_ENCLOSED"
    PROSPECTUS_SEPARATE_MAIL = "PROSPECTUS_SEPARATE_MAIL"
    SOLICITED = "SOLICITED"
    UNSOLICITED = "UNSOLICITED"
    X_DIVIDEND = "X_DIVIDEND"
    ACTING_AS_PRINCIPAL = "ACTING_AS_PRINCIPAL"
    AVERAGE_PRICE = "AVERAGE_PRICE"
    BROKER_LIQUIDATION = "BROKER_LIQUIDATION"
    COUPON_BOOKS = "COUPON_BOOKS"
    HAS_POSTAGE_FEE = "HAS_POSTAGE_FEE"
    INTERNET_ORDER = "INTERNET_ORDER"
    MARGIN_SELLOUT = "MARGIN_SELLOUT"
    MARKET_MAKERS_AS_PRINCIPAL = "MARKET_MAKERS_AS_PRINCIPAL"
    NEGATIVE_NET_PROCEED = "NEGATIVE_NET_PROCEED"
    PRE_FIG_INDICATOR = "PRE_FIG_INDICATOR"
    RISKLESS_PRINCIPAL_INSTRUCTION = "RISKLESS_PRINCIPAL_INSTRUCTION"
    SHORT_INSTRUCTION = "SHORT_INSTRUCTION"
    THIRD_MARKET = "THIRD_MARKET"
    SUPPRESS_MSRB_TRANSMISSION = "SUPPRESS_MSRB_TRANSMISSION"
    SUPPRESS_TRACE_REPORTING = "SUPPRESS_TRACE_REPORTING"
    SUPPRESS_EMAIL_NOTIFICATION = "SUPPRESS_EMAIL_NOTIFICATION"
    STOCK_REWARD = "STOCK_REWARD"
    SUPPRESS_REG_FEES = "SUPPRESS_REG_FEES"
    SUPPRESS_SEC_FEE = "SUPPRESS_SEC_FEE"
    SUPPRESS_TAF_FEE = "SUPPRESS_TAF_FEE"
    DIVIDEND_REINVESTMENT = "DIVIDEND_REINVESTMENT"


class TradeAllocationState(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The state that the trade allocation is in."""

    STATE_UNSPECIFIED = "STATE_UNSPECIFIED"
    CREATING = "CREATING"
    REBOOKING = "REBOOKING"
    CANCELING = "CANCELING"
    BOOKED = "BOOKED"
    REBOOKED = "REBOOKED"
    CANCELED = "CANCELED"
    FAILED = "FAILED"


class TradeAllocationToSide(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Denotes the side of the position going into the to_account_id. A to_side of SELL indicates the position will be allocated with a BUY out of the from_account, and a SELL into the to_account."""

    SIDE_UNSPECIFIED = "SIDE_UNSPECIFIED"
    BUY = "BUY"
    SELL = "SELL"


class TradeAllocationWhenIssued(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Denotes that this trade allocation was either when_issued or when_distributed."""

    WHEN_ISSUED_TYPE_UNSPECIFIED = "WHEN_ISSUED_TYPE_UNSPECIFIED"
    WHEN_ISSUED = "WHEN_ISSUED"
    WHEN_DISTRIBUTED = "WHEN_DISTRIBUTED"


class TradeAllocationTypedDict(TypedDict):
    r"""A TradeAllocation represents the movement of positions between two ascend accounts."""

    accrued_interest_amount: NotRequired[
        Nullable[TradeAllocationAccruedInterestAmountTypedDict]
    ]
    r"""The amount of interest that has been accrued in the issuing currency for a single instrument."""
    additional_instructions: NotRequired[str]
    r"""Free form instructions that can be used to provide additional instructions (that are not captured by existing special instructions) and will be put on the trade confirm."""
    asset_type: NotRequired[TradeAllocationAssetType]
    r"""Type of the asset being traded."""
    bond_yield: NotRequired[List[BondYieldTypedDict]]
    r"""The yield associated with an individual fill of a fixed income trade. Required for FIXED_INCOME trades. Not allowed for trades of other instrument types."""
    broker_capacity: NotRequired[TradeAllocationBrokerCapacity]
    r"""Broker capacity for the trade."""
    client_order_id: NotRequired[str]
    r"""The unique identifier that is associated with an order. This is useful for associating the trade allocation with the original trade. This will be assigned a unique UUID if not provided."""
    commission_amount: NotRequired[Nullable[TradeAllocationCommissionAmountTypedDict]]
    r"""Commission amount of the trade allocation that will only be applied to the to_account_id."""
    execution_time: NotRequired[Nullable[datetime]]
    r"""Timestamp of when the trade allocation took place. If settlement_date is not provided, this field will be converted into Eastern Time and used to calculate settlement_date."""
    fees: NotRequired[List[BookingFeeTypedDict]]
    r"""Client calculated fees that will only be applied to the to_account_id. Regulatory fees will be calculated automatically if they are not explicitly overwritten or suppressed."""
    from_account_id: NotRequired[str]
    r"""The ULID formatted account_id that the positions will be moved from."""
    from_activity_id: NotRequired[str]
    r"""The current activity_id of the trade allocation that positions will be moved from in the Ledger."""
    gross_amount: NotRequired[Nullable[TradeAllocationGrossAmountTypedDict]]
    r"""Gross amount is calculated by the Booking service by multiplying price and quantity and fixing it to 2 fractional precision. Optionally specifiable. If present, will override the gross_amount calculated above."""
    identifier: NotRequired[str]
    r"""Identifier (of the type specified in `identifier_type`). Responses will supply the originally requested identifier."""
    identifier_type: NotRequired[TradeAllocationIdentifierType]
    r"""Identifier type for the asset being traded."""
    issuing_region_code: NotRequired[str]
    r"""Unicode CLDR region code. Issuing Region Code is required for some `identifier_type`s, especially CUSIP."""
    lot_matching_instructions: NotRequired[List[BookingLotTypedDict]]
    r"""One or many lot matching instructions for the trade allocation."""
    memo: NotRequired[str]
    r"""Caller provided but can be used for booking-service to note original trade details when booking into the error account or using the error asset."""
    name: NotRequired[str]
    r"""The resource name of the trade allocation."""
    prevailing_market_price: NotRequired[
        Nullable[TradeAllocationPrevailingMarketPriceTypedDict]
    ]
    r"""The price for the instrument that is prevailing in the market. Required for FIXED_INCOME trade allocations when the broker_capacity is PRINCIPAL."""
    price: NotRequired[Nullable[TradeAllocationPriceTypedDict]]
    r"""Price with requirement of 8 or less integral number and 8 or less fractional precision."""
    price_adjustment: NotRequired[Nullable[TradeAllocationPriceAdjustmentTypedDict]]
    r"""Price adjustment that will be applied to the net price of the security."""
    quantity: NotRequired[Nullable[TradeAllocationQuantityTypedDict]]
    r"""Quantity with requirement of 12 or less integral number and 5 or less fractional precision."""
    settlement_date: NotRequired[Nullable[TradeAllocationSettlementDateTypedDict]]
    r"""Defaults to T+1 for equities if this is not provided. Calculated using the execution_time field in Eastern Time."""
    side_modifier: NotRequired[TradeAllocationSideModifier]
    r"""Side modifier for the trade allocation."""
    source_application: NotRequired[str]
    r"""The source of the submission."""
    special_instructions: NotRequired[List[TradeAllocationSpecialInstructions]]
    r"""An enumerated list of values used to indicate certain attributes about a trade allocation (E.g. BROKER_LIQUIDATION) and/or trigger downstream processing rules (e.g. SUPPRESS_TRACE_REPORTING)"""
    state: NotRequired[TradeAllocationState]
    r"""The state that the trade allocation is in."""
    to_account_id: NotRequired[str]
    r"""The ULID formatted account_id that the positions will be moved to."""
    to_activity_id: NotRequired[str]
    r"""The current activity_id of the trade allocation that positions will be moved to in the Ledger."""
    to_side: NotRequired[TradeAllocationToSide]
    r"""Denotes the side of the position going into the to_account_id. A to_side of SELL indicates the position will be allocated with a BUY out of the from_account, and a SELL into the to_account."""
    trade_allocation_id: NotRequired[str]
    r"""A ULID to uniquely identify the trade allocation globally."""
    when_issued: NotRequired[TradeAllocationWhenIssued]
    r"""Denotes that this trade allocation was either when_issued or when_distributed."""


class TradeAllocation(BaseModel):
    r"""A TradeAllocation represents the movement of positions between two ascend accounts."""

    accrued_interest_amount: OptionalNullable[TradeAllocationAccruedInterestAmount] = (
        UNSET
    )
    r"""The amount of interest that has been accrued in the issuing currency for a single instrument."""

    additional_instructions: Optional[str] = None
    r"""Free form instructions that can be used to provide additional instructions (that are not captured by existing special instructions) and will be put on the trade confirm."""

    asset_type: Annotated[
        Optional[TradeAllocationAssetType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Type of the asset being traded."""

    bond_yield: Optional[List[BondYield]] = None
    r"""The yield associated with an individual fill of a fixed income trade. Required for FIXED_INCOME trades. Not allowed for trades of other instrument types."""

    broker_capacity: Annotated[
        Optional[TradeAllocationBrokerCapacity],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Broker capacity for the trade."""

    client_order_id: Optional[str] = None
    r"""The unique identifier that is associated with an order. This is useful for associating the trade allocation with the original trade. This will be assigned a unique UUID if not provided."""

    commission_amount: OptionalNullable[TradeAllocationCommissionAmount] = UNSET
    r"""Commission amount of the trade allocation that will only be applied to the to_account_id."""

    execution_time: OptionalNullable[datetime] = UNSET
    r"""Timestamp of when the trade allocation took place. If settlement_date is not provided, this field will be converted into Eastern Time and used to calculate settlement_date."""

    fees: Optional[List[BookingFee]] = None
    r"""Client calculated fees that will only be applied to the to_account_id. Regulatory fees will be calculated automatically if they are not explicitly overwritten or suppressed."""

    from_account_id: Optional[str] = None
    r"""The ULID formatted account_id that the positions will be moved from."""

    from_activity_id: Optional[str] = None
    r"""The current activity_id of the trade allocation that positions will be moved from in the Ledger."""

    gross_amount: OptionalNullable[TradeAllocationGrossAmount] = UNSET
    r"""Gross amount is calculated by the Booking service by multiplying price and quantity and fixing it to 2 fractional precision. Optionally specifiable. If present, will override the gross_amount calculated above."""

    identifier: Optional[str] = None
    r"""Identifier (of the type specified in `identifier_type`). Responses will supply the originally requested identifier."""

    identifier_type: Annotated[
        Optional[TradeAllocationIdentifierType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Identifier type for the asset being traded."""

    issuing_region_code: Optional[str] = None
    r"""Unicode CLDR region code. Issuing Region Code is required for some `identifier_type`s, especially CUSIP."""

    lot_matching_instructions: Optional[List[BookingLot]] = None
    r"""One or many lot matching instructions for the trade allocation."""

    memo: Optional[str] = None
    r"""Caller provided but can be used for booking-service to note original trade details when booking into the error account or using the error asset."""

    name: Optional[str] = None
    r"""The resource name of the trade allocation."""

    prevailing_market_price: OptionalNullable[TradeAllocationPrevailingMarketPrice] = (
        UNSET
    )
    r"""The price for the instrument that is prevailing in the market. Required for FIXED_INCOME trade allocations when the broker_capacity is PRINCIPAL."""

    price: OptionalNullable[TradeAllocationPrice] = UNSET
    r"""Price with requirement of 8 or less integral number and 8 or less fractional precision."""

    price_adjustment: OptionalNullable[TradeAllocationPriceAdjustment] = UNSET
    r"""Price adjustment that will be applied to the net price of the security."""

    quantity: OptionalNullable[TradeAllocationQuantity] = UNSET
    r"""Quantity with requirement of 12 or less integral number and 5 or less fractional precision."""

    settlement_date: OptionalNullable[TradeAllocationSettlementDate] = UNSET
    r"""Defaults to T+1 for equities if this is not provided. Calculated using the execution_time field in Eastern Time."""

    side_modifier: Annotated[
        Optional[TradeAllocationSideModifier], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Side modifier for the trade allocation."""

    source_application: Optional[str] = None
    r"""The source of the submission."""

    special_instructions: Optional[
        List[
            Annotated[
                TradeAllocationSpecialInstructions,
                PlainValidator(validate_open_enum(False)),
            ]
        ]
    ] = None
    r"""An enumerated list of values used to indicate certain attributes about a trade allocation (E.g. BROKER_LIQUIDATION) and/or trigger downstream processing rules (e.g. SUPPRESS_TRACE_REPORTING)"""

    state: Annotated[
        Optional[TradeAllocationState], PlainValidator(validate_open_enum(False))
    ] = None
    r"""The state that the trade allocation is in."""

    to_account_id: Optional[str] = None
    r"""The ULID formatted account_id that the positions will be moved to."""

    to_activity_id: Optional[str] = None
    r"""The current activity_id of the trade allocation that positions will be moved to in the Ledger."""

    to_side: Annotated[
        Optional[TradeAllocationToSide], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Denotes the side of the position going into the to_account_id. A to_side of SELL indicates the position will be allocated with a BUY out of the from_account, and a SELL into the to_account."""

    trade_allocation_id: Optional[str] = None
    r"""A ULID to uniquely identify the trade allocation globally."""

    when_issued: Annotated[
        Optional[TradeAllocationWhenIssued], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Denotes that this trade allocation was either when_issued or when_distributed."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "accrued_interest_amount",
            "additional_instructions",
            "asset_type",
            "bond_yield",
            "broker_capacity",
            "client_order_id",
            "commission_amount",
            "execution_time",
            "fees",
            "from_account_id",
            "from_activity_id",
            "gross_amount",
            "identifier",
            "identifier_type",
            "issuing_region_code",
            "lot_matching_instructions",
            "memo",
            "name",
            "prevailing_market_price",
            "price",
            "price_adjustment",
            "quantity",
            "settlement_date",
            "side_modifier",
            "source_application",
            "special_instructions",
            "state",
            "to_account_id",
            "to_activity_id",
            "to_side",
            "trade_allocation_id",
            "when_issued",
        ]
        nullable_fields = [
            "accrued_interest_amount",
            "commission_amount",
            "execution_time",
            "gross_amount",
            "prevailing_market_price",
            "price",
            "price_adjustment",
            "quantity",
            "settlement_date",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                k not in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
