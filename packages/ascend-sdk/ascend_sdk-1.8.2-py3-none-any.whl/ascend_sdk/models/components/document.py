"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from ascend_sdk import utils
from ascend_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from ascend_sdk.utils import validate_open_enum
from enum import Enum
from pydantic import model_serializer
from pydantic.functional_validators import PlainValidator
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class DocumentDocumentType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Describes the contents of a document and how it is used"""

    ACCOUNT_DOCUMENT_TYPE_UNSPECIFIED = "ACCOUNT_DOCUMENT_TYPE_UNSPECIFIED"
    CERTIFICATE_OF_APPOINTMENT = "CERTIFICATE_OF_APPOINTMENT"
    FDIC_SWEEP_PROGRAM_AGREEMENT = "FDIC_SWEEP_PROGRAM_AGREEMENT"
    FPSL_MASTER_SERVICES_LOAN_AGREEMENT = "FPSL_MASTER_SERVICES_LOAN_AGREEMENT"
    TRANSFER_ON_DEATH_BENEFICIARY_DESIGNATION = (
        "TRANSFER_ON_DEATH_BENEFICIARY_DESIGNATION"
    )
    CHANGE_OF_ADDRESS = "CHANGE_OF_ADDRESS"
    NEW_ACCOUNT_FORM = "NEW_ACCOUNT_FORM"
    LETTER_3210 = "LETTER_3210"
    IRA_APPL_FORM = "IRA_APPL_FORM"
    RIA_IRA_APPL_FORM = "RIA_IRA_APPL_FORM"
    IRA_DEPOSIT_FORM = "IRA_DEPOSIT_FORM"
    RIA_IRA_DEPOSIT_FORM = "RIA_IRA_DEPOSIT_FORM"
    IRA_DIST_FORM = "IRA_DIST_FORM"
    RIA_IRA_DIST_FORM = "RIA_IRA_DIST_FORM"
    ROTH_APPL_FORM = "ROTH_APPL_FORM"
    RIA_ROTH_APPL_FORM = "RIA_ROTH_APPL_FORM"
    ROTH_DIST_FORM = "ROTH_DIST_FORM"
    RIA_ROTH_DIST_FORM = "RIA_ROTH_DIST_FORM"
    SIMPLE_CONT_TRANSM = "SIMPLE_CONT_TRANSM"
    ESA_APPL_FORM = "ESA_APPL_FORM"
    ESA_WTHDR_STATEMENT = "ESA_WTHDR_STATEMENT"
    DIR_CONV_FORM = "DIR_CONV_FORM"
    IRA_BENE_FORM = "IRA_BENE_FORM"
    IRA_JRNL_FORM = "IRA_JRNL_FORM"
    SEP_EMPL_PLAN_DOC = "SEP_EMPL_PLAN_DOC"
    SIMPLE_ADOPT_AGREEMENT = "SIMPLE_ADOPT_AGREEMENT"
    SIMPLE_APPL_FORM = "SIMPLE_APPL_FORM"
    DEATH_CERTIFICATION = "DEATH_CERTIFICATION"
    ACH_AGREEMENT = "ACH_AGREEMENT"
    APEX_SELECT_APPLICATION = "APEX_SELECT_APPLICATION"
    ASA_DIRECT_DEPOSIT = "ASA_DIRECT_DEPOSIT"
    BANKING_MISC = "BANKING_MISC"
    ACC_TRANSFER_FORM = "ACC_TRANSFER_FORM"
    ADDRESS_VERIFICATION_NOTICE = "ADDRESS_VERIFICATION_NOTICE"
    AFFIDAVIT_OF_DOMICILE = "AFFIDAVIT_OF_DOMICILE"
    APEX_SIMPLE_DIRECT_DEPOSIT = "APEX_SIMPLE_DIRECT_DEPOSIT"
    TRANSFER_FORM = "TRANSFER_FORM"
    JOURNAL_REQUEST_FORM = "JOURNAL_REQUEST_FORM"
    CHECK = "CHECK"
    CHECK_REQUEST_FORM = "CHECK_REQUEST_FORM"
    CORP_AGREEMENT_CASH = "CORP_AGREEMENT_CASH"
    CORP_RESOLUTION = "CORP_RESOLUTION"
    COURT_DOCUMENT = "COURT_DOCUMENT"
    COURT_ORDER = "COURT_ORDER"
    DEPOSIT_SECURITIES_REQUEST_FORM = "DEPOSIT_SECURITIES_REQUEST_FORM"
    DIGITAL_SIGNATURE = "DIGITAL_SIGNATURE"
    DIRECT_CONVERSION_REQUEST = "DIRECT_CONVERSION_REQUEST"
    DISTRIBUTION_FORM = "DISTRIBUTION_FORM"
    DOCUMENT_IRS = "DOCUMENT_IRS"
    DOMESTIC_WIRE = "DOMESTIC_WIRE"
    DWAC_REQUEST_FORM = "DWAC_REQUEST_FORM"
    DWRE = "DWRE"
    ENTITY_DUE_DILIGENCE_QUESTIONNAIRE = "ENTITY_DUE_DILIGENCE_QUESTIONNAIRE"
    ENTITY_UPDATE_FORM = "ENTITY_UPDATE_FORM"
    ESCHEAT_FORM = "ESCHEAT_FORM"
    ESCHEATMENT_DUE_DILIGENCE_LETTER = "ESCHEATMENT_DUE_DILIGENCE_LETTER"
    E_SIGNATURE = "E_SIGNATURE"
    FOREIGN_ACCOUNT_DUE_DILIGENCE_QUESTIONNAIRE = (
        "FOREIGN_ACCOUNT_DUE_DILIGENCE_QUESTIONNAIRE"
    )
    FOREIGN_BANK_CERTIFICATION_DISCLOSURE = "FOREIGN_BANK_CERTIFICATION_DISCLOSURE"
    FOREIGN_ENTITY_DECLARATION_FORM = "FOREIGN_ENTITY_DECLARATION_FORM"
    FOREIGN_FIN_INST_DUE_DILIGENCE_QUESTIONNAIRE = (
        "FOREIGN_FIN_INST_DUE_DILIGENCE_QUESTIONNAIRE"
    )
    FORM_144 = "FORM_144"
    FREE_DELIVERY_FORM = "FREE_DELIVERY_FORM"
    FULL_TRADING_AUTHORIZATION = "FULL_TRADING_AUTHORIZATION"
    INTERNATIONAL_WIRE_REQUEST_FORM = "INTERNATIONAL_WIRE_REQUEST_FORM"
    IRREVOCABLE_STOCK_BOND_POWER = "IRREVOCABLE_STOCK_BOND_POWER"
    JOINT_ACC_AGREEMENT_ENTIRETY = "JOINT_ACC_AGREEMENT_ENTIRETY"
    JOINT_ACC_AGREEMENT_RIGHTS_OF_SURVIVORSHIP = (
        "JOINT_ACC_AGREEMENT_RIGHTS_OF_SURVIVORSHIP"
    )
    JOINT_ACC_AGREEMENT_COMMUNITY_PROPERTY = "JOINT_ACC_AGREEMENT_COMMUNITY_PROPERTY"
    JOINT_ACC_AGREEMENT_TENANTS_IN_COMMON = "JOINT_ACC_AGREEMENT_TENANTS_IN_COMMON"
    JOINT_TEFRA_W8 = "JOINT_TEFRA_W8"
    LEGAL_OPINION = "LEGAL_OPINION"
    LETTER_OF_AUTHORITY = "LETTER_OF_AUTHORITY"
    LETTERS_OF_TESTAMENTARY_CERT_APPOINTMENT = (
        "LETTERS_OF_TESTAMENTARY_CERT_APPOINTMENT"
    )
    LIMITED_LIABILITY_COMPANY_AGREEMENT = "LIMITED_LIABILITY_COMPANY_AGREEMENT"
    LIMITED_PURPOSE_MARGIN = "LIMITED_PURPOSE_MARGIN"
    MAIL_AUTHORIZATION = "MAIL_AUTHORIZATION"
    MSLA = "MSLA"
    MISC_GENERAL = "MISC_GENERAL"
    NEW_ACCOUNT_APPLICATION_ENTITY = "NEW_ACCOUNT_APPLICATION_ENTITY"
    NON_CORPORATE_ASSOCIATION = "NON_CORPORATE_ASSOCIATION"
    PARTNERSHIP_AGREEMENT = "PARTNERSHIP_AGREEMENT"
    PATTERN_DAY_TRADER_FORM = "PATTERN_DAY_TRADER_FORM"
    POWER_OF_ATTORNEY_DURABLE = "POWER_OF_ATTORNEY_DURABLE"
    POWER_OF_ATTORNEY_GENERAL = "POWER_OF_ATTORNEY_GENERAL"
    REGISTERED_ADVISORY_AUTHORITY_FORM = "REGISTERED_ADVISORY_AUTHORITY_FORM"
    RMD = "RMD"
    RISK_DISCLOSURE = "RISK_DISCLOSURE"
    RULE_145_SELLERS_LETTER = "RULE_145_SELLERS_LETTER"
    RULE_701_LETTER = "RULE_701_LETTER"
    SAME_NAME_LOA = "SAME_NAME_LOA"
    SECURITIES_BASED_LENDING_AGREEMENT = "SECURITIES_BASED_LENDING_AGREEMENT"
    SEP_CONTRIBUTION_AGREEMENT = "SEP_CONTRIBUTION_AGREEMENT"
    SEP_EMPLOYER_PLAN_DOCUMENTATION = "SEP_EMPLOYER_PLAN_DOCUMENTATION"
    SIGNATURE_CARD = "SIGNATURE_CARD"
    SIMPLE_FORM_5304 = "SIMPLE_FORM_5304"
    SIMPLIFIED_EMPLOYEE_PENSION = "SIMPLIFIED_EMPLOYEE_PENSION"
    CERTIFICATE_SOLE_PROPRIETORSHIP = "CERTIFICATE_SOLE_PROPRIETORSHIP"
    TRANSFER_ON_DEATH = "TRANSFER_ON_DEATH"
    TRUST_AGREEMENT = "TRUST_AGREEMENT"
    TAX_W8_BEN = "TAX_W8_BEN"
    TAX_W8_BEN_JOINT_ACCOUNT_HOLDER = "TAX_W8_BEN_JOINT_ACCOUNT_HOLDER"
    TAX_W8_ECI = "TAX_W8_ECI"
    TAX_W8_EXP = "TAX_W8_EXP"
    TAX_W8_IMY = "TAX_W8_IMY"
    TAX_W9 = "TAX_W9"
    WILL_COPY = "WILL_COPY"
    WIRE_REQUEST_FORM = "WIRE_REQUEST_FORM"
    WORTHLESS_SECURITIES = "WORTHLESS_SECURITIES"
    CHANGE_OF_ADDRESS_REQUEST = "CHANGE_OF_ADDRESS_REQUEST"
    OPTIONS_AGREEMENT = "OPTIONS_AGREEMENT"
    STATE_WAIVER_FORM = "STATE_WAIVER_FORM"
    ALTS_SUBSCRIPTION_AGREEMENT = "ALTS_SUBSCRIPTION_AGREEMENT"


class UploadedDateTypedDict(TypedDict):
    r"""Date that the document was uploaded"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class UploadedDate(BaseModel):
    r"""Date that the document was uploaded"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class AccountDocumentTypedDict(TypedDict):
    r"""Fields specific to an account document"""

    account_id: NotRequired[str]
    r"""Identifies the account relevant to the document"""
    document_type: NotRequired[DocumentDocumentType]
    r"""Describes the contents of a document and how it is used"""
    uploaded_date: NotRequired[Nullable[UploadedDateTypedDict]]
    r"""Date that the document was uploaded"""


class AccountDocument(BaseModel):
    r"""Fields specific to an account document"""

    account_id: Optional[str] = None
    r"""Identifies the account relevant to the document"""

    document_type: Annotated[
        Optional[DocumentDocumentType], PlainValidator(validate_open_enum(False))
    ] = None
    r"""Describes the contents of a document and how it is used"""

    uploaded_date: OptionalNullable[UploadedDate] = UNSET
    r"""Date that the document was uploaded"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["account_id", "document_type", "uploaded_date"]
        nullable_fields = ["uploaded_date"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                k not in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentIDDocumentDocumentType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Describes the contents of a document and how it is used"""

    ID_DOCUMENT_TYPE_UNSPECIFIED = "ID_DOCUMENT_TYPE_UNSPECIFIED"
    BIRTH_CERTIFICATE = "BIRTH_CERTIFICATE"
    CUSTOMER_IDENTIFICATION_PROCESS = "CUSTOMER_IDENTIFICATION_PROCESS"
    DEATH_CERTIFICATE = "DEATH_CERTIFICATE"
    DRIVING_LICENSE = "DRIVING_LICENSE"
    EMPLOYER_CONSENT_FORM_407_LETTER = "EMPLOYER_CONSENT_FORM_407_LETTER"
    MARRIAGE_CERTIFICATE = "MARRIAGE_CERTIFICATE"
    PASSPORT = "PASSPORT"
    PROOF_OF_TAX_ID = "PROOF_OF_TAX_ID"
    SOCIAL_SECURITY_DOCUMENT = "SOCIAL_SECURITY_DOCUMENT"
    THIRD_PARTY_CIP_RESULTS = "THIRD_PARTY_CIP_RESULTS"
    STATE_ID_CARD = "STATE_ID_CARD"
    NATIONAL_ID_CARD = "NATIONAL_ID_CARD"
    PERMANENT_RESIDENT_VISA = "PERMANENT_RESIDENT_VISA"
    IRIS_ITIN_LETTER = "IRIS_ITIN_LETTER"
    UTILITY_BILL = "UTILITY_BILL"
    MILITARY_ID_CARD = "MILITARY_ID_CARD"
    MORTGAGE_STATEMENT = "MORTGAGE_STATEMENT"
    LEASE_AGREEMENT = "LEASE_AGREEMENT"
    EXECUTOR_CERTIFICATION = "EXECUTOR_CERTIFICATION"
    TRUSTEE_CERTIFICATION = "TRUSTEE_CERTIFICATION"
    SELFIE = "SELFIE"
    CERT_OF_SOLE_OFFICER = "CERT_OF_SOLE_OFFICER"
    CERTIFICATION_CORRESPONDENT_ACCOUNTS = "CERTIFICATION_CORRESPONDENT_ACCOUNTS"
    CERTIFICATION_FOREIGN_BANKS = "CERTIFICATION_FOREIGN_BANKS"
    CHARTER_ARTICLES_OF_INCORPORATION = "CHARTER_ARTICLES_OF_INCORPORATION"
    DIVORCE_DECREE = "DIVORCE_DECREE"
    PROOF_OF_RESIDENCE = "PROOF_OF_RESIDENCE"
    BO_REPORTING_EXEMPTION_PROOF = "BO_REPORTING_EXEMPTION_PROOF"
    OPERATING_AGREEMENT = "OPERATING_AGREEMENT"
    REGISTER_OF_MEMBERS = "REGISTER_OF_MEMBERS"
    BOARD_RESOLUTION = "BOARD_RESOLUTION"
    TRUST_DEEDS_AGREEMENT = "TRUST_DEEDS_AGREEMENT"
    CORPORATE_BYLAWS = "CORPORATE_BYLAWS"
    SHAREHOLDER_AGREEMENT = "SHAREHOLDER_AGREEMENT"
    CORPORATE_RECORDS = "CORPORATE_RECORDS"
    ARTICLES_OF_ORGANIZATION = "ARTICLES_OF_ORGANIZATION"


class DocumentUploadedDateTypedDict(TypedDict):
    r"""Date that the document was uploaded"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class DocumentUploadedDate(BaseModel):
    r"""Date that the document was uploaded"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class IDDocumentTypedDict(TypedDict):
    r"""Fields specific to an identity document"""

    document_type: NotRequired[DocumentIDDocumentDocumentType]
    r"""Describes the contents of a document and how it is used"""
    legal_natural_person_id: NotRequired[str]
    r"""Identifies the legal natural person relevant to the document"""
    uploaded_date: NotRequired[Nullable[DocumentUploadedDateTypedDict]]
    r"""Date that the document was uploaded"""


class IDDocument(BaseModel):
    r"""Fields specific to an identity document"""

    document_type: Annotated[
        Optional[DocumentIDDocumentDocumentType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Describes the contents of a document and how it is used"""

    legal_natural_person_id: Optional[str] = None
    r"""Identifies the legal natural person relevant to the document"""

    uploaded_date: OptionalNullable[DocumentUploadedDate] = UNSET
    r"""Date that the document was uploaded"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["document_type", "legal_natural_person_id", "uploaded_date"]
        nullable_fields = ["uploaded_date"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                k not in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentInvestorDocumentDocumentType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Describes the contents of a document and how it is used"""

    INVESTOR_DOCUMENT_TYPE_UNSPECIFIED = "INVESTOR_DOCUMENT_TYPE_UNSPECIFIED"
    CONFIRM_DAILY = "CONFIRM_DAILY"
    CONFIRM_MONTHLY = "CONFIRM_MONTHLY"
    FORM_CONSOLIDATED_1099 = "FORM_CONSOLIDATED_1099"
    FORM_1042_S = "FORM_1042_S"
    FORM_1099_Q = "FORM_1099_Q"
    FORM_1099_R = "FORM_1099_R"
    FORM_2439 = "FORM_2439"
    FORM_480_6_A = "FORM_480_6A"
    FORM_480_6_B = "FORM_480_6B"
    FORM_5498 = "FORM_5498"
    STATEMENT_MONTHLY = "STATEMENT_MONTHLY"
    STATEMENT_QUARTERLY = "STATEMENT_QUARTERLY"
    FORM_1099_C = "FORM_1099_C"
    FORM_480_6_D = "FORM_480_6D"
    FORM_5498_ESA = "FORM_5498_ESA"
    FPSL_NEGATIVE_CONSENT_FORM = "FPSL_NEGATIVE_CONSENT_FORM"
    CRS_FORM = "CRS_FORM"
    FPSL_CONFIRMATION = "FPSL_CONFIRMATION"


class DocumentProcessDateTypedDict(TypedDict):
    r"""Date that the related activities were processed"""

    day: NotRequired[int]
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""
    month: NotRequired[int]
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""
    year: NotRequired[int]
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class DocumentProcessDate(BaseModel):
    r"""Date that the related activities were processed"""

    day: Optional[int] = None
    r"""Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant."""

    month: Optional[int] = None
    r"""Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day."""

    year: Optional[int] = None
    r"""Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year."""


class InvestorDocumentTypedDict(TypedDict):
    r"""Fields specific to an investor document"""

    account_id: NotRequired[str]
    r"""Identifies the account relevant to the document"""
    document_type: NotRequired[DocumentInvestorDocumentDocumentType]
    r"""Describes the contents of a document and how it is used"""
    process_date: NotRequired[Nullable[DocumentProcessDateTypedDict]]
    r"""Date that the related activities were processed"""


class InvestorDocument(BaseModel):
    r"""Fields specific to an investor document"""

    account_id: Optional[str] = None
    r"""Identifies the account relevant to the document"""

    document_type: Annotated[
        Optional[DocumentInvestorDocumentDocumentType],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""Describes the contents of a document and how it is used"""

    process_date: OptionalNullable[DocumentProcessDate] = UNSET
    r"""Date that the related activities were processed"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["account_id", "document_type", "process_date"]
        nullable_fields = ["process_date"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                k not in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentTypedDict(TypedDict):
    r"""Describes a document that has been uploaded to Apex storage."""

    account_document: NotRequired[Nullable[AccountDocumentTypedDict]]
    r"""Fields specific to an account document"""
    correspondent_id: NotRequired[str]
    r"""Identifies the correspondent relevant to the document"""
    download_link: NotRequired[str]
    r"""Signed link used to download a document; The link expires one hour after being generated"""
    id_document: NotRequired[Nullable[IDDocumentTypedDict]]
    r"""Fields specific to an identity document"""
    investor_document: NotRequired[Nullable[InvestorDocumentTypedDict]]
    r"""Fields specific to an investor document"""
    name: NotRequired[str]
    r"""Identifier for the document"""


class Document(BaseModel):
    r"""Describes a document that has been uploaded to Apex storage."""

    account_document: OptionalNullable[AccountDocument] = UNSET
    r"""Fields specific to an account document"""

    correspondent_id: Optional[str] = None
    r"""Identifies the correspondent relevant to the document"""

    download_link: Optional[str] = None
    r"""Signed link used to download a document; The link expires one hour after being generated"""

    id_document: OptionalNullable[IDDocument] = UNSET
    r"""Fields specific to an identity document"""

    investor_document: OptionalNullable[InvestorDocument] = UNSET
    r"""Fields specific to an investor document"""

    name: Optional[str] = None
    r"""Identifier for the document"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "account_document",
            "correspondent_id",
            "download_link",
            "id_document",
            "investor_document",
            "name",
        ]
        nullable_fields = ["account_document", "id_document", "investor_document"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                k not in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
