{# Plan Mode Prompt Template - Sub-Query Decomposition Approach

   Variables:
   - current_phase: Current phase of plan mode ("generating", "executing", "confirming", etc.)
   - replan_feedback: User feedback for replanning (optional)
#}

{# Execution prompt - reused across different phases #}
{% set execution_prompt %}
IMPORTANT: After calling todo_write, immediately proceed to execute each sub-question step in sequence.

EXECUTION WORKFLOW for each pending step:

1. Start the step:
   - Call todo_update(todo_id, 'pending') to mark step as starting

2. Execute the sub-question to get actual data:
   - Follow all tool usage rules from the system instructions
   - Use available tools to explore schema and execute queries
   - Generate and run SQL query that answers this specific sub-question
   - Capture the actual query results (not just schema verification)

3. Complete the step:
   - ONLY call todo_update(todo_id, 'completed') after you have obtained actual query results
   - Document the results for aggregating in later steps

CRITICAL: Each step must produce REAL DATA RESULTS, not just schema verification.
DO NOT mark a step as completed until you have executed queries and captured real data.

DO NOT STOP after creating the plan. Continue with the first pending step immediately.
{% endset %}

{% if replan_feedback and current_phase == "generating" %}
{# REPLAN MODE: Generate revised plan based on user feedback #}

REPLAN MODE - QUERY DECOMPOSITION
Revise the current query decomposition plan based on USER FEEDBACK: {{ replan_feedback }}

STEPS:
1. FIRST: call todo_read to review the current plan, the completed and pending sub-queries
2. Analyze completed sub-queries:
   - Review their results
   - Identify what insights were gained
   - Determine which remaining sub-questions are still needed
3. Generate revised plan using todo_write following these rules:
   - COMPLETED sub-queries: keep items as 'completed' with their results
   - PENDING sub-queries that are no longer needed: DISCARD (don't include)
   - PENDING sub-queries that are still needed: keep as 'pending' or revise based on new insights
   - NEW sub-queries (if needed): add as 'pending'
4. Only include sub-queries that are actually needed to answer the user's question

{{ execution_prompt }}

{% elif current_phase == "generating" %}
{# INITIAL PLANNING PHASE: Generate query decomposition plan #}

PLAN MODE - QUERY DECOMPOSITION PHASE

Your task is to break down the user's question into **independent sub-questions**, where each sub-question can be answered with a separate SQL query.

DECOMPOSITION STRATEGY:
1. Analyze the user's question to identify:
   - What data entities/tables are involved?
   - What are the distinct analytical components? (e.g., filtering, aggregation, comparison, ranking)
   - What temporal/dimensional breakdowns are needed?
   - Are there dependencies between parts of the question?

2. Break down into sub-questions following these principles:
   - Each sub-question should address ONE specific aspect of the overall question
   - Each sub-question MUST be answerable by a SINGLE SQL query that returns actual data
   - Sub-questions should be as independent as possible (can be executed in parallel)
   - If dependencies exist, order them logically (prerequisite queries first)
   - Each sub-question MUST produce actual data results (not just schema exploration)
   - The combination of all sub-query results should answer the complete question
   - Number of sub-questions should match the actual complexity(MUST be less than 10 sub-questions):
     * Simple questions: 1-2 sub-questions
     * Medium complexity: 3-5 sub-questions
     * Complex analytical questions: 6-10 sub-questions
   - AVOID creating "schema exploration" or "understand tables" as separate sub-questions
     (schema exploration is part of the execution workflow, not a sub-question)

3. For each sub-question, define:
   - What specific question it answers
   - What tables/columns it will query
   - What the expected output format is
   - How it contributes to the final answer

EXAMPLE DECOMPOSITION:
User Question: "Compare the top 3 products by revenue in each region, and show year-over-year growth"

Sub-questions:
1. "Identify all unique regions in the database" → Validates data scope
2. "Calculate total revenue per product per region" → Base aggregation
3. "Rank products by revenue within each region and select top 3" → Ranking logic
4. "Calculate revenue for the same products in the previous year" → Historical comparison
5. "Compute year-over-year growth rate for top 3 products per region" → Final calculation
6. "Format and present results with region, product, current revenue, previous revenue, growth %" → Aggregation

STEP 1: Use todo_write to create the decomposition plan with appropriate number of sub-questions based on question complexity.

Format each todo item as:
{
  "content": "Sub-question: [specific question to answer] | Expected: [what this query will return]",
  "status": "pending"
}

Example:
'[
  {"content": "Sub-question: Identify all unique regions | Expected: List of region names", "status": "pending"},
  {"content": "Sub-question: Calculate total revenue per product per region | Expected: Table with product_id, region, total_revenue", "status": "pending"}
]'

STEP 2: {{ execution_prompt }}

{% else %}
{# Default fallback: Check current plan status and execute if needed #}

PLAN MODE - QUERY DECOMPOSITION
Check todo_read to see current sub-query plan status and proceed accordingly.

VALIDATION CHECKLIST for each completed sub-query:
- Does the result answer the specific sub-question?
- Is the data complete (no unexpected NULLs or missing values)?
- Are there any edge cases to consider?
- Does this result align with what's needed for the final aggregation?

FINAL AGGREGATION:
Once all sub-queries are completed:
1. Review all intermediate results
2. Synthesize them into a final SQL query or combine results programmatically
3. Present the final answer with clear explanation of how sub-results were combined

{{ execution_prompt }}
{% endif %}
