

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_xmtpv3_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_xmtpv3_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_xmtpv3_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("xmtpv3")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 29
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_xmtpv3_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_xmtpv3_checksum_func_apply_signature_request() != 65134:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_connect_to_backend() != 18636:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_create_client() != 16448:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_actions() != 13209:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_attachment() != 20456:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_group_updated() != 277:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_intent() != 24165:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_leave_request() != 20951:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_markdown() != 24145:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_multi_remote_attachment() != 59746:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_reaction() != 24150:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_read_receipt() != 60393:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_remote_attachment() != 53450:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_reply() != 41903:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_text() != 7209:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_transaction_reference() != 25896:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_decode_wallet_send_calls() != 2959:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_actions() != 15414:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_attachment() != 47054:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_intent() != 64568:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_leave_request() != 28716:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_markdown() != 14192:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_multi_remote_attachment() != 28938:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_reaction() != 48662:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_read_receipt() != 46693:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_remote_attachment() != 14050:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_reply() != 3022:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_text() != 6696:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_transaction_reference() != 22144:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_encode_wallet_send_calls() != 8163:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_enter_debug_writer() != 60052:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_enter_debug_writer_with_level() != 41119:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_ethereum_address_from_pubkey() != 12568:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_ethereum_generate_public_key() != 36134:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_ethereum_hash_personal() != 43764:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_ethereum_sign_recoverable() != 58098:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_exit_debug_writer() != 31716:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_generate_inbox_id() != 35602:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_get_inbox_id_for_identifier() != 54811:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_get_newest_message_metadata() != 45697:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_get_version_info() != 29277:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_inbox_state_from_inbox_ids() != 55434:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_is_connected() != 17295:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_func_revoke_installations() != 39546:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffiauthcallback_on_auth_required() != 41151:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffiauthhandle_id() != 11318:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffiauthhandle_set() != 39409:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonsentcallback_on_consent_update() != 12532:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonsentcallback_on_error() != 5882:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonsentcallback_on_close() != 18566:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_add_admin() != 52417:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_add_members() != 52510:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_add_members_by_inbox_id() != 30553:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_add_super_admin() != 62984:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_added_by_inbox_id() != 12748:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_admin_list() != 26668:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_app_data() != 57646:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_consent_state() != 25033:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_conversation_debug_info() != 13258:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_conversation_message_disappearing_settings() != 53380:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_conversation_type() != 43322:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_count_messages() != 14036:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_created_at_ns() != 17973:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_dm_peer_inbox_id() != 2178:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_find_duplicate_dms() != 15813:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_find_enriched_messages() != 4573:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_find_messages() != 19931:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_find_messages_with_reactions() != 46761:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_get_hmac_keys() != 35284:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_get_last_read_times() != 5152:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_group_description() != 53570:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_group_image_url_square() != 3200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_group_metadata() != 7860:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_group_name() != 9344:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_group_permissions() != 61947:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_id() != 5542:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_is_active() != 49581:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_is_admin() != 12325:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_is_conversation_message_disappearing_enabled() != 13756:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_is_super_admin() != 25811:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_leave_group() != 6817:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_list_members() != 21260:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_membership_state() != 9048:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_paused_for_version() != 61438:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_process_streamed_conversation_message() != 33913:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_publish_messages() != 15643:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_remove_admin() != 7973:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_remove_conversation_message_disappearing_settings() != 37503:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_remove_members() != 27638:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_remove_members_by_inbox_id() != 53192:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_remove_super_admin() != 46017:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_send() != 12477:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_send_optimistic() != 22242:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_send_text() != 55684:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_stream() != 26870:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_super_admin_list() != 50610:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_sync() != 17206:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_update_app_data() != 26175:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_update_consent_state() != 27721:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_update_conversation_message_disappearing_settings() != 18023:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_update_group_description() != 14549:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_update_group_image_url_square() != 36900:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_update_group_name() != 62600:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversation_update_permission_policy() != 3743:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversationcallback_on_conversation() != 25316:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversationcallback_on_error() != 461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversationcallback_on_close() != 26905:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversationlistitem_conversation() != 20525:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversationlistitem_is_commit_log_forked() != 16358:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversationlistitem_last_message() != 42510:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversationmetadata_conversation_type() != 22241:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversationmetadata_creator_inbox_id() != 61067:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_create_group() != 5386:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_create_group_optimistic() != 41612:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_create_group_with_inbox_ids() != 56407:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm() != 25610:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm_by_inbox_id() != 42164:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_get_hmac_keys() != 44064:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_list() != 23197:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_list_dms() != 39437:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_list_groups() != 7791:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_process_streamed_welcome_message() != 24295:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_stream() != 31576:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_stream_all_dm_messages() != 7006:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_stream_all_group_messages() != 16815:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_stream_all_messages() != 34596:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_stream_consent() != 27123:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_stream_dms() != 52710:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_stream_groups() != 11064:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_stream_message_deletions() != 61355:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_stream_messages() != 45879:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_stream_preferences() != 37452:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_sync() != 9054:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_fficonversations_sync_all_conversations() != 29050:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_content() != 6416:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_content_type_id() != 63211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_conversation_id() != 1070:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_delivery_status() != 10321:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_expires_at_ns() != 54265:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_fallback_text() != 1914:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_has_reactions() != 60219:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_id() != 41676:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_inserted_at_ns() != 46609:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_kind() != 55657:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_num_replies() != 35773:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_reaction_count() != 7084:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_reactions() != 53291:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_inbox_id() != 12782:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_installation_id() != 58886:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_sent_at_ns() != 54409:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_set() != 24928:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_type() != 56975:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffiinboxowner_get_identifier() != 4926:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffiinboxowner_sign() != 10423:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffimessagecallback_on_message() != 5286:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffimessagecallback_on_error() != 32204:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffimessagecallback_on_close() != 9150:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffimessagedeletioncallback_on_message_deleted() != 4903:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_preference_update() != 19900:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_error() != 41454:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_close() != 48198:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_ecdsa_signature() != 8706:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_passkey_signature() != 11222:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_scw_signature() != 52793:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_is_ready() != 65051:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_missing_address_signatures() != 55383:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_signature_text() != 60472:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffistreamcloser_end() != 11040:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffistreamcloser_end_and_wait() != 23074:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffistreamcloser_is_closed() != 62423:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffistreamcloser_wait_for_ready() != 38545:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffisyncworker_wait() != 30763:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_add_identity() != 61490:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_addresses_from_inbox_id() != 29264:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_api_aggregate_statistics() != 18475:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_api_identity_statistics() != 47055:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_api_statistics() != 31059:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_apply_signature_request() != 32172:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_archive_metadata() != 27089:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_can_message() != 32993:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_change_recovery_identifier() != 39513:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_clear_all_statistics() != 38737:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_conversation() != 60290:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_conversations() != 47463:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_create_archive() != 6966:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_db_reconnect() != 6707:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_delete_message() != 34289:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_dm_conversation() != 23917:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_enriched_message() != 37575:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_find_inbox_id() != 17517:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_get_consent_state() != 58208:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_get_key_package_statuses_for_installation_ids() != 60893:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_get_latest_inbox_state() != 3165:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_import_archive() != 7049:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_id() != 25128:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_state() != 7826:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_installation_id() != 37173:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_message() != 26932:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_register_identity() != 42003:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_release_db_connection() != 11067:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_all_other_installations_signature_request() != 46778:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_identity() != 63231:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_installations() != 2611:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_send_sync_request() != 42032:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_set_consent_states() != 64566:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_sign_with_installation_key() != 42647:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_signature_request() != 18270:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_sync_preferences() != 36404:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_installation_key() != 3285:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_public_key() != 10898:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_xmtpv3_checksum_constructor_ffiauthhandle_new() != 11700:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UNIFFI_CALLBACK_INTERFACE_FFI_AUTH_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_CONSENT_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_CONSENT_CALLBACK_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_CONSENT_CALLBACK_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_CONVERSATION_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_CONVERSATION_CALLBACK_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_CONVERSATION_CALLBACK_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_INBOX_OWNER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.POINTER(_UniffiRustBuffer),
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_INBOX_OWNER_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.POINTER(_UniffiRustBuffer),
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_CALLBACK_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_CALLBACK_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_DELETION_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_PREFERENCE_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_PREFERENCE_CALLBACK_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_FFI_PREFERENCE_CALLBACK_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
class _UniffiVTableCallbackInterfaceFfiAuthCallback(ctypes.Structure):
    _fields_ = [
        ("on_auth_required", _UNIFFI_CALLBACK_INTERFACE_FFI_AUTH_CALLBACK_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceFfiConsentCallback(ctypes.Structure):
    _fields_ = [
        ("on_consent_update", _UNIFFI_CALLBACK_INTERFACE_FFI_CONSENT_CALLBACK_METHOD0),
        ("on_error", _UNIFFI_CALLBACK_INTERFACE_FFI_CONSENT_CALLBACK_METHOD1),
        ("on_close", _UNIFFI_CALLBACK_INTERFACE_FFI_CONSENT_CALLBACK_METHOD2),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceFfiConversationCallback(ctypes.Structure):
    _fields_ = [
        ("on_conversation", _UNIFFI_CALLBACK_INTERFACE_FFI_CONVERSATION_CALLBACK_METHOD0),
        ("on_error", _UNIFFI_CALLBACK_INTERFACE_FFI_CONVERSATION_CALLBACK_METHOD1),
        ("on_close", _UNIFFI_CALLBACK_INTERFACE_FFI_CONVERSATION_CALLBACK_METHOD2),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceFfiInboxOwner(ctypes.Structure):
    _fields_ = [
        ("get_identifier", _UNIFFI_CALLBACK_INTERFACE_FFI_INBOX_OWNER_METHOD0),
        ("sign", _UNIFFI_CALLBACK_INTERFACE_FFI_INBOX_OWNER_METHOD1),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceFfiMessageCallback(ctypes.Structure):
    _fields_ = [
        ("on_message", _UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_CALLBACK_METHOD0),
        ("on_error", _UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_CALLBACK_METHOD1),
        ("on_close", _UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_CALLBACK_METHOD2),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceFfiMessageDeletionCallback(ctypes.Structure):
    _fields_ = [
        ("on_message_deleted", _UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_DELETION_CALLBACK_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceFfiPreferenceCallback(ctypes.Structure):
    _fields_ = [
        ("on_preference_update", _UNIFFI_CALLBACK_INTERFACE_FFI_PREFERENCE_CALLBACK_METHOD0),
        ("on_error", _UNIFFI_CALLBACK_INTERFACE_FFI_PREFERENCE_CALLBACK_METHOD1),
        ("on_close", _UNIFFI_CALLBACK_INTERFACE_FFI_PREFERENCE_CALLBACK_METHOD2),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
_UniffiLib.uniffi_xmtpv3_fn_clone_ffiauthcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffiauthcallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffiauthcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffiauthcallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffiauthcallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceFfiAuthCallback),
)
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffiauthcallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffiauthcallback_on_auth_required.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffiauthcallback_on_auth_required.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_clone_ffiauthhandle.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffiauthhandle.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffiauthhandle.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffiauthhandle.restype = None
_UniffiLib.uniffi_xmtpv3_fn_constructor_ffiauthhandle_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_constructor_ffiauthhandle_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_method_ffiauthhandle_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffiauthhandle_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffiauthhandle_set.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffiauthhandle_set.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonsentcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonsentcallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_fficonsentcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_fficonsentcallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_fficonsentcallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceFfiConsentCallback),
)
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_fficonsentcallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_fficonsentcallback_on_consent_update.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonsentcallback_on_consent_update.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_fficonsentcallback_on_error.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonsentcallback_on_error.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_fficonsentcallback_on_close.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonsentcallback_on_close.restype = None
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversation.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_fficonversation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_fficonversation.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_admin.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_admin.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_members.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_members.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_members_by_inbox_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_members_by_inbox_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_super_admin.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_super_admin.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_added_by_inbox_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_added_by_inbox_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_admin_list.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_admin_list.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_app_data.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_app_data.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_consent_state.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_consent_state.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_conversation_debug_info.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_conversation_debug_info.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_conversation_message_disappearing_settings.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_conversation_message_disappearing_settings.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_conversation_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_conversation_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_count_messages.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_count_messages.restype = ctypes.c_int64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_created_at_ns.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_created_at_ns.restype = ctypes.c_int64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_dm_peer_inbox_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_dm_peer_inbox_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_duplicate_dms.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_duplicate_dms.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_enriched_messages.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_enriched_messages.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_messages.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_messages.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_messages_with_reactions.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_messages_with_reactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_get_hmac_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_get_hmac_keys.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_get_last_read_times.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_get_last_read_times.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_image_url_square.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_image_url_square.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_metadata.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_metadata.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_permissions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_permissions.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_active.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_active.restype = ctypes.c_int8
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_admin.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_admin.restype = ctypes.c_int8
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_conversation_message_disappearing_enabled.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_conversation_message_disappearing_enabled.restype = ctypes.c_int8
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_super_admin.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_super_admin.restype = ctypes.c_int8
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_leave_group.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_leave_group.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_list_members.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_list_members.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_membership_state.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_membership_state.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_paused_for_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_paused_for_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_process_streamed_conversation_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_process_streamed_conversation_message.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_publish_messages.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_publish_messages.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_admin.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_admin.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_conversation_message_disappearing_settings.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_conversation_message_disappearing_settings.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_members.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_members.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_members_by_inbox_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_members_by_inbox_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_super_admin.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_super_admin.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_send.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_send.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_send_optimistic.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_send_optimistic.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_send_text.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_send_text.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_stream.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_stream.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_super_admin_list.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_super_admin_list.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_sync.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_sync.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_app_data.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_app_data.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_consent_state.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_consent_state.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_conversation_message_disappearing_settings.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_conversation_message_disappearing_settings.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_group_description.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_group_description.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_group_image_url_square.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_group_image_url_square.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_group_name.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_group_name.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_permission_policy.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_permission_policy.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversationcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversationcallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_fficonversationcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_fficonversationcallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_fficonversationcallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceFfiConversationCallback),
)
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_fficonversationcallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationcallback_on_conversation.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationcallback_on_conversation.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationcallback_on_error.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationcallback_on_error.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationcallback_on_close.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationcallback_on_close.restype = None
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversationlistitem.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversationlistitem.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_fficonversationlistitem.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_fficonversationlistitem.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationlistitem_conversation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationlistitem_conversation.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationlistitem_is_commit_log_forked.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationlistitem_is_commit_log_forked.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationlistitem_last_message.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationlistitem_last_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversationmetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversationmetadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_fficonversationmetadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_fficonversationmetadata.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationmetadata_conversation_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationmetadata_conversation_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationmetadata_creator_inbox_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationmetadata_creator_inbox_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversations.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversations.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_fficonversations.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_fficonversations.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_create_group.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_create_group.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_create_group_optimistic.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_create_group_optimistic.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_create_group_with_inbox_ids.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_create_group_with_inbox_ids.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm_by_inbox_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm_by_inbox_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_get_hmac_keys.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_get_hmac_keys.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_list.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_list.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_list_dms.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_list_dms.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_list_groups.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_list_groups.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_process_streamed_welcome_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_process_streamed_welcome_message.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_all_dm_messages.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_all_dm_messages.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_all_group_messages.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_all_group_messages.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_all_messages.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_all_messages.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_consent.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_consent.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_dms.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_dms.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_groups.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_groups.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_message_deletions.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_message_deletions.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_messages.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_messages.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_preferences.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_preferences.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_sync.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_sync.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_sync_all_conversations.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_sync_all_conversations.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_clone_ffidecodedmessage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffidecodedmessage.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffidecodedmessage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffidecodedmessage.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_content.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_content.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_content_type_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_content_type_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_conversation_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_conversation_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_delivery_status.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_delivery_status.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_expires_at_ns.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_expires_at_ns.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_fallback_text.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_fallback_text.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_has_reactions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_has_reactions.restype = ctypes.c_int8
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_inserted_at_ns.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_inserted_at_ns.restype = ctypes.c_int64
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_kind.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_num_replies.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_num_replies.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_reaction_count.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_reaction_count.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_reactions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_reactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_sender_inbox_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_sender_inbox_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_sender_installation_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_sender_installation_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_sent_at_ns.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_sent_at_ns.restype = ctypes.c_int64
_UniffiLib.uniffi_xmtpv3_fn_clone_ffigrouppermissions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffigrouppermissions.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffigrouppermissions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffigrouppermissions.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_set.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_set.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_clone_ffiinboxowner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffiinboxowner.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffiinboxowner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffiinboxowner.restype = None
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffiinboxowner.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceFfiInboxOwner),
)
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffiinboxowner.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffiinboxowner_get_identifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffiinboxowner_get_identifier.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffiinboxowner_sign.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffiinboxowner_sign.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_clone_ffimessagecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffimessagecallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffimessagecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffimessagecallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffimessagecallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceFfiMessageCallback),
)
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffimessagecallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagecallback_on_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagecallback_on_message.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagecallback_on_error.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagecallback_on_error.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagecallback_on_close.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagecallback_on_close.restype = None
_UniffiLib.uniffi_xmtpv3_fn_clone_ffimessagedeletioncallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffimessagedeletioncallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffimessagedeletioncallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffimessagedeletioncallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffimessagedeletioncallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceFfiMessageDeletionCallback),
)
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffimessagedeletioncallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagedeletioncallback_on_message_deleted.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagedeletioncallback_on_message_deleted.restype = None
_UniffiLib.uniffi_xmtpv3_fn_clone_ffipreferencecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffipreferencecallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffipreferencecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffipreferencecallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffipreferencecallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceFfiPreferenceCallback),
)
_UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffipreferencecallback.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffipreferencecallback_on_preference_update.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffipreferencecallback_on_preference_update.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffipreferencecallback_on_error.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffipreferencecallback_on_error.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffipreferencecallback_on_close.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffipreferencecallback_on_close.restype = None
_UniffiLib.uniffi_xmtpv3_fn_clone_ffisignaturerequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffisignaturerequest.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffisignaturerequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffisignaturerequest.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_add_ecdsa_signature.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_add_ecdsa_signature.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_add_passkey_signature.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_add_passkey_signature.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_add_scw_signature.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_add_scw_signature.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_is_ready.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_is_ready.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_missing_address_signatures.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_missing_address_signatures.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_signature_text.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_signature_text.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_clone_ffistreamcloser.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffistreamcloser.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffistreamcloser.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffistreamcloser.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_end.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_end.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_end_and_wait.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_end_and_wait.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_is_closed.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_is_closed.restype = ctypes.c_int8
_UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_wait_for_ready.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_wait_for_ready.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_clone_ffisyncworker.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffisyncworker.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffisyncworker.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffisyncworker.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffisyncworker_wait.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffisyncworker_wait.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_clone_ffixmtpclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_ffixmtpclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_ffixmtpclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_ffixmtpclient.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_add_identity.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_add_identity.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_addresses_from_inbox_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_addresses_from_inbox_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_api_aggregate_statistics.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_api_aggregate_statistics.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_api_identity_statistics.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_api_identity_statistics.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_api_statistics.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_api_statistics.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_apply_signature_request.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_apply_signature_request.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_archive_metadata.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_archive_metadata.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_can_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_can_message.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_change_recovery_identifier.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_change_recovery_identifier.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_clear_all_statistics.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_clear_all_statistics.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_conversation.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_conversation.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_conversations.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_conversations.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_create_archive.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_create_archive.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_db_reconnect.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_db_reconnect.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_delete_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_delete_message.restype = ctypes.c_uint32
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_dm_conversation.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_dm_conversation.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_enriched_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_enriched_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_find_inbox_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_find_inbox_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_get_consent_state.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_get_consent_state.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_get_key_package_statuses_for_installation_ids.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_get_key_package_statuses_for_installation_ids.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_get_latest_inbox_state.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_get_latest_inbox_state.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_import_archive.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_import_archive.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_state.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_state.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_installation_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_installation_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_register_identity.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_register_identity.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_release_db_connection.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_release_db_connection.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_all_other_installations_signature_request.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_all_other_installations_signature_request.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_identity.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_identity.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_installations.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_installations.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_send_sync_request.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_send_sync_request.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_set_consent_states.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_set_consent_states.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_sign_with_installation_key.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_sign_with_installation_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_signature_request.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_signature_request.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_sync_preferences.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_sync_preferences.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_installation_key.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_installation_key.restype = None
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_public_key.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_public_key.restype = None
_UniffiLib.uniffi_xmtpv3_fn_clone_xmtpapiclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_clone_xmtpapiclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_xmtpv3_fn_free_xmtpapiclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_free_xmtpapiclient.restype = None
_UniffiLib.uniffi_xmtpv3_fn_func_apply_signature_request.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_func_apply_signature_request.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_func_connect_to_backend.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_int8,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_func_connect_to_backend.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_func_create_client.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_func_create_client.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_func_decode_actions.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_actions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_attachment.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_attachment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_group_updated.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_group_updated.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_intent.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_intent.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_leave_request.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_leave_request.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_markdown.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_markdown.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_multi_remote_attachment.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_multi_remote_attachment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_reaction.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_reaction.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_read_receipt.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_read_receipt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_remote_attachment.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_remote_attachment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_reply.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_reply.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_text.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_text.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_transaction_reference.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_transaction_reference.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_decode_wallet_send_calls.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_decode_wallet_send_calls.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_actions.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_actions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_attachment.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_attachment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_intent.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_intent.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_leave_request.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_leave_request.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_markdown.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_markdown.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_multi_remote_attachment.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_multi_remote_attachment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_reaction.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_reaction.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_read_receipt.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_read_receipt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_remote_attachment.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_remote_attachment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_reply.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_reply.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_text.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_text.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_transaction_reference.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_transaction_reference.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_encode_wallet_send_calls.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_encode_wallet_send_calls.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_enter_debug_writer.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_enter_debug_writer.restype = None
_UniffiLib.uniffi_xmtpv3_fn_func_enter_debug_writer_with_level.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_enter_debug_writer_with_level.restype = None
_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_address_from_pubkey.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_address_from_pubkey.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_generate_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_generate_public_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_hash_personal.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_hash_personal.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_sign_recoverable.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_sign_recoverable.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_exit_debug_writer.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_exit_debug_writer.restype = None
_UniffiLib.uniffi_xmtpv3_fn_func_generate_inbox_id.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_generate_inbox_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_get_inbox_id_for_identifier.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_func_get_inbox_id_for_identifier.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_func_get_newest_message_metadata.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_func_get_newest_message_metadata.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_func_get_version_info.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_get_version_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_xmtpv3_fn_func_inbox_state_from_inbox_ids.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_xmtpv3_fn_func_inbox_state_from_inbox_ids.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_func_is_connected.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_xmtpv3_fn_func_is_connected.restype = ctypes.c_uint64
_UniffiLib.uniffi_xmtpv3_fn_func_revoke_installations.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_xmtpv3_fn_func_revoke_installations.restype = ctypes.c_void_p
_UniffiLib.ffi_xmtpv3_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_xmtpv3_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_xmtpv3_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rustbuffer_free.restype = None
_UniffiLib.ffi_xmtpv3_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_xmtpv3_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_u8.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_u8.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_xmtpv3_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_i8.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_i8.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_xmtpv3_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_u16.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_u16.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_xmtpv3_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_i16.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_i16.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_xmtpv3_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_u32.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_u32.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_xmtpv3_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_i32.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_i32.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_xmtpv3_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_u64.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_u64.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_xmtpv3_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_i64.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_i64.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_xmtpv3_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_f32.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_f32.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_xmtpv3_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_f64.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_f64.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_xmtpv3_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_pointer.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_xmtpv3_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_poll_void.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_cancel_void.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_xmtpv3_rust_future_free_void.restype = None
_UniffiLib.ffi_xmtpv3_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_xmtpv3_rust_future_complete_void.restype = None
_UniffiLib.uniffi_xmtpv3_checksum_func_apply_signature_request.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_apply_signature_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_connect_to_backend.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_connect_to_backend.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_create_client.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_create_client.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_actions.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_actions.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_attachment.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_attachment.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_group_updated.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_group_updated.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_intent.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_intent.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_leave_request.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_leave_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_markdown.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_markdown.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_multi_remote_attachment.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_multi_remote_attachment.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_reaction.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_reaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_read_receipt.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_read_receipt.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_remote_attachment.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_remote_attachment.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_reply.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_reply.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_text.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_text.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_transaction_reference.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_transaction_reference.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_wallet_send_calls.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_decode_wallet_send_calls.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_actions.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_actions.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_attachment.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_attachment.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_intent.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_intent.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_leave_request.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_leave_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_markdown.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_markdown.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_multi_remote_attachment.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_multi_remote_attachment.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_reaction.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_reaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_read_receipt.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_read_receipt.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_remote_attachment.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_remote_attachment.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_reply.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_reply.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_text.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_text.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_transaction_reference.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_transaction_reference.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_wallet_send_calls.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_encode_wallet_send_calls.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_enter_debug_writer.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_enter_debug_writer.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_enter_debug_writer_with_level.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_enter_debug_writer_with_level.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_ethereum_address_from_pubkey.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_ethereum_address_from_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_ethereum_generate_public_key.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_ethereum_generate_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_ethereum_hash_personal.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_ethereum_hash_personal.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_ethereum_sign_recoverable.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_ethereum_sign_recoverable.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_exit_debug_writer.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_exit_debug_writer.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_generate_inbox_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_generate_inbox_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_get_inbox_id_for_identifier.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_get_inbox_id_for_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_get_newest_message_metadata.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_get_newest_message_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_get_version_info.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_get_version_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_inbox_state_from_inbox_ids.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_inbox_state_from_inbox_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_is_connected.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_is_connected.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_func_revoke_installations.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_func_revoke_installations.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffiauthcallback_on_auth_required.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffiauthcallback_on_auth_required.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffiauthhandle_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffiauthhandle_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffiauthhandle_set.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffiauthhandle_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonsentcallback_on_consent_update.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonsentcallback_on_consent_update.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonsentcallback_on_error.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonsentcallback_on_error.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonsentcallback_on_close.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonsentcallback_on_close.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_add_admin.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_add_admin.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_add_members.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_add_members.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_add_members_by_inbox_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_add_members_by_inbox_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_add_super_admin.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_add_super_admin.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_added_by_inbox_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_added_by_inbox_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_admin_list.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_admin_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_app_data.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_app_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_consent_state.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_consent_state.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_conversation_debug_info.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_conversation_debug_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_conversation_message_disappearing_settings.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_conversation_message_disappearing_settings.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_conversation_type.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_conversation_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_count_messages.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_count_messages.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_created_at_ns.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_created_at_ns.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_dm_peer_inbox_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_dm_peer_inbox_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_find_duplicate_dms.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_find_duplicate_dms.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_find_enriched_messages.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_find_enriched_messages.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_find_messages.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_find_messages.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_find_messages_with_reactions.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_find_messages_with_reactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_get_hmac_keys.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_get_hmac_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_get_last_read_times.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_get_last_read_times.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_group_description.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_group_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_group_image_url_square.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_group_image_url_square.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_group_metadata.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_group_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_group_name.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_group_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_group_permissions.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_group_permissions.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_is_active.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_is_active.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_is_admin.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_is_admin.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_is_conversation_message_disappearing_enabled.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_is_conversation_message_disappearing_enabled.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_is_super_admin.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_is_super_admin.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_leave_group.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_leave_group.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_list_members.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_list_members.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_membership_state.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_membership_state.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_paused_for_version.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_paused_for_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_process_streamed_conversation_message.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_process_streamed_conversation_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_publish_messages.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_publish_messages.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_remove_admin.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_remove_admin.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_remove_conversation_message_disappearing_settings.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_remove_conversation_message_disappearing_settings.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_remove_members.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_remove_members.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_remove_members_by_inbox_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_remove_members_by_inbox_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_remove_super_admin.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_remove_super_admin.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_send.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_send_optimistic.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_send_optimistic.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_send_text.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_send_text.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_stream.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_stream.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_super_admin_list.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_super_admin_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_sync.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_app_data.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_app_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_consent_state.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_consent_state.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_conversation_message_disappearing_settings.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_conversation_message_disappearing_settings.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_group_description.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_group_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_group_image_url_square.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_group_image_url_square.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_group_name.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_group_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_permission_policy.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversation_update_permission_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationcallback_on_conversation.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationcallback_on_conversation.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationcallback_on_error.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationcallback_on_error.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationcallback_on_close.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationcallback_on_close.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationlistitem_conversation.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationlistitem_conversation.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationlistitem_is_commit_log_forked.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationlistitem_is_commit_log_forked.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationlistitem_last_message.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationlistitem_last_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationmetadata_conversation_type.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationmetadata_conversation_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationmetadata_creator_inbox_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversationmetadata_creator_inbox_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_create_group.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_create_group.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_create_group_optimistic.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_create_group_optimistic.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_create_group_with_inbox_ids.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_create_group_with_inbox_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm_by_inbox_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_find_or_create_dm_by_inbox_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_get_hmac_keys.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_get_hmac_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_list.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_list_dms.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_list_dms.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_list_groups.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_list_groups.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_process_streamed_welcome_message.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_process_streamed_welcome_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_all_dm_messages.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_all_dm_messages.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_all_group_messages.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_all_group_messages.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_all_messages.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_all_messages.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_consent.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_consent.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_dms.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_dms.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_groups.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_groups.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_message_deletions.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_message_deletions.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_messages.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_messages.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_preferences.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_stream_preferences.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_sync.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_sync_all_conversations.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_fficonversations_sync_all_conversations.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_content.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_content.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_content_type_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_content_type_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_conversation_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_conversation_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_delivery_status.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_delivery_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_expires_at_ns.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_expires_at_ns.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_fallback_text.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_fallback_text.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_has_reactions.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_has_reactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_inserted_at_ns.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_inserted_at_ns.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_kind.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_num_replies.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_num_replies.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_reaction_count.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_reaction_count.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_reactions.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_reactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_inbox_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_inbox_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_installation_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_sender_installation_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_sent_at_ns.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffidecodedmessage_sent_at_ns.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_set.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_type.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffigrouppermissions_policy_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffiinboxowner_get_identifier.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffiinboxowner_get_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffiinboxowner_sign.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffiinboxowner_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffimessagecallback_on_message.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffimessagecallback_on_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffimessagecallback_on_error.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffimessagecallback_on_error.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffimessagecallback_on_close.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffimessagecallback_on_close.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffimessagedeletioncallback_on_message_deleted.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffimessagedeletioncallback_on_message_deleted.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_preference_update.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_preference_update.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_error.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_error.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_close.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffipreferencecallback_on_close.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_ecdsa_signature.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_ecdsa_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_passkey_signature.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_passkey_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_scw_signature.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_add_scw_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_is_ready.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_is_ready.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_missing_address_signatures.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_missing_address_signatures.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_signature_text.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisignaturerequest_signature_text.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffistreamcloser_end.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffistreamcloser_end.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffistreamcloser_end_and_wait.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffistreamcloser_end_and_wait.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffistreamcloser_is_closed.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffistreamcloser_is_closed.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffistreamcloser_wait_for_ready.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffistreamcloser_wait_for_ready.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisyncworker_wait.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffisyncworker_wait.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_add_identity.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_add_identity.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_addresses_from_inbox_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_addresses_from_inbox_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_api_aggregate_statistics.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_api_aggregate_statistics.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_api_identity_statistics.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_api_identity_statistics.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_api_statistics.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_api_statistics.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_apply_signature_request.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_apply_signature_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_archive_metadata.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_archive_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_can_message.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_can_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_change_recovery_identifier.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_change_recovery_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_clear_all_statistics.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_clear_all_statistics.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_conversation.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_conversation.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_conversations.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_conversations.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_create_archive.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_create_archive.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_db_reconnect.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_db_reconnect.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_delete_message.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_delete_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_dm_conversation.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_dm_conversation.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_enriched_message.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_enriched_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_find_inbox_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_find_inbox_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_get_consent_state.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_get_consent_state.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_get_key_package_statuses_for_installation_ids.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_get_key_package_statuses_for_installation_ids.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_get_latest_inbox_state.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_get_latest_inbox_state.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_import_archive.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_import_archive.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_state.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_inbox_state.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_installation_id.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_installation_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_message.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_register_identity.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_register_identity.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_release_db_connection.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_release_db_connection.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_all_other_installations_signature_request.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_all_other_installations_signature_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_identity.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_identity.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_installations.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_revoke_installations.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_send_sync_request.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_send_sync_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_set_consent_states.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_set_consent_states.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_sign_with_installation_key.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_sign_with_installation_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_signature_request.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_signature_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_sync_preferences.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_sync_preferences.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_installation_key.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_installation_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_public_key.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_method_ffixmtpclient_verify_signed_with_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_xmtpv3_checksum_constructor_ffiauthhandle_new.argtypes = (
)
_UniffiLib.uniffi_xmtpv3_checksum_constructor_ffiauthhandle_new.restype = ctypes.c_uint16
_UniffiLib.ffi_xmtpv3_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_xmtpv3_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.
# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiConverterDouble(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)








































class FfiAction:
    id: "str"
    label: "str"
    image_url: "typing.Optional[str]"
    style: "typing.Optional[FfiActionStyle]"
    expires_at_ns: "typing.Optional[int]"
    def __init__(self, *, id: "str", label: "str", image_url: "typing.Optional[str]", style: "typing.Optional[FfiActionStyle]", expires_at_ns: "typing.Optional[int]"):
        self.id = id
        self.label = label
        self.image_url = image_url
        self.style = style
        self.expires_at_ns = expires_at_ns

    def __str__(self):
        return "FfiAction(id={}, label={}, image_url={}, style={}, expires_at_ns={})".format(self.id, self.label, self.image_url, self.style, self.expires_at_ns)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.label != other.label:
            return False
        if self.image_url != other.image_url:
            return False
        if self.style != other.style:
            return False
        if self.expires_at_ns != other.expires_at_ns:
            return False
        return True

class _UniffiConverterTypeFfiAction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiAction(
            id=_UniffiConverterString.read(buf),
            label=_UniffiConverterString.read(buf),
            image_url=_UniffiConverterOptionalString.read(buf),
            style=_UniffiConverterOptionalTypeFfiActionStyle.read(buf),
            expires_at_ns=_UniffiConverterOptionalInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.label)
        _UniffiConverterOptionalString.check_lower(value.image_url)
        _UniffiConverterOptionalTypeFfiActionStyle.check_lower(value.style)
        _UniffiConverterOptionalInt64.check_lower(value.expires_at_ns)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.label, buf)
        _UniffiConverterOptionalString.write(value.image_url, buf)
        _UniffiConverterOptionalTypeFfiActionStyle.write(value.style, buf)
        _UniffiConverterOptionalInt64.write(value.expires_at_ns, buf)


class FfiActions:
    id: "str"
    description: "str"
    actions: "typing.List[FfiAction]"
    expires_at_ns: "typing.Optional[int]"
    def __init__(self, *, id: "str", description: "str", actions: "typing.List[FfiAction]", expires_at_ns: "typing.Optional[int]"):
        self.id = id
        self.description = description
        self.actions = actions
        self.expires_at_ns = expires_at_ns

    def __str__(self):
        return "FfiActions(id={}, description={}, actions={}, expires_at_ns={})".format(self.id, self.description, self.actions, self.expires_at_ns)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.description != other.description:
            return False
        if self.actions != other.actions:
            return False
        if self.expires_at_ns != other.expires_at_ns:
            return False
        return True

class _UniffiConverterTypeFfiActions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiActions(
            id=_UniffiConverterString.read(buf),
            description=_UniffiConverterString.read(buf),
            actions=_UniffiConverterSequenceTypeFfiAction.read(buf),
            expires_at_ns=_UniffiConverterOptionalInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.description)
        _UniffiConverterSequenceTypeFfiAction.check_lower(value.actions)
        _UniffiConverterOptionalInt64.check_lower(value.expires_at_ns)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.description, buf)
        _UniffiConverterSequenceTypeFfiAction.write(value.actions, buf)
        _UniffiConverterOptionalInt64.write(value.expires_at_ns, buf)


class FfiApiStats:
    upload_key_package: "int"
    fetch_key_package: "int"
    send_group_messages: "int"
    send_welcome_messages: "int"
    query_group_messages: "int"
    query_welcome_messages: "int"
    subscribe_messages: "int"
    subscribe_welcomes: "int"
    def __init__(self, *, upload_key_package: "int", fetch_key_package: "int", send_group_messages: "int", send_welcome_messages: "int", query_group_messages: "int", query_welcome_messages: "int", subscribe_messages: "int", subscribe_welcomes: "int"):
        self.upload_key_package = upload_key_package
        self.fetch_key_package = fetch_key_package
        self.send_group_messages = send_group_messages
        self.send_welcome_messages = send_welcome_messages
        self.query_group_messages = query_group_messages
        self.query_welcome_messages = query_welcome_messages
        self.subscribe_messages = subscribe_messages
        self.subscribe_welcomes = subscribe_welcomes

    def __str__(self):
        return "FfiApiStats(upload_key_package={}, fetch_key_package={}, send_group_messages={}, send_welcome_messages={}, query_group_messages={}, query_welcome_messages={}, subscribe_messages={}, subscribe_welcomes={})".format(self.upload_key_package, self.fetch_key_package, self.send_group_messages, self.send_welcome_messages, self.query_group_messages, self.query_welcome_messages, self.subscribe_messages, self.subscribe_welcomes)

    def __eq__(self, other):
        if self.upload_key_package != other.upload_key_package:
            return False
        if self.fetch_key_package != other.fetch_key_package:
            return False
        if self.send_group_messages != other.send_group_messages:
            return False
        if self.send_welcome_messages != other.send_welcome_messages:
            return False
        if self.query_group_messages != other.query_group_messages:
            return False
        if self.query_welcome_messages != other.query_welcome_messages:
            return False
        if self.subscribe_messages != other.subscribe_messages:
            return False
        if self.subscribe_welcomes != other.subscribe_welcomes:
            return False
        return True

class _UniffiConverterTypeFfiApiStats(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiApiStats(
            upload_key_package=_UniffiConverterUInt64.read(buf),
            fetch_key_package=_UniffiConverterUInt64.read(buf),
            send_group_messages=_UniffiConverterUInt64.read(buf),
            send_welcome_messages=_UniffiConverterUInt64.read(buf),
            query_group_messages=_UniffiConverterUInt64.read(buf),
            query_welcome_messages=_UniffiConverterUInt64.read(buf),
            subscribe_messages=_UniffiConverterUInt64.read(buf),
            subscribe_welcomes=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.upload_key_package)
        _UniffiConverterUInt64.check_lower(value.fetch_key_package)
        _UniffiConverterUInt64.check_lower(value.send_group_messages)
        _UniffiConverterUInt64.check_lower(value.send_welcome_messages)
        _UniffiConverterUInt64.check_lower(value.query_group_messages)
        _UniffiConverterUInt64.check_lower(value.query_welcome_messages)
        _UniffiConverterUInt64.check_lower(value.subscribe_messages)
        _UniffiConverterUInt64.check_lower(value.subscribe_welcomes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.upload_key_package, buf)
        _UniffiConverterUInt64.write(value.fetch_key_package, buf)
        _UniffiConverterUInt64.write(value.send_group_messages, buf)
        _UniffiConverterUInt64.write(value.send_welcome_messages, buf)
        _UniffiConverterUInt64.write(value.query_group_messages, buf)
        _UniffiConverterUInt64.write(value.query_welcome_messages, buf)
        _UniffiConverterUInt64.write(value.subscribe_messages, buf)
        _UniffiConverterUInt64.write(value.subscribe_welcomes, buf)


class FfiArchiveOptions:
    start_ns: "typing.Optional[int]"
    end_ns: "typing.Optional[int]"
    elements: "typing.List[FfiBackupElementSelection]"
    exclude_disappearing_messages: "bool"
    def __init__(self, *, start_ns: "typing.Optional[int]", end_ns: "typing.Optional[int]", elements: "typing.List[FfiBackupElementSelection]", exclude_disappearing_messages: "bool"):
        self.start_ns = start_ns
        self.end_ns = end_ns
        self.elements = elements
        self.exclude_disappearing_messages = exclude_disappearing_messages

    def __str__(self):
        return "FfiArchiveOptions(start_ns={}, end_ns={}, elements={}, exclude_disappearing_messages={})".format(self.start_ns, self.end_ns, self.elements, self.exclude_disappearing_messages)

    def __eq__(self, other):
        if self.start_ns != other.start_ns:
            return False
        if self.end_ns != other.end_ns:
            return False
        if self.elements != other.elements:
            return False
        if self.exclude_disappearing_messages != other.exclude_disappearing_messages:
            return False
        return True

class _UniffiConverterTypeFfiArchiveOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiArchiveOptions(
            start_ns=_UniffiConverterOptionalInt64.read(buf),
            end_ns=_UniffiConverterOptionalInt64.read(buf),
            elements=_UniffiConverterSequenceTypeFfiBackupElementSelection.read(buf),
            exclude_disappearing_messages=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalInt64.check_lower(value.start_ns)
        _UniffiConverterOptionalInt64.check_lower(value.end_ns)
        _UniffiConverterSequenceTypeFfiBackupElementSelection.check_lower(value.elements)
        _UniffiConverterBool.check_lower(value.exclude_disappearing_messages)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalInt64.write(value.start_ns, buf)
        _UniffiConverterOptionalInt64.write(value.end_ns, buf)
        _UniffiConverterSequenceTypeFfiBackupElementSelection.write(value.elements, buf)
        _UniffiConverterBool.write(value.exclude_disappearing_messages, buf)


class FfiAttachment:
    filename: "typing.Optional[str]"
    mime_type: "str"
    content: "bytes"
    def __init__(self, *, filename: "typing.Optional[str]", mime_type: "str", content: "bytes"):
        self.filename = filename
        self.mime_type = mime_type
        self.content = content

    def __str__(self):
        return "FfiAttachment(filename={}, mime_type={}, content={})".format(self.filename, self.mime_type, self.content)

    def __eq__(self, other):
        if self.filename != other.filename:
            return False
        if self.mime_type != other.mime_type:
            return False
        if self.content != other.content:
            return False
        return True

class _UniffiConverterTypeFfiAttachment(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiAttachment(
            filename=_UniffiConverterOptionalString.read(buf),
            mime_type=_UniffiConverterString.read(buf),
            content=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.filename)
        _UniffiConverterString.check_lower(value.mime_type)
        _UniffiConverterBytes.check_lower(value.content)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.filename, buf)
        _UniffiConverterString.write(value.mime_type, buf)
        _UniffiConverterBytes.write(value.content, buf)


class FfiBackupMetadata:
    backup_version: "int"
    elements: "typing.List[FfiBackupElementSelection]"
    exported_at_ns: "int"
    start_ns: "typing.Optional[int]"
    end_ns: "typing.Optional[int]"
    def __init__(self, *, backup_version: "int", elements: "typing.List[FfiBackupElementSelection]", exported_at_ns: "int", start_ns: "typing.Optional[int]", end_ns: "typing.Optional[int]"):
        self.backup_version = backup_version
        self.elements = elements
        self.exported_at_ns = exported_at_ns
        self.start_ns = start_ns
        self.end_ns = end_ns

    def __str__(self):
        return "FfiBackupMetadata(backup_version={}, elements={}, exported_at_ns={}, start_ns={}, end_ns={})".format(self.backup_version, self.elements, self.exported_at_ns, self.start_ns, self.end_ns)

    def __eq__(self, other):
        if self.backup_version != other.backup_version:
            return False
        if self.elements != other.elements:
            return False
        if self.exported_at_ns != other.exported_at_ns:
            return False
        if self.start_ns != other.start_ns:
            return False
        if self.end_ns != other.end_ns:
            return False
        return True

class _UniffiConverterTypeFfiBackupMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiBackupMetadata(
            backup_version=_UniffiConverterUInt16.read(buf),
            elements=_UniffiConverterSequenceTypeFfiBackupElementSelection.read(buf),
            exported_at_ns=_UniffiConverterInt64.read(buf),
            start_ns=_UniffiConverterOptionalInt64.read(buf),
            end_ns=_UniffiConverterOptionalInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt16.check_lower(value.backup_version)
        _UniffiConverterSequenceTypeFfiBackupElementSelection.check_lower(value.elements)
        _UniffiConverterInt64.check_lower(value.exported_at_ns)
        _UniffiConverterOptionalInt64.check_lower(value.start_ns)
        _UniffiConverterOptionalInt64.check_lower(value.end_ns)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt16.write(value.backup_version, buf)
        _UniffiConverterSequenceTypeFfiBackupElementSelection.write(value.elements, buf)
        _UniffiConverterInt64.write(value.exported_at_ns, buf)
        _UniffiConverterOptionalInt64.write(value.start_ns, buf)
        _UniffiConverterOptionalInt64.write(value.end_ns, buf)


class FfiConsent:
    entity_type: "FfiConsentEntityType"
    state: "FfiConsentState"
    entity: "str"
    def __init__(self, *, entity_type: "FfiConsentEntityType", state: "FfiConsentState", entity: "str"):
        self.entity_type = entity_type
        self.state = state
        self.entity = entity

    def __str__(self):
        return "FfiConsent(entity_type={}, state={}, entity={})".format(self.entity_type, self.state, self.entity)

    def __eq__(self, other):
        if self.entity_type != other.entity_type:
            return False
        if self.state != other.state:
            return False
        if self.entity != other.entity:
            return False
        return True

class _UniffiConverterTypeFfiConsent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiConsent(
            entity_type=_UniffiConverterTypeFfiConsentEntityType.read(buf),
            state=_UniffiConverterTypeFfiConsentState.read(buf),
            entity=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeFfiConsentEntityType.check_lower(value.entity_type)
        _UniffiConverterTypeFfiConsentState.check_lower(value.state)
        _UniffiConverterString.check_lower(value.entity)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeFfiConsentEntityType.write(value.entity_type, buf)
        _UniffiConverterTypeFfiConsentState.write(value.state, buf)
        _UniffiConverterString.write(value.entity, buf)


class FfiContentTypeId:
    authority_id: "str"
    type_id: "str"
    version_major: "int"
    version_minor: "int"
    def __init__(self, *, authority_id: "str", type_id: "str", version_major: "int", version_minor: "int"):
        self.authority_id = authority_id
        self.type_id = type_id
        self.version_major = version_major
        self.version_minor = version_minor

    def __str__(self):
        return "FfiContentTypeId(authority_id={}, type_id={}, version_major={}, version_minor={})".format(self.authority_id, self.type_id, self.version_major, self.version_minor)

    def __eq__(self, other):
        if self.authority_id != other.authority_id:
            return False
        if self.type_id != other.type_id:
            return False
        if self.version_major != other.version_major:
            return False
        if self.version_minor != other.version_minor:
            return False
        return True

class _UniffiConverterTypeFfiContentTypeId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiContentTypeId(
            authority_id=_UniffiConverterString.read(buf),
            type_id=_UniffiConverterString.read(buf),
            version_major=_UniffiConverterUInt32.read(buf),
            version_minor=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.authority_id)
        _UniffiConverterString.check_lower(value.type_id)
        _UniffiConverterUInt32.check_lower(value.version_major)
        _UniffiConverterUInt32.check_lower(value.version_minor)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.authority_id, buf)
        _UniffiConverterString.write(value.type_id, buf)
        _UniffiConverterUInt32.write(value.version_major, buf)
        _UniffiConverterUInt32.write(value.version_minor, buf)


class FfiConversationDebugInfo:
    epoch: "int"
    maybe_forked: "bool"
    fork_details: "str"
    is_commit_log_forked: "typing.Optional[bool]"
    local_commit_log: "str"
    remote_commit_log: "str"
    cursor: "typing.List[FfiCursor]"
    def __init__(self, *, epoch: "int", maybe_forked: "bool", fork_details: "str", is_commit_log_forked: "typing.Optional[bool]", local_commit_log: "str", remote_commit_log: "str", cursor: "typing.List[FfiCursor]"):
        self.epoch = epoch
        self.maybe_forked = maybe_forked
        self.fork_details = fork_details
        self.is_commit_log_forked = is_commit_log_forked
        self.local_commit_log = local_commit_log
        self.remote_commit_log = remote_commit_log
        self.cursor = cursor

    def __str__(self):
        return "FfiConversationDebugInfo(epoch={}, maybe_forked={}, fork_details={}, is_commit_log_forked={}, local_commit_log={}, remote_commit_log={}, cursor={})".format(self.epoch, self.maybe_forked, self.fork_details, self.is_commit_log_forked, self.local_commit_log, self.remote_commit_log, self.cursor)

    def __eq__(self, other):
        if self.epoch != other.epoch:
            return False
        if self.maybe_forked != other.maybe_forked:
            return False
        if self.fork_details != other.fork_details:
            return False
        if self.is_commit_log_forked != other.is_commit_log_forked:
            return False
        if self.local_commit_log != other.local_commit_log:
            return False
        if self.remote_commit_log != other.remote_commit_log:
            return False
        if self.cursor != other.cursor:
            return False
        return True

class _UniffiConverterTypeFfiConversationDebugInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiConversationDebugInfo(
            epoch=_UniffiConverterUInt64.read(buf),
            maybe_forked=_UniffiConverterBool.read(buf),
            fork_details=_UniffiConverterString.read(buf),
            is_commit_log_forked=_UniffiConverterOptionalBool.read(buf),
            local_commit_log=_UniffiConverterString.read(buf),
            remote_commit_log=_UniffiConverterString.read(buf),
            cursor=_UniffiConverterSequenceTypeFfiCursor.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.epoch)
        _UniffiConverterBool.check_lower(value.maybe_forked)
        _UniffiConverterString.check_lower(value.fork_details)
        _UniffiConverterOptionalBool.check_lower(value.is_commit_log_forked)
        _UniffiConverterString.check_lower(value.local_commit_log)
        _UniffiConverterString.check_lower(value.remote_commit_log)
        _UniffiConverterSequenceTypeFfiCursor.check_lower(value.cursor)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.epoch, buf)
        _UniffiConverterBool.write(value.maybe_forked, buf)
        _UniffiConverterString.write(value.fork_details, buf)
        _UniffiConverterOptionalBool.write(value.is_commit_log_forked, buf)
        _UniffiConverterString.write(value.local_commit_log, buf)
        _UniffiConverterString.write(value.remote_commit_log, buf)
        _UniffiConverterSequenceTypeFfiCursor.write(value.cursor, buf)


class FfiConversationMember:
    inbox_id: "str"
    account_identifiers: "typing.List[FfiIdentifier]"
    installation_ids: "typing.List[bytes]"
    permission_level: "FfiPermissionLevel"
    consent_state: "FfiConsentState"
    def __init__(self, *, inbox_id: "str", account_identifiers: "typing.List[FfiIdentifier]", installation_ids: "typing.List[bytes]", permission_level: "FfiPermissionLevel", consent_state: "FfiConsentState"):
        self.inbox_id = inbox_id
        self.account_identifiers = account_identifiers
        self.installation_ids = installation_ids
        self.permission_level = permission_level
        self.consent_state = consent_state

    def __str__(self):
        return "FfiConversationMember(inbox_id={}, account_identifiers={}, installation_ids={}, permission_level={}, consent_state={})".format(self.inbox_id, self.account_identifiers, self.installation_ids, self.permission_level, self.consent_state)

    def __eq__(self, other):
        if self.inbox_id != other.inbox_id:
            return False
        if self.account_identifiers != other.account_identifiers:
            return False
        if self.installation_ids != other.installation_ids:
            return False
        if self.permission_level != other.permission_level:
            return False
        if self.consent_state != other.consent_state:
            return False
        return True

class _UniffiConverterTypeFfiConversationMember(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiConversationMember(
            inbox_id=_UniffiConverterString.read(buf),
            account_identifiers=_UniffiConverterSequenceTypeFfiIdentifier.read(buf),
            installation_ids=_UniffiConverterSequenceBytes.read(buf),
            permission_level=_UniffiConverterTypeFfiPermissionLevel.read(buf),
            consent_state=_UniffiConverterTypeFfiConsentState.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.inbox_id)
        _UniffiConverterSequenceTypeFfiIdentifier.check_lower(value.account_identifiers)
        _UniffiConverterSequenceBytes.check_lower(value.installation_ids)
        _UniffiConverterTypeFfiPermissionLevel.check_lower(value.permission_level)
        _UniffiConverterTypeFfiConsentState.check_lower(value.consent_state)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.inbox_id, buf)
        _UniffiConverterSequenceTypeFfiIdentifier.write(value.account_identifiers, buf)
        _UniffiConverterSequenceBytes.write(value.installation_ids, buf)
        _UniffiConverterTypeFfiPermissionLevel.write(value.permission_level, buf)
        _UniffiConverterTypeFfiConsentState.write(value.consent_state, buf)


class FfiCreateDmOptions:
    message_disappearing_settings: "typing.Optional[FfiMessageDisappearingSettings]"
    def __init__(self, *, message_disappearing_settings: "typing.Optional[FfiMessageDisappearingSettings]"):
        self.message_disappearing_settings = message_disappearing_settings

    def __str__(self):
        return "FfiCreateDmOptions(message_disappearing_settings={})".format(self.message_disappearing_settings)

    def __eq__(self, other):
        if self.message_disappearing_settings != other.message_disappearing_settings:
            return False
        return True

class _UniffiConverterTypeFfiCreateDmOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiCreateDmOptions(
            message_disappearing_settings=_UniffiConverterOptionalTypeFfiMessageDisappearingSettings.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeFfiMessageDisappearingSettings.check_lower(value.message_disappearing_settings)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeFfiMessageDisappearingSettings.write(value.message_disappearing_settings, buf)


class FfiCreateGroupOptions:
    permissions: "typing.Optional[FfiGroupPermissionsOptions]"
    group_name: "typing.Optional[str]"
    group_image_url_square: "typing.Optional[str]"
    group_description: "typing.Optional[str]"
    custom_permission_policy_set: "typing.Optional[FfiPermissionPolicySet]"
    message_disappearing_settings: "typing.Optional[FfiMessageDisappearingSettings]"
    app_data: "typing.Optional[str]"
    def __init__(self, *, permissions: "typing.Optional[FfiGroupPermissionsOptions]", group_name: "typing.Optional[str]", group_image_url_square: "typing.Optional[str]", group_description: "typing.Optional[str]", custom_permission_policy_set: "typing.Optional[FfiPermissionPolicySet]", message_disappearing_settings: "typing.Optional[FfiMessageDisappearingSettings]", app_data: "typing.Optional[str]"):
        self.permissions = permissions
        self.group_name = group_name
        self.group_image_url_square = group_image_url_square
        self.group_description = group_description
        self.custom_permission_policy_set = custom_permission_policy_set
        self.message_disappearing_settings = message_disappearing_settings
        self.app_data = app_data

    def __str__(self):
        return "FfiCreateGroupOptions(permissions={}, group_name={}, group_image_url_square={}, group_description={}, custom_permission_policy_set={}, message_disappearing_settings={}, app_data={})".format(self.permissions, self.group_name, self.group_image_url_square, self.group_description, self.custom_permission_policy_set, self.message_disappearing_settings, self.app_data)

    def __eq__(self, other):
        if self.permissions != other.permissions:
            return False
        if self.group_name != other.group_name:
            return False
        if self.group_image_url_square != other.group_image_url_square:
            return False
        if self.group_description != other.group_description:
            return False
        if self.custom_permission_policy_set != other.custom_permission_policy_set:
            return False
        if self.message_disappearing_settings != other.message_disappearing_settings:
            return False
        if self.app_data != other.app_data:
            return False
        return True

class _UniffiConverterTypeFfiCreateGroupOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiCreateGroupOptions(
            permissions=_UniffiConverterOptionalTypeFfiGroupPermissionsOptions.read(buf),
            group_name=_UniffiConverterOptionalString.read(buf),
            group_image_url_square=_UniffiConverterOptionalString.read(buf),
            group_description=_UniffiConverterOptionalString.read(buf),
            custom_permission_policy_set=_UniffiConverterOptionalTypeFfiPermissionPolicySet.read(buf),
            message_disappearing_settings=_UniffiConverterOptionalTypeFfiMessageDisappearingSettings.read(buf),
            app_data=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeFfiGroupPermissionsOptions.check_lower(value.permissions)
        _UniffiConverterOptionalString.check_lower(value.group_name)
        _UniffiConverterOptionalString.check_lower(value.group_image_url_square)
        _UniffiConverterOptionalString.check_lower(value.group_description)
        _UniffiConverterOptionalTypeFfiPermissionPolicySet.check_lower(value.custom_permission_policy_set)
        _UniffiConverterOptionalTypeFfiMessageDisappearingSettings.check_lower(value.message_disappearing_settings)
        _UniffiConverterOptionalString.check_lower(value.app_data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeFfiGroupPermissionsOptions.write(value.permissions, buf)
        _UniffiConverterOptionalString.write(value.group_name, buf)
        _UniffiConverterOptionalString.write(value.group_image_url_square, buf)
        _UniffiConverterOptionalString.write(value.group_description, buf)
        _UniffiConverterOptionalTypeFfiPermissionPolicySet.write(value.custom_permission_policy_set, buf)
        _UniffiConverterOptionalTypeFfiMessageDisappearingSettings.write(value.message_disappearing_settings, buf)
        _UniffiConverterOptionalString.write(value.app_data, buf)


class FfiCredential:
    name: "typing.Optional[str]"
    value: "str"
    expires_at_seconds: "int"
    def __init__(self, *, name: "typing.Optional[str]", value: "str", expires_at_seconds: "int"):
        self.name = name
        self.value = value
        self.expires_at_seconds = expires_at_seconds

    def __str__(self):
        return "FfiCredential(name={}, value={}, expires_at_seconds={})".format(self.name, self.value, self.expires_at_seconds)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.value != other.value:
            return False
        if self.expires_at_seconds != other.expires_at_seconds:
            return False
        return True

class _UniffiConverterTypeFfiCredential(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiCredential(
            name=_UniffiConverterOptionalString.read(buf),
            value=_UniffiConverterString.read(buf),
            expires_at_seconds=_UniffiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.name)
        _UniffiConverterString.check_lower(value.value)
        _UniffiConverterInt64.check_lower(value.expires_at_seconds)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.name, buf)
        _UniffiConverterString.write(value.value, buf)
        _UniffiConverterInt64.write(value.expires_at_seconds, buf)


class FfiCursor:
    originator_id: "int"
    sequence_id: "int"
    def __init__(self, *, originator_id: "int", sequence_id: "int"):
        self.originator_id = originator_id
        self.sequence_id = sequence_id

    def __str__(self):
        return "FfiCursor(originator_id={}, sequence_id={})".format(self.originator_id, self.sequence_id)

    def __eq__(self, other):
        if self.originator_id != other.originator_id:
            return False
        if self.sequence_id != other.sequence_id:
            return False
        return True

class _UniffiConverterTypeFfiCursor(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiCursor(
            originator_id=_UniffiConverterUInt32.read(buf),
            sequence_id=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.originator_id)
        _UniffiConverterUInt64.check_lower(value.sequence_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.originator_id, buf)
        _UniffiConverterUInt64.write(value.sequence_id, buf)


class FfiDecodedMessageMetadata:
    id: "bytes"
    sent_at_ns: "int"
    kind: "FfiGroupMessageKind"
    sender_installation_id: "bytes"
    sender_inbox_id: "str"
    content_type: "FfiContentTypeId"
    conversation_id: "bytes"
    inserted_at_ns: "int"
    expires_at_ns: "typing.Optional[int]"
    def __init__(self, *, id: "bytes", sent_at_ns: "int", kind: "FfiGroupMessageKind", sender_installation_id: "bytes", sender_inbox_id: "str", content_type: "FfiContentTypeId", conversation_id: "bytes", inserted_at_ns: "int", expires_at_ns: "typing.Optional[int]"):
        self.id = id
        self.sent_at_ns = sent_at_ns
        self.kind = kind
        self.sender_installation_id = sender_installation_id
        self.sender_inbox_id = sender_inbox_id
        self.content_type = content_type
        self.conversation_id = conversation_id
        self.inserted_at_ns = inserted_at_ns
        self.expires_at_ns = expires_at_ns

    def __str__(self):
        return "FfiDecodedMessageMetadata(id={}, sent_at_ns={}, kind={}, sender_installation_id={}, sender_inbox_id={}, content_type={}, conversation_id={}, inserted_at_ns={}, expires_at_ns={})".format(self.id, self.sent_at_ns, self.kind, self.sender_installation_id, self.sender_inbox_id, self.content_type, self.conversation_id, self.inserted_at_ns, self.expires_at_ns)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.sent_at_ns != other.sent_at_ns:
            return False
        if self.kind != other.kind:
            return False
        if self.sender_installation_id != other.sender_installation_id:
            return False
        if self.sender_inbox_id != other.sender_inbox_id:
            return False
        if self.content_type != other.content_type:
            return False
        if self.conversation_id != other.conversation_id:
            return False
        if self.inserted_at_ns != other.inserted_at_ns:
            return False
        if self.expires_at_ns != other.expires_at_ns:
            return False
        return True

class _UniffiConverterTypeFfiDecodedMessageMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiDecodedMessageMetadata(
            id=_UniffiConverterBytes.read(buf),
            sent_at_ns=_UniffiConverterInt64.read(buf),
            kind=_UniffiConverterTypeFfiGroupMessageKind.read(buf),
            sender_installation_id=_UniffiConverterBytes.read(buf),
            sender_inbox_id=_UniffiConverterString.read(buf),
            content_type=_UniffiConverterTypeFfiContentTypeId.read(buf),
            conversation_id=_UniffiConverterBytes.read(buf),
            inserted_at_ns=_UniffiConverterInt64.read(buf),
            expires_at_ns=_UniffiConverterOptionalInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.id)
        _UniffiConverterInt64.check_lower(value.sent_at_ns)
        _UniffiConverterTypeFfiGroupMessageKind.check_lower(value.kind)
        _UniffiConverterBytes.check_lower(value.sender_installation_id)
        _UniffiConverterString.check_lower(value.sender_inbox_id)
        _UniffiConverterTypeFfiContentTypeId.check_lower(value.content_type)
        _UniffiConverterBytes.check_lower(value.conversation_id)
        _UniffiConverterInt64.check_lower(value.inserted_at_ns)
        _UniffiConverterOptionalInt64.check_lower(value.expires_at_ns)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.id, buf)
        _UniffiConverterInt64.write(value.sent_at_ns, buf)
        _UniffiConverterTypeFfiGroupMessageKind.write(value.kind, buf)
        _UniffiConverterBytes.write(value.sender_installation_id, buf)
        _UniffiConverterString.write(value.sender_inbox_id, buf)
        _UniffiConverterTypeFfiContentTypeId.write(value.content_type, buf)
        _UniffiConverterBytes.write(value.conversation_id, buf)
        _UniffiConverterInt64.write(value.inserted_at_ns, buf)
        _UniffiConverterOptionalInt64.write(value.expires_at_ns, buf)


class FfiEncodedContent:
    type_id: "typing.Optional[FfiContentTypeId]"
    parameters: "dict[str, str]"
    fallback: "typing.Optional[str]"
    compression: "typing.Optional[int]"
    content: "bytes"
    def __init__(self, *, type_id: "typing.Optional[FfiContentTypeId]", parameters: "dict[str, str]", fallback: "typing.Optional[str]", compression: "typing.Optional[int]", content: "bytes"):
        self.type_id = type_id
        self.parameters = parameters
        self.fallback = fallback
        self.compression = compression
        self.content = content

    def __str__(self):
        return "FfiEncodedContent(type_id={}, parameters={}, fallback={}, compression={}, content={})".format(self.type_id, self.parameters, self.fallback, self.compression, self.content)

    def __eq__(self, other):
        if self.type_id != other.type_id:
            return False
        if self.parameters != other.parameters:
            return False
        if self.fallback != other.fallback:
            return False
        if self.compression != other.compression:
            return False
        if self.content != other.content:
            return False
        return True

class _UniffiConverterTypeFfiEncodedContent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiEncodedContent(
            type_id=_UniffiConverterOptionalTypeFfiContentTypeId.read(buf),
            parameters=_UniffiConverterMapStringString.read(buf),
            fallback=_UniffiConverterOptionalString.read(buf),
            compression=_UniffiConverterOptionalInt32.read(buf),
            content=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeFfiContentTypeId.check_lower(value.type_id)
        _UniffiConverterMapStringString.check_lower(value.parameters)
        _UniffiConverterOptionalString.check_lower(value.fallback)
        _UniffiConverterOptionalInt32.check_lower(value.compression)
        _UniffiConverterBytes.check_lower(value.content)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeFfiContentTypeId.write(value.type_id, buf)
        _UniffiConverterMapStringString.write(value.parameters, buf)
        _UniffiConverterOptionalString.write(value.fallback, buf)
        _UniffiConverterOptionalInt32.write(value.compression, buf)
        _UniffiConverterBytes.write(value.content, buf)


class FfiEnrichedReply:
    in_reply_to: "typing.Optional[FfiDecodedMessage]"
    content: "typing.Optional[FfiDecodedMessageBody]"
    reference_id: "str"
    def __init__(self, *, in_reply_to: "typing.Optional[FfiDecodedMessage]", content: "typing.Optional[FfiDecodedMessageBody]", reference_id: "str"):
        self.in_reply_to = in_reply_to
        self.content = content
        self.reference_id = reference_id

    def __str__(self):
        return "FfiEnrichedReply(in_reply_to={}, content={}, reference_id={})".format(self.in_reply_to, self.content, self.reference_id)

    def __eq__(self, other):
        if self.in_reply_to != other.in_reply_to:
            return False
        if self.content != other.content:
            return False
        if self.reference_id != other.reference_id:
            return False
        return True

class _UniffiConverterTypeFfiEnrichedReply(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiEnrichedReply(
            in_reply_to=_UniffiConverterOptionalTypeFfiDecodedMessage.read(buf),
            content=_UniffiConverterOptionalTypeFfiDecodedMessageBody.read(buf),
            reference_id=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeFfiDecodedMessage.check_lower(value.in_reply_to)
        _UniffiConverterOptionalTypeFfiDecodedMessageBody.check_lower(value.content)
        _UniffiConverterString.check_lower(value.reference_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeFfiDecodedMessage.write(value.in_reply_to, buf)
        _UniffiConverterOptionalTypeFfiDecodedMessageBody.write(value.content, buf)
        _UniffiConverterString.write(value.reference_id, buf)


class FfiForkRecoveryOpts:
    enable_recovery_requests: "FfiForkRecoveryPolicy"
    groups_to_request_recovery: "typing.List[str]"
    disable_recovery_responses: "typing.Optional[bool]"
    worker_interval_ns: "typing.Optional[int]"
    def __init__(self, *, enable_recovery_requests: "FfiForkRecoveryPolicy", groups_to_request_recovery: "typing.List[str]", disable_recovery_responses: "typing.Optional[bool]", worker_interval_ns: "typing.Optional[int]"):
        self.enable_recovery_requests = enable_recovery_requests
        self.groups_to_request_recovery = groups_to_request_recovery
        self.disable_recovery_responses = disable_recovery_responses
        self.worker_interval_ns = worker_interval_ns

    def __str__(self):
        return "FfiForkRecoveryOpts(enable_recovery_requests={}, groups_to_request_recovery={}, disable_recovery_responses={}, worker_interval_ns={})".format(self.enable_recovery_requests, self.groups_to_request_recovery, self.disable_recovery_responses, self.worker_interval_ns)

    def __eq__(self, other):
        if self.enable_recovery_requests != other.enable_recovery_requests:
            return False
        if self.groups_to_request_recovery != other.groups_to_request_recovery:
            return False
        if self.disable_recovery_responses != other.disable_recovery_responses:
            return False
        if self.worker_interval_ns != other.worker_interval_ns:
            return False
        return True

class _UniffiConverterTypeFfiForkRecoveryOpts(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiForkRecoveryOpts(
            enable_recovery_requests=_UniffiConverterTypeFfiForkRecoveryPolicy.read(buf),
            groups_to_request_recovery=_UniffiConverterSequenceString.read(buf),
            disable_recovery_responses=_UniffiConverterOptionalBool.read(buf),
            worker_interval_ns=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeFfiForkRecoveryPolicy.check_lower(value.enable_recovery_requests)
        _UniffiConverterSequenceString.check_lower(value.groups_to_request_recovery)
        _UniffiConverterOptionalBool.check_lower(value.disable_recovery_responses)
        _UniffiConverterOptionalUInt64.check_lower(value.worker_interval_ns)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeFfiForkRecoveryPolicy.write(value.enable_recovery_requests, buf)
        _UniffiConverterSequenceString.write(value.groups_to_request_recovery, buf)
        _UniffiConverterOptionalBool.write(value.disable_recovery_responses, buf)
        _UniffiConverterOptionalUInt64.write(value.worker_interval_ns, buf)


class FfiGroupSyncSummary:
    num_eligible: "int"
    num_synced: "int"
    def __init__(self, *, num_eligible: "int", num_synced: "int"):
        self.num_eligible = num_eligible
        self.num_synced = num_synced

    def __str__(self):
        return "FfiGroupSyncSummary(num_eligible={}, num_synced={})".format(self.num_eligible, self.num_synced)

    def __eq__(self, other):
        if self.num_eligible != other.num_eligible:
            return False
        if self.num_synced != other.num_synced:
            return False
        return True

class _UniffiConverterTypeFfiGroupSyncSummary(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiGroupSyncSummary(
            num_eligible=_UniffiConverterUInt64.read(buf),
            num_synced=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.num_eligible)
        _UniffiConverterUInt64.check_lower(value.num_synced)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.num_eligible, buf)
        _UniffiConverterUInt64.write(value.num_synced, buf)


class FfiGroupUpdated:
    initiated_by_inbox_id: "str"
    added_inboxes: "typing.List[FfiInbox]"
    removed_inboxes: "typing.List[FfiInbox]"
    left_inboxes: "typing.List[FfiInbox]"
    metadata_field_changes: "typing.List[FfiMetadataFieldChange]"
    added_admin_inboxes: "typing.List[FfiInbox]"
    removed_admin_inboxes: "typing.List[FfiInbox]"
    added_super_admin_inboxes: "typing.List[FfiInbox]"
    removed_super_admin_inboxes: "typing.List[FfiInbox]"
    def __init__(self, *, initiated_by_inbox_id: "str", added_inboxes: "typing.List[FfiInbox]", removed_inboxes: "typing.List[FfiInbox]", left_inboxes: "typing.List[FfiInbox]", metadata_field_changes: "typing.List[FfiMetadataFieldChange]", added_admin_inboxes: "typing.List[FfiInbox]", removed_admin_inboxes: "typing.List[FfiInbox]", added_super_admin_inboxes: "typing.List[FfiInbox]", removed_super_admin_inboxes: "typing.List[FfiInbox]"):
        self.initiated_by_inbox_id = initiated_by_inbox_id
        self.added_inboxes = added_inboxes
        self.removed_inboxes = removed_inboxes
        self.left_inboxes = left_inboxes
        self.metadata_field_changes = metadata_field_changes
        self.added_admin_inboxes = added_admin_inboxes
        self.removed_admin_inboxes = removed_admin_inboxes
        self.added_super_admin_inboxes = added_super_admin_inboxes
        self.removed_super_admin_inboxes = removed_super_admin_inboxes

    def __str__(self):
        return "FfiGroupUpdated(initiated_by_inbox_id={}, added_inboxes={}, removed_inboxes={}, left_inboxes={}, metadata_field_changes={}, added_admin_inboxes={}, removed_admin_inboxes={}, added_super_admin_inboxes={}, removed_super_admin_inboxes={})".format(self.initiated_by_inbox_id, self.added_inboxes, self.removed_inboxes, self.left_inboxes, self.metadata_field_changes, self.added_admin_inboxes, self.removed_admin_inboxes, self.added_super_admin_inboxes, self.removed_super_admin_inboxes)

    def __eq__(self, other):
        if self.initiated_by_inbox_id != other.initiated_by_inbox_id:
            return False
        if self.added_inboxes != other.added_inboxes:
            return False
        if self.removed_inboxes != other.removed_inboxes:
            return False
        if self.left_inboxes != other.left_inboxes:
            return False
        if self.metadata_field_changes != other.metadata_field_changes:
            return False
        if self.added_admin_inboxes != other.added_admin_inboxes:
            return False
        if self.removed_admin_inboxes != other.removed_admin_inboxes:
            return False
        if self.added_super_admin_inboxes != other.added_super_admin_inboxes:
            return False
        if self.removed_super_admin_inboxes != other.removed_super_admin_inboxes:
            return False
        return True

class _UniffiConverterTypeFfiGroupUpdated(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiGroupUpdated(
            initiated_by_inbox_id=_UniffiConverterString.read(buf),
            added_inboxes=_UniffiConverterSequenceTypeFfiInbox.read(buf),
            removed_inboxes=_UniffiConverterSequenceTypeFfiInbox.read(buf),
            left_inboxes=_UniffiConverterSequenceTypeFfiInbox.read(buf),
            metadata_field_changes=_UniffiConverterSequenceTypeFfiMetadataFieldChange.read(buf),
            added_admin_inboxes=_UniffiConverterSequenceTypeFfiInbox.read(buf),
            removed_admin_inboxes=_UniffiConverterSequenceTypeFfiInbox.read(buf),
            added_super_admin_inboxes=_UniffiConverterSequenceTypeFfiInbox.read(buf),
            removed_super_admin_inboxes=_UniffiConverterSequenceTypeFfiInbox.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.initiated_by_inbox_id)
        _UniffiConverterSequenceTypeFfiInbox.check_lower(value.added_inboxes)
        _UniffiConverterSequenceTypeFfiInbox.check_lower(value.removed_inboxes)
        _UniffiConverterSequenceTypeFfiInbox.check_lower(value.left_inboxes)
        _UniffiConverterSequenceTypeFfiMetadataFieldChange.check_lower(value.metadata_field_changes)
        _UniffiConverterSequenceTypeFfiInbox.check_lower(value.added_admin_inboxes)
        _UniffiConverterSequenceTypeFfiInbox.check_lower(value.removed_admin_inboxes)
        _UniffiConverterSequenceTypeFfiInbox.check_lower(value.added_super_admin_inboxes)
        _UniffiConverterSequenceTypeFfiInbox.check_lower(value.removed_super_admin_inboxes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.initiated_by_inbox_id, buf)
        _UniffiConverterSequenceTypeFfiInbox.write(value.added_inboxes, buf)
        _UniffiConverterSequenceTypeFfiInbox.write(value.removed_inboxes, buf)
        _UniffiConverterSequenceTypeFfiInbox.write(value.left_inboxes, buf)
        _UniffiConverterSequenceTypeFfiMetadataFieldChange.write(value.metadata_field_changes, buf)
        _UniffiConverterSequenceTypeFfiInbox.write(value.added_admin_inboxes, buf)
        _UniffiConverterSequenceTypeFfiInbox.write(value.removed_admin_inboxes, buf)
        _UniffiConverterSequenceTypeFfiInbox.write(value.added_super_admin_inboxes, buf)
        _UniffiConverterSequenceTypeFfiInbox.write(value.removed_super_admin_inboxes, buf)


class FfiHmacKey:
    key: "bytes"
    epoch: "int"
    def __init__(self, *, key: "bytes", epoch: "int"):
        self.key = key
        self.epoch = epoch

    def __str__(self):
        return "FfiHmacKey(key={}, epoch={})".format(self.key, self.epoch)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.epoch != other.epoch:
            return False
        return True

class _UniffiConverterTypeFfiHmacKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiHmacKey(
            key=_UniffiConverterBytes.read(buf),
            epoch=_UniffiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.key)
        _UniffiConverterInt64.check_lower(value.epoch)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.key, buf)
        _UniffiConverterInt64.write(value.epoch, buf)


class FfiIdentifier:
    identifier: "str"
    identifier_kind: "FfiIdentifierKind"
    def __init__(self, *, identifier: "str", identifier_kind: "FfiIdentifierKind"):
        self.identifier = identifier
        self.identifier_kind = identifier_kind

    def __str__(self):
        return "FfiIdentifier(identifier={}, identifier_kind={})".format(self.identifier, self.identifier_kind)

    def __eq__(self, other):
        if self.identifier != other.identifier:
            return False
        if self.identifier_kind != other.identifier_kind:
            return False
        return True

class _UniffiConverterTypeFfiIdentifier(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiIdentifier(
            identifier=_UniffiConverterString.read(buf),
            identifier_kind=_UniffiConverterTypeFfiIdentifierKind.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.identifier)
        _UniffiConverterTypeFfiIdentifierKind.check_lower(value.identifier_kind)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.identifier, buf)
        _UniffiConverterTypeFfiIdentifierKind.write(value.identifier_kind, buf)


class FfiIdentityStats:
    publish_identity_update: "int"
    get_identity_updates_v2: "int"
    get_inbox_ids: "int"
    verify_smart_contract_wallet_signature: "int"
    def __init__(self, *, publish_identity_update: "int", get_identity_updates_v2: "int", get_inbox_ids: "int", verify_smart_contract_wallet_signature: "int"):
        self.publish_identity_update = publish_identity_update
        self.get_identity_updates_v2 = get_identity_updates_v2
        self.get_inbox_ids = get_inbox_ids
        self.verify_smart_contract_wallet_signature = verify_smart_contract_wallet_signature

    def __str__(self):
        return "FfiIdentityStats(publish_identity_update={}, get_identity_updates_v2={}, get_inbox_ids={}, verify_smart_contract_wallet_signature={})".format(self.publish_identity_update, self.get_identity_updates_v2, self.get_inbox_ids, self.verify_smart_contract_wallet_signature)

    def __eq__(self, other):
        if self.publish_identity_update != other.publish_identity_update:
            return False
        if self.get_identity_updates_v2 != other.get_identity_updates_v2:
            return False
        if self.get_inbox_ids != other.get_inbox_ids:
            return False
        if self.verify_smart_contract_wallet_signature != other.verify_smart_contract_wallet_signature:
            return False
        return True

class _UniffiConverterTypeFfiIdentityStats(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiIdentityStats(
            publish_identity_update=_UniffiConverterUInt64.read(buf),
            get_identity_updates_v2=_UniffiConverterUInt64.read(buf),
            get_inbox_ids=_UniffiConverterUInt64.read(buf),
            verify_smart_contract_wallet_signature=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.publish_identity_update)
        _UniffiConverterUInt64.check_lower(value.get_identity_updates_v2)
        _UniffiConverterUInt64.check_lower(value.get_inbox_ids)
        _UniffiConverterUInt64.check_lower(value.verify_smart_contract_wallet_signature)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.publish_identity_update, buf)
        _UniffiConverterUInt64.write(value.get_identity_updates_v2, buf)
        _UniffiConverterUInt64.write(value.get_inbox_ids, buf)
        _UniffiConverterUInt64.write(value.verify_smart_contract_wallet_signature, buf)


class FfiInbox:
    inbox_id: "str"
    def __init__(self, *, inbox_id: "str"):
        self.inbox_id = inbox_id

    def __str__(self):
        return "FfiInbox(inbox_id={})".format(self.inbox_id)

    def __eq__(self, other):
        if self.inbox_id != other.inbox_id:
            return False
        return True

class _UniffiConverterTypeFfiInbox(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiInbox(
            inbox_id=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.inbox_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.inbox_id, buf)


class FfiInboxState:
    inbox_id: "str"
    recovery_identity: "FfiIdentifier"
    installations: "typing.List[FfiInstallation]"
    account_identities: "typing.List[FfiIdentifier]"
    creation_signature_kind: "typing.Optional[FfiSignatureKind]"
    def __init__(self, *, inbox_id: "str", recovery_identity: "FfiIdentifier", installations: "typing.List[FfiInstallation]", account_identities: "typing.List[FfiIdentifier]", creation_signature_kind: "typing.Optional[FfiSignatureKind]"):
        self.inbox_id = inbox_id
        self.recovery_identity = recovery_identity
        self.installations = installations
        self.account_identities = account_identities
        self.creation_signature_kind = creation_signature_kind

    def __str__(self):
        return "FfiInboxState(inbox_id={}, recovery_identity={}, installations={}, account_identities={}, creation_signature_kind={})".format(self.inbox_id, self.recovery_identity, self.installations, self.account_identities, self.creation_signature_kind)

    def __eq__(self, other):
        if self.inbox_id != other.inbox_id:
            return False
        if self.recovery_identity != other.recovery_identity:
            return False
        if self.installations != other.installations:
            return False
        if self.account_identities != other.account_identities:
            return False
        if self.creation_signature_kind != other.creation_signature_kind:
            return False
        return True

class _UniffiConverterTypeFfiInboxState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiInboxState(
            inbox_id=_UniffiConverterString.read(buf),
            recovery_identity=_UniffiConverterTypeFfiIdentifier.read(buf),
            installations=_UniffiConverterSequenceTypeFfiInstallation.read(buf),
            account_identities=_UniffiConverterSequenceTypeFfiIdentifier.read(buf),
            creation_signature_kind=_UniffiConverterOptionalTypeFfiSignatureKind.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.inbox_id)
        _UniffiConverterTypeFfiIdentifier.check_lower(value.recovery_identity)
        _UniffiConverterSequenceTypeFfiInstallation.check_lower(value.installations)
        _UniffiConverterSequenceTypeFfiIdentifier.check_lower(value.account_identities)
        _UniffiConverterOptionalTypeFfiSignatureKind.check_lower(value.creation_signature_kind)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.inbox_id, buf)
        _UniffiConverterTypeFfiIdentifier.write(value.recovery_identity, buf)
        _UniffiConverterSequenceTypeFfiInstallation.write(value.installations, buf)
        _UniffiConverterSequenceTypeFfiIdentifier.write(value.account_identities, buf)
        _UniffiConverterOptionalTypeFfiSignatureKind.write(value.creation_signature_kind, buf)


class FfiInstallation:
    id: "bytes"
    client_timestamp_ns: "typing.Optional[int]"
    def __init__(self, *, id: "bytes", client_timestamp_ns: "typing.Optional[int]"):
        self.id = id
        self.client_timestamp_ns = client_timestamp_ns

    def __str__(self):
        return "FfiInstallation(id={}, client_timestamp_ns={})".format(self.id, self.client_timestamp_ns)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.client_timestamp_ns != other.client_timestamp_ns:
            return False
        return True

class _UniffiConverterTypeFfiInstallation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiInstallation(
            id=_UniffiConverterBytes.read(buf),
            client_timestamp_ns=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.id)
        _UniffiConverterOptionalUInt64.check_lower(value.client_timestamp_ns)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.id, buf)
        _UniffiConverterOptionalUInt64.write(value.client_timestamp_ns, buf)


class FfiIntent:
    id: "str"
    action_id: "str"
    metadata: "typing.Optional[str]"
    def __init__(self, *, id: "str", action_id: "str", metadata: "typing.Optional[str]"):
        self.id = id
        self.action_id = action_id
        self.metadata = metadata

    def __str__(self):
        return "FfiIntent(id={}, action_id={}, metadata={})".format(self.id, self.action_id, self.metadata)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.action_id != other.action_id:
            return False
        if self.metadata != other.metadata:
            return False
        return True

class _UniffiConverterTypeFfiIntent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiIntent(
            id=_UniffiConverterString.read(buf),
            action_id=_UniffiConverterString.read(buf),
            metadata=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.action_id)
        _UniffiConverterOptionalString.check_lower(value.metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.action_id, buf)
        _UniffiConverterOptionalString.write(value.metadata, buf)


class FfiKeyPackageStatus:
    lifetime: "typing.Optional[FfiLifetime]"
    validation_error: "typing.Optional[str]"
    def __init__(self, *, lifetime: "typing.Optional[FfiLifetime]", validation_error: "typing.Optional[str]"):
        self.lifetime = lifetime
        self.validation_error = validation_error

    def __str__(self):
        return "FfiKeyPackageStatus(lifetime={}, validation_error={})".format(self.lifetime, self.validation_error)

    def __eq__(self, other):
        if self.lifetime != other.lifetime:
            return False
        if self.validation_error != other.validation_error:
            return False
        return True

class _UniffiConverterTypeFfiKeyPackageStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiKeyPackageStatus(
            lifetime=_UniffiConverterOptionalTypeFfiLifetime.read(buf),
            validation_error=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeFfiLifetime.check_lower(value.lifetime)
        _UniffiConverterOptionalString.check_lower(value.validation_error)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeFfiLifetime.write(value.lifetime, buf)
        _UniffiConverterOptionalString.write(value.validation_error, buf)


class FfiLeaveRequest:
    """
    Represents a leave request message sent when a user wants to leave a group.
    """

    authenticated_note: "typing.Optional[bytes]"
    """
    Optional authenticated note for the leave request
    """

    def __init__(self, *, authenticated_note: "typing.Optional[bytes]"):
        self.authenticated_note = authenticated_note

    def __str__(self):
        return "FfiLeaveRequest(authenticated_note={})".format(self.authenticated_note)

    def __eq__(self, other):
        if self.authenticated_note != other.authenticated_note:
            return False
        return True

class _UniffiConverterTypeFfiLeaveRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiLeaveRequest(
            authenticated_note=_UniffiConverterOptionalBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalBytes.check_lower(value.authenticated_note)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalBytes.write(value.authenticated_note, buf)


class FfiLifetime:
    not_before: "int"
    not_after: "int"
    def __init__(self, *, not_before: "int", not_after: "int"):
        self.not_before = not_before
        self.not_after = not_after

    def __str__(self):
        return "FfiLifetime(not_before={}, not_after={})".format(self.not_before, self.not_after)

    def __eq__(self, other):
        if self.not_before != other.not_before:
            return False
        if self.not_after != other.not_after:
            return False
        return True

class _UniffiConverterTypeFfiLifetime(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiLifetime(
            not_before=_UniffiConverterUInt64.read(buf),
            not_after=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.not_before)
        _UniffiConverterUInt64.check_lower(value.not_after)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.not_before, buf)
        _UniffiConverterUInt64.write(value.not_after, buf)


class FfiListConversationsOptions:
    created_after_ns: "typing.Optional[int]"
    created_before_ns: "typing.Optional[int]"
    last_activity_before_ns: "typing.Optional[int]"
    last_activity_after_ns: "typing.Optional[int]"
    order_by: "typing.Optional[FfiGroupQueryOrderBy]"
    limit: "typing.Optional[int]"
    consent_states: "typing.Optional[typing.List[FfiConsentState]]"
    include_duplicate_dms: "bool"
    def __init__(self, *, created_after_ns: "typing.Optional[int]", created_before_ns: "typing.Optional[int]", last_activity_before_ns: "typing.Optional[int]", last_activity_after_ns: "typing.Optional[int]", order_by: "typing.Optional[FfiGroupQueryOrderBy]", limit: "typing.Optional[int]", consent_states: "typing.Optional[typing.List[FfiConsentState]]", include_duplicate_dms: "bool"):
        self.created_after_ns = created_after_ns
        self.created_before_ns = created_before_ns
        self.last_activity_before_ns = last_activity_before_ns
        self.last_activity_after_ns = last_activity_after_ns
        self.order_by = order_by
        self.limit = limit
        self.consent_states = consent_states
        self.include_duplicate_dms = include_duplicate_dms

    def __str__(self):
        return "FfiListConversationsOptions(created_after_ns={}, created_before_ns={}, last_activity_before_ns={}, last_activity_after_ns={}, order_by={}, limit={}, consent_states={}, include_duplicate_dms={})".format(self.created_after_ns, self.created_before_ns, self.last_activity_before_ns, self.last_activity_after_ns, self.order_by, self.limit, self.consent_states, self.include_duplicate_dms)

    def __eq__(self, other):
        if self.created_after_ns != other.created_after_ns:
            return False
        if self.created_before_ns != other.created_before_ns:
            return False
        if self.last_activity_before_ns != other.last_activity_before_ns:
            return False
        if self.last_activity_after_ns != other.last_activity_after_ns:
            return False
        if self.order_by != other.order_by:
            return False
        if self.limit != other.limit:
            return False
        if self.consent_states != other.consent_states:
            return False
        if self.include_duplicate_dms != other.include_duplicate_dms:
            return False
        return True

class _UniffiConverterTypeFfiListConversationsOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiListConversationsOptions(
            created_after_ns=_UniffiConverterOptionalInt64.read(buf),
            created_before_ns=_UniffiConverterOptionalInt64.read(buf),
            last_activity_before_ns=_UniffiConverterOptionalInt64.read(buf),
            last_activity_after_ns=_UniffiConverterOptionalInt64.read(buf),
            order_by=_UniffiConverterOptionalTypeFfiGroupQueryOrderBy.read(buf),
            limit=_UniffiConverterOptionalInt64.read(buf),
            consent_states=_UniffiConverterOptionalSequenceTypeFfiConsentState.read(buf),
            include_duplicate_dms=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalInt64.check_lower(value.created_after_ns)
        _UniffiConverterOptionalInt64.check_lower(value.created_before_ns)
        _UniffiConverterOptionalInt64.check_lower(value.last_activity_before_ns)
        _UniffiConverterOptionalInt64.check_lower(value.last_activity_after_ns)
        _UniffiConverterOptionalTypeFfiGroupQueryOrderBy.check_lower(value.order_by)
        _UniffiConverterOptionalInt64.check_lower(value.limit)
        _UniffiConverterOptionalSequenceTypeFfiConsentState.check_lower(value.consent_states)
        _UniffiConverterBool.check_lower(value.include_duplicate_dms)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalInt64.write(value.created_after_ns, buf)
        _UniffiConverterOptionalInt64.write(value.created_before_ns, buf)
        _UniffiConverterOptionalInt64.write(value.last_activity_before_ns, buf)
        _UniffiConverterOptionalInt64.write(value.last_activity_after_ns, buf)
        _UniffiConverterOptionalTypeFfiGroupQueryOrderBy.write(value.order_by, buf)
        _UniffiConverterOptionalInt64.write(value.limit, buf)
        _UniffiConverterOptionalSequenceTypeFfiConsentState.write(value.consent_states, buf)
        _UniffiConverterBool.write(value.include_duplicate_dms, buf)


class FfiListMessagesOptions:
    sent_before_ns: "typing.Optional[int]"
    sent_after_ns: "typing.Optional[int]"
    limit: "typing.Optional[int]"
    delivery_status: "typing.Optional[FfiDeliveryStatus]"
    direction: "typing.Optional[FfiDirection]"
    content_types: "typing.Optional[typing.List[FfiContentType]]"
    exclude_content_types: "typing.Optional[typing.List[FfiContentType]]"
    exclude_sender_inbox_ids: "typing.Optional[typing.List[str]]"
    sort_by: "typing.Optional[FfiSortBy]"
    inserted_after_ns: "typing.Optional[int]"
    inserted_before_ns: "typing.Optional[int]"
    def __init__(self, *, sent_before_ns: "typing.Optional[int]", sent_after_ns: "typing.Optional[int]", limit: "typing.Optional[int]", delivery_status: "typing.Optional[FfiDeliveryStatus]", direction: "typing.Optional[FfiDirection]", content_types: "typing.Optional[typing.List[FfiContentType]]", exclude_content_types: "typing.Optional[typing.List[FfiContentType]]", exclude_sender_inbox_ids: "typing.Optional[typing.List[str]]", sort_by: "typing.Optional[FfiSortBy]", inserted_after_ns: "typing.Optional[int]", inserted_before_ns: "typing.Optional[int]"):
        self.sent_before_ns = sent_before_ns
        self.sent_after_ns = sent_after_ns
        self.limit = limit
        self.delivery_status = delivery_status
        self.direction = direction
        self.content_types = content_types
        self.exclude_content_types = exclude_content_types
        self.exclude_sender_inbox_ids = exclude_sender_inbox_ids
        self.sort_by = sort_by
        self.inserted_after_ns = inserted_after_ns
        self.inserted_before_ns = inserted_before_ns

    def __str__(self):
        return "FfiListMessagesOptions(sent_before_ns={}, sent_after_ns={}, limit={}, delivery_status={}, direction={}, content_types={}, exclude_content_types={}, exclude_sender_inbox_ids={}, sort_by={}, inserted_after_ns={}, inserted_before_ns={})".format(self.sent_before_ns, self.sent_after_ns, self.limit, self.delivery_status, self.direction, self.content_types, self.exclude_content_types, self.exclude_sender_inbox_ids, self.sort_by, self.inserted_after_ns, self.inserted_before_ns)

    def __eq__(self, other):
        if self.sent_before_ns != other.sent_before_ns:
            return False
        if self.sent_after_ns != other.sent_after_ns:
            return False
        if self.limit != other.limit:
            return False
        if self.delivery_status != other.delivery_status:
            return False
        if self.direction != other.direction:
            return False
        if self.content_types != other.content_types:
            return False
        if self.exclude_content_types != other.exclude_content_types:
            return False
        if self.exclude_sender_inbox_ids != other.exclude_sender_inbox_ids:
            return False
        if self.sort_by != other.sort_by:
            return False
        if self.inserted_after_ns != other.inserted_after_ns:
            return False
        if self.inserted_before_ns != other.inserted_before_ns:
            return False
        return True

class _UniffiConverterTypeFfiListMessagesOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiListMessagesOptions(
            sent_before_ns=_UniffiConverterOptionalInt64.read(buf),
            sent_after_ns=_UniffiConverterOptionalInt64.read(buf),
            limit=_UniffiConverterOptionalInt64.read(buf),
            delivery_status=_UniffiConverterOptionalTypeFfiDeliveryStatus.read(buf),
            direction=_UniffiConverterOptionalTypeFfiDirection.read(buf),
            content_types=_UniffiConverterOptionalSequenceTypeFfiContentType.read(buf),
            exclude_content_types=_UniffiConverterOptionalSequenceTypeFfiContentType.read(buf),
            exclude_sender_inbox_ids=_UniffiConverterOptionalSequenceString.read(buf),
            sort_by=_UniffiConverterOptionalTypeFfiSortBy.read(buf),
            inserted_after_ns=_UniffiConverterOptionalInt64.read(buf),
            inserted_before_ns=_UniffiConverterOptionalInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalInt64.check_lower(value.sent_before_ns)
        _UniffiConverterOptionalInt64.check_lower(value.sent_after_ns)
        _UniffiConverterOptionalInt64.check_lower(value.limit)
        _UniffiConverterOptionalTypeFfiDeliveryStatus.check_lower(value.delivery_status)
        _UniffiConverterOptionalTypeFfiDirection.check_lower(value.direction)
        _UniffiConverterOptionalSequenceTypeFfiContentType.check_lower(value.content_types)
        _UniffiConverterOptionalSequenceTypeFfiContentType.check_lower(value.exclude_content_types)
        _UniffiConverterOptionalSequenceString.check_lower(value.exclude_sender_inbox_ids)
        _UniffiConverterOptionalTypeFfiSortBy.check_lower(value.sort_by)
        _UniffiConverterOptionalInt64.check_lower(value.inserted_after_ns)
        _UniffiConverterOptionalInt64.check_lower(value.inserted_before_ns)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalInt64.write(value.sent_before_ns, buf)
        _UniffiConverterOptionalInt64.write(value.sent_after_ns, buf)
        _UniffiConverterOptionalInt64.write(value.limit, buf)
        _UniffiConverterOptionalTypeFfiDeliveryStatus.write(value.delivery_status, buf)
        _UniffiConverterOptionalTypeFfiDirection.write(value.direction, buf)
        _UniffiConverterOptionalSequenceTypeFfiContentType.write(value.content_types, buf)
        _UniffiConverterOptionalSequenceTypeFfiContentType.write(value.exclude_content_types, buf)
        _UniffiConverterOptionalSequenceString.write(value.exclude_sender_inbox_ids, buf)
        _UniffiConverterOptionalTypeFfiSortBy.write(value.sort_by, buf)
        _UniffiConverterOptionalInt64.write(value.inserted_after_ns, buf)
        _UniffiConverterOptionalInt64.write(value.inserted_before_ns, buf)


class FfiMarkdownContent:
    content: "str"
    def __init__(self, *, content: "str"):
        self.content = content

    def __str__(self):
        return "FfiMarkdownContent(content={})".format(self.content)

    def __eq__(self, other):
        if self.content != other.content:
            return False
        return True

class _UniffiConverterTypeFfiMarkdownContent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiMarkdownContent(
            content=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.content)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.content, buf)


class FfiMessage:
    id: "bytes"
    sent_at_ns: "int"
    conversation_id: "bytes"
    sender_inbox_id: "str"
    content: "bytes"
    kind: "FfiConversationMessageKind"
    delivery_status: "FfiDeliveryStatus"
    sequence_id: "int"
    originator_id: "int"
    inserted_at_ns: "int"
    expire_at_ns: "typing.Optional[int]"
    def __init__(self, *, id: "bytes", sent_at_ns: "int", conversation_id: "bytes", sender_inbox_id: "str", content: "bytes", kind: "FfiConversationMessageKind", delivery_status: "FfiDeliveryStatus", sequence_id: "int", originator_id: "int", inserted_at_ns: "int", expire_at_ns: "typing.Optional[int]"):
        self.id = id
        self.sent_at_ns = sent_at_ns
        self.conversation_id = conversation_id
        self.sender_inbox_id = sender_inbox_id
        self.content = content
        self.kind = kind
        self.delivery_status = delivery_status
        self.sequence_id = sequence_id
        self.originator_id = originator_id
        self.inserted_at_ns = inserted_at_ns
        self.expire_at_ns = expire_at_ns

    def __str__(self):
        return "FfiMessage(id={}, sent_at_ns={}, conversation_id={}, sender_inbox_id={}, content={}, kind={}, delivery_status={}, sequence_id={}, originator_id={}, inserted_at_ns={}, expire_at_ns={})".format(self.id, self.sent_at_ns, self.conversation_id, self.sender_inbox_id, self.content, self.kind, self.delivery_status, self.sequence_id, self.originator_id, self.inserted_at_ns, self.expire_at_ns)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.sent_at_ns != other.sent_at_ns:
            return False
        if self.conversation_id != other.conversation_id:
            return False
        if self.sender_inbox_id != other.sender_inbox_id:
            return False
        if self.content != other.content:
            return False
        if self.kind != other.kind:
            return False
        if self.delivery_status != other.delivery_status:
            return False
        if self.sequence_id != other.sequence_id:
            return False
        if self.originator_id != other.originator_id:
            return False
        if self.inserted_at_ns != other.inserted_at_ns:
            return False
        if self.expire_at_ns != other.expire_at_ns:
            return False
        return True

class _UniffiConverterTypeFfiMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiMessage(
            id=_UniffiConverterBytes.read(buf),
            sent_at_ns=_UniffiConverterInt64.read(buf),
            conversation_id=_UniffiConverterBytes.read(buf),
            sender_inbox_id=_UniffiConverterString.read(buf),
            content=_UniffiConverterBytes.read(buf),
            kind=_UniffiConverterTypeFfiConversationMessageKind.read(buf),
            delivery_status=_UniffiConverterTypeFfiDeliveryStatus.read(buf),
            sequence_id=_UniffiConverterUInt64.read(buf),
            originator_id=_UniffiConverterUInt32.read(buf),
            inserted_at_ns=_UniffiConverterInt64.read(buf),
            expire_at_ns=_UniffiConverterOptionalInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.id)
        _UniffiConverterInt64.check_lower(value.sent_at_ns)
        _UniffiConverterBytes.check_lower(value.conversation_id)
        _UniffiConverterString.check_lower(value.sender_inbox_id)
        _UniffiConverterBytes.check_lower(value.content)
        _UniffiConverterTypeFfiConversationMessageKind.check_lower(value.kind)
        _UniffiConverterTypeFfiDeliveryStatus.check_lower(value.delivery_status)
        _UniffiConverterUInt64.check_lower(value.sequence_id)
        _UniffiConverterUInt32.check_lower(value.originator_id)
        _UniffiConverterInt64.check_lower(value.inserted_at_ns)
        _UniffiConverterOptionalInt64.check_lower(value.expire_at_ns)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.id, buf)
        _UniffiConverterInt64.write(value.sent_at_ns, buf)
        _UniffiConverterBytes.write(value.conversation_id, buf)
        _UniffiConverterString.write(value.sender_inbox_id, buf)
        _UniffiConverterBytes.write(value.content, buf)
        _UniffiConverterTypeFfiConversationMessageKind.write(value.kind, buf)
        _UniffiConverterTypeFfiDeliveryStatus.write(value.delivery_status, buf)
        _UniffiConverterUInt64.write(value.sequence_id, buf)
        _UniffiConverterUInt32.write(value.originator_id, buf)
        _UniffiConverterInt64.write(value.inserted_at_ns, buf)
        _UniffiConverterOptionalInt64.write(value.expire_at_ns, buf)


class FfiMessageDisappearingSettings:
    """
    Settings for disappearing messages in a conversation.

    # Fields

    * `from_ns` - The timestamp (in nanoseconds) from when messages should be tracked for deletion.
    * `in_ns` - The duration (in nanoseconds) after which tracked messages will be deleted.
    """

    from_ns: "int"
    in_ns: "int"
    def __init__(self, *, from_ns: "int", in_ns: "int"):
        self.from_ns = from_ns
        self.in_ns = in_ns

    def __str__(self):
        return "FfiMessageDisappearingSettings(from_ns={}, in_ns={})".format(self.from_ns, self.in_ns)

    def __eq__(self, other):
        if self.from_ns != other.from_ns:
            return False
        if self.in_ns != other.in_ns:
            return False
        return True

class _UniffiConverterTypeFfiMessageDisappearingSettings(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiMessageDisappearingSettings(
            from_ns=_UniffiConverterInt64.read(buf),
            in_ns=_UniffiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt64.check_lower(value.from_ns)
        _UniffiConverterInt64.check_lower(value.in_ns)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt64.write(value.from_ns, buf)
        _UniffiConverterInt64.write(value.in_ns, buf)


class FfiMessageMetadata:
    cursor: "FfiCursor"
    created_ns: "int"
    def __init__(self, *, cursor: "FfiCursor", created_ns: "int"):
        self.cursor = cursor
        self.created_ns = created_ns

    def __str__(self):
        return "FfiMessageMetadata(cursor={}, created_ns={})".format(self.cursor, self.created_ns)

    def __eq__(self, other):
        if self.cursor != other.cursor:
            return False
        if self.created_ns != other.created_ns:
            return False
        return True

class _UniffiConverterTypeFfiMessageMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiMessageMetadata(
            cursor=_UniffiConverterTypeFfiCursor.read(buf),
            created_ns=_UniffiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeFfiCursor.check_lower(value.cursor)
        _UniffiConverterInt64.check_lower(value.created_ns)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeFfiCursor.write(value.cursor, buf)
        _UniffiConverterInt64.write(value.created_ns, buf)


class FfiMessageWithReactions:
    message: "FfiMessage"
    reactions: "typing.List[FfiMessage]"
    def __init__(self, *, message: "FfiMessage", reactions: "typing.List[FfiMessage]"):
        self.message = message
        self.reactions = reactions

    def __str__(self):
        return "FfiMessageWithReactions(message={}, reactions={})".format(self.message, self.reactions)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        if self.reactions != other.reactions:
            return False
        return True

class _UniffiConverterTypeFfiMessageWithReactions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiMessageWithReactions(
            message=_UniffiConverterTypeFfiMessage.read(buf),
            reactions=_UniffiConverterSequenceTypeFfiMessage.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeFfiMessage.check_lower(value.message)
        _UniffiConverterSequenceTypeFfiMessage.check_lower(value.reactions)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeFfiMessage.write(value.message, buf)
        _UniffiConverterSequenceTypeFfiMessage.write(value.reactions, buf)


class FfiMetadataFieldChange:
    field_name: "str"
    old_value: "typing.Optional[str]"
    new_value: "typing.Optional[str]"
    def __init__(self, *, field_name: "str", old_value: "typing.Optional[str]", new_value: "typing.Optional[str]"):
        self.field_name = field_name
        self.old_value = old_value
        self.new_value = new_value

    def __str__(self):
        return "FfiMetadataFieldChange(field_name={}, old_value={}, new_value={})".format(self.field_name, self.old_value, self.new_value)

    def __eq__(self, other):
        if self.field_name != other.field_name:
            return False
        if self.old_value != other.old_value:
            return False
        if self.new_value != other.new_value:
            return False
        return True

class _UniffiConverterTypeFfiMetadataFieldChange(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiMetadataFieldChange(
            field_name=_UniffiConverterString.read(buf),
            old_value=_UniffiConverterOptionalString.read(buf),
            new_value=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.field_name)
        _UniffiConverterOptionalString.check_lower(value.old_value)
        _UniffiConverterOptionalString.check_lower(value.new_value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.field_name, buf)
        _UniffiConverterOptionalString.write(value.old_value, buf)
        _UniffiConverterOptionalString.write(value.new_value, buf)


class FfiMultiRemoteAttachment:
    attachments: "typing.List[FfiRemoteAttachmentInfo]"
    def __init__(self, *, attachments: "typing.List[FfiRemoteAttachmentInfo]"):
        self.attachments = attachments

    def __str__(self):
        return "FfiMultiRemoteAttachment(attachments={})".format(self.attachments)

    def __eq__(self, other):
        if self.attachments != other.attachments:
            return False
        return True

class _UniffiConverterTypeFfiMultiRemoteAttachment(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiMultiRemoteAttachment(
            attachments=_UniffiConverterSequenceTypeFfiRemoteAttachmentInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeFfiRemoteAttachmentInfo.check_lower(value.attachments)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeFfiRemoteAttachmentInfo.write(value.attachments, buf)


class FfiPasskeySignature:
    public_key: "bytes"
    signature: "bytes"
    authenticator_data: "bytes"
    client_data_json: "bytes"
    def __init__(self, *, public_key: "bytes", signature: "bytes", authenticator_data: "bytes", client_data_json: "bytes"):
        self.public_key = public_key
        self.signature = signature
        self.authenticator_data = authenticator_data
        self.client_data_json = client_data_json

    def __str__(self):
        return "FfiPasskeySignature(public_key={}, signature={}, authenticator_data={}, client_data_json={})".format(self.public_key, self.signature, self.authenticator_data, self.client_data_json)

    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        if self.signature != other.signature:
            return False
        if self.authenticator_data != other.authenticator_data:
            return False
        if self.client_data_json != other.client_data_json:
            return False
        return True

class _UniffiConverterTypeFfiPasskeySignature(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiPasskeySignature(
            public_key=_UniffiConverterBytes.read(buf),
            signature=_UniffiConverterBytes.read(buf),
            authenticator_data=_UniffiConverterBytes.read(buf),
            client_data_json=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.public_key)
        _UniffiConverterBytes.check_lower(value.signature)
        _UniffiConverterBytes.check_lower(value.authenticator_data)
        _UniffiConverterBytes.check_lower(value.client_data_json)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.public_key, buf)
        _UniffiConverterBytes.write(value.signature, buf)
        _UniffiConverterBytes.write(value.authenticator_data, buf)
        _UniffiConverterBytes.write(value.client_data_json, buf)


class FfiPermissionPolicySet:
    add_member_policy: "FfiPermissionPolicy"
    remove_member_policy: "FfiPermissionPolicy"
    add_admin_policy: "FfiPermissionPolicy"
    remove_admin_policy: "FfiPermissionPolicy"
    update_group_name_policy: "FfiPermissionPolicy"
    update_group_description_policy: "FfiPermissionPolicy"
    update_group_image_url_square_policy: "FfiPermissionPolicy"
    update_message_disappearing_policy: "FfiPermissionPolicy"
    update_app_data_policy: "FfiPermissionPolicy"
    def __init__(self, *, add_member_policy: "FfiPermissionPolicy", remove_member_policy: "FfiPermissionPolicy", add_admin_policy: "FfiPermissionPolicy", remove_admin_policy: "FfiPermissionPolicy", update_group_name_policy: "FfiPermissionPolicy", update_group_description_policy: "FfiPermissionPolicy", update_group_image_url_square_policy: "FfiPermissionPolicy", update_message_disappearing_policy: "FfiPermissionPolicy", update_app_data_policy: "FfiPermissionPolicy"):
        self.add_member_policy = add_member_policy
        self.remove_member_policy = remove_member_policy
        self.add_admin_policy = add_admin_policy
        self.remove_admin_policy = remove_admin_policy
        self.update_group_name_policy = update_group_name_policy
        self.update_group_description_policy = update_group_description_policy
        self.update_group_image_url_square_policy = update_group_image_url_square_policy
        self.update_message_disappearing_policy = update_message_disappearing_policy
        self.update_app_data_policy = update_app_data_policy

    def __str__(self):
        return "FfiPermissionPolicySet(add_member_policy={}, remove_member_policy={}, add_admin_policy={}, remove_admin_policy={}, update_group_name_policy={}, update_group_description_policy={}, update_group_image_url_square_policy={}, update_message_disappearing_policy={}, update_app_data_policy={})".format(self.add_member_policy, self.remove_member_policy, self.add_admin_policy, self.remove_admin_policy, self.update_group_name_policy, self.update_group_description_policy, self.update_group_image_url_square_policy, self.update_message_disappearing_policy, self.update_app_data_policy)

    def __eq__(self, other):
        if self.add_member_policy != other.add_member_policy:
            return False
        if self.remove_member_policy != other.remove_member_policy:
            return False
        if self.add_admin_policy != other.add_admin_policy:
            return False
        if self.remove_admin_policy != other.remove_admin_policy:
            return False
        if self.update_group_name_policy != other.update_group_name_policy:
            return False
        if self.update_group_description_policy != other.update_group_description_policy:
            return False
        if self.update_group_image_url_square_policy != other.update_group_image_url_square_policy:
            return False
        if self.update_message_disappearing_policy != other.update_message_disappearing_policy:
            return False
        if self.update_app_data_policy != other.update_app_data_policy:
            return False
        return True

class _UniffiConverterTypeFfiPermissionPolicySet(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiPermissionPolicySet(
            add_member_policy=_UniffiConverterTypeFfiPermissionPolicy.read(buf),
            remove_member_policy=_UniffiConverterTypeFfiPermissionPolicy.read(buf),
            add_admin_policy=_UniffiConverterTypeFfiPermissionPolicy.read(buf),
            remove_admin_policy=_UniffiConverterTypeFfiPermissionPolicy.read(buf),
            update_group_name_policy=_UniffiConverterTypeFfiPermissionPolicy.read(buf),
            update_group_description_policy=_UniffiConverterTypeFfiPermissionPolicy.read(buf),
            update_group_image_url_square_policy=_UniffiConverterTypeFfiPermissionPolicy.read(buf),
            update_message_disappearing_policy=_UniffiConverterTypeFfiPermissionPolicy.read(buf),
            update_app_data_policy=_UniffiConverterTypeFfiPermissionPolicy.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeFfiPermissionPolicy.check_lower(value.add_member_policy)
        _UniffiConverterTypeFfiPermissionPolicy.check_lower(value.remove_member_policy)
        _UniffiConverterTypeFfiPermissionPolicy.check_lower(value.add_admin_policy)
        _UniffiConverterTypeFfiPermissionPolicy.check_lower(value.remove_admin_policy)
        _UniffiConverterTypeFfiPermissionPolicy.check_lower(value.update_group_name_policy)
        _UniffiConverterTypeFfiPermissionPolicy.check_lower(value.update_group_description_policy)
        _UniffiConverterTypeFfiPermissionPolicy.check_lower(value.update_group_image_url_square_policy)
        _UniffiConverterTypeFfiPermissionPolicy.check_lower(value.update_message_disappearing_policy)
        _UniffiConverterTypeFfiPermissionPolicy.check_lower(value.update_app_data_policy)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeFfiPermissionPolicy.write(value.add_member_policy, buf)
        _UniffiConverterTypeFfiPermissionPolicy.write(value.remove_member_policy, buf)
        _UniffiConverterTypeFfiPermissionPolicy.write(value.add_admin_policy, buf)
        _UniffiConverterTypeFfiPermissionPolicy.write(value.remove_admin_policy, buf)
        _UniffiConverterTypeFfiPermissionPolicy.write(value.update_group_name_policy, buf)
        _UniffiConverterTypeFfiPermissionPolicy.write(value.update_group_description_policy, buf)
        _UniffiConverterTypeFfiPermissionPolicy.write(value.update_group_image_url_square_policy, buf)
        _UniffiConverterTypeFfiPermissionPolicy.write(value.update_message_disappearing_policy, buf)
        _UniffiConverterTypeFfiPermissionPolicy.write(value.update_app_data_policy, buf)


class FfiReactionPayload:
    reference: "str"
    reference_inbox_id: "str"
    action: "FfiReactionAction"
    content: "str"
    schema: "FfiReactionSchema"
    def __init__(self, *, reference: "str", reference_inbox_id: "str", action: "FfiReactionAction", content: "str", schema: "FfiReactionSchema"):
        self.reference = reference
        self.reference_inbox_id = reference_inbox_id
        self.action = action
        self.content = content
        self.schema = schema

    def __str__(self):
        return "FfiReactionPayload(reference={}, reference_inbox_id={}, action={}, content={}, schema={})".format(self.reference, self.reference_inbox_id, self.action, self.content, self.schema)

    def __eq__(self, other):
        if self.reference != other.reference:
            return False
        if self.reference_inbox_id != other.reference_inbox_id:
            return False
        if self.action != other.action:
            return False
        if self.content != other.content:
            return False
        if self.schema != other.schema:
            return False
        return True

class _UniffiConverterTypeFfiReactionPayload(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiReactionPayload(
            reference=_UniffiConverterString.read(buf),
            reference_inbox_id=_UniffiConverterString.read(buf),
            action=_UniffiConverterTypeFfiReactionAction.read(buf),
            content=_UniffiConverterString.read(buf),
            schema=_UniffiConverterTypeFfiReactionSchema.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.reference)
        _UniffiConverterString.check_lower(value.reference_inbox_id)
        _UniffiConverterTypeFfiReactionAction.check_lower(value.action)
        _UniffiConverterString.check_lower(value.content)
        _UniffiConverterTypeFfiReactionSchema.check_lower(value.schema)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.reference, buf)
        _UniffiConverterString.write(value.reference_inbox_id, buf)
        _UniffiConverterTypeFfiReactionAction.write(value.action, buf)
        _UniffiConverterString.write(value.content, buf)
        _UniffiConverterTypeFfiReactionSchema.write(value.schema, buf)


class FfiReadReceipt:

    def __str__(self):
        return "FfiReadReceipt()".format()

    def __eq__(self, other):
        return True

class _UniffiConverterTypeFfiReadReceipt(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiReadReceipt(
        )

    @staticmethod
    def check_lower(value):
        pass

    @staticmethod
    def write(value, buf):
        pass


class FfiRemoteAttachment:
    url: "str"
    content_digest: "str"
    secret: "bytes"
    salt: "bytes"
    nonce: "bytes"
    scheme: "str"
    content_length: "int"
    filename: "typing.Optional[str]"
    def __init__(self, *, url: "str", content_digest: "str", secret: "bytes", salt: "bytes", nonce: "bytes", scheme: "str", content_length: "int", filename: "typing.Optional[str]"):
        self.url = url
        self.content_digest = content_digest
        self.secret = secret
        self.salt = salt
        self.nonce = nonce
        self.scheme = scheme
        self.content_length = content_length
        self.filename = filename

    def __str__(self):
        return "FfiRemoteAttachment(url={}, content_digest={}, secret={}, salt={}, nonce={}, scheme={}, content_length={}, filename={})".format(self.url, self.content_digest, self.secret, self.salt, self.nonce, self.scheme, self.content_length, self.filename)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.content_digest != other.content_digest:
            return False
        if self.secret != other.secret:
            return False
        if self.salt != other.salt:
            return False
        if self.nonce != other.nonce:
            return False
        if self.scheme != other.scheme:
            return False
        if self.content_length != other.content_length:
            return False
        if self.filename != other.filename:
            return False
        return True

class _UniffiConverterTypeFfiRemoteAttachment(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiRemoteAttachment(
            url=_UniffiConverterString.read(buf),
            content_digest=_UniffiConverterString.read(buf),
            secret=_UniffiConverterBytes.read(buf),
            salt=_UniffiConverterBytes.read(buf),
            nonce=_UniffiConverterBytes.read(buf),
            scheme=_UniffiConverterString.read(buf),
            content_length=_UniffiConverterUInt32.read(buf),
            filename=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterString.check_lower(value.content_digest)
        _UniffiConverterBytes.check_lower(value.secret)
        _UniffiConverterBytes.check_lower(value.salt)
        _UniffiConverterBytes.check_lower(value.nonce)
        _UniffiConverterString.check_lower(value.scheme)
        _UniffiConverterUInt32.check_lower(value.content_length)
        _UniffiConverterOptionalString.check_lower(value.filename)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterString.write(value.content_digest, buf)
        _UniffiConverterBytes.write(value.secret, buf)
        _UniffiConverterBytes.write(value.salt, buf)
        _UniffiConverterBytes.write(value.nonce, buf)
        _UniffiConverterString.write(value.scheme, buf)
        _UniffiConverterUInt32.write(value.content_length, buf)
        _UniffiConverterOptionalString.write(value.filename, buf)


class FfiRemoteAttachmentInfo:
    url: "str"
    content_digest: "str"
    secret: "bytes"
    salt: "bytes"
    nonce: "bytes"
    scheme: "str"
    content_length: "typing.Optional[int]"
    filename: "typing.Optional[str]"
    def __init__(self, *, url: "str", content_digest: "str", secret: "bytes", salt: "bytes", nonce: "bytes", scheme: "str", content_length: "typing.Optional[int]", filename: "typing.Optional[str]"):
        self.url = url
        self.content_digest = content_digest
        self.secret = secret
        self.salt = salt
        self.nonce = nonce
        self.scheme = scheme
        self.content_length = content_length
        self.filename = filename

    def __str__(self):
        return "FfiRemoteAttachmentInfo(url={}, content_digest={}, secret={}, salt={}, nonce={}, scheme={}, content_length={}, filename={})".format(self.url, self.content_digest, self.secret, self.salt, self.nonce, self.scheme, self.content_length, self.filename)

    def __eq__(self, other):
        if self.url != other.url:
            return False
        if self.content_digest != other.content_digest:
            return False
        if self.secret != other.secret:
            return False
        if self.salt != other.salt:
            return False
        if self.nonce != other.nonce:
            return False
        if self.scheme != other.scheme:
            return False
        if self.content_length != other.content_length:
            return False
        if self.filename != other.filename:
            return False
        return True

class _UniffiConverterTypeFfiRemoteAttachmentInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiRemoteAttachmentInfo(
            url=_UniffiConverterString.read(buf),
            content_digest=_UniffiConverterString.read(buf),
            secret=_UniffiConverterBytes.read(buf),
            salt=_UniffiConverterBytes.read(buf),
            nonce=_UniffiConverterBytes.read(buf),
            scheme=_UniffiConverterString.read(buf),
            content_length=_UniffiConverterOptionalUInt32.read(buf),
            filename=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.url)
        _UniffiConverterString.check_lower(value.content_digest)
        _UniffiConverterBytes.check_lower(value.secret)
        _UniffiConverterBytes.check_lower(value.salt)
        _UniffiConverterBytes.check_lower(value.nonce)
        _UniffiConverterString.check_lower(value.scheme)
        _UniffiConverterOptionalUInt32.check_lower(value.content_length)
        _UniffiConverterOptionalString.check_lower(value.filename)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.url, buf)
        _UniffiConverterString.write(value.content_digest, buf)
        _UniffiConverterBytes.write(value.secret, buf)
        _UniffiConverterBytes.write(value.salt, buf)
        _UniffiConverterBytes.write(value.nonce, buf)
        _UniffiConverterString.write(value.scheme, buf)
        _UniffiConverterOptionalUInt32.write(value.content_length, buf)
        _UniffiConverterOptionalString.write(value.filename, buf)


class FfiReply:
    reference: "str"
    reference_inbox_id: "typing.Optional[str]"
    content: "FfiEncodedContent"
    def __init__(self, *, reference: "str", reference_inbox_id: "typing.Optional[str]", content: "FfiEncodedContent"):
        self.reference = reference
        self.reference_inbox_id = reference_inbox_id
        self.content = content

    def __str__(self):
        return "FfiReply(reference={}, reference_inbox_id={}, content={})".format(self.reference, self.reference_inbox_id, self.content)

    def __eq__(self, other):
        if self.reference != other.reference:
            return False
        if self.reference_inbox_id != other.reference_inbox_id:
            return False
        if self.content != other.content:
            return False
        return True

class _UniffiConverterTypeFfiReply(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiReply(
            reference=_UniffiConverterString.read(buf),
            reference_inbox_id=_UniffiConverterOptionalString.read(buf),
            content=_UniffiConverterTypeFfiEncodedContent.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.reference)
        _UniffiConverterOptionalString.check_lower(value.reference_inbox_id)
        _UniffiConverterTypeFfiEncodedContent.check_lower(value.content)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.reference, buf)
        _UniffiConverterOptionalString.write(value.reference_inbox_id, buf)
        _UniffiConverterTypeFfiEncodedContent.write(value.content, buf)


class FfiSendMessageOpts:
    should_push: "bool"
    def __init__(self, *, should_push: "bool"):
        self.should_push = should_push

    def __str__(self):
        return "FfiSendMessageOpts(should_push={})".format(self.should_push)

    def __eq__(self, other):
        if self.should_push != other.should_push:
            return False
        return True

class _UniffiConverterTypeFfiSendMessageOpts(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiSendMessageOpts(
            should_push=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.should_push)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.should_push, buf)


class FfiTextContent:
    content: "str"
    def __init__(self, *, content: "str"):
        self.content = content

    def __str__(self):
        return "FfiTextContent(content={})".format(self.content)

    def __eq__(self, other):
        if self.content != other.content:
            return False
        return True

class _UniffiConverterTypeFfiTextContent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiTextContent(
            content=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.content)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.content, buf)


class FfiTransactionMetadata:
    transaction_type: "str"
    currency: "str"
    amount: "float"
    decimals: "int"
    from_address: "str"
    to_address: "str"
    def __init__(self, *, transaction_type: "str", currency: "str", amount: "float", decimals: "int", from_address: "str", to_address: "str"):
        self.transaction_type = transaction_type
        self.currency = currency
        self.amount = amount
        self.decimals = decimals
        self.from_address = from_address
        self.to_address = to_address

    def __str__(self):
        return "FfiTransactionMetadata(transaction_type={}, currency={}, amount={}, decimals={}, from_address={}, to_address={})".format(self.transaction_type, self.currency, self.amount, self.decimals, self.from_address, self.to_address)

    def __eq__(self, other):
        if self.transaction_type != other.transaction_type:
            return False
        if self.currency != other.currency:
            return False
        if self.amount != other.amount:
            return False
        if self.decimals != other.decimals:
            return False
        if self.from_address != other.from_address:
            return False
        if self.to_address != other.to_address:
            return False
        return True

class _UniffiConverterTypeFfiTransactionMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiTransactionMetadata(
            transaction_type=_UniffiConverterString.read(buf),
            currency=_UniffiConverterString.read(buf),
            amount=_UniffiConverterDouble.read(buf),
            decimals=_UniffiConverterUInt32.read(buf),
            from_address=_UniffiConverterString.read(buf),
            to_address=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.transaction_type)
        _UniffiConverterString.check_lower(value.currency)
        _UniffiConverterDouble.check_lower(value.amount)
        _UniffiConverterUInt32.check_lower(value.decimals)
        _UniffiConverterString.check_lower(value.from_address)
        _UniffiConverterString.check_lower(value.to_address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.transaction_type, buf)
        _UniffiConverterString.write(value.currency, buf)
        _UniffiConverterDouble.write(value.amount, buf)
        _UniffiConverterUInt32.write(value.decimals, buf)
        _UniffiConverterString.write(value.from_address, buf)
        _UniffiConverterString.write(value.to_address, buf)


class FfiTransactionReference:
    namespace: "typing.Optional[str]"
    network_id: "str"
    reference: "str"
    metadata: "typing.Optional[FfiTransactionMetadata]"
    def __init__(self, *, namespace: "typing.Optional[str]", network_id: "str", reference: "str", metadata: "typing.Optional[FfiTransactionMetadata]"):
        self.namespace = namespace
        self.network_id = network_id
        self.reference = reference
        self.metadata = metadata

    def __str__(self):
        return "FfiTransactionReference(namespace={}, network_id={}, reference={}, metadata={})".format(self.namespace, self.network_id, self.reference, self.metadata)

    def __eq__(self, other):
        if self.namespace != other.namespace:
            return False
        if self.network_id != other.network_id:
            return False
        if self.reference != other.reference:
            return False
        if self.metadata != other.metadata:
            return False
        return True

class _UniffiConverterTypeFfiTransactionReference(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiTransactionReference(
            namespace=_UniffiConverterOptionalString.read(buf),
            network_id=_UniffiConverterString.read(buf),
            reference=_UniffiConverterString.read(buf),
            metadata=_UniffiConverterOptionalTypeFfiTransactionMetadata.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.namespace)
        _UniffiConverterString.check_lower(value.network_id)
        _UniffiConverterString.check_lower(value.reference)
        _UniffiConverterOptionalTypeFfiTransactionMetadata.check_lower(value.metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.namespace, buf)
        _UniffiConverterString.write(value.network_id, buf)
        _UniffiConverterString.write(value.reference, buf)
        _UniffiConverterOptionalTypeFfiTransactionMetadata.write(value.metadata, buf)


class FfiUpdateGroupMembershipResult:
    added_members: "dict[str, int]"
    removed_members: "typing.List[str]"
    failed_installations: "typing.List[bytes]"
    def __init__(self, *, added_members: "dict[str, int]", removed_members: "typing.List[str]", failed_installations: "typing.List[bytes]"):
        self.added_members = added_members
        self.removed_members = removed_members
        self.failed_installations = failed_installations

    def __str__(self):
        return "FfiUpdateGroupMembershipResult(added_members={}, removed_members={}, failed_installations={})".format(self.added_members, self.removed_members, self.failed_installations)

    def __eq__(self, other):
        if self.added_members != other.added_members:
            return False
        if self.removed_members != other.removed_members:
            return False
        if self.failed_installations != other.failed_installations:
            return False
        return True

class _UniffiConverterTypeFfiUpdateGroupMembershipResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiUpdateGroupMembershipResult(
            added_members=_UniffiConverterMapStringUInt64.read(buf),
            removed_members=_UniffiConverterSequenceString.read(buf),
            failed_installations=_UniffiConverterSequenceBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterMapStringUInt64.check_lower(value.added_members)
        _UniffiConverterSequenceString.check_lower(value.removed_members)
        _UniffiConverterSequenceBytes.check_lower(value.failed_installations)

    @staticmethod
    def write(value, buf):
        _UniffiConverterMapStringUInt64.write(value.added_members, buf)
        _UniffiConverterSequenceString.write(value.removed_members, buf)
        _UniffiConverterSequenceBytes.write(value.failed_installations, buf)


class FfiWalletCall:
    to: "typing.Optional[str]"
    data: "typing.Optional[str]"
    value: "typing.Optional[str]"
    gas: "typing.Optional[str]"
    metadata: "typing.Optional[FfiWalletCallMetadata]"
    def __init__(self, *, to: "typing.Optional[str]", data: "typing.Optional[str]", value: "typing.Optional[str]", gas: "typing.Optional[str]", metadata: "typing.Optional[FfiWalletCallMetadata]"):
        self.to = to
        self.data = data
        self.value = value
        self.gas = gas
        self.metadata = metadata

    def __str__(self):
        return "FfiWalletCall(to={}, data={}, value={}, gas={}, metadata={})".format(self.to, self.data, self.value, self.gas, self.metadata)

    def __eq__(self, other):
        if self.to != other.to:
            return False
        if self.data != other.data:
            return False
        if self.value != other.value:
            return False
        if self.gas != other.gas:
            return False
        if self.metadata != other.metadata:
            return False
        return True

class _UniffiConverterTypeFfiWalletCall(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiWalletCall(
            to=_UniffiConverterOptionalString.read(buf),
            data=_UniffiConverterOptionalString.read(buf),
            value=_UniffiConverterOptionalString.read(buf),
            gas=_UniffiConverterOptionalString.read(buf),
            metadata=_UniffiConverterOptionalTypeFfiWalletCallMetadata.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.to)
        _UniffiConverterOptionalString.check_lower(value.data)
        _UniffiConverterOptionalString.check_lower(value.value)
        _UniffiConverterOptionalString.check_lower(value.gas)
        _UniffiConverterOptionalTypeFfiWalletCallMetadata.check_lower(value.metadata)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.to, buf)
        _UniffiConverterOptionalString.write(value.data, buf)
        _UniffiConverterOptionalString.write(value.value, buf)
        _UniffiConverterOptionalString.write(value.gas, buf)
        _UniffiConverterOptionalTypeFfiWalletCallMetadata.write(value.metadata, buf)


class FfiWalletCallMetadata:
    description: "str"
    transaction_type: "str"
    extra: "dict[str, str]"
    def __init__(self, *, description: "str", transaction_type: "str", extra: "dict[str, str]"):
        self.description = description
        self.transaction_type = transaction_type
        self.extra = extra

    def __str__(self):
        return "FfiWalletCallMetadata(description={}, transaction_type={}, extra={})".format(self.description, self.transaction_type, self.extra)

    def __eq__(self, other):
        if self.description != other.description:
            return False
        if self.transaction_type != other.transaction_type:
            return False
        if self.extra != other.extra:
            return False
        return True

class _UniffiConverterTypeFfiWalletCallMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiWalletCallMetadata(
            description=_UniffiConverterString.read(buf),
            transaction_type=_UniffiConverterString.read(buf),
            extra=_UniffiConverterMapStringString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.description)
        _UniffiConverterString.check_lower(value.transaction_type)
        _UniffiConverterMapStringString.check_lower(value.extra)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.description, buf)
        _UniffiConverterString.write(value.transaction_type, buf)
        _UniffiConverterMapStringString.write(value.extra, buf)


class FfiWalletSendCalls:
    version: "str"
    chain_id: "str"
    _from: "str"
    calls: "typing.List[FfiWalletCall]"
    capabilities: "typing.Optional[dict[str, str]]"
    def __init__(self, *, version: "str", chain_id: "str", _from: "str", calls: "typing.List[FfiWalletCall]", capabilities: "typing.Optional[dict[str, str]]"):
        self.version = version
        self.chain_id = chain_id
        self._from = _from
        self.calls = calls
        self.capabilities = capabilities

    def __str__(self):
        return "FfiWalletSendCalls(version={}, chain_id={}, _from={}, calls={}, capabilities={})".format(self.version, self.chain_id, self._from, self.calls, self.capabilities)

    def __eq__(self, other):
        if self.version != other.version:
            return False
        if self.chain_id != other.chain_id:
            return False
        if self._from != other._from:
            return False
        if self.calls != other.calls:
            return False
        if self.capabilities != other.capabilities:
            return False
        return True

class _UniffiConverterTypeFfiWalletSendCalls(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FfiWalletSendCalls(
            version=_UniffiConverterString.read(buf),
            chain_id=_UniffiConverterString.read(buf),
            _from=_UniffiConverterString.read(buf),
            calls=_UniffiConverterSequenceTypeFfiWalletCall.read(buf),
            capabilities=_UniffiConverterOptionalMapStringString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.version)
        _UniffiConverterString.check_lower(value.chain_id)
        _UniffiConverterString.check_lower(value._from)
        _UniffiConverterSequenceTypeFfiWalletCall.check_lower(value.calls)
        _UniffiConverterOptionalMapStringString.check_lower(value.capabilities)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.version, buf)
        _UniffiConverterString.write(value.chain_id, buf)
        _UniffiConverterString.write(value._from, buf)
        _UniffiConverterSequenceTypeFfiWalletCall.write(value.calls, buf)
        _UniffiConverterOptionalMapStringString.write(value.capabilities, buf)





class FfiActionStyle(enum.Enum):
    PRIMARY = 0
    
    SECONDARY = 1
    
    DANGER = 2
    


class _UniffiConverterTypeFfiActionStyle(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiActionStyle.PRIMARY
        if variant == 2:
            return FfiActionStyle.SECONDARY
        if variant == 3:
            return FfiActionStyle.DANGER
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiActionStyle.PRIMARY:
            return
        if value == FfiActionStyle.SECONDARY:
            return
        if value == FfiActionStyle.DANGER:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiActionStyle.PRIMARY:
            buf.write_i32(1)
        if value == FfiActionStyle.SECONDARY:
            buf.write_i32(2)
        if value == FfiActionStyle.DANGER:
            buf.write_i32(3)







class FfiBackupElementSelection(enum.Enum):
    MESSAGES = 0
    
    CONSENT = 1
    


class _UniffiConverterTypeFfiBackupElementSelection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiBackupElementSelection.MESSAGES
        if variant == 2:
            return FfiBackupElementSelection.CONSENT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiBackupElementSelection.MESSAGES:
            return
        if value == FfiBackupElementSelection.CONSENT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiBackupElementSelection.MESSAGES:
            buf.write_i32(1)
        if value == FfiBackupElementSelection.CONSENT:
            buf.write_i32(2)







class FfiClientMode(enum.Enum):
    DEFAULT = 0
    
    NOTIFICATION = 1
    


class _UniffiConverterTypeFfiClientMode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiClientMode.DEFAULT
        if variant == 2:
            return FfiClientMode.NOTIFICATION
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiClientMode.DEFAULT:
            return
        if value == FfiClientMode.NOTIFICATION:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiClientMode.DEFAULT:
            buf.write_i32(1)
        if value == FfiClientMode.NOTIFICATION:
            buf.write_i32(2)







class FfiConsentEntityType(enum.Enum):
    CONVERSATION_ID = 0
    
    INBOX_ID = 1
    


class _UniffiConverterTypeFfiConsentEntityType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiConsentEntityType.CONVERSATION_ID
        if variant == 2:
            return FfiConsentEntityType.INBOX_ID
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiConsentEntityType.CONVERSATION_ID:
            return
        if value == FfiConsentEntityType.INBOX_ID:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiConsentEntityType.CONVERSATION_ID:
            buf.write_i32(1)
        if value == FfiConsentEntityType.INBOX_ID:
            buf.write_i32(2)







class FfiConsentState(enum.Enum):
    UNKNOWN = 0
    
    ALLOWED = 1
    
    DENIED = 2
    


class _UniffiConverterTypeFfiConsentState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiConsentState.UNKNOWN
        if variant == 2:
            return FfiConsentState.ALLOWED
        if variant == 3:
            return FfiConsentState.DENIED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiConsentState.UNKNOWN:
            return
        if value == FfiConsentState.ALLOWED:
            return
        if value == FfiConsentState.DENIED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiConsentState.UNKNOWN:
            buf.write_i32(1)
        if value == FfiConsentState.ALLOWED:
            buf.write_i32(2)
        if value == FfiConsentState.DENIED:
            buf.write_i32(3)







class FfiContentType(enum.Enum):
    UNKNOWN = 0
    
    TEXT = 1
    
    GROUP_MEMBERSHIP_CHANGE = 2
    
    GROUP_UPDATED = 3
    
    REACTION = 4
    
    READ_RECEIPT = 5
    
    REPLY = 6
    
    ATTACHMENT = 7
    
    REMOTE_ATTACHMENT = 8
    
    TRANSACTION_REFERENCE = 9
    
    WALLET_SEND_CALLS = 10
    
    LEAVE_REQUEST = 11
    
    MARKDOWN = 12
    
    ACTIONS = 13
    
    INTENT = 14
    
    MULTI_REMOTE_ATTACHMENT = 15
    


class _UniffiConverterTypeFfiContentType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiContentType.UNKNOWN
        if variant == 2:
            return FfiContentType.TEXT
        if variant == 3:
            return FfiContentType.GROUP_MEMBERSHIP_CHANGE
        if variant == 4:
            return FfiContentType.GROUP_UPDATED
        if variant == 5:
            return FfiContentType.REACTION
        if variant == 6:
            return FfiContentType.READ_RECEIPT
        if variant == 7:
            return FfiContentType.REPLY
        if variant == 8:
            return FfiContentType.ATTACHMENT
        if variant == 9:
            return FfiContentType.REMOTE_ATTACHMENT
        if variant == 10:
            return FfiContentType.TRANSACTION_REFERENCE
        if variant == 11:
            return FfiContentType.WALLET_SEND_CALLS
        if variant == 12:
            return FfiContentType.LEAVE_REQUEST
        if variant == 13:
            return FfiContentType.MARKDOWN
        if variant == 14:
            return FfiContentType.ACTIONS
        if variant == 15:
            return FfiContentType.INTENT
        if variant == 16:
            return FfiContentType.MULTI_REMOTE_ATTACHMENT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiContentType.UNKNOWN:
            return
        if value == FfiContentType.TEXT:
            return
        if value == FfiContentType.GROUP_MEMBERSHIP_CHANGE:
            return
        if value == FfiContentType.GROUP_UPDATED:
            return
        if value == FfiContentType.REACTION:
            return
        if value == FfiContentType.READ_RECEIPT:
            return
        if value == FfiContentType.REPLY:
            return
        if value == FfiContentType.ATTACHMENT:
            return
        if value == FfiContentType.REMOTE_ATTACHMENT:
            return
        if value == FfiContentType.TRANSACTION_REFERENCE:
            return
        if value == FfiContentType.WALLET_SEND_CALLS:
            return
        if value == FfiContentType.LEAVE_REQUEST:
            return
        if value == FfiContentType.MARKDOWN:
            return
        if value == FfiContentType.ACTIONS:
            return
        if value == FfiContentType.INTENT:
            return
        if value == FfiContentType.MULTI_REMOTE_ATTACHMENT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiContentType.UNKNOWN:
            buf.write_i32(1)
        if value == FfiContentType.TEXT:
            buf.write_i32(2)
        if value == FfiContentType.GROUP_MEMBERSHIP_CHANGE:
            buf.write_i32(3)
        if value == FfiContentType.GROUP_UPDATED:
            buf.write_i32(4)
        if value == FfiContentType.REACTION:
            buf.write_i32(5)
        if value == FfiContentType.READ_RECEIPT:
            buf.write_i32(6)
        if value == FfiContentType.REPLY:
            buf.write_i32(7)
        if value == FfiContentType.ATTACHMENT:
            buf.write_i32(8)
        if value == FfiContentType.REMOTE_ATTACHMENT:
            buf.write_i32(9)
        if value == FfiContentType.TRANSACTION_REFERENCE:
            buf.write_i32(10)
        if value == FfiContentType.WALLET_SEND_CALLS:
            buf.write_i32(11)
        if value == FfiContentType.LEAVE_REQUEST:
            buf.write_i32(12)
        if value == FfiContentType.MARKDOWN:
            buf.write_i32(13)
        if value == FfiContentType.ACTIONS:
            buf.write_i32(14)
        if value == FfiContentType.INTENT:
            buf.write_i32(15)
        if value == FfiContentType.MULTI_REMOTE_ATTACHMENT:
            buf.write_i32(16)







class FfiConversationMessageKind(enum.Enum):
    APPLICATION = 0
    
    MEMBERSHIP_CHANGE = 1
    


class _UniffiConverterTypeFfiConversationMessageKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiConversationMessageKind.APPLICATION
        if variant == 2:
            return FfiConversationMessageKind.MEMBERSHIP_CHANGE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiConversationMessageKind.APPLICATION:
            return
        if value == FfiConversationMessageKind.MEMBERSHIP_CHANGE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiConversationMessageKind.APPLICATION:
            buf.write_i32(1)
        if value == FfiConversationMessageKind.MEMBERSHIP_CHANGE:
            buf.write_i32(2)







class FfiConversationType(enum.Enum):
    GROUP = 0
    
    DM = 1
    
    SYNC = 2
    
    ONESHOT = 3
    


class _UniffiConverterTypeFfiConversationType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiConversationType.GROUP
        if variant == 2:
            return FfiConversationType.DM
        if variant == 3:
            return FfiConversationType.SYNC
        if variant == 4:
            return FfiConversationType.ONESHOT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiConversationType.GROUP:
            return
        if value == FfiConversationType.DM:
            return
        if value == FfiConversationType.SYNC:
            return
        if value == FfiConversationType.ONESHOT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiConversationType.GROUP:
            buf.write_i32(1)
        if value == FfiConversationType.DM:
            buf.write_i32(2)
        if value == FfiConversationType.SYNC:
            buf.write_i32(3)
        if value == FfiConversationType.ONESHOT:
            buf.write_i32(4)




# FfiCryptoError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class FfiCryptoError(Exception):
    pass

_UniffiTempFfiCryptoError = FfiCryptoError

class FfiCryptoError:  # type: ignore
    class InvalidLength(_UniffiTempFfiCryptoError):
        def __init__(self):
            pass

        def __repr__(self):
            return "FfiCryptoError.InvalidLength({})".format(str(self))
    _UniffiTempFfiCryptoError.InvalidLength = InvalidLength # type: ignore
    class InvalidKey(_UniffiTempFfiCryptoError):
        def __init__(self):
            pass

        def __repr__(self):
            return "FfiCryptoError.InvalidKey({})".format(str(self))
    _UniffiTempFfiCryptoError.InvalidKey = InvalidKey # type: ignore
    class SignFailure(_UniffiTempFfiCryptoError):
        def __init__(self):
            pass

        def __repr__(self):
            return "FfiCryptoError.SignFailure({})".format(str(self))
    _UniffiTempFfiCryptoError.SignFailure = SignFailure # type: ignore
    class DecompressFailure(_UniffiTempFfiCryptoError):
        def __init__(self):
            pass

        def __repr__(self):
            return "FfiCryptoError.DecompressFailure({})".format(str(self))
    _UniffiTempFfiCryptoError.DecompressFailure = DecompressFailure # type: ignore

FfiCryptoError = _UniffiTempFfiCryptoError # type: ignore
del _UniffiTempFfiCryptoError


class _UniffiConverterTypeFfiCryptoError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiCryptoError.InvalidLength(
            )
        if variant == 2:
            return FfiCryptoError.InvalidKey(
            )
        if variant == 3:
            return FfiCryptoError.SignFailure(
            )
        if variant == 4:
            return FfiCryptoError.DecompressFailure(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, FfiCryptoError.InvalidLength):
            return
        if isinstance(value, FfiCryptoError.InvalidKey):
            return
        if isinstance(value, FfiCryptoError.SignFailure):
            return
        if isinstance(value, FfiCryptoError.DecompressFailure):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, FfiCryptoError.InvalidLength):
            buf.write_i32(1)
        if isinstance(value, FfiCryptoError.InvalidKey):
            buf.write_i32(2)
        if isinstance(value, FfiCryptoError.SignFailure):
            buf.write_i32(3)
        if isinstance(value, FfiCryptoError.DecompressFailure):
            buf.write_i32(4)





class FfiDecodedMessageBody:
    def __init__(self):
        raise RuntimeError("FfiDecodedMessageBody cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class TEXT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.TEXT{self._values!r}"

        def __eq__(self, other):
            if not other.is_TEXT():
                return False
            return self._values == other._values
    class MARKDOWN:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.MARKDOWN{self._values!r}"

        def __eq__(self, other):
            if not other.is_MARKDOWN():
                return False
            return self._values == other._values
    class REACTION:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.REACTION{self._values!r}"

        def __eq__(self, other):
            if not other.is_REACTION():
                return False
            return self._values == other._values
    class ATTACHMENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.ATTACHMENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_ATTACHMENT():
                return False
            return self._values == other._values
    class REMOTE_ATTACHMENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.REMOTE_ATTACHMENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_REMOTE_ATTACHMENT():
                return False
            return self._values == other._values
    class MULTI_REMOTE_ATTACHMENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.MULTI_REMOTE_ATTACHMENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_MULTI_REMOTE_ATTACHMENT():
                return False
            return self._values == other._values
    class TRANSACTION_REFERENCE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.TRANSACTION_REFERENCE{self._values!r}"

        def __eq__(self, other):
            if not other.is_TRANSACTION_REFERENCE():
                return False
            return self._values == other._values
    class GROUP_UPDATED:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.GROUP_UPDATED{self._values!r}"

        def __eq__(self, other):
            if not other.is_GROUP_UPDATED():
                return False
            return self._values == other._values
    class READ_RECEIPT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.READ_RECEIPT{self._values!r}"

        def __eq__(self, other):
            if not other.is_READ_RECEIPT():
                return False
            return self._values == other._values
    class WALLET_SEND_CALLS:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.WALLET_SEND_CALLS{self._values!r}"

        def __eq__(self, other):
            if not other.is_WALLET_SEND_CALLS():
                return False
            return self._values == other._values
    class INTENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.INTENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_INTENT():
                return False
            return self._values == other._values
    class ACTIONS:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.ACTIONS{self._values!r}"

        def __eq__(self, other):
            if not other.is_ACTIONS():
                return False
            return self._values == other._values
    class LEAVE_REQUEST:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.LEAVE_REQUEST{self._values!r}"

        def __eq__(self, other):
            if not other.is_LEAVE_REQUEST():
                return False
            return self._values == other._values
    class CUSTOM:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageBody.CUSTOM{self._values!r}"

        def __eq__(self, other):
            if not other.is_CUSTOM():
                return False
            return self._values == other._values
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_TEXT(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.TEXT)
    def is_text(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.TEXT)
    def is_MARKDOWN(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.MARKDOWN)
    def is_markdown(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.MARKDOWN)
    def is_REACTION(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.REACTION)
    def is_reaction(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.REACTION)
    def is_ATTACHMENT(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.ATTACHMENT)
    def is_attachment(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.ATTACHMENT)
    def is_REMOTE_ATTACHMENT(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.REMOTE_ATTACHMENT)
    def is_remote_attachment(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.REMOTE_ATTACHMENT)
    def is_MULTI_REMOTE_ATTACHMENT(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.MULTI_REMOTE_ATTACHMENT)
    def is_multi_remote_attachment(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.MULTI_REMOTE_ATTACHMENT)
    def is_TRANSACTION_REFERENCE(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.TRANSACTION_REFERENCE)
    def is_transaction_reference(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.TRANSACTION_REFERENCE)
    def is_GROUP_UPDATED(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.GROUP_UPDATED)
    def is_group_updated(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.GROUP_UPDATED)
    def is_READ_RECEIPT(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.READ_RECEIPT)
    def is_read_receipt(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.READ_RECEIPT)
    def is_WALLET_SEND_CALLS(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.WALLET_SEND_CALLS)
    def is_wallet_send_calls(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.WALLET_SEND_CALLS)
    def is_INTENT(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.INTENT)
    def is_intent(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.INTENT)
    def is_ACTIONS(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.ACTIONS)
    def is_actions(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.ACTIONS)
    def is_LEAVE_REQUEST(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.LEAVE_REQUEST)
    def is_leave_request(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.LEAVE_REQUEST)
    def is_CUSTOM(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.CUSTOM)
    def is_custom(self) -> bool:
        return isinstance(self, FfiDecodedMessageBody.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiDecodedMessageBody.TEXT = type("FfiDecodedMessageBody.TEXT", (FfiDecodedMessageBody.TEXT, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.MARKDOWN = type("FfiDecodedMessageBody.MARKDOWN", (FfiDecodedMessageBody.MARKDOWN, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.REACTION = type("FfiDecodedMessageBody.REACTION", (FfiDecodedMessageBody.REACTION, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.ATTACHMENT = type("FfiDecodedMessageBody.ATTACHMENT", (FfiDecodedMessageBody.ATTACHMENT, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.REMOTE_ATTACHMENT = type("FfiDecodedMessageBody.REMOTE_ATTACHMENT", (FfiDecodedMessageBody.REMOTE_ATTACHMENT, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.MULTI_REMOTE_ATTACHMENT = type("FfiDecodedMessageBody.MULTI_REMOTE_ATTACHMENT", (FfiDecodedMessageBody.MULTI_REMOTE_ATTACHMENT, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.TRANSACTION_REFERENCE = type("FfiDecodedMessageBody.TRANSACTION_REFERENCE", (FfiDecodedMessageBody.TRANSACTION_REFERENCE, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.GROUP_UPDATED = type("FfiDecodedMessageBody.GROUP_UPDATED", (FfiDecodedMessageBody.GROUP_UPDATED, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.READ_RECEIPT = type("FfiDecodedMessageBody.READ_RECEIPT", (FfiDecodedMessageBody.READ_RECEIPT, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.WALLET_SEND_CALLS = type("FfiDecodedMessageBody.WALLET_SEND_CALLS", (FfiDecodedMessageBody.WALLET_SEND_CALLS, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.INTENT = type("FfiDecodedMessageBody.INTENT", (FfiDecodedMessageBody.INTENT, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.ACTIONS = type("FfiDecodedMessageBody.ACTIONS", (FfiDecodedMessageBody.ACTIONS, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.LEAVE_REQUEST = type("FfiDecodedMessageBody.LEAVE_REQUEST", (FfiDecodedMessageBody.LEAVE_REQUEST, FfiDecodedMessageBody,), {})  # type: ignore
FfiDecodedMessageBody.CUSTOM = type("FfiDecodedMessageBody.CUSTOM", (FfiDecodedMessageBody.CUSTOM, FfiDecodedMessageBody,), {})  # type: ignore




class _UniffiConverterTypeFfiDecodedMessageBody(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiDecodedMessageBody.TEXT(
                _UniffiConverterTypeFfiTextContent.read(buf),
            )
        if variant == 2:
            return FfiDecodedMessageBody.MARKDOWN(
                _UniffiConverterTypeFfiMarkdownContent.read(buf),
            )
        if variant == 3:
            return FfiDecodedMessageBody.REACTION(
                _UniffiConverterTypeFfiReactionPayload.read(buf),
            )
        if variant == 4:
            return FfiDecodedMessageBody.ATTACHMENT(
                _UniffiConverterTypeFfiAttachment.read(buf),
            )
        if variant == 5:
            return FfiDecodedMessageBody.REMOTE_ATTACHMENT(
                _UniffiConverterTypeFfiRemoteAttachment.read(buf),
            )
        if variant == 6:
            return FfiDecodedMessageBody.MULTI_REMOTE_ATTACHMENT(
                _UniffiConverterTypeFfiMultiRemoteAttachment.read(buf),
            )
        if variant == 7:
            return FfiDecodedMessageBody.TRANSACTION_REFERENCE(
                _UniffiConverterTypeFfiTransactionReference.read(buf),
            )
        if variant == 8:
            return FfiDecodedMessageBody.GROUP_UPDATED(
                _UniffiConverterTypeFfiGroupUpdated.read(buf),
            )
        if variant == 9:
            return FfiDecodedMessageBody.READ_RECEIPT(
                _UniffiConverterTypeFfiReadReceipt.read(buf),
            )
        if variant == 10:
            return FfiDecodedMessageBody.WALLET_SEND_CALLS(
                _UniffiConverterTypeFfiWalletSendCalls.read(buf),
            )
        if variant == 11:
            return FfiDecodedMessageBody.INTENT(
                _UniffiConverterTypeFfiIntent.read(buf),
            )
        if variant == 12:
            return FfiDecodedMessageBody.ACTIONS(
                _UniffiConverterTypeFfiActions.read(buf),
            )
        if variant == 13:
            return FfiDecodedMessageBody.LEAVE_REQUEST(
                _UniffiConverterTypeFfiLeaveRequest.read(buf),
            )
        if variant == 14:
            return FfiDecodedMessageBody.CUSTOM(
                _UniffiConverterTypeFfiEncodedContent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_TEXT():
            _UniffiConverterTypeFfiTextContent.check_lower(value._values[0])
            return
        if value.is_MARKDOWN():
            _UniffiConverterTypeFfiMarkdownContent.check_lower(value._values[0])
            return
        if value.is_REACTION():
            _UniffiConverterTypeFfiReactionPayload.check_lower(value._values[0])
            return
        if value.is_ATTACHMENT():
            _UniffiConverterTypeFfiAttachment.check_lower(value._values[0])
            return
        if value.is_REMOTE_ATTACHMENT():
            _UniffiConverterTypeFfiRemoteAttachment.check_lower(value._values[0])
            return
        if value.is_MULTI_REMOTE_ATTACHMENT():
            _UniffiConverterTypeFfiMultiRemoteAttachment.check_lower(value._values[0])
            return
        if value.is_TRANSACTION_REFERENCE():
            _UniffiConverterTypeFfiTransactionReference.check_lower(value._values[0])
            return
        if value.is_GROUP_UPDATED():
            _UniffiConverterTypeFfiGroupUpdated.check_lower(value._values[0])
            return
        if value.is_READ_RECEIPT():
            _UniffiConverterTypeFfiReadReceipt.check_lower(value._values[0])
            return
        if value.is_WALLET_SEND_CALLS():
            _UniffiConverterTypeFfiWalletSendCalls.check_lower(value._values[0])
            return
        if value.is_INTENT():
            _UniffiConverterTypeFfiIntent.check_lower(value._values[0])
            return
        if value.is_ACTIONS():
            _UniffiConverterTypeFfiActions.check_lower(value._values[0])
            return
        if value.is_LEAVE_REQUEST():
            _UniffiConverterTypeFfiLeaveRequest.check_lower(value._values[0])
            return
        if value.is_CUSTOM():
            _UniffiConverterTypeFfiEncodedContent.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_TEXT():
            buf.write_i32(1)
            _UniffiConverterTypeFfiTextContent.write(value._values[0], buf)
        if value.is_MARKDOWN():
            buf.write_i32(2)
            _UniffiConverterTypeFfiMarkdownContent.write(value._values[0], buf)
        if value.is_REACTION():
            buf.write_i32(3)
            _UniffiConverterTypeFfiReactionPayload.write(value._values[0], buf)
        if value.is_ATTACHMENT():
            buf.write_i32(4)
            _UniffiConverterTypeFfiAttachment.write(value._values[0], buf)
        if value.is_REMOTE_ATTACHMENT():
            buf.write_i32(5)
            _UniffiConverterTypeFfiRemoteAttachment.write(value._values[0], buf)
        if value.is_MULTI_REMOTE_ATTACHMENT():
            buf.write_i32(6)
            _UniffiConverterTypeFfiMultiRemoteAttachment.write(value._values[0], buf)
        if value.is_TRANSACTION_REFERENCE():
            buf.write_i32(7)
            _UniffiConverterTypeFfiTransactionReference.write(value._values[0], buf)
        if value.is_GROUP_UPDATED():
            buf.write_i32(8)
            _UniffiConverterTypeFfiGroupUpdated.write(value._values[0], buf)
        if value.is_READ_RECEIPT():
            buf.write_i32(9)
            _UniffiConverterTypeFfiReadReceipt.write(value._values[0], buf)
        if value.is_WALLET_SEND_CALLS():
            buf.write_i32(10)
            _UniffiConverterTypeFfiWalletSendCalls.write(value._values[0], buf)
        if value.is_INTENT():
            buf.write_i32(11)
            _UniffiConverterTypeFfiIntent.write(value._values[0], buf)
        if value.is_ACTIONS():
            buf.write_i32(12)
            _UniffiConverterTypeFfiActions.write(value._values[0], buf)
        if value.is_LEAVE_REQUEST():
            buf.write_i32(13)
            _UniffiConverterTypeFfiLeaveRequest.write(value._values[0], buf)
        if value.is_CUSTOM():
            buf.write_i32(14)
            _UniffiConverterTypeFfiEncodedContent.write(value._values[0], buf)







class FfiDecodedMessageContent:
    def __init__(self):
        raise RuntimeError("FfiDecodedMessageContent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class TEXT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.TEXT{self._values!r}"

        def __eq__(self, other):
            if not other.is_TEXT():
                return False
            return self._values == other._values
    class MARKDOWN:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.MARKDOWN{self._values!r}"

        def __eq__(self, other):
            if not other.is_MARKDOWN():
                return False
            return self._values == other._values
    class REPLY:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.REPLY{self._values!r}"

        def __eq__(self, other):
            if not other.is_REPLY():
                return False
            return self._values == other._values
    class REACTION:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.REACTION{self._values!r}"

        def __eq__(self, other):
            if not other.is_REACTION():
                return False
            return self._values == other._values
    class ATTACHMENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.ATTACHMENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_ATTACHMENT():
                return False
            return self._values == other._values
    class REMOTE_ATTACHMENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.REMOTE_ATTACHMENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_REMOTE_ATTACHMENT():
                return False
            return self._values == other._values
    class MULTI_REMOTE_ATTACHMENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.MULTI_REMOTE_ATTACHMENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_MULTI_REMOTE_ATTACHMENT():
                return False
            return self._values == other._values
    class TRANSACTION_REFERENCE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.TRANSACTION_REFERENCE{self._values!r}"

        def __eq__(self, other):
            if not other.is_TRANSACTION_REFERENCE():
                return False
            return self._values == other._values
    class GROUP_UPDATED:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.GROUP_UPDATED{self._values!r}"

        def __eq__(self, other):
            if not other.is_GROUP_UPDATED():
                return False
            return self._values == other._values
    class READ_RECEIPT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.READ_RECEIPT{self._values!r}"

        def __eq__(self, other):
            if not other.is_READ_RECEIPT():
                return False
            return self._values == other._values
    class WALLET_SEND_CALLS:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.WALLET_SEND_CALLS{self._values!r}"

        def __eq__(self, other):
            if not other.is_WALLET_SEND_CALLS():
                return False
            return self._values == other._values
    class INTENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.INTENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_INTENT():
                return False
            return self._values == other._values
    class ACTIONS:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.ACTIONS{self._values!r}"

        def __eq__(self, other):
            if not other.is_ACTIONS():
                return False
            return self._values == other._values
    class LEAVE_REQUEST:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.LEAVE_REQUEST{self._values!r}"

        def __eq__(self, other):
            if not other.is_LEAVE_REQUEST():
                return False
            return self._values == other._values
    class CUSTOM:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"FfiDecodedMessageContent.CUSTOM{self._values!r}"

        def __eq__(self, other):
            if not other.is_CUSTOM():
                return False
            return self._values == other._values
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_TEXT(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.TEXT)
    def is_text(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.TEXT)
    def is_MARKDOWN(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.MARKDOWN)
    def is_markdown(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.MARKDOWN)
    def is_REPLY(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.REPLY)
    def is_reply(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.REPLY)
    def is_REACTION(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.REACTION)
    def is_reaction(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.REACTION)
    def is_ATTACHMENT(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.ATTACHMENT)
    def is_attachment(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.ATTACHMENT)
    def is_REMOTE_ATTACHMENT(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.REMOTE_ATTACHMENT)
    def is_remote_attachment(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.REMOTE_ATTACHMENT)
    def is_MULTI_REMOTE_ATTACHMENT(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.MULTI_REMOTE_ATTACHMENT)
    def is_multi_remote_attachment(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.MULTI_REMOTE_ATTACHMENT)
    def is_TRANSACTION_REFERENCE(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.TRANSACTION_REFERENCE)
    def is_transaction_reference(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.TRANSACTION_REFERENCE)
    def is_GROUP_UPDATED(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.GROUP_UPDATED)
    def is_group_updated(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.GROUP_UPDATED)
    def is_READ_RECEIPT(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.READ_RECEIPT)
    def is_read_receipt(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.READ_RECEIPT)
    def is_WALLET_SEND_CALLS(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.WALLET_SEND_CALLS)
    def is_wallet_send_calls(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.WALLET_SEND_CALLS)
    def is_INTENT(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.INTENT)
    def is_intent(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.INTENT)
    def is_ACTIONS(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.ACTIONS)
    def is_actions(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.ACTIONS)
    def is_LEAVE_REQUEST(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.LEAVE_REQUEST)
    def is_leave_request(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.LEAVE_REQUEST)
    def is_CUSTOM(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.CUSTOM)
    def is_custom(self) -> bool:
        return isinstance(self, FfiDecodedMessageContent.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiDecodedMessageContent.TEXT = type("FfiDecodedMessageContent.TEXT", (FfiDecodedMessageContent.TEXT, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.MARKDOWN = type("FfiDecodedMessageContent.MARKDOWN", (FfiDecodedMessageContent.MARKDOWN, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.REPLY = type("FfiDecodedMessageContent.REPLY", (FfiDecodedMessageContent.REPLY, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.REACTION = type("FfiDecodedMessageContent.REACTION", (FfiDecodedMessageContent.REACTION, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.ATTACHMENT = type("FfiDecodedMessageContent.ATTACHMENT", (FfiDecodedMessageContent.ATTACHMENT, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.REMOTE_ATTACHMENT = type("FfiDecodedMessageContent.REMOTE_ATTACHMENT", (FfiDecodedMessageContent.REMOTE_ATTACHMENT, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.MULTI_REMOTE_ATTACHMENT = type("FfiDecodedMessageContent.MULTI_REMOTE_ATTACHMENT", (FfiDecodedMessageContent.MULTI_REMOTE_ATTACHMENT, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.TRANSACTION_REFERENCE = type("FfiDecodedMessageContent.TRANSACTION_REFERENCE", (FfiDecodedMessageContent.TRANSACTION_REFERENCE, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.GROUP_UPDATED = type("FfiDecodedMessageContent.GROUP_UPDATED", (FfiDecodedMessageContent.GROUP_UPDATED, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.READ_RECEIPT = type("FfiDecodedMessageContent.READ_RECEIPT", (FfiDecodedMessageContent.READ_RECEIPT, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.WALLET_SEND_CALLS = type("FfiDecodedMessageContent.WALLET_SEND_CALLS", (FfiDecodedMessageContent.WALLET_SEND_CALLS, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.INTENT = type("FfiDecodedMessageContent.INTENT", (FfiDecodedMessageContent.INTENT, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.ACTIONS = type("FfiDecodedMessageContent.ACTIONS", (FfiDecodedMessageContent.ACTIONS, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.LEAVE_REQUEST = type("FfiDecodedMessageContent.LEAVE_REQUEST", (FfiDecodedMessageContent.LEAVE_REQUEST, FfiDecodedMessageContent,), {})  # type: ignore
FfiDecodedMessageContent.CUSTOM = type("FfiDecodedMessageContent.CUSTOM", (FfiDecodedMessageContent.CUSTOM, FfiDecodedMessageContent,), {})  # type: ignore




class _UniffiConverterTypeFfiDecodedMessageContent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiDecodedMessageContent.TEXT(
                _UniffiConverterTypeFfiTextContent.read(buf),
            )
        if variant == 2:
            return FfiDecodedMessageContent.MARKDOWN(
                _UniffiConverterTypeFfiMarkdownContent.read(buf),
            )
        if variant == 3:
            return FfiDecodedMessageContent.REPLY(
                _UniffiConverterTypeFfiEnrichedReply.read(buf),
            )
        if variant == 4:
            return FfiDecodedMessageContent.REACTION(
                _UniffiConverterTypeFfiReactionPayload.read(buf),
            )
        if variant == 5:
            return FfiDecodedMessageContent.ATTACHMENT(
                _UniffiConverterTypeFfiAttachment.read(buf),
            )
        if variant == 6:
            return FfiDecodedMessageContent.REMOTE_ATTACHMENT(
                _UniffiConverterTypeFfiRemoteAttachment.read(buf),
            )
        if variant == 7:
            return FfiDecodedMessageContent.MULTI_REMOTE_ATTACHMENT(
                _UniffiConverterTypeFfiMultiRemoteAttachment.read(buf),
            )
        if variant == 8:
            return FfiDecodedMessageContent.TRANSACTION_REFERENCE(
                _UniffiConverterTypeFfiTransactionReference.read(buf),
            )
        if variant == 9:
            return FfiDecodedMessageContent.GROUP_UPDATED(
                _UniffiConverterTypeFfiGroupUpdated.read(buf),
            )
        if variant == 10:
            return FfiDecodedMessageContent.READ_RECEIPT(
                _UniffiConverterTypeFfiReadReceipt.read(buf),
            )
        if variant == 11:
            return FfiDecodedMessageContent.WALLET_SEND_CALLS(
                _UniffiConverterTypeFfiWalletSendCalls.read(buf),
            )
        if variant == 12:
            return FfiDecodedMessageContent.INTENT(
                _UniffiConverterOptionalTypeFfiIntent.read(buf),
            )
        if variant == 13:
            return FfiDecodedMessageContent.ACTIONS(
                _UniffiConverterOptionalTypeFfiActions.read(buf),
            )
        if variant == 14:
            return FfiDecodedMessageContent.LEAVE_REQUEST(
                _UniffiConverterTypeFfiLeaveRequest.read(buf),
            )
        if variant == 15:
            return FfiDecodedMessageContent.CUSTOM(
                _UniffiConverterTypeFfiEncodedContent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_TEXT():
            _UniffiConverterTypeFfiTextContent.check_lower(value._values[0])
            return
        if value.is_MARKDOWN():
            _UniffiConverterTypeFfiMarkdownContent.check_lower(value._values[0])
            return
        if value.is_REPLY():
            _UniffiConverterTypeFfiEnrichedReply.check_lower(value._values[0])
            return
        if value.is_REACTION():
            _UniffiConverterTypeFfiReactionPayload.check_lower(value._values[0])
            return
        if value.is_ATTACHMENT():
            _UniffiConverterTypeFfiAttachment.check_lower(value._values[0])
            return
        if value.is_REMOTE_ATTACHMENT():
            _UniffiConverterTypeFfiRemoteAttachment.check_lower(value._values[0])
            return
        if value.is_MULTI_REMOTE_ATTACHMENT():
            _UniffiConverterTypeFfiMultiRemoteAttachment.check_lower(value._values[0])
            return
        if value.is_TRANSACTION_REFERENCE():
            _UniffiConverterTypeFfiTransactionReference.check_lower(value._values[0])
            return
        if value.is_GROUP_UPDATED():
            _UniffiConverterTypeFfiGroupUpdated.check_lower(value._values[0])
            return
        if value.is_READ_RECEIPT():
            _UniffiConverterTypeFfiReadReceipt.check_lower(value._values[0])
            return
        if value.is_WALLET_SEND_CALLS():
            _UniffiConverterTypeFfiWalletSendCalls.check_lower(value._values[0])
            return
        if value.is_INTENT():
            _UniffiConverterOptionalTypeFfiIntent.check_lower(value._values[0])
            return
        if value.is_ACTIONS():
            _UniffiConverterOptionalTypeFfiActions.check_lower(value._values[0])
            return
        if value.is_LEAVE_REQUEST():
            _UniffiConverterTypeFfiLeaveRequest.check_lower(value._values[0])
            return
        if value.is_CUSTOM():
            _UniffiConverterTypeFfiEncodedContent.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_TEXT():
            buf.write_i32(1)
            _UniffiConverterTypeFfiTextContent.write(value._values[0], buf)
        if value.is_MARKDOWN():
            buf.write_i32(2)
            _UniffiConverterTypeFfiMarkdownContent.write(value._values[0], buf)
        if value.is_REPLY():
            buf.write_i32(3)
            _UniffiConverterTypeFfiEnrichedReply.write(value._values[0], buf)
        if value.is_REACTION():
            buf.write_i32(4)
            _UniffiConverterTypeFfiReactionPayload.write(value._values[0], buf)
        if value.is_ATTACHMENT():
            buf.write_i32(5)
            _UniffiConverterTypeFfiAttachment.write(value._values[0], buf)
        if value.is_REMOTE_ATTACHMENT():
            buf.write_i32(6)
            _UniffiConverterTypeFfiRemoteAttachment.write(value._values[0], buf)
        if value.is_MULTI_REMOTE_ATTACHMENT():
            buf.write_i32(7)
            _UniffiConverterTypeFfiMultiRemoteAttachment.write(value._values[0], buf)
        if value.is_TRANSACTION_REFERENCE():
            buf.write_i32(8)
            _UniffiConverterTypeFfiTransactionReference.write(value._values[0], buf)
        if value.is_GROUP_UPDATED():
            buf.write_i32(9)
            _UniffiConverterTypeFfiGroupUpdated.write(value._values[0], buf)
        if value.is_READ_RECEIPT():
            buf.write_i32(10)
            _UniffiConverterTypeFfiReadReceipt.write(value._values[0], buf)
        if value.is_WALLET_SEND_CALLS():
            buf.write_i32(11)
            _UniffiConverterTypeFfiWalletSendCalls.write(value._values[0], buf)
        if value.is_INTENT():
            buf.write_i32(12)
            _UniffiConverterOptionalTypeFfiIntent.write(value._values[0], buf)
        if value.is_ACTIONS():
            buf.write_i32(13)
            _UniffiConverterOptionalTypeFfiActions.write(value._values[0], buf)
        if value.is_LEAVE_REQUEST():
            buf.write_i32(14)
            _UniffiConverterTypeFfiLeaveRequest.write(value._values[0], buf)
        if value.is_CUSTOM():
            buf.write_i32(15)
            _UniffiConverterTypeFfiEncodedContent.write(value._values[0], buf)







class FfiDeliveryStatus(enum.Enum):
    UNPUBLISHED = 0
    
    PUBLISHED = 1
    
    FAILED = 2
    


class _UniffiConverterTypeFfiDeliveryStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiDeliveryStatus.UNPUBLISHED
        if variant == 2:
            return FfiDeliveryStatus.PUBLISHED
        if variant == 3:
            return FfiDeliveryStatus.FAILED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiDeliveryStatus.UNPUBLISHED:
            return
        if value == FfiDeliveryStatus.PUBLISHED:
            return
        if value == FfiDeliveryStatus.FAILED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiDeliveryStatus.UNPUBLISHED:
            buf.write_i32(1)
        if value == FfiDeliveryStatus.PUBLISHED:
            buf.write_i32(2)
        if value == FfiDeliveryStatus.FAILED:
            buf.write_i32(3)







class FfiDirection(enum.Enum):
    ASCENDING = 0
    
    DESCENDING = 1
    


class _UniffiConverterTypeFfiDirection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiDirection.ASCENDING
        if variant == 2:
            return FfiDirection.DESCENDING
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiDirection.ASCENDING:
            return
        if value == FfiDirection.DESCENDING:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiDirection.ASCENDING:
            buf.write_i32(1)
        if value == FfiDirection.DESCENDING:
            buf.write_i32(2)







class FfiForkRecoveryPolicy(enum.Enum):
    NONE = 0
    
    ALLOWLISTED_GROUPS = 1
    
    ALL = 2
    


class _UniffiConverterTypeFfiForkRecoveryPolicy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiForkRecoveryPolicy.NONE
        if variant == 2:
            return FfiForkRecoveryPolicy.ALLOWLISTED_GROUPS
        if variant == 3:
            return FfiForkRecoveryPolicy.ALL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiForkRecoveryPolicy.NONE:
            return
        if value == FfiForkRecoveryPolicy.ALLOWLISTED_GROUPS:
            return
        if value == FfiForkRecoveryPolicy.ALL:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiForkRecoveryPolicy.NONE:
            buf.write_i32(1)
        if value == FfiForkRecoveryPolicy.ALLOWLISTED_GROUPS:
            buf.write_i32(2)
        if value == FfiForkRecoveryPolicy.ALL:
            buf.write_i32(3)







class FfiGroupMembershipState(enum.Enum):
    ALLOWED = 0
    
    REJECTED = 1
    
    PENDING = 2
    
    RESTORED = 3
    
    PENDING_REMOVE = 4
    


class _UniffiConverterTypeFfiGroupMembershipState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiGroupMembershipState.ALLOWED
        if variant == 2:
            return FfiGroupMembershipState.REJECTED
        if variant == 3:
            return FfiGroupMembershipState.PENDING
        if variant == 4:
            return FfiGroupMembershipState.RESTORED
        if variant == 5:
            return FfiGroupMembershipState.PENDING_REMOVE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiGroupMembershipState.ALLOWED:
            return
        if value == FfiGroupMembershipState.REJECTED:
            return
        if value == FfiGroupMembershipState.PENDING:
            return
        if value == FfiGroupMembershipState.RESTORED:
            return
        if value == FfiGroupMembershipState.PENDING_REMOVE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiGroupMembershipState.ALLOWED:
            buf.write_i32(1)
        if value == FfiGroupMembershipState.REJECTED:
            buf.write_i32(2)
        if value == FfiGroupMembershipState.PENDING:
            buf.write_i32(3)
        if value == FfiGroupMembershipState.RESTORED:
            buf.write_i32(4)
        if value == FfiGroupMembershipState.PENDING_REMOVE:
            buf.write_i32(5)







class FfiGroupMessageKind(enum.Enum):
    APPLICATION = 0
    
    MEMBERSHIP_CHANGE = 1
    


class _UniffiConverterTypeFfiGroupMessageKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiGroupMessageKind.APPLICATION
        if variant == 2:
            return FfiGroupMessageKind.MEMBERSHIP_CHANGE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiGroupMessageKind.APPLICATION:
            return
        if value == FfiGroupMessageKind.MEMBERSHIP_CHANGE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiGroupMessageKind.APPLICATION:
            buf.write_i32(1)
        if value == FfiGroupMessageKind.MEMBERSHIP_CHANGE:
            buf.write_i32(2)







class FfiGroupPermissionsOptions(enum.Enum):
    DEFAULT = 0
    
    ADMIN_ONLY = 1
    
    CUSTOM_POLICY = 2
    


class _UniffiConverterTypeFfiGroupPermissionsOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiGroupPermissionsOptions.DEFAULT
        if variant == 2:
            return FfiGroupPermissionsOptions.ADMIN_ONLY
        if variant == 3:
            return FfiGroupPermissionsOptions.CUSTOM_POLICY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiGroupPermissionsOptions.DEFAULT:
            return
        if value == FfiGroupPermissionsOptions.ADMIN_ONLY:
            return
        if value == FfiGroupPermissionsOptions.CUSTOM_POLICY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiGroupPermissionsOptions.DEFAULT:
            buf.write_i32(1)
        if value == FfiGroupPermissionsOptions.ADMIN_ONLY:
            buf.write_i32(2)
        if value == FfiGroupPermissionsOptions.CUSTOM_POLICY:
            buf.write_i32(3)







class FfiGroupQueryOrderBy(enum.Enum):
    CREATED_AT = 0
    
    LAST_ACTIVITY = 1
    


class _UniffiConverterTypeFfiGroupQueryOrderBy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiGroupQueryOrderBy.CREATED_AT
        if variant == 2:
            return FfiGroupQueryOrderBy.LAST_ACTIVITY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiGroupQueryOrderBy.CREATED_AT:
            return
        if value == FfiGroupQueryOrderBy.LAST_ACTIVITY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiGroupQueryOrderBy.CREATED_AT:
            buf.write_i32(1)
        if value == FfiGroupQueryOrderBy.LAST_ACTIVITY:
            buf.write_i32(2)







class FfiIdentifierKind(enum.Enum):
    ETHEREUM = 0
    
    PASSKEY = 1
    


class _UniffiConverterTypeFfiIdentifierKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiIdentifierKind.ETHEREUM
        if variant == 2:
            return FfiIdentifierKind.PASSKEY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiIdentifierKind.ETHEREUM:
            return
        if value == FfiIdentifierKind.PASSKEY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiIdentifierKind.ETHEREUM:
            buf.write_i32(1)
        if value == FfiIdentifierKind.PASSKEY:
            buf.write_i32(2)







class FfiLogLevel(enum.Enum):
    """
    Enum representing log levels
    """

    ERROR = 0
    """
    Error level logs only
    """

    
    WARN = 1
    """
    Warning level and above
    """

    
    INFO = 2
    """
    Info level and above
    """

    
    DEBUG = 3
    """
    Debug level and above
    """

    
    TRACE = 4
    """
    Trace level and all logs
    """

    


class _UniffiConverterTypeFfiLogLevel(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiLogLevel.ERROR
        if variant == 2:
            return FfiLogLevel.WARN
        if variant == 3:
            return FfiLogLevel.INFO
        if variant == 4:
            return FfiLogLevel.DEBUG
        if variant == 5:
            return FfiLogLevel.TRACE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiLogLevel.ERROR:
            return
        if value == FfiLogLevel.WARN:
            return
        if value == FfiLogLevel.INFO:
            return
        if value == FfiLogLevel.DEBUG:
            return
        if value == FfiLogLevel.TRACE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiLogLevel.ERROR:
            buf.write_i32(1)
        if value == FfiLogLevel.WARN:
            buf.write_i32(2)
        if value == FfiLogLevel.INFO:
            buf.write_i32(3)
        if value == FfiLogLevel.DEBUG:
            buf.write_i32(4)
        if value == FfiLogLevel.TRACE:
            buf.write_i32(5)







class FfiLogRotation(enum.Enum):
    """
    Enum representing log file rotation options
    """

    MINUTELY = 0
    """
    Rotate log files every minute
    """

    
    HOURLY = 1
    """
    Rotate log files every hour
    """

    
    DAILY = 2
    """
    Rotate log files every day
    """

    
    NEVER = 3
    """
    Never rotate log files
    """

    


class _UniffiConverterTypeFfiLogRotation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiLogRotation.MINUTELY
        if variant == 2:
            return FfiLogRotation.HOURLY
        if variant == 3:
            return FfiLogRotation.DAILY
        if variant == 4:
            return FfiLogRotation.NEVER
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiLogRotation.MINUTELY:
            return
        if value == FfiLogRotation.HOURLY:
            return
        if value == FfiLogRotation.DAILY:
            return
        if value == FfiLogRotation.NEVER:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiLogRotation.MINUTELY:
            buf.write_i32(1)
        if value == FfiLogRotation.HOURLY:
            buf.write_i32(2)
        if value == FfiLogRotation.DAILY:
            buf.write_i32(3)
        if value == FfiLogRotation.NEVER:
            buf.write_i32(4)







class FfiMetadataField(enum.Enum):
    GROUP_NAME = 0
    
    DESCRIPTION = 1
    
    IMAGE_URL_SQUARE = 2
    
    APP_DATA = 3
    


class _UniffiConverterTypeFfiMetadataField(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiMetadataField.GROUP_NAME
        if variant == 2:
            return FfiMetadataField.DESCRIPTION
        if variant == 3:
            return FfiMetadataField.IMAGE_URL_SQUARE
        if variant == 4:
            return FfiMetadataField.APP_DATA
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiMetadataField.GROUP_NAME:
            return
        if value == FfiMetadataField.DESCRIPTION:
            return
        if value == FfiMetadataField.IMAGE_URL_SQUARE:
            return
        if value == FfiMetadataField.APP_DATA:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiMetadataField.GROUP_NAME:
            buf.write_i32(1)
        if value == FfiMetadataField.DESCRIPTION:
            buf.write_i32(2)
        if value == FfiMetadataField.IMAGE_URL_SQUARE:
            buf.write_i32(3)
        if value == FfiMetadataField.APP_DATA:
            buf.write_i32(4)







class FfiPermissionLevel(enum.Enum):
    MEMBER = 0
    
    ADMIN = 1
    
    SUPER_ADMIN = 2
    


class _UniffiConverterTypeFfiPermissionLevel(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiPermissionLevel.MEMBER
        if variant == 2:
            return FfiPermissionLevel.ADMIN
        if variant == 3:
            return FfiPermissionLevel.SUPER_ADMIN
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiPermissionLevel.MEMBER:
            return
        if value == FfiPermissionLevel.ADMIN:
            return
        if value == FfiPermissionLevel.SUPER_ADMIN:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiPermissionLevel.MEMBER:
            buf.write_i32(1)
        if value == FfiPermissionLevel.ADMIN:
            buf.write_i32(2)
        if value == FfiPermissionLevel.SUPER_ADMIN:
            buf.write_i32(3)







class FfiPermissionPolicy(enum.Enum):
    ALLOW = 0
    
    DENY = 1
    
    ADMIN = 2
    
    SUPER_ADMIN = 3
    
    DOES_NOT_EXIST = 4
    
    OTHER = 5
    


class _UniffiConverterTypeFfiPermissionPolicy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiPermissionPolicy.ALLOW
        if variant == 2:
            return FfiPermissionPolicy.DENY
        if variant == 3:
            return FfiPermissionPolicy.ADMIN
        if variant == 4:
            return FfiPermissionPolicy.SUPER_ADMIN
        if variant == 5:
            return FfiPermissionPolicy.DOES_NOT_EXIST
        if variant == 6:
            return FfiPermissionPolicy.OTHER
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiPermissionPolicy.ALLOW:
            return
        if value == FfiPermissionPolicy.DENY:
            return
        if value == FfiPermissionPolicy.ADMIN:
            return
        if value == FfiPermissionPolicy.SUPER_ADMIN:
            return
        if value == FfiPermissionPolicy.DOES_NOT_EXIST:
            return
        if value == FfiPermissionPolicy.OTHER:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiPermissionPolicy.ALLOW:
            buf.write_i32(1)
        if value == FfiPermissionPolicy.DENY:
            buf.write_i32(2)
        if value == FfiPermissionPolicy.ADMIN:
            buf.write_i32(3)
        if value == FfiPermissionPolicy.SUPER_ADMIN:
            buf.write_i32(4)
        if value == FfiPermissionPolicy.DOES_NOT_EXIST:
            buf.write_i32(5)
        if value == FfiPermissionPolicy.OTHER:
            buf.write_i32(6)







class FfiPermissionUpdateType(enum.Enum):
    ADD_MEMBER = 0
    
    REMOVE_MEMBER = 1
    
    ADD_ADMIN = 2
    
    REMOVE_ADMIN = 3
    
    UPDATE_METADATA = 4
    


class _UniffiConverterTypeFfiPermissionUpdateType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiPermissionUpdateType.ADD_MEMBER
        if variant == 2:
            return FfiPermissionUpdateType.REMOVE_MEMBER
        if variant == 3:
            return FfiPermissionUpdateType.ADD_ADMIN
        if variant == 4:
            return FfiPermissionUpdateType.REMOVE_ADMIN
        if variant == 5:
            return FfiPermissionUpdateType.UPDATE_METADATA
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiPermissionUpdateType.ADD_MEMBER:
            return
        if value == FfiPermissionUpdateType.REMOVE_MEMBER:
            return
        if value == FfiPermissionUpdateType.ADD_ADMIN:
            return
        if value == FfiPermissionUpdateType.REMOVE_ADMIN:
            return
        if value == FfiPermissionUpdateType.UPDATE_METADATA:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiPermissionUpdateType.ADD_MEMBER:
            buf.write_i32(1)
        if value == FfiPermissionUpdateType.REMOVE_MEMBER:
            buf.write_i32(2)
        if value == FfiPermissionUpdateType.ADD_ADMIN:
            buf.write_i32(3)
        if value == FfiPermissionUpdateType.REMOVE_ADMIN:
            buf.write_i32(4)
        if value == FfiPermissionUpdateType.UPDATE_METADATA:
            buf.write_i32(5)







class FfiPreferenceUpdate:
    def __init__(self):
        raise RuntimeError("FfiPreferenceUpdate cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class HMAC:
        key: "bytes"

        def __init__(self,key: "bytes"):
            self.key = key

        def __str__(self):
            return "FfiPreferenceUpdate.HMAC(key={})".format(self.key)

        def __eq__(self, other):
            if not other.is_HMAC():
                return False
            if self.key != other.key:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_HMAC(self) -> bool:
        return isinstance(self, FfiPreferenceUpdate.HMAC)
    def is_hmac(self) -> bool:
        return isinstance(self, FfiPreferenceUpdate.HMAC)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
FfiPreferenceUpdate.HMAC = type("FfiPreferenceUpdate.HMAC", (FfiPreferenceUpdate.HMAC, FfiPreferenceUpdate,), {})  # type: ignore




class _UniffiConverterTypeFfiPreferenceUpdate(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiPreferenceUpdate.HMAC(
                _UniffiConverterBytes.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_HMAC():
            _UniffiConverterBytes.check_lower(value.key)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_HMAC():
            buf.write_i32(1)
            _UniffiConverterBytes.write(value.key, buf)







class FfiProcessType(enum.Enum):
    """
    Enum representing process types for logging
    """

    MAIN = 0
    """
    Main application process
    """

    
    NOTIFICATION_EXTENSION = 1
    """
    Notification extension/service process
    """

    


class _UniffiConverterTypeFfiProcessType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiProcessType.MAIN
        if variant == 2:
            return FfiProcessType.NOTIFICATION_EXTENSION
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiProcessType.MAIN:
            return
        if value == FfiProcessType.NOTIFICATION_EXTENSION:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiProcessType.MAIN:
            buf.write_i32(1)
        if value == FfiProcessType.NOTIFICATION_EXTENSION:
            buf.write_i32(2)







class FfiReactionAction(enum.Enum):
    UNKNOWN = 0
    
    ADDED = 1
    
    REMOVED = 2
    


class _UniffiConverterTypeFfiReactionAction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiReactionAction.UNKNOWN
        if variant == 2:
            return FfiReactionAction.ADDED
        if variant == 3:
            return FfiReactionAction.REMOVED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiReactionAction.UNKNOWN:
            return
        if value == FfiReactionAction.ADDED:
            return
        if value == FfiReactionAction.REMOVED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiReactionAction.UNKNOWN:
            buf.write_i32(1)
        if value == FfiReactionAction.ADDED:
            buf.write_i32(2)
        if value == FfiReactionAction.REMOVED:
            buf.write_i32(3)







class FfiReactionSchema(enum.Enum):
    UNKNOWN = 0
    
    UNICODE = 1
    
    SHORTCODE = 2
    
    CUSTOM = 3
    


class _UniffiConverterTypeFfiReactionSchema(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiReactionSchema.UNKNOWN
        if variant == 2:
            return FfiReactionSchema.UNICODE
        if variant == 3:
            return FfiReactionSchema.SHORTCODE
        if variant == 4:
            return FfiReactionSchema.CUSTOM
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiReactionSchema.UNKNOWN:
            return
        if value == FfiReactionSchema.UNICODE:
            return
        if value == FfiReactionSchema.SHORTCODE:
            return
        if value == FfiReactionSchema.CUSTOM:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiReactionSchema.UNKNOWN:
            buf.write_i32(1)
        if value == FfiReactionSchema.UNICODE:
            buf.write_i32(2)
        if value == FfiReactionSchema.SHORTCODE:
            buf.write_i32(3)
        if value == FfiReactionSchema.CUSTOM:
            buf.write_i32(4)







class FfiSignatureKind(enum.Enum):
    """
    Signature kind used in identity operations
    """

    ERC191 = 0
    """
    ERC-191 signature (Externally Owned Account/EOA)
    """

    
    ERC1271 = 1
    """
    ERC-1271 signature (Smart Contract Wallet/SCW)
    """

    
    INSTALLATION_KEY = 2
    """
    Installation key signature
    """

    
    LEGACY_DELEGATED = 3
    """
    Legacy delegated signature
    """

    
    P256 = 4
    """
    P256 passkey signature
    """

    


class _UniffiConverterTypeFfiSignatureKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiSignatureKind.ERC191
        if variant == 2:
            return FfiSignatureKind.ERC1271
        if variant == 3:
            return FfiSignatureKind.INSTALLATION_KEY
        if variant == 4:
            return FfiSignatureKind.LEGACY_DELEGATED
        if variant == 5:
            return FfiSignatureKind.P256
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiSignatureKind.ERC191:
            return
        if value == FfiSignatureKind.ERC1271:
            return
        if value == FfiSignatureKind.INSTALLATION_KEY:
            return
        if value == FfiSignatureKind.LEGACY_DELEGATED:
            return
        if value == FfiSignatureKind.P256:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiSignatureKind.ERC191:
            buf.write_i32(1)
        if value == FfiSignatureKind.ERC1271:
            buf.write_i32(2)
        if value == FfiSignatureKind.INSTALLATION_KEY:
            buf.write_i32(3)
        if value == FfiSignatureKind.LEGACY_DELEGATED:
            buf.write_i32(4)
        if value == FfiSignatureKind.P256:
            buf.write_i32(5)







class FfiSortBy(enum.Enum):
    SENT_AT = 0
    
    INSERTED_AT = 1
    


class _UniffiConverterTypeFfiSortBy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiSortBy.SENT_AT
        if variant == 2:
            return FfiSortBy.INSERTED_AT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiSortBy.SENT_AT:
            return
        if value == FfiSortBy.INSERTED_AT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiSortBy.SENT_AT:
            buf.write_i32(1)
        if value == FfiSortBy.INSERTED_AT:
            buf.write_i32(2)




# FfiSubscribeError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class FfiSubscribeError(Exception):
    pass

_UniffiTempFfiSubscribeError = FfiSubscribeError

class FfiSubscribeError:  # type: ignore
    class Subscribe(_UniffiTempFfiSubscribeError):

        def __repr__(self):
            return "FfiSubscribeError.Subscribe({})".format(repr(str(self)))
    _UniffiTempFfiSubscribeError.Subscribe = Subscribe # type: ignore
    class Storage(_UniffiTempFfiSubscribeError):

        def __repr__(self):
            return "FfiSubscribeError.Storage({})".format(repr(str(self)))
    _UniffiTempFfiSubscribeError.Storage = Storage # type: ignore

FfiSubscribeError = _UniffiTempFfiSubscribeError # type: ignore
del _UniffiTempFfiSubscribeError


class _UniffiConverterTypeFfiSubscribeError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiSubscribeError.Subscribe(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return FfiSubscribeError.Storage(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, FfiSubscribeError.Subscribe):
            return
        if isinstance(value, FfiSubscribeError.Storage):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, FfiSubscribeError.Subscribe):
            buf.write_i32(1)
        if isinstance(value, FfiSubscribeError.Storage):
            buf.write_i32(2)





class FfiSyncMetric(enum.Enum):
    INIT = 0
    
    SYNC_GROUP_CREATED = 1
    
    SYNC_GROUP_WELCOMES_PROCESSED = 2
    
    REQUEST_RECEIVED = 3
    
    PAYLOAD_SENT = 4
    
    PAYLOAD_PROCESSED = 5
    
    HMAC_SENT = 6
    
    HMAC_RECEIVED = 7
    
    CONSENT_SENT = 8
    
    CONSENT_RECEIVED = 9
    
    V1_CONSENT_SENT = 10
    
    V1_HMAC_SENT = 11
    
    V1_PAYLOAD_SENT = 12
    
    V1_PAYLOAD_PROCESSED = 13
    


class _UniffiConverterTypeFfiSyncMetric(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiSyncMetric.INIT
        if variant == 2:
            return FfiSyncMetric.SYNC_GROUP_CREATED
        if variant == 3:
            return FfiSyncMetric.SYNC_GROUP_WELCOMES_PROCESSED
        if variant == 4:
            return FfiSyncMetric.REQUEST_RECEIVED
        if variant == 5:
            return FfiSyncMetric.PAYLOAD_SENT
        if variant == 6:
            return FfiSyncMetric.PAYLOAD_PROCESSED
        if variant == 7:
            return FfiSyncMetric.HMAC_SENT
        if variant == 8:
            return FfiSyncMetric.HMAC_RECEIVED
        if variant == 9:
            return FfiSyncMetric.CONSENT_SENT
        if variant == 10:
            return FfiSyncMetric.CONSENT_RECEIVED
        if variant == 11:
            return FfiSyncMetric.V1_CONSENT_SENT
        if variant == 12:
            return FfiSyncMetric.V1_HMAC_SENT
        if variant == 13:
            return FfiSyncMetric.V1_PAYLOAD_SENT
        if variant == 14:
            return FfiSyncMetric.V1_PAYLOAD_PROCESSED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiSyncMetric.INIT:
            return
        if value == FfiSyncMetric.SYNC_GROUP_CREATED:
            return
        if value == FfiSyncMetric.SYNC_GROUP_WELCOMES_PROCESSED:
            return
        if value == FfiSyncMetric.REQUEST_RECEIVED:
            return
        if value == FfiSyncMetric.PAYLOAD_SENT:
            return
        if value == FfiSyncMetric.PAYLOAD_PROCESSED:
            return
        if value == FfiSyncMetric.HMAC_SENT:
            return
        if value == FfiSyncMetric.HMAC_RECEIVED:
            return
        if value == FfiSyncMetric.CONSENT_SENT:
            return
        if value == FfiSyncMetric.CONSENT_RECEIVED:
            return
        if value == FfiSyncMetric.V1_CONSENT_SENT:
            return
        if value == FfiSyncMetric.V1_HMAC_SENT:
            return
        if value == FfiSyncMetric.V1_PAYLOAD_SENT:
            return
        if value == FfiSyncMetric.V1_PAYLOAD_PROCESSED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiSyncMetric.INIT:
            buf.write_i32(1)
        if value == FfiSyncMetric.SYNC_GROUP_CREATED:
            buf.write_i32(2)
        if value == FfiSyncMetric.SYNC_GROUP_WELCOMES_PROCESSED:
            buf.write_i32(3)
        if value == FfiSyncMetric.REQUEST_RECEIVED:
            buf.write_i32(4)
        if value == FfiSyncMetric.PAYLOAD_SENT:
            buf.write_i32(5)
        if value == FfiSyncMetric.PAYLOAD_PROCESSED:
            buf.write_i32(6)
        if value == FfiSyncMetric.HMAC_SENT:
            buf.write_i32(7)
        if value == FfiSyncMetric.HMAC_RECEIVED:
            buf.write_i32(8)
        if value == FfiSyncMetric.CONSENT_SENT:
            buf.write_i32(9)
        if value == FfiSyncMetric.CONSENT_RECEIVED:
            buf.write_i32(10)
        if value == FfiSyncMetric.V1_CONSENT_SENT:
            buf.write_i32(11)
        if value == FfiSyncMetric.V1_HMAC_SENT:
            buf.write_i32(12)
        if value == FfiSyncMetric.V1_PAYLOAD_SENT:
            buf.write_i32(13)
        if value == FfiSyncMetric.V1_PAYLOAD_PROCESSED:
            buf.write_i32(14)







class FfiSyncWorkerMode(enum.Enum):
    ENABLED = 0
    
    DISABLED = 1
    


class _UniffiConverterTypeFfiSyncWorkerMode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FfiSyncWorkerMode.ENABLED
        if variant == 2:
            return FfiSyncWorkerMode.DISABLED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == FfiSyncWorkerMode.ENABLED:
            return
        if value == FfiSyncWorkerMode.DISABLED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == FfiSyncWorkerMode.ENABLED:
            buf.write_i32(1)
        if value == FfiSyncWorkerMode.DISABLED:
            buf.write_i32(2)




# GenericError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GenericError(Exception):
    pass

_UniffiTempGenericError = GenericError

class GenericError:  # type: ignore
    class Client(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Client({})".format(repr(str(self)))
    _UniffiTempGenericError.Client = Client # type: ignore
    class ClientBuilder(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.ClientBuilder({})".format(repr(str(self)))
    _UniffiTempGenericError.ClientBuilder = ClientBuilder # type: ignore
    class Storage(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Storage({})".format(repr(str(self)))
    _UniffiTempGenericError.Storage = Storage # type: ignore
    class GroupError(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.GroupError({})".format(repr(str(self)))
    _UniffiTempGenericError.GroupError = GroupError # type: ignore
    class Signature(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Signature({})".format(repr(str(self)))
    _UniffiTempGenericError.Signature = Signature # type: ignore
    class GroupMetadata(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.GroupMetadata({})".format(repr(str(self)))
    _UniffiTempGenericError.GroupMetadata = GroupMetadata # type: ignore
    class GroupMutablePermissions(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.GroupMutablePermissions({})".format(repr(str(self)))
    _UniffiTempGenericError.GroupMutablePermissions = GroupMutablePermissions # type: ignore
    class Generic(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Generic({})".format(repr(str(self)))
    _UniffiTempGenericError.Generic = Generic # type: ignore
    class SignatureRequestError(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.SignatureRequestError({})".format(repr(str(self)))
    _UniffiTempGenericError.SignatureRequestError = SignatureRequestError # type: ignore
    class Erc1271SignatureError(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Erc1271SignatureError({})".format(repr(str(self)))
    _UniffiTempGenericError.Erc1271SignatureError = Erc1271SignatureError # type: ignore
    class Verifier(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Verifier({})".format(repr(str(self)))
    _UniffiTempGenericError.Verifier = Verifier # type: ignore
    class FailedToConvertToU32(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.FailedToConvertToU32({})".format(repr(str(self)))
    _UniffiTempGenericError.FailedToConvertToU32 = FailedToConvertToU32 # type: ignore
    class Association(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Association({})".format(repr(str(self)))
    _UniffiTempGenericError.Association = Association # type: ignore
    class DeviceSync(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.DeviceSync({})".format(repr(str(self)))
    _UniffiTempGenericError.DeviceSync = DeviceSync # type: ignore
    class Identity(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Identity({})".format(repr(str(self)))
    _UniffiTempGenericError.Identity = Identity # type: ignore
    class JoinError(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.JoinError({})".format(repr(str(self)))
    _UniffiTempGenericError.JoinError = JoinError # type: ignore
    class IoError(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.IoError({})".format(repr(str(self)))
    _UniffiTempGenericError.IoError = IoError # type: ignore
    class Subscription(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Subscription({})".format(repr(str(self)))
    _UniffiTempGenericError.Subscription = Subscription # type: ignore
    class ApiClientBuild(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.ApiClientBuild({})".format(repr(str(self)))
    _UniffiTempGenericError.ApiClientBuild = ApiClientBuild # type: ignore
    class Grpc(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Grpc({})".format(repr(str(self)))
    _UniffiTempGenericError.Grpc = Grpc # type: ignore
    class AddressValidation(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.AddressValidation({})".format(repr(str(self)))
    _UniffiTempGenericError.AddressValidation = AddressValidation # type: ignore
    class LogInit(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.LogInit({})".format(repr(str(self)))
    _UniffiTempGenericError.LogInit = LogInit # type: ignore
    class ReloadLog(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.ReloadLog({})".format(repr(str(self)))
    _UniffiTempGenericError.ReloadLog = ReloadLog # type: ignore
    class Log(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Log({})".format(repr(str(self)))
    _UniffiTempGenericError.Log = Log # type: ignore
    class Expired(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Expired({})".format(repr(str(self)))
    _UniffiTempGenericError.Expired = Expired # type: ignore
    class BackendBuilder(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.BackendBuilder({})".format(repr(str(self)))
    _UniffiTempGenericError.BackendBuilder = BackendBuilder # type: ignore
    class Api(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Api({})".format(repr(str(self)))
    _UniffiTempGenericError.Api = Api # type: ignore
    class Enrich(_UniffiTempGenericError):

        def __repr__(self):
            return "GenericError.Enrich({})".format(repr(str(self)))
    _UniffiTempGenericError.Enrich = Enrich # type: ignore

GenericError = _UniffiTempGenericError # type: ignore
del _UniffiTempGenericError


class _UniffiConverterTypeGenericError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GenericError.Client(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return GenericError.ClientBuilder(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return GenericError.Storage(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return GenericError.GroupError(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return GenericError.Signature(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return GenericError.GroupMetadata(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return GenericError.GroupMutablePermissions(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return GenericError.Generic(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return GenericError.SignatureRequestError(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return GenericError.Erc1271SignatureError(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return GenericError.Verifier(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return GenericError.FailedToConvertToU32(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return GenericError.Association(
                _UniffiConverterString.read(buf),
            )
        if variant == 14:
            return GenericError.DeviceSync(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return GenericError.Identity(
                _UniffiConverterString.read(buf),
            )
        if variant == 16:
            return GenericError.JoinError(
                _UniffiConverterString.read(buf),
            )
        if variant == 17:
            return GenericError.IoError(
                _UniffiConverterString.read(buf),
            )
        if variant == 18:
            return GenericError.Subscription(
                _UniffiConverterString.read(buf),
            )
        if variant == 19:
            return GenericError.ApiClientBuild(
                _UniffiConverterString.read(buf),
            )
        if variant == 20:
            return GenericError.Grpc(
                _UniffiConverterString.read(buf),
            )
        if variant == 21:
            return GenericError.AddressValidation(
                _UniffiConverterString.read(buf),
            )
        if variant == 22:
            return GenericError.LogInit(
                _UniffiConverterString.read(buf),
            )
        if variant == 23:
            return GenericError.ReloadLog(
                _UniffiConverterString.read(buf),
            )
        if variant == 24:
            return GenericError.Log(
                _UniffiConverterString.read(buf),
            )
        if variant == 25:
            return GenericError.Expired(
                _UniffiConverterString.read(buf),
            )
        if variant == 26:
            return GenericError.BackendBuilder(
                _UniffiConverterString.read(buf),
            )
        if variant == 27:
            return GenericError.Api(
                _UniffiConverterString.read(buf),
            )
        if variant == 28:
            return GenericError.Enrich(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GenericError.Client):
            return
        if isinstance(value, GenericError.ClientBuilder):
            return
        if isinstance(value, GenericError.Storage):
            return
        if isinstance(value, GenericError.GroupError):
            return
        if isinstance(value, GenericError.Signature):
            return
        if isinstance(value, GenericError.GroupMetadata):
            return
        if isinstance(value, GenericError.GroupMutablePermissions):
            return
        if isinstance(value, GenericError.Generic):
            return
        if isinstance(value, GenericError.SignatureRequestError):
            return
        if isinstance(value, GenericError.Erc1271SignatureError):
            return
        if isinstance(value, GenericError.Verifier):
            return
        if isinstance(value, GenericError.FailedToConvertToU32):
            return
        if isinstance(value, GenericError.Association):
            return
        if isinstance(value, GenericError.DeviceSync):
            return
        if isinstance(value, GenericError.Identity):
            return
        if isinstance(value, GenericError.JoinError):
            return
        if isinstance(value, GenericError.IoError):
            return
        if isinstance(value, GenericError.Subscription):
            return
        if isinstance(value, GenericError.ApiClientBuild):
            return
        if isinstance(value, GenericError.Grpc):
            return
        if isinstance(value, GenericError.AddressValidation):
            return
        if isinstance(value, GenericError.LogInit):
            return
        if isinstance(value, GenericError.ReloadLog):
            return
        if isinstance(value, GenericError.Log):
            return
        if isinstance(value, GenericError.Expired):
            return
        if isinstance(value, GenericError.BackendBuilder):
            return
        if isinstance(value, GenericError.Api):
            return
        if isinstance(value, GenericError.Enrich):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GenericError.Client):
            buf.write_i32(1)
        if isinstance(value, GenericError.ClientBuilder):
            buf.write_i32(2)
        if isinstance(value, GenericError.Storage):
            buf.write_i32(3)
        if isinstance(value, GenericError.GroupError):
            buf.write_i32(4)
        if isinstance(value, GenericError.Signature):
            buf.write_i32(5)
        if isinstance(value, GenericError.GroupMetadata):
            buf.write_i32(6)
        if isinstance(value, GenericError.GroupMutablePermissions):
            buf.write_i32(7)
        if isinstance(value, GenericError.Generic):
            buf.write_i32(8)
        if isinstance(value, GenericError.SignatureRequestError):
            buf.write_i32(9)
        if isinstance(value, GenericError.Erc1271SignatureError):
            buf.write_i32(10)
        if isinstance(value, GenericError.Verifier):
            buf.write_i32(11)
        if isinstance(value, GenericError.FailedToConvertToU32):
            buf.write_i32(12)
        if isinstance(value, GenericError.Association):
            buf.write_i32(13)
        if isinstance(value, GenericError.DeviceSync):
            buf.write_i32(14)
        if isinstance(value, GenericError.Identity):
            buf.write_i32(15)
        if isinstance(value, GenericError.JoinError):
            buf.write_i32(16)
        if isinstance(value, GenericError.IoError):
            buf.write_i32(17)
        if isinstance(value, GenericError.Subscription):
            buf.write_i32(18)
        if isinstance(value, GenericError.ApiClientBuild):
            buf.write_i32(19)
        if isinstance(value, GenericError.Grpc):
            buf.write_i32(20)
        if isinstance(value, GenericError.AddressValidation):
            buf.write_i32(21)
        if isinstance(value, GenericError.LogInit):
            buf.write_i32(22)
        if isinstance(value, GenericError.ReloadLog):
            buf.write_i32(23)
        if isinstance(value, GenericError.Log):
            buf.write_i32(24)
        if isinstance(value, GenericError.Expired):
            buf.write_i32(25)
        if isinstance(value, GenericError.BackendBuilder):
            buf.write_i32(26)
        if isinstance(value, GenericError.Api):
            buf.write_i32(27)
        if isinstance(value, GenericError.Enrich):
            buf.write_i32(28)


# IdentityValidationError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class IdentityValidationError(Exception):
    pass

_UniffiTempIdentityValidationError = IdentityValidationError

class IdentityValidationError:  # type: ignore
    class Generic(_UniffiTempIdentityValidationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "IdentityValidationError.Generic({})".format(str(self))
    _UniffiTempIdentityValidationError.Generic = Generic # type: ignore

IdentityValidationError = _UniffiTempIdentityValidationError # type: ignore
del _UniffiTempIdentityValidationError


class _UniffiConverterTypeIdentityValidationError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return IdentityValidationError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, IdentityValidationError.Generic):
            _UniffiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, IdentityValidationError.Generic):
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)


# SigningError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SigningError(Exception):
    pass

_UniffiTempSigningError = SigningError

class SigningError:  # type: ignore
    class Generic(_UniffiTempSigningError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SigningError.Generic({})".format(str(self))
    _UniffiTempSigningError.Generic = Generic # type: ignore

SigningError = _UniffiTempSigningError # type: ignore
del _UniffiTempSigningError


class _UniffiConverterTypeSigningError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SigningError.Generic(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SigningError.Generic):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SigningError.Generic):
            buf.write_i32(1)



class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBool.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiAuthCallback(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiAuthCallback.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiAuthCallback.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiAuthCallback.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiAuthHandle(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiAuthHandle.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiAuthHandle.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiAuthHandle.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiDecodedMessage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiDecodedMessage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiDecodedMessage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiDecodedMessage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiSignatureRequest(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiSignatureRequest.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiSignatureRequest.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiSignatureRequest.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiActions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiActions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiActions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiActions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiContentTypeId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiContentTypeId.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiContentTypeId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiContentTypeId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiForkRecoveryOpts(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiForkRecoveryOpts.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiForkRecoveryOpts.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiForkRecoveryOpts.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiIntent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiIntent.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiIntent.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiIntent.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiLifetime(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiLifetime.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiLifetime.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiLifetime.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiMessage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiMessage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiMessage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiMessage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiMessageDisappearingSettings(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiMessageDisappearingSettings.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiMessageDisappearingSettings.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiMessageDisappearingSettings.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiPermissionPolicySet(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiPermissionPolicySet.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiPermissionPolicySet.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiPermissionPolicySet.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiTransactionMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiTransactionMetadata.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiTransactionMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiTransactionMetadata.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiWalletCallMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiWalletCallMetadata.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiWalletCallMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiWalletCallMetadata.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiActionStyle(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiActionStyle.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiActionStyle.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiActionStyle.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiClientMode(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiClientMode.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiClientMode.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiClientMode.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiConversationType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiConversationType.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiConversationType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiConversationType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiDecodedMessageBody(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiDecodedMessageBody.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiDecodedMessageBody.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiDecodedMessageBody.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiDeliveryStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiDeliveryStatus.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiDeliveryStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiDeliveryStatus.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiDirection(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiDirection.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiDirection.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiDirection.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiGroupPermissionsOptions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiGroupPermissionsOptions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiGroupPermissionsOptions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiGroupPermissionsOptions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiGroupQueryOrderBy(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiGroupQueryOrderBy.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiGroupQueryOrderBy.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiGroupQueryOrderBy.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiMetadataField(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiMetadataField.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiMetadataField.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiMetadataField.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiSignatureKind(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiSignatureKind.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiSignatureKind.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiSignatureKind.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiSortBy(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiSortBy.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiSortBy.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiSortBy.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFfiSyncWorkerMode(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFfiSyncWorkerMode.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFfiSyncWorkerMode.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFfiSyncWorkerMode.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeFfiConsentState(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeFfiConsentState.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeFfiConsentState.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeFfiConsentState.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeFfiContentType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeFfiContentType.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeFfiContentType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeFfiContentType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalMapStringString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterMapStringString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterMapStringString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterMapStringString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterBytes.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterBytes.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterBytes.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiConversation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiConversation.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiConversation.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiConversation.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiConversationListItem(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiConversationListItem.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiConversationListItem.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiConversationListItem.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiDecodedMessage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiDecodedMessage.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiDecodedMessage.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiDecodedMessage.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiAction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiAction.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiAction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiAction.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiConsent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiConsent.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiConsent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiConsent.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiConversationMember(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiConversationMember.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiConversationMember.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiConversationMember.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiCursor(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiCursor.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiCursor.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiCursor.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiHmacKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiHmacKey.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiHmacKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiHmacKey.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiIdentifier(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiIdentifier.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiIdentifier.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiIdentifier.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiInbox(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiInbox.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiInbox.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiInbox.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiInboxState(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiInboxState.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiInboxState.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiInboxState.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiInstallation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiInstallation.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiInstallation.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiInstallation.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiMessage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiMessage.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiMessage.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiMessage.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiMessageWithReactions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiMessageWithReactions.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiMessageWithReactions.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiMessageWithReactions.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiMetadataFieldChange(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiMetadataFieldChange.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiMetadataFieldChange.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiMetadataFieldChange.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiRemoteAttachmentInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiRemoteAttachmentInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiRemoteAttachmentInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiRemoteAttachmentInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiWalletCall(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiWalletCall.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiWalletCall.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiWalletCall.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiBackupElementSelection(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiBackupElementSelection.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiBackupElementSelection.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiBackupElementSelection.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiConsentState(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiConsentState.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiConsentState.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiConsentState.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiContentType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiContentType.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiContentType.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiContentType.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFfiPreferenceUpdate(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFfiPreferenceUpdate.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFfiPreferenceUpdate.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFfiPreferenceUpdate.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterUInt64.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterInt64.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterInt64.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapStringString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterString.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapBytesTypeFfiKeyPackageStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterBytes.check_lower(key)
            _UniffiConverterTypeFfiKeyPackageStatus.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterBytes.write(key, buf)
            _UniffiConverterTypeFfiKeyPackageStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterBytes.read(buf)
            val = _UniffiConverterTypeFfiKeyPackageStatus.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapBytesTypeFfiMessageMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterBytes.check_lower(key)
            _UniffiConverterTypeFfiMessageMetadata.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterBytes.write(key, buf)
            _UniffiConverterTypeFfiMessageMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterBytes.read(buf)
            val = _UniffiConverterTypeFfiMessageMetadata.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapBytesSequenceTypeFfiHmacKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterBytes.check_lower(key)
            _UniffiConverterSequenceTypeFfiHmacKey.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterBytes.write(key, buf)
            _UniffiConverterSequenceTypeFfiHmacKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterBytes.read(buf)
            val = _UniffiConverterSequenceTypeFfiHmacKey.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeFfiIdentifierBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeFfiIdentifier.check_lower(key)
            _UniffiConverterBool.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeFfiIdentifier.write(key, buf)
            _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeFfiIdentifier.read(buf)
            val = _UniffiConverterBool.read(buf)
            d[key] = val
        return d

# objects.
class FfiAuthCallbackProtocol(typing.Protocol):
    def on_auth_required(self, ):
        raise NotImplementedError
# FfiAuthCallback is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class FfiAuthCallback():
    def on_auth_required(self, ):
        raise NotImplementedError
# `FfiAuthCallbackImpl` is the implementation for a Rust implemented version.
class FfiAuthCallbackImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffiauthcallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffiauthcallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def on_auth_required(self, ) -> "FfiCredential":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffiauthcallback_on_auth_required(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFfiCredential.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplFfiAuthCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_FFI_AUTH_CALLBACK_METHOD0
    def on_auth_required(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeFfiAuthCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.on_auth_required
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeFfiCredential.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, GenericError, _UniffiConverterTypeGenericError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeFfiAuthCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceFfiAuthCallback(
        on_auth_required,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffiauthcallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeFfiAuthCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return FfiAuthCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiAuthCallback):
        pass

    @staticmethod
    def lower(value: FfiAuthCallbackProtocol):
        return _UniffiConverterTypeFfiAuthCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiAuthCallbackProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiConsentCallbackProtocol(typing.Protocol):
    def on_consent_update(self, consent: "typing.List[FfiConsent]"):
        raise NotImplementedError
    def on_error(self, error: "FfiSubscribeError"):
        raise NotImplementedError
    def on_close(self, ):
        raise NotImplementedError
# FfiConsentCallback is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class FfiConsentCallback():
    def on_consent_update(self, consent: "typing.List[FfiConsent]"):
        raise NotImplementedError
    def on_error(self, error: "FfiSubscribeError"):
        raise NotImplementedError
    def on_close(self, ):
        raise NotImplementedError
# `FfiConsentCallbackImpl` is the implementation for a Rust implemented version.
class FfiConsentCallbackImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_fficonsentcallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_fficonsentcallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def on_consent_update(self, consent: "typing.List[FfiConsent]") -> None:
        _UniffiConverterSequenceTypeFfiConsent.check_lower(consent)
        
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonsentcallback_on_consent_update,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeFfiConsent.lower(consent))






    def on_error(self, error: "FfiSubscribeError") -> None:
        _UniffiConverterTypeFfiSubscribeError.check_lower(error)
        
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonsentcallback_on_error,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiSubscribeError.lower(error))






    def on_close(self, ) -> None:
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonsentcallback_on_close,self._uniffi_clone_pointer(),)






# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplFfiConsentCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_FFI_CONSENT_CALLBACK_METHOD0
    def on_consent_update(
            uniffi_handle,
            consent,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiConsentCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterSequenceTypeFfiConsent.lift(consent), )
            method = uniffi_obj.on_consent_update
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FFI_CONSENT_CALLBACK_METHOD1
    def on_error(
            uniffi_handle,
            error,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiConsentCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeFfiSubscribeError.lift(error), )
            method = uniffi_obj.on_error
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FFI_CONSENT_CALLBACK_METHOD2
    def on_close(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiConsentCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.on_close
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeFfiConsentCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceFfiConsentCallback(
        on_consent_update,
        on_error,
        on_close,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_fficonsentcallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeFfiConsentCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return FfiConsentCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiConsentCallback):
        pass

    @staticmethod
    def lower(value: FfiConsentCallbackProtocol):
        return _UniffiConverterTypeFfiConsentCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiConsentCallbackProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiConversationCallbackProtocol(typing.Protocol):
    def on_conversation(self, conversation: "FfiConversation"):
        raise NotImplementedError
    def on_error(self, error: "FfiSubscribeError"):
        raise NotImplementedError
    def on_close(self, ):
        raise NotImplementedError
# FfiConversationCallback is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class FfiConversationCallback():
    def on_conversation(self, conversation: "FfiConversation"):
        raise NotImplementedError
    def on_error(self, error: "FfiSubscribeError"):
        raise NotImplementedError
    def on_close(self, ):
        raise NotImplementedError
# `FfiConversationCallbackImpl` is the implementation for a Rust implemented version.
class FfiConversationCallbackImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_fficonversationcallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversationcallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def on_conversation(self, conversation: "FfiConversation") -> None:
        _UniffiConverterTypeFfiConversation.check_lower(conversation)
        
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationcallback_on_conversation,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiConversation.lower(conversation))






    def on_error(self, error: "FfiSubscribeError") -> None:
        _UniffiConverterTypeFfiSubscribeError.check_lower(error)
        
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationcallback_on_error,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiSubscribeError.lower(error))






    def on_close(self, ) -> None:
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationcallback_on_close,self._uniffi_clone_pointer(),)






# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplFfiConversationCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_FFI_CONVERSATION_CALLBACK_METHOD0
    def on_conversation(
            uniffi_handle,
            conversation,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiConversationCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeFfiConversation.lift(conversation), )
            method = uniffi_obj.on_conversation
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FFI_CONVERSATION_CALLBACK_METHOD1
    def on_error(
            uniffi_handle,
            error,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiConversationCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeFfiSubscribeError.lift(error), )
            method = uniffi_obj.on_error
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FFI_CONVERSATION_CALLBACK_METHOD2
    def on_close(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiConversationCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.on_close
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeFfiConversationCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceFfiConversationCallback(
        on_conversation,
        on_error,
        on_close,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_fficonversationcallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeFfiConversationCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return FfiConversationCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiConversationCallback):
        pass

    @staticmethod
    def lower(value: FfiConversationCallbackProtocol):
        return _UniffiConverterTypeFfiConversationCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiConversationCallbackProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiInboxOwnerProtocol(typing.Protocol):
    def get_identifier(self, ):
        raise NotImplementedError
    def sign(self, text: "str"):
        raise NotImplementedError
# FfiInboxOwner is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class FfiInboxOwner():
    def get_identifier(self, ):
        raise NotImplementedError
    def sign(self, text: "str"):
        raise NotImplementedError
# `FfiInboxOwnerImpl` is the implementation for a Rust implemented version.
class FfiInboxOwnerImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffiinboxowner, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffiinboxowner, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get_identifier(self, ) -> "FfiIdentifier":
        return _UniffiConverterTypeFfiIdentifier.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeIdentityValidationError,_UniffiLib.uniffi_xmtpv3_fn_method_ffiinboxowner_get_identifier,self._uniffi_clone_pointer(),)
        )





    def sign(self, text: "str") -> "bytes":
        _UniffiConverterString.check_lower(text)
        
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSigningError,_UniffiLib.uniffi_xmtpv3_fn_method_ffiinboxowner_sign,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(text))
        )





# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplFfiInboxOwner:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_FFI_INBOX_OWNER_METHOD0
    def get_identifier(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiInboxOwner._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_identifier
            return method(*args)

        
        def write_return_value(v):
            uniffi_out_return[0] = _UniffiConverterTypeFfiIdentifier.lower(v)
        _uniffi_trait_interface_call_with_error(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
                IdentityValidationError,
                _UniffiConverterTypeIdentityValidationError.lower,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FFI_INBOX_OWNER_METHOD1
    def sign(
            uniffi_handle,
            text,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiInboxOwner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(text), )
            method = uniffi_obj.sign
            return method(*args)

        
        def write_return_value(v):
            uniffi_out_return[0] = _UniffiConverterBytes.lower(v)
        _uniffi_trait_interface_call_with_error(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
                SigningError,
                _UniffiConverterTypeSigningError.lower,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeFfiInboxOwner._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceFfiInboxOwner(
        get_identifier,
        sign,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffiinboxowner(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeFfiInboxOwner:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return FfiInboxOwnerImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiInboxOwner):
        pass

    @staticmethod
    def lower(value: FfiInboxOwnerProtocol):
        return _UniffiConverterTypeFfiInboxOwner._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiInboxOwnerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiMessageCallbackProtocol(typing.Protocol):
    def on_message(self, message: "FfiMessage"):
        raise NotImplementedError
    def on_error(self, error: "FfiSubscribeError"):
        raise NotImplementedError
    def on_close(self, ):
        raise NotImplementedError
# FfiMessageCallback is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class FfiMessageCallback():
    def on_message(self, message: "FfiMessage"):
        raise NotImplementedError
    def on_error(self, error: "FfiSubscribeError"):
        raise NotImplementedError
    def on_close(self, ):
        raise NotImplementedError
# `FfiMessageCallbackImpl` is the implementation for a Rust implemented version.
class FfiMessageCallbackImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffimessagecallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffimessagecallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def on_message(self, message: "FfiMessage") -> None:
        _UniffiConverterTypeFfiMessage.check_lower(message)
        
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagecallback_on_message,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiMessage.lower(message))






    def on_error(self, error: "FfiSubscribeError") -> None:
        _UniffiConverterTypeFfiSubscribeError.check_lower(error)
        
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagecallback_on_error,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiSubscribeError.lower(error))






    def on_close(self, ) -> None:
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagecallback_on_close,self._uniffi_clone_pointer(),)






# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplFfiMessageCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_CALLBACK_METHOD0
    def on_message(
            uniffi_handle,
            message,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiMessageCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeFfiMessage.lift(message), )
            method = uniffi_obj.on_message
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_CALLBACK_METHOD1
    def on_error(
            uniffi_handle,
            error,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiMessageCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeFfiSubscribeError.lift(error), )
            method = uniffi_obj.on_error
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_CALLBACK_METHOD2
    def on_close(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiMessageCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.on_close
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeFfiMessageCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceFfiMessageCallback(
        on_message,
        on_error,
        on_close,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffimessagecallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeFfiMessageCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return FfiMessageCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiMessageCallback):
        pass

    @staticmethod
    def lower(value: FfiMessageCallbackProtocol):
        return _UniffiConverterTypeFfiMessageCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiMessageCallbackProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiMessageDeletionCallbackProtocol(typing.Protocol):
    def on_message_deleted(self, message_id: "bytes"):
        raise NotImplementedError
# FfiMessageDeletionCallback is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class FfiMessageDeletionCallback():
    def on_message_deleted(self, message_id: "bytes"):
        raise NotImplementedError
# `FfiMessageDeletionCallbackImpl` is the implementation for a Rust implemented version.
class FfiMessageDeletionCallbackImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffimessagedeletioncallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffimessagedeletioncallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def on_message_deleted(self, message_id: "bytes") -> None:
        _UniffiConverterBytes.check_lower(message_id)
        
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffimessagedeletioncallback_on_message_deleted,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message_id))






# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplFfiMessageDeletionCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_FFI_MESSAGE_DELETION_CALLBACK_METHOD0
    def on_message_deleted(
            uniffi_handle,
            message_id,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiMessageDeletionCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(message_id), )
            method = uniffi_obj.on_message_deleted
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeFfiMessageDeletionCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceFfiMessageDeletionCallback(
        on_message_deleted,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffimessagedeletioncallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeFfiMessageDeletionCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return FfiMessageDeletionCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiMessageDeletionCallback):
        pass

    @staticmethod
    def lower(value: FfiMessageDeletionCallbackProtocol):
        return _UniffiConverterTypeFfiMessageDeletionCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiMessageDeletionCallbackProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiPreferenceCallbackProtocol(typing.Protocol):
    def on_preference_update(self, preference: "typing.List[FfiPreferenceUpdate]"):
        raise NotImplementedError
    def on_error(self, error: "FfiSubscribeError"):
        raise NotImplementedError
    def on_close(self, ):
        raise NotImplementedError
# FfiPreferenceCallback is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class FfiPreferenceCallback():
    def on_preference_update(self, preference: "typing.List[FfiPreferenceUpdate]"):
        raise NotImplementedError
    def on_error(self, error: "FfiSubscribeError"):
        raise NotImplementedError
    def on_close(self, ):
        raise NotImplementedError
# `FfiPreferenceCallbackImpl` is the implementation for a Rust implemented version.
class FfiPreferenceCallbackImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffipreferencecallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffipreferencecallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def on_preference_update(self, preference: "typing.List[FfiPreferenceUpdate]") -> None:
        _UniffiConverterSequenceTypeFfiPreferenceUpdate.check_lower(preference)
        
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffipreferencecallback_on_preference_update,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeFfiPreferenceUpdate.lower(preference))






    def on_error(self, error: "FfiSubscribeError") -> None:
        _UniffiConverterTypeFfiSubscribeError.check_lower(error)
        
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffipreferencecallback_on_error,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiSubscribeError.lower(error))






    def on_close(self, ) -> None:
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffipreferencecallback_on_close,self._uniffi_clone_pointer(),)






# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplFfiPreferenceCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_FFI_PREFERENCE_CALLBACK_METHOD0
    def on_preference_update(
            uniffi_handle,
            preference,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiPreferenceCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterSequenceTypeFfiPreferenceUpdate.lift(preference), )
            method = uniffi_obj.on_preference_update
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FFI_PREFERENCE_CALLBACK_METHOD1
    def on_error(
            uniffi_handle,
            error,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiPreferenceCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeFfiSubscribeError.lift(error), )
            method = uniffi_obj.on_error
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FFI_PREFERENCE_CALLBACK_METHOD2
    def on_close(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFfiPreferenceCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.on_close
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeFfiPreferenceCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceFfiPreferenceCallback(
        on_preference_update,
        on_error,
        on_close,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_xmtpv3_fn_init_callback_vtable_ffipreferencecallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeFfiPreferenceCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return FfiPreferenceCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiPreferenceCallback):
        pass

    @staticmethod
    def lower(value: FfiPreferenceCallbackProtocol):
        return _UniffiConverterTypeFfiPreferenceCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiPreferenceCallbackProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiAuthHandleProtocol(typing.Protocol):
    def id(self, ):
        raise NotImplementedError
    def set(self, credential: "FfiCredential"):
        raise NotImplementedError
# FfiAuthHandle is a Rust-only trait - it's a wrapper around a Rust implementation.
class FfiAuthHandle():
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_constructor_ffiauthhandle_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffiauthhandle, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffiauthhandle, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def id(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffiauthhandle_id,self._uniffi_clone_pointer(),)
        )




    async def set(self, credential: "FfiCredential") -> None:

        _UniffiConverterTypeFfiCredential.check_lower(credential)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffiauthhandle_set(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiCredential.lower(credential)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )





class _UniffiConverterTypeFfiAuthHandle:

    @staticmethod
    def lift(value: int):
        return FfiAuthHandle._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiAuthHandle):
        if not isinstance(value, FfiAuthHandle):
            raise TypeError("Expected FfiAuthHandle instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiAuthHandleProtocol):
        if not isinstance(value, FfiAuthHandle):
            raise TypeError("Expected FfiAuthHandle instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiAuthHandleProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiConversationProtocol(typing.Protocol):
    def add_admin(self, inbox_id: "str"):
        raise NotImplementedError
    def add_members(self, account_identifiers: "typing.List[FfiIdentifier]"):
        raise NotImplementedError
    def add_members_by_inbox_id(self, inbox_ids: "typing.List[str]"):
        raise NotImplementedError
    def add_super_admin(self, inbox_id: "str"):
        raise NotImplementedError
    def added_by_inbox_id(self, ):
        raise NotImplementedError
    def admin_list(self, ):
        raise NotImplementedError
    def app_data(self, ):
        raise NotImplementedError
    def consent_state(self, ):
        raise NotImplementedError
    def conversation_debug_info(self, ):
        raise NotImplementedError
    def conversation_message_disappearing_settings(self, ):
        raise NotImplementedError
    def conversation_type(self, ):
        raise NotImplementedError
    def count_messages(self, opts: "FfiListMessagesOptions"):
        raise NotImplementedError
    def created_at_ns(self, ):
        raise NotImplementedError
    def dm_peer_inbox_id(self, ):
        raise NotImplementedError
    def find_duplicate_dms(self, ):
        raise NotImplementedError
    def find_enriched_messages(self, opts: "FfiListMessagesOptions"):
        raise NotImplementedError
    def find_messages(self, opts: "FfiListMessagesOptions"):
        raise NotImplementedError
    def find_messages_with_reactions(self, opts: "FfiListMessagesOptions"):
        raise NotImplementedError
    def get_hmac_keys(self, ):
        raise NotImplementedError
    def get_last_read_times(self, ):
        raise NotImplementedError
    def group_description(self, ):
        raise NotImplementedError
    def group_image_url_square(self, ):
        raise NotImplementedError
    def group_metadata(self, ):
        raise NotImplementedError
    def group_name(self, ):
        raise NotImplementedError
    def group_permissions(self, ):
        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def is_active(self, ):
        raise NotImplementedError
    def is_admin(self, inbox_id: "str"):
        raise NotImplementedError
    def is_conversation_message_disappearing_enabled(self, ):
        raise NotImplementedError
    def is_super_admin(self, inbox_id: "str"):
        raise NotImplementedError
    def leave_group(self, ):
        raise NotImplementedError
    def list_members(self, ):
        raise NotImplementedError
    def membership_state(self, ):
        raise NotImplementedError
    def paused_for_version(self, ):
        raise NotImplementedError
    def process_streamed_conversation_message(self, envelope_bytes: "bytes"):
        raise NotImplementedError
    def publish_messages(self, ):
        """
        Publish all unpublished messages
        """

        raise NotImplementedError
    def remove_admin(self, inbox_id: "str"):
        raise NotImplementedError
    def remove_conversation_message_disappearing_settings(self, ):
        raise NotImplementedError
    def remove_members(self, account_identifiers: "typing.List[FfiIdentifier]"):
        raise NotImplementedError
    def remove_members_by_inbox_id(self, inbox_ids: "typing.List[str]"):
        raise NotImplementedError
    def remove_super_admin(self, inbox_id: "str"):
        raise NotImplementedError
    def send(self, content_bytes: "bytes",opts: "FfiSendMessageOpts"):
        raise NotImplementedError
    def send_optimistic(self, content_bytes: "bytes",opts: "FfiSendMessageOpts"):
        """
        send a message without immediately publishing to the delivery service.
        """

        raise NotImplementedError
    def send_text(self, text: "str"):
        raise NotImplementedError
    def stream(self, message_callback: "FfiMessageCallback"):
        raise NotImplementedError
    def super_admin_list(self, ):
        raise NotImplementedError
    def sync(self, ):
        raise NotImplementedError
    def update_app_data(self, app_data: "str"):
        raise NotImplementedError
    def update_consent_state(self, state: "FfiConsentState"):
        raise NotImplementedError
    def update_conversation_message_disappearing_settings(self, settings: "FfiMessageDisappearingSettings"):
        raise NotImplementedError
    def update_group_description(self, group_description: "str"):
        raise NotImplementedError
    def update_group_image_url_square(self, group_image_url_square: "str"):
        raise NotImplementedError
    def update_group_name(self, group_name: "str"):
        raise NotImplementedError
    def update_permission_policy(self, permission_update_type: "FfiPermissionUpdateType",permission_policy_option: "FfiPermissionPolicy",metadata_field: "typing.Optional[FfiMetadataField]"):
        raise NotImplementedError
# FfiConversation is a Rust-only trait - it's a wrapper around a Rust implementation.
class FfiConversation():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_fficonversation, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversation, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def add_admin(self, inbox_id: "str") -> None:

        _UniffiConverterString.check_lower(inbox_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_admin(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(inbox_id)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def add_members(self, account_identifiers: "typing.List[FfiIdentifier]") -> "FfiUpdateGroupMembershipResult":
        _UniffiConverterSequenceTypeFfiIdentifier.check_lower(account_identifiers)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_members(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeFfiIdentifier.lower(account_identifiers)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFfiUpdateGroupMembershipResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def add_members_by_inbox_id(self, inbox_ids: "typing.List[str]") -> "FfiUpdateGroupMembershipResult":
        _UniffiConverterSequenceString.check_lower(inbox_ids)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_members_by_inbox_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceString.lower(inbox_ids)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFfiUpdateGroupMembershipResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def add_super_admin(self, inbox_id: "str") -> None:

        _UniffiConverterString.check_lower(inbox_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_add_super_admin(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(inbox_id)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def added_by_inbox_id(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_added_by_inbox_id,self._uniffi_clone_pointer(),)
        )





    def admin_list(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_admin_list,self._uniffi_clone_pointer(),)
        )





    def app_data(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_app_data,self._uniffi_clone_pointer(),)
        )





    def consent_state(self, ) -> "FfiConsentState":
        return _UniffiConverterTypeFfiConsentState.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_consent_state,self._uniffi_clone_pointer(),)
        )




    async def conversation_debug_info(self, ) -> "FfiConversationDebugInfo":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_conversation_debug_info(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFfiConversationDebugInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def conversation_message_disappearing_settings(self, ) -> "typing.Optional[FfiMessageDisappearingSettings]":
        return _UniffiConverterOptionalTypeFfiMessageDisappearingSettings.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_conversation_message_disappearing_settings,self._uniffi_clone_pointer(),)
        )





    def conversation_type(self, ) -> "FfiConversationType":
        return _UniffiConverterTypeFfiConversationType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_conversation_type,self._uniffi_clone_pointer(),)
        )





    def count_messages(self, opts: "FfiListMessagesOptions") -> "int":
        _UniffiConverterTypeFfiListMessagesOptions.check_lower(opts)
        
        return _UniffiConverterInt64.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_count_messages,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiListMessagesOptions.lower(opts))
        )





    def created_at_ns(self, ) -> "int":
        return _UniffiConverterInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_created_at_ns,self._uniffi_clone_pointer(),)
        )





    def dm_peer_inbox_id(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_dm_peer_inbox_id,self._uniffi_clone_pointer(),)
        )




    async def find_duplicate_dms(self, ) -> "typing.List[FfiConversation]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_duplicate_dms(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeFfiConversation.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def find_enriched_messages(self, opts: "FfiListMessagesOptions") -> "typing.List[FfiDecodedMessage]":
        _UniffiConverterTypeFfiListMessagesOptions.check_lower(opts)
        
        return _UniffiConverterSequenceTypeFfiDecodedMessage.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_enriched_messages,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiListMessagesOptions.lower(opts))
        )




    async def find_messages(self, opts: "FfiListMessagesOptions") -> "typing.List[FfiMessage]":
        _UniffiConverterTypeFfiListMessagesOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_messages(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiListMessagesOptions.lower(opts)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeFfiMessage.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def find_messages_with_reactions(self, opts: "FfiListMessagesOptions") -> "typing.List[FfiMessageWithReactions]":
        _UniffiConverterTypeFfiListMessagesOptions.check_lower(opts)
        
        return _UniffiConverterSequenceTypeFfiMessageWithReactions.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_find_messages_with_reactions,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiListMessagesOptions.lower(opts))
        )





    def get_hmac_keys(self, ) -> "dict[bytes, typing.List[FfiHmacKey]]":
        return _UniffiConverterMapBytesSequenceTypeFfiHmacKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_get_hmac_keys,self._uniffi_clone_pointer(),)
        )





    def get_last_read_times(self, ) -> "dict[str, int]":
        return _UniffiConverterMapStringInt64.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_get_last_read_times,self._uniffi_clone_pointer(),)
        )





    def group_description(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_description,self._uniffi_clone_pointer(),)
        )





    def group_image_url_square(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_image_url_square,self._uniffi_clone_pointer(),)
        )




    async def group_metadata(self, ) -> "FfiConversationMetadata":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_metadata(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiConversationMetadata.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def group_name(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_name,self._uniffi_clone_pointer(),)
        )





    def group_permissions(self, ) -> "FfiGroupPermissions":
        return _UniffiConverterTypeFfiGroupPermissions.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_group_permissions,self._uniffi_clone_pointer(),)
        )





    def id(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_id,self._uniffi_clone_pointer(),)
        )





    def is_active(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_active,self._uniffi_clone_pointer(),)
        )





    def is_admin(self, inbox_id: "str") -> "bool":
        _UniffiConverterString.check_lower(inbox_id)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_admin,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(inbox_id))
        )





    def is_conversation_message_disappearing_enabled(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_conversation_message_disappearing_enabled,self._uniffi_clone_pointer(),)
        )





    def is_super_admin(self, inbox_id: "str") -> "bool":
        _UniffiConverterString.check_lower(inbox_id)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_is_super_admin,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(inbox_id))
        )




    async def leave_group(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_leave_group(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def list_members(self, ) -> "typing.List[FfiConversationMember]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_list_members(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeFfiConversationMember.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def membership_state(self, ) -> "FfiGroupMembershipState":
        return _UniffiConverterTypeFfiGroupMembershipState.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_membership_state,self._uniffi_clone_pointer(),)
        )





    def paused_for_version(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_paused_for_version,self._uniffi_clone_pointer(),)
        )




    async def process_streamed_conversation_message(self, envelope_bytes: "bytes") -> "typing.List[FfiMessage]":
        _UniffiConverterBytes.check_lower(envelope_bytes)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_process_streamed_conversation_message(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(envelope_bytes)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeFfiMessage.lift,
            
    # Error FFI converter
_UniffiConverterTypeFfiSubscribeError,

        )



    async def publish_messages(self, ) -> None:

        """
        Publish all unpublished messages
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_publish_messages(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def remove_admin(self, inbox_id: "str") -> None:

        _UniffiConverterString.check_lower(inbox_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_admin(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(inbox_id)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def remove_conversation_message_disappearing_settings(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_conversation_message_disappearing_settings(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def remove_members(self, account_identifiers: "typing.List[FfiIdentifier]") -> None:

        _UniffiConverterSequenceTypeFfiIdentifier.check_lower(account_identifiers)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_members(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeFfiIdentifier.lower(account_identifiers)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def remove_members_by_inbox_id(self, inbox_ids: "typing.List[str]") -> None:

        _UniffiConverterSequenceString.check_lower(inbox_ids)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_members_by_inbox_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceString.lower(inbox_ids)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def remove_super_admin(self, inbox_id: "str") -> None:

        _UniffiConverterString.check_lower(inbox_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_remove_super_admin(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(inbox_id)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def send(self, content_bytes: "bytes",opts: "FfiSendMessageOpts") -> "bytes":
        _UniffiConverterBytes.check_lower(content_bytes)
        
        _UniffiConverterTypeFfiSendMessageOpts.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_send(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(content_bytes),
        _UniffiConverterTypeFfiSendMessageOpts.lower(opts)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def send_optimistic(self, content_bytes: "bytes",opts: "FfiSendMessageOpts") -> "bytes":
        """
        send a message without immediately publishing to the delivery service.
        """

        _UniffiConverterBytes.check_lower(content_bytes)
        
        _UniffiConverterTypeFfiSendMessageOpts.check_lower(opts)
        
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_send_optimistic,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(content_bytes),
        _UniffiConverterTypeFfiSendMessageOpts.lower(opts))
        )




    async def send_text(self, text: "str") -> "bytes":
        _UniffiConverterString.check_lower(text)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_send_text(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(text)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def stream(self, message_callback: "FfiMessageCallback") -> "FfiStreamCloser":
        _UniffiConverterTypeFfiMessageCallback.check_lower(message_callback)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_stream(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiMessageCallback.lower(message_callback)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiStreamCloser.lift,
            
    # Error FFI converter

    None,

        )




    def super_admin_list(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_super_admin_list,self._uniffi_clone_pointer(),)
        )




    async def sync(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_sync(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def update_app_data(self, app_data: "str") -> None:

        _UniffiConverterString.check_lower(app_data)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_app_data(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(app_data)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def update_consent_state(self, state: "FfiConsentState") -> None:
        _UniffiConverterTypeFfiConsentState.check_lower(state)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_consent_state,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiConsentState.lower(state))





    async def update_conversation_message_disappearing_settings(self, settings: "FfiMessageDisappearingSettings") -> None:

        _UniffiConverterTypeFfiMessageDisappearingSettings.check_lower(settings)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_conversation_message_disappearing_settings(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiMessageDisappearingSettings.lower(settings)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def update_group_description(self, group_description: "str") -> None:

        _UniffiConverterString.check_lower(group_description)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_group_description(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(group_description)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def update_group_image_url_square(self, group_image_url_square: "str") -> None:

        _UniffiConverterString.check_lower(group_image_url_square)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_group_image_url_square(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(group_image_url_square)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def update_group_name(self, group_name: "str") -> None:

        _UniffiConverterString.check_lower(group_name)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_group_name(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(group_name)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def update_permission_policy(self, permission_update_type: "FfiPermissionUpdateType",permission_policy_option: "FfiPermissionPolicy",metadata_field: "typing.Optional[FfiMetadataField]") -> None:

        _UniffiConverterTypeFfiPermissionUpdateType.check_lower(permission_update_type)
        
        _UniffiConverterTypeFfiPermissionPolicy.check_lower(permission_policy_option)
        
        _UniffiConverterOptionalTypeFfiMetadataField.check_lower(metadata_field)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversation_update_permission_policy(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiPermissionUpdateType.lower(permission_update_type),
        _UniffiConverterTypeFfiPermissionPolicy.lower(permission_policy_option),
        _UniffiConverterOptionalTypeFfiMetadataField.lower(metadata_field)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )





class _UniffiConverterTypeFfiConversation:

    @staticmethod
    def lift(value: int):
        return FfiConversation._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiConversation):
        if not isinstance(value, FfiConversation):
            raise TypeError("Expected FfiConversation instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiConversationProtocol):
        if not isinstance(value, FfiConversation):
            raise TypeError("Expected FfiConversation instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiConversationProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiConversationListItemProtocol(typing.Protocol):
    def conversation(self, ):
        raise NotImplementedError
    def is_commit_log_forked(self, ):
        raise NotImplementedError
    def last_message(self, ):
        raise NotImplementedError
# FfiConversationListItem is a Rust-only trait - it's a wrapper around a Rust implementation.
class FfiConversationListItem():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_fficonversationlistitem, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversationlistitem, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def conversation(self, ) -> "FfiConversation":
        return _UniffiConverterTypeFfiConversation.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationlistitem_conversation,self._uniffi_clone_pointer(),)
        )





    def is_commit_log_forked(self, ) -> "typing.Optional[bool]":
        return _UniffiConverterOptionalBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationlistitem_is_commit_log_forked,self._uniffi_clone_pointer(),)
        )





    def last_message(self, ) -> "typing.Optional[FfiMessage]":
        return _UniffiConverterOptionalTypeFfiMessage.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationlistitem_last_message,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeFfiConversationListItem:

    @staticmethod
    def lift(value: int):
        return FfiConversationListItem._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiConversationListItem):
        if not isinstance(value, FfiConversationListItem):
            raise TypeError("Expected FfiConversationListItem instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiConversationListItemProtocol):
        if not isinstance(value, FfiConversationListItem):
            raise TypeError("Expected FfiConversationListItem instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiConversationListItemProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiConversationMetadataProtocol(typing.Protocol):
    def conversation_type(self, ):
        raise NotImplementedError
    def creator_inbox_id(self, ):
        raise NotImplementedError
# FfiConversationMetadata is a Rust-only trait - it's a wrapper around a Rust implementation.
class FfiConversationMetadata():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_fficonversationmetadata, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversationmetadata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def conversation_type(self, ) -> "FfiConversationType":
        return _UniffiConverterTypeFfiConversationType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationmetadata_conversation_type,self._uniffi_clone_pointer(),)
        )





    def creator_inbox_id(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_fficonversationmetadata_creator_inbox_id,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeFfiConversationMetadata:

    @staticmethod
    def lift(value: int):
        return FfiConversationMetadata._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiConversationMetadata):
        if not isinstance(value, FfiConversationMetadata):
            raise TypeError("Expected FfiConversationMetadata instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiConversationMetadataProtocol):
        if not isinstance(value, FfiConversationMetadata):
            raise TypeError("Expected FfiConversationMetadata instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiConversationMetadataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiConversationsProtocol(typing.Protocol):
    def create_group(self, account_identities: "typing.List[FfiIdentifier]",opts: "FfiCreateGroupOptions"):
        raise NotImplementedError
    def create_group_optimistic(self, opts: "FfiCreateGroupOptions"):
        raise NotImplementedError
    def create_group_with_inbox_ids(self, inbox_ids: "typing.List[str]",opts: "FfiCreateGroupOptions"):
        raise NotImplementedError
    def find_or_create_dm(self, target_identity: "FfiIdentifier",opts: "FfiCreateDmOptions"):
        raise NotImplementedError
    def find_or_create_dm_by_inbox_id(self, inbox_id: "str",opts: "FfiCreateDmOptions"):
        raise NotImplementedError
    def get_hmac_keys(self, ):
        raise NotImplementedError
    def list(self, opts: "FfiListConversationsOptions"):
        raise NotImplementedError
    def list_dms(self, opts: "FfiListConversationsOptions"):
        raise NotImplementedError
    def list_groups(self, opts: "FfiListConversationsOptions"):
        raise NotImplementedError
    def process_streamed_welcome_message(self, envelope_bytes: "bytes"):
        raise NotImplementedError
    def stream(self, callback: "FfiConversationCallback"):
        raise NotImplementedError
    def stream_all_dm_messages(self, message_callback: "FfiMessageCallback",consent_states: "typing.Optional[typing.List[FfiConsentState]]"):
        raise NotImplementedError
    def stream_all_group_messages(self, message_callback: "FfiMessageCallback",consent_states: "typing.Optional[typing.List[FfiConsentState]]"):
        raise NotImplementedError
    def stream_all_messages(self, message_callback: "FfiMessageCallback",consent_states: "typing.Optional[typing.List[FfiConsentState]]"):
        raise NotImplementedError
    def stream_consent(self, callback: "FfiConsentCallback"):
        """
        Get notified when there is a new consent update either locally or is synced from another device
        allowing the user to re-render the new state appropriately
        """

        raise NotImplementedError
    def stream_dms(self, callback: "FfiConversationCallback"):
        raise NotImplementedError
    def stream_groups(self, callback: "FfiConversationCallback"):
        raise NotImplementedError
    def stream_message_deletions(self, callback: "FfiMessageDeletionCallback"):
        """
        Get notified when a message is deleted by the disappearing messages worker.
        The callback receives the message ID of each deleted message.
        """

        raise NotImplementedError
    def stream_messages(self, message_callback: "FfiMessageCallback",conversation_type: "typing.Optional[FfiConversationType]",consent_states: "typing.Optional[typing.List[FfiConsentState]]"):
        raise NotImplementedError
    def stream_preferences(self, callback: "FfiPreferenceCallback"):
        """
        Get notified when a preference changes either locally or is synced from another device
        allowing the user to re-render the new state appropriately.
        """

        raise NotImplementedError
    def sync(self, ):
        raise NotImplementedError
    def sync_all_conversations(self, consent_states: "typing.Optional[typing.List[FfiConsentState]]"):
        raise NotImplementedError
# FfiConversations is a Rust-only trait - it's a wrapper around a Rust implementation.
class FfiConversations():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_fficonversations, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_fficonversations, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def create_group(self, account_identities: "typing.List[FfiIdentifier]",opts: "FfiCreateGroupOptions") -> "FfiConversation":
        _UniffiConverterSequenceTypeFfiIdentifier.check_lower(account_identities)
        
        _UniffiConverterTypeFfiCreateGroupOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_create_group(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeFfiIdentifier.lower(account_identities),
        _UniffiConverterTypeFfiCreateGroupOptions.lower(opts)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiConversation.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def create_group_optimistic(self, opts: "FfiCreateGroupOptions") -> "FfiConversation":
        _UniffiConverterTypeFfiCreateGroupOptions.check_lower(opts)
        
        return _UniffiConverterTypeFfiConversation.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_create_group_optimistic,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiCreateGroupOptions.lower(opts))
        )




    async def create_group_with_inbox_ids(self, inbox_ids: "typing.List[str]",opts: "FfiCreateGroupOptions") -> "FfiConversation":
        _UniffiConverterSequenceString.check_lower(inbox_ids)
        
        _UniffiConverterTypeFfiCreateGroupOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_create_group_with_inbox_ids(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceString.lower(inbox_ids),
        _UniffiConverterTypeFfiCreateGroupOptions.lower(opts)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiConversation.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def find_or_create_dm(self, target_identity: "FfiIdentifier",opts: "FfiCreateDmOptions") -> "FfiConversation":
        _UniffiConverterTypeFfiIdentifier.check_lower(target_identity)
        
        _UniffiConverterTypeFfiCreateDmOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiIdentifier.lower(target_identity),
        _UniffiConverterTypeFfiCreateDmOptions.lower(opts)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiConversation.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def find_or_create_dm_by_inbox_id(self, inbox_id: "str",opts: "FfiCreateDmOptions") -> "FfiConversation":
        _UniffiConverterString.check_lower(inbox_id)
        
        _UniffiConverterTypeFfiCreateDmOptions.check_lower(opts)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_find_or_create_dm_by_inbox_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(inbox_id),
        _UniffiConverterTypeFfiCreateDmOptions.lower(opts)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiConversation.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def get_hmac_keys(self, ) -> "dict[bytes, typing.List[FfiHmacKey]]":
        return _UniffiConverterMapBytesSequenceTypeFfiHmacKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_get_hmac_keys,self._uniffi_clone_pointer(),)
        )





    def list(self, opts: "FfiListConversationsOptions") -> "typing.List[FfiConversationListItem]":
        _UniffiConverterTypeFfiListConversationsOptions.check_lower(opts)
        
        return _UniffiConverterSequenceTypeFfiConversationListItem.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_list,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiListConversationsOptions.lower(opts))
        )





    def list_dms(self, opts: "FfiListConversationsOptions") -> "typing.List[FfiConversationListItem]":
        _UniffiConverterTypeFfiListConversationsOptions.check_lower(opts)
        
        return _UniffiConverterSequenceTypeFfiConversationListItem.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_list_dms,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiListConversationsOptions.lower(opts))
        )





    def list_groups(self, opts: "FfiListConversationsOptions") -> "typing.List[FfiConversationListItem]":
        _UniffiConverterTypeFfiListConversationsOptions.check_lower(opts)
        
        return _UniffiConverterSequenceTypeFfiConversationListItem.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_list_groups,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFfiListConversationsOptions.lower(opts))
        )




    async def process_streamed_welcome_message(self, envelope_bytes: "bytes") -> "typing.List[FfiConversation]":
        _UniffiConverterBytes.check_lower(envelope_bytes)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_process_streamed_welcome_message(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(envelope_bytes)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeFfiConversation.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def stream(self, callback: "FfiConversationCallback") -> "FfiStreamCloser":
        _UniffiConverterTypeFfiConversationCallback.check_lower(callback)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiConversationCallback.lower(callback)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiStreamCloser.lift,
            
    # Error FFI converter

    None,

        )



    async def stream_all_dm_messages(self, message_callback: "FfiMessageCallback",consent_states: "typing.Optional[typing.List[FfiConsentState]]") -> "FfiStreamCloser":
        _UniffiConverterTypeFfiMessageCallback.check_lower(message_callback)
        
        _UniffiConverterOptionalSequenceTypeFfiConsentState.check_lower(consent_states)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_all_dm_messages(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiMessageCallback.lower(message_callback),
        _UniffiConverterOptionalSequenceTypeFfiConsentState.lower(consent_states)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiStreamCloser.lift,
            
    # Error FFI converter

    None,

        )



    async def stream_all_group_messages(self, message_callback: "FfiMessageCallback",consent_states: "typing.Optional[typing.List[FfiConsentState]]") -> "FfiStreamCloser":
        _UniffiConverterTypeFfiMessageCallback.check_lower(message_callback)
        
        _UniffiConverterOptionalSequenceTypeFfiConsentState.check_lower(consent_states)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_all_group_messages(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiMessageCallback.lower(message_callback),
        _UniffiConverterOptionalSequenceTypeFfiConsentState.lower(consent_states)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiStreamCloser.lift,
            
    # Error FFI converter

    None,

        )



    async def stream_all_messages(self, message_callback: "FfiMessageCallback",consent_states: "typing.Optional[typing.List[FfiConsentState]]") -> "FfiStreamCloser":
        _UniffiConverterTypeFfiMessageCallback.check_lower(message_callback)
        
        _UniffiConverterOptionalSequenceTypeFfiConsentState.check_lower(consent_states)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_all_messages(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiMessageCallback.lower(message_callback),
        _UniffiConverterOptionalSequenceTypeFfiConsentState.lower(consent_states)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiStreamCloser.lift,
            
    # Error FFI converter

    None,

        )



    async def stream_consent(self, callback: "FfiConsentCallback") -> "FfiStreamCloser":
        """
        Get notified when there is a new consent update either locally or is synced from another device
        allowing the user to re-render the new state appropriately
        """

        _UniffiConverterTypeFfiConsentCallback.check_lower(callback)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_consent(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiConsentCallback.lower(callback)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiStreamCloser.lift,
            
    # Error FFI converter

    None,

        )



    async def stream_dms(self, callback: "FfiConversationCallback") -> "FfiStreamCloser":
        _UniffiConverterTypeFfiConversationCallback.check_lower(callback)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_dms(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiConversationCallback.lower(callback)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiStreamCloser.lift,
            
    # Error FFI converter

    None,

        )



    async def stream_groups(self, callback: "FfiConversationCallback") -> "FfiStreamCloser":
        _UniffiConverterTypeFfiConversationCallback.check_lower(callback)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_groups(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiConversationCallback.lower(callback)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiStreamCloser.lift,
            
    # Error FFI converter

    None,

        )



    async def stream_message_deletions(self, callback: "FfiMessageDeletionCallback") -> "FfiStreamCloser":
        """
        Get notified when a message is deleted by the disappearing messages worker.
        The callback receives the message ID of each deleted message.
        """

        _UniffiConverterTypeFfiMessageDeletionCallback.check_lower(callback)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_message_deletions(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiMessageDeletionCallback.lower(callback)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiStreamCloser.lift,
            
    # Error FFI converter

    None,

        )



    async def stream_messages(self, message_callback: "FfiMessageCallback",conversation_type: "typing.Optional[FfiConversationType]",consent_states: "typing.Optional[typing.List[FfiConsentState]]") -> "FfiStreamCloser":
        _UniffiConverterTypeFfiMessageCallback.check_lower(message_callback)
        
        _UniffiConverterOptionalTypeFfiConversationType.check_lower(conversation_type)
        
        _UniffiConverterOptionalSequenceTypeFfiConsentState.check_lower(consent_states)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_messages(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiMessageCallback.lower(message_callback),
        _UniffiConverterOptionalTypeFfiConversationType.lower(conversation_type),
        _UniffiConverterOptionalSequenceTypeFfiConsentState.lower(consent_states)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiStreamCloser.lift,
            
    # Error FFI converter

    None,

        )



    async def stream_preferences(self, callback: "FfiPreferenceCallback") -> "FfiStreamCloser":
        """
        Get notified when a preference changes either locally or is synced from another device
        allowing the user to re-render the new state appropriately.
        """

        _UniffiConverterTypeFfiPreferenceCallback.check_lower(callback)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_stream_preferences(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiPreferenceCallback.lower(callback)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiStreamCloser.lift,
            
    # Error FFI converter

    None,

        )



    async def sync(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_sync(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def sync_all_conversations(self, consent_states: "typing.Optional[typing.List[FfiConsentState]]") -> "FfiGroupSyncSummary":
        _UniffiConverterOptionalSequenceTypeFfiConsentState.check_lower(consent_states)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_fficonversations_sync_all_conversations(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalSequenceTypeFfiConsentState.lower(consent_states)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFfiGroupSyncSummary.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )





class _UniffiConverterTypeFfiConversations:

    @staticmethod
    def lift(value: int):
        return FfiConversations._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiConversations):
        if not isinstance(value, FfiConversations):
            raise TypeError("Expected FfiConversations instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiConversationsProtocol):
        if not isinstance(value, FfiConversations):
            raise TypeError("Expected FfiConversations instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiConversationsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiDecodedMessageProtocol(typing.Protocol):
    def content(self, ):
        raise NotImplementedError
    def content_type_id(self, ):
        raise NotImplementedError
    def conversation_id(self, ):
        raise NotImplementedError
    def delivery_status(self, ):
        raise NotImplementedError
    def expires_at_ns(self, ):
        raise NotImplementedError
    def fallback_text(self, ):
        raise NotImplementedError
    def has_reactions(self, ):
        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def inserted_at_ns(self, ):
        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def num_replies(self, ):
        raise NotImplementedError
    def reaction_count(self, ):
        raise NotImplementedError
    def reactions(self, ):
        raise NotImplementedError
    def sender_inbox_id(self, ):
        raise NotImplementedError
    def sender_installation_id(self, ):
        raise NotImplementedError
    def sent_at_ns(self, ):
        raise NotImplementedError
# FfiDecodedMessage is a Rust-only trait - it's a wrapper around a Rust implementation.
class FfiDecodedMessage():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffidecodedmessage, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffidecodedmessage, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def content(self, ) -> "FfiDecodedMessageContent":
        return _UniffiConverterTypeFfiDecodedMessageContent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_content,self._uniffi_clone_pointer(),)
        )





    def content_type_id(self, ) -> "FfiContentTypeId":
        return _UniffiConverterTypeFfiContentTypeId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_content_type_id,self._uniffi_clone_pointer(),)
        )





    def conversation_id(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_conversation_id,self._uniffi_clone_pointer(),)
        )





    def delivery_status(self, ) -> "FfiDeliveryStatus":
        return _UniffiConverterTypeFfiDeliveryStatus.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_delivery_status,self._uniffi_clone_pointer(),)
        )





    def expires_at_ns(self, ) -> "typing.Optional[int]":
        return _UniffiConverterOptionalInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_expires_at_ns,self._uniffi_clone_pointer(),)
        )





    def fallback_text(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_fallback_text,self._uniffi_clone_pointer(),)
        )





    def has_reactions(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_has_reactions,self._uniffi_clone_pointer(),)
        )





    def id(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_id,self._uniffi_clone_pointer(),)
        )





    def inserted_at_ns(self, ) -> "int":
        return _UniffiConverterInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_inserted_at_ns,self._uniffi_clone_pointer(),)
        )





    def kind(self, ) -> "FfiGroupMessageKind":
        return _UniffiConverterTypeFfiGroupMessageKind.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_kind,self._uniffi_clone_pointer(),)
        )





    def num_replies(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_num_replies,self._uniffi_clone_pointer(),)
        )





    def reaction_count(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_reaction_count,self._uniffi_clone_pointer(),)
        )





    def reactions(self, ) -> "typing.List[FfiDecodedMessage]":
        return _UniffiConverterSequenceTypeFfiDecodedMessage.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_reactions,self._uniffi_clone_pointer(),)
        )





    def sender_inbox_id(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_sender_inbox_id,self._uniffi_clone_pointer(),)
        )





    def sender_installation_id(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_sender_installation_id,self._uniffi_clone_pointer(),)
        )





    def sent_at_ns(self, ) -> "int":
        return _UniffiConverterInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffidecodedmessage_sent_at_ns,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeFfiDecodedMessage:

    @staticmethod
    def lift(value: int):
        return FfiDecodedMessage._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiDecodedMessage):
        if not isinstance(value, FfiDecodedMessage):
            raise TypeError("Expected FfiDecodedMessage instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiDecodedMessageProtocol):
        if not isinstance(value, FfiDecodedMessage):
            raise TypeError("Expected FfiDecodedMessage instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiDecodedMessageProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiGroupPermissionsProtocol(typing.Protocol):
    def policy_set(self, ):
        raise NotImplementedError
    def policy_type(self, ):
        raise NotImplementedError
# FfiGroupPermissions is a Rust-only trait - it's a wrapper around a Rust implementation.
class FfiGroupPermissions():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffigrouppermissions, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffigrouppermissions, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def policy_set(self, ) -> "FfiPermissionPolicySet":
        return _UniffiConverterTypeFfiPermissionPolicySet.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_set,self._uniffi_clone_pointer(),)
        )





    def policy_type(self, ) -> "FfiGroupPermissionsOptions":
        return _UniffiConverterTypeFfiGroupPermissionsOptions.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_ffigrouppermissions_policy_type,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeFfiGroupPermissions:

    @staticmethod
    def lift(value: int):
        return FfiGroupPermissions._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiGroupPermissions):
        if not isinstance(value, FfiGroupPermissions):
            raise TypeError("Expected FfiGroupPermissions instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiGroupPermissionsProtocol):
        if not isinstance(value, FfiGroupPermissions):
            raise TypeError("Expected FfiGroupPermissions instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiGroupPermissionsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiSignatureRequestProtocol(typing.Protocol):
    def add_ecdsa_signature(self, signature_bytes: "bytes"):
        raise NotImplementedError
    def add_passkey_signature(self, signature: "FfiPasskeySignature"):
        raise NotImplementedError
    def add_scw_signature(self, signature_bytes: "bytes",address: "str",chain_id: "int",block_number: "typing.Optional[int]"):
        raise NotImplementedError
    def is_ready(self, ):
        raise NotImplementedError
    def missing_address_signatures(self, ):
        """
        missing signatures that are from `MemberKind::Address`
        """

        raise NotImplementedError
    def signature_text(self, ):
        raise NotImplementedError
# FfiSignatureRequest is a Rust-only trait - it's a wrapper around a Rust implementation.
class FfiSignatureRequest():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffisignaturerequest, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffisignaturerequest, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def add_ecdsa_signature(self, signature_bytes: "bytes") -> None:

        _UniffiConverterBytes.check_lower(signature_bytes)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_add_ecdsa_signature(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(signature_bytes)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def add_passkey_signature(self, signature: "FfiPasskeySignature") -> None:

        _UniffiConverterTypeFfiPasskeySignature.check_lower(signature)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_add_passkey_signature(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiPasskeySignature.lower(signature)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def add_scw_signature(self, signature_bytes: "bytes",address: "str",chain_id: "int",block_number: "typing.Optional[int]") -> None:

        _UniffiConverterBytes.check_lower(signature_bytes)
        
        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterUInt64.check_lower(chain_id)
        
        _UniffiConverterOptionalUInt64.check_lower(block_number)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_add_scw_signature(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(signature_bytes),
        _UniffiConverterString.lower(address),
        _UniffiConverterUInt64.lower(chain_id),
        _UniffiConverterOptionalUInt64.lower(block_number)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def is_ready(self, ) -> "bool":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_is_ready(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_i8,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_i8,
            _UniffiLib.ffi_xmtpv3_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter

    None,

        )



    async def missing_address_signatures(self, ) -> "typing.List[str]":
        """
        missing signatures that are from `MemberKind::Address`
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_missing_address_signatures(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceString.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def signature_text(self, ) -> "str":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffisignaturerequest_signature_text(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )





class _UniffiConverterTypeFfiSignatureRequest:

    @staticmethod
    def lift(value: int):
        return FfiSignatureRequest._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiSignatureRequest):
        if not isinstance(value, FfiSignatureRequest):
            raise TypeError("Expected FfiSignatureRequest instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiSignatureRequestProtocol):
        if not isinstance(value, FfiSignatureRequest):
            raise TypeError("Expected FfiSignatureRequest instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiSignatureRequestProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiStreamCloserProtocol(typing.Protocol):
    def end(self, ):
        """
        Signal the stream to end
        Does not wait for the stream to end.
        """

        raise NotImplementedError
    def end_and_wait(self, ):
        """
        End the stream and asynchronously wait for it to shutdown
        """

        raise NotImplementedError
    def is_closed(self, ):
        raise NotImplementedError
    def wait_for_ready(self, ):
        raise NotImplementedError
# FfiStreamCloser is a Rust-only trait - it's a wrapper around a Rust implementation.
class FfiStreamCloser():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffistreamcloser, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffistreamcloser, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def end(self, ) -> None:
        """
        Signal the stream to end
        Does not wait for the stream to end.
        """

        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_end,self._uniffi_clone_pointer(),)





    async def end_and_wait(self, ) -> None:

        """
        End the stream and asynchronously wait for it to shutdown
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_end_and_wait(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def is_closed(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_is_closed,self._uniffi_clone_pointer(),)
        )




    async def wait_for_ready(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffistreamcloser_wait_for_ready(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )





class _UniffiConverterTypeFfiStreamCloser:

    @staticmethod
    def lift(value: int):
        return FfiStreamCloser._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiStreamCloser):
        if not isinstance(value, FfiStreamCloser):
            raise TypeError("Expected FfiStreamCloser instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiStreamCloserProtocol):
        if not isinstance(value, FfiStreamCloser):
            raise TypeError("Expected FfiStreamCloser instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiStreamCloserProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiSyncWorkerProtocol(typing.Protocol):
    def wait(self, metric: "FfiSyncMetric",count: "int"):
        raise NotImplementedError
# FfiSyncWorker is a Rust-only trait - it's a wrapper around a Rust implementation.
class FfiSyncWorker():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffisyncworker, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffisyncworker, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def wait(self, metric: "FfiSyncMetric",count: "int") -> None:

        _UniffiConverterTypeFfiSyncMetric.check_lower(metric)
        
        _UniffiConverterUInt64.check_lower(count)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffisyncworker_wait(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiSyncMetric.lower(metric),
        _UniffiConverterUInt64.lower(count)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )





class _UniffiConverterTypeFfiSyncWorker:

    @staticmethod
    def lift(value: int):
        return FfiSyncWorker._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiSyncWorker):
        if not isinstance(value, FfiSyncWorker):
            raise TypeError("Expected FfiSyncWorker instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiSyncWorkerProtocol):
        if not isinstance(value, FfiSyncWorker):
            raise TypeError("Expected FfiSyncWorker instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiSyncWorkerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FfiXmtpClientProtocol(typing.Protocol):
    def add_identity(self, new_identity: "FfiIdentifier"):
        """
        Adds a wallet address to the existing client
        """

        raise NotImplementedError
    def addresses_from_inbox_id(self, refresh_from_network: "bool",inbox_ids: "typing.List[str]"):
        """
        * Get the inbox state for each `inbox_id`.
             *
             * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
             * Otherwise, the state will be read from the local database.
        """

        raise NotImplementedError
    def api_aggregate_statistics(self, ):
        raise NotImplementedError
    def api_identity_statistics(self, ):
        raise NotImplementedError
    def api_statistics(self, ):
        raise NotImplementedError
    def apply_signature_request(self, signature_request: "FfiSignatureRequest"):
        raise NotImplementedError
    def archive_metadata(self, path: "str",key: "bytes"):
        """
        Load the metadata for an archive to see what it contains.
        Reads only the metadata without loading the entire file, so this function is quick.
        """

        raise NotImplementedError
    def can_message(self, account_identifiers: "typing.List[FfiIdentifier]"):
        raise NotImplementedError
    def change_recovery_identifier(self, new_recovery_identifier: "FfiIdentifier"):
        """
        * Change the recovery identifier for your inboxId
        """

        raise NotImplementedError
    def clear_all_statistics(self, ):
        raise NotImplementedError
    def conversation(self, conversation_id: "bytes"):
        raise NotImplementedError
    def conversations(self, ):
        raise NotImplementedError
    def create_archive(self, path: "str",opts: "FfiArchiveOptions",key: "bytes"):
        """
        Archive application elements to file for later restoration.
        """

        raise NotImplementedError
    def db_reconnect(self, ):
        raise NotImplementedError
    def delete_message(self, message_id: "bytes"):
        raise NotImplementedError
    def dm_conversation(self, target_inbox_id: "str"):
        raise NotImplementedError
    def enriched_message(self, message_id: "bytes"):
        raise NotImplementedError
    def find_inbox_id(self, identifier: "FfiIdentifier"):
        raise NotImplementedError
    def get_consent_state(self, entity_type: "FfiConsentEntityType",entity: "str"):
        raise NotImplementedError
    def get_key_package_statuses_for_installation_ids(self, installation_ids: "typing.List[bytes]"):
        raise NotImplementedError
    def get_latest_inbox_state(self, inbox_id: "str"):
        raise NotImplementedError
    def import_archive(self, path: "str",key: "bytes"):
        """
        Import a previous archive
        """

        raise NotImplementedError
    def inbox_id(self, ):
        raise NotImplementedError
    def inbox_state(self, refresh_from_network: "bool"):
        """
        * Get the client's inbox state.
             *
             * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
             * Otherwise, the state will be read from the local database.
        """

        raise NotImplementedError
    def installation_id(self, ):
        raise NotImplementedError
    def message(self, message_id: "bytes"):
        raise NotImplementedError
    def register_identity(self, signature_request: "FfiSignatureRequest"):
        raise NotImplementedError
    def release_db_connection(self, ):
        raise NotImplementedError
    def revoke_all_other_installations_signature_request(self, ):
        """
        * Revokes all installations except the one the client is currently using
             * Returns Some FfiSignatureRequest if we have installations to revoke.
             * If we have no other installations to revoke, returns None.
        """

        raise NotImplementedError
    def revoke_identity(self, identifier: "FfiIdentifier"):
        """
        Revokes or removes an identity from the existing client
        """

        raise NotImplementedError
    def revoke_installations(self, installation_ids: "typing.List[bytes]"):
        """
        * Revoke a list of installations
        """

        raise NotImplementedError
    def send_sync_request(self, ):
        """
        Manually trigger a device sync request to sync records from another active device on this account.
        """

        raise NotImplementedError
    def set_consent_states(self, records: "typing.List[FfiConsent]"):
        raise NotImplementedError
    def sign_with_installation_key(self, text: "str"):
        """
        A utility function to sign a piece of text with this installation's private key.
        """

        raise NotImplementedError
    def signature_request(self, ):
        raise NotImplementedError
    def sync_preferences(self, ):
        raise NotImplementedError
    def verify_signed_with_installation_key(self, signature_text: "str",signature_bytes: "bytes"):
        """
        A utility function to easily verify that a piece of text was signed by this installation.
        """

        raise NotImplementedError
    def verify_signed_with_public_key(self, signature_text: "str",signature_bytes: "bytes",public_key: "bytes"):
        """
        A utility function to easily verify that a string has been signed by another libXmtp installation.
        Only works for verifying libXmtp public context signatures.
        """

        raise NotImplementedError
# FfiXmtpClient is a Rust-only trait - it's a wrapper around a Rust implementation.
class FfiXmtpClient():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_ffixmtpclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_ffixmtpclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def add_identity(self, new_identity: "FfiIdentifier") -> "FfiSignatureRequest":
        """
        Adds a wallet address to the existing client
        """

        _UniffiConverterTypeFfiIdentifier.check_lower(new_identity)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_add_identity(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiIdentifier.lower(new_identity)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiSignatureRequest.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def addresses_from_inbox_id(self, refresh_from_network: "bool",inbox_ids: "typing.List[str]") -> "typing.List[FfiInboxState]":
        """
        * Get the inbox state for each `inbox_id`.
             *
             * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
             * Otherwise, the state will be read from the local database.
        """

        _UniffiConverterBool.check_lower(refresh_from_network)
        
        _UniffiConverterSequenceString.check_lower(inbox_ids)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_addresses_from_inbox_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBool.lower(refresh_from_network),
        _UniffiConverterSequenceString.lower(inbox_ids)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeFfiInboxState.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def api_aggregate_statistics(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_api_aggregate_statistics,self._uniffi_clone_pointer(),)
        )





    def api_identity_statistics(self, ) -> "FfiIdentityStats":
        return _UniffiConverterTypeFfiIdentityStats.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_api_identity_statistics,self._uniffi_clone_pointer(),)
        )





    def api_statistics(self, ) -> "FfiApiStats":
        return _UniffiConverterTypeFfiApiStats.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_api_statistics,self._uniffi_clone_pointer(),)
        )




    async def apply_signature_request(self, signature_request: "FfiSignatureRequest") -> None:

        _UniffiConverterTypeFfiSignatureRequest.check_lower(signature_request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_apply_signature_request(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiSignatureRequest.lower(signature_request)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def archive_metadata(self, path: "str",key: "bytes") -> "FfiBackupMetadata":
        """
        Load the metadata for an archive to see what it contains.
        Reads only the metadata without loading the entire file, so this function is quick.
        """

        _UniffiConverterString.check_lower(path)
        
        _UniffiConverterBytes.check_lower(key)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_archive_metadata(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(path),
        _UniffiConverterBytes.lower(key)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFfiBackupMetadata.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def can_message(self, account_identifiers: "typing.List[FfiIdentifier]") -> "dict[FfiIdentifier, bool]":
        _UniffiConverterSequenceTypeFfiIdentifier.check_lower(account_identifiers)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_can_message(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeFfiIdentifier.lower(account_identifiers)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapTypeFfiIdentifierBool.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def change_recovery_identifier(self, new_recovery_identifier: "FfiIdentifier") -> "FfiSignatureRequest":
        """
        * Change the recovery identifier for your inboxId
        """

        _UniffiConverterTypeFfiIdentifier.check_lower(new_recovery_identifier)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_change_recovery_identifier(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiIdentifier.lower(new_recovery_identifier)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiSignatureRequest.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def clear_all_statistics(self, ) -> None:
        _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_clear_all_statistics,self._uniffi_clone_pointer(),)






    def conversation(self, conversation_id: "bytes") -> "FfiConversation":
        _UniffiConverterBytes.check_lower(conversation_id)
        
        return _UniffiConverterTypeFfiConversation.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_conversation,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(conversation_id))
        )





    def conversations(self, ) -> "FfiConversations":
        return _UniffiConverterTypeFfiConversations.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_conversations,self._uniffi_clone_pointer(),)
        )




    async def create_archive(self, path: "str",opts: "FfiArchiveOptions",key: "bytes") -> None:

        """
        Archive application elements to file for later restoration.
        """

        _UniffiConverterString.check_lower(path)
        
        _UniffiConverterTypeFfiArchiveOptions.check_lower(opts)
        
        _UniffiConverterBytes.check_lower(key)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_create_archive(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(path),
        _UniffiConverterTypeFfiArchiveOptions.lower(opts),
        _UniffiConverterBytes.lower(key)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def db_reconnect(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_db_reconnect(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def delete_message(self, message_id: "bytes") -> "int":
        _UniffiConverterBytes.check_lower(message_id)
        
        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_delete_message,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message_id))
        )





    def dm_conversation(self, target_inbox_id: "str") -> "FfiConversation":
        _UniffiConverterString.check_lower(target_inbox_id)
        
        return _UniffiConverterTypeFfiConversation.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_dm_conversation,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(target_inbox_id))
        )





    def enriched_message(self, message_id: "bytes") -> "FfiDecodedMessage":
        _UniffiConverterBytes.check_lower(message_id)
        
        return _UniffiConverterTypeFfiDecodedMessage.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_enriched_message,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message_id))
        )




    async def find_inbox_id(self, identifier: "FfiIdentifier") -> "typing.Optional[str]":
        _UniffiConverterTypeFfiIdentifier.check_lower(identifier)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_find_inbox_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiIdentifier.lower(identifier)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalString.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def get_consent_state(self, entity_type: "FfiConsentEntityType",entity: "str") -> "FfiConsentState":
        _UniffiConverterTypeFfiConsentEntityType.check_lower(entity_type)
        
        _UniffiConverterString.check_lower(entity)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_get_consent_state(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiConsentEntityType.lower(entity_type),
        _UniffiConverterString.lower(entity)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFfiConsentState.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def get_key_package_statuses_for_installation_ids(self, installation_ids: "typing.List[bytes]") -> "dict[bytes, FfiKeyPackageStatus]":
        _UniffiConverterSequenceBytes.check_lower(installation_ids)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_get_key_package_statuses_for_installation_ids(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceBytes.lower(installation_ids)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapBytesTypeFfiKeyPackageStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def get_latest_inbox_state(self, inbox_id: "str") -> "FfiInboxState":
        _UniffiConverterString.check_lower(inbox_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_get_latest_inbox_state(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(inbox_id)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFfiInboxState.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def import_archive(self, path: "str",key: "bytes") -> None:

        """
        Import a previous archive
        """

        _UniffiConverterString.check_lower(path)
        
        _UniffiConverterBytes.check_lower(key)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_import_archive(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(path),
        _UniffiConverterBytes.lower(key)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def inbox_id(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_id,self._uniffi_clone_pointer(),)
        )




    async def inbox_state(self, refresh_from_network: "bool") -> "FfiInboxState":
        """
        * Get the client's inbox state.
             *
             * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
             * Otherwise, the state will be read from the local database.
        """

        _UniffiConverterBool.check_lower(refresh_from_network)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_inbox_state(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBool.lower(refresh_from_network)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFfiInboxState.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def installation_id(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_installation_id,self._uniffi_clone_pointer(),)
        )





    def message(self, message_id: "bytes") -> "FfiMessage":
        _UniffiConverterBytes.check_lower(message_id)
        
        return _UniffiConverterTypeFfiMessage.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_message,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message_id))
        )




    async def register_identity(self, signature_request: "FfiSignatureRequest") -> None:

        _UniffiConverterTypeFfiSignatureRequest.check_lower(signature_request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_register_identity(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiSignatureRequest.lower(signature_request)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def release_db_connection(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_release_db_connection,self._uniffi_clone_pointer(),)





    async def revoke_all_other_installations_signature_request(self, ) -> "typing.Optional[FfiSignatureRequest]":
        """
        * Revokes all installations except the one the client is currently using
             * Returns Some FfiSignatureRequest if we have installations to revoke.
             * If we have no other installations to revoke, returns None.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_all_other_installations_signature_request(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeFfiSignatureRequest.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def revoke_identity(self, identifier: "FfiIdentifier") -> "FfiSignatureRequest":
        """
        Revokes or removes an identity from the existing client
        """

        _UniffiConverterTypeFfiIdentifier.check_lower(identifier)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_identity(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeFfiIdentifier.lower(identifier)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiSignatureRequest.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def revoke_installations(self, installation_ids: "typing.List[bytes]") -> "FfiSignatureRequest":
        """
        * Revoke a list of installations
        """

        _UniffiConverterSequenceBytes.check_lower(installation_ids)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_revoke_installations(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceBytes.lower(installation_ids)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeFfiSignatureRequest.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def send_sync_request(self, ) -> None:

        """
        Manually trigger a device sync request to sync records from another active device on this account.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_send_sync_request(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )



    async def set_consent_states(self, records: "typing.List[FfiConsent]") -> None:

        _UniffiConverterSequenceTypeFfiConsent.check_lower(records)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_set_consent_states(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeFfiConsent.lower(records)
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
            _UniffiLib.ffi_xmtpv3_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def sign_with_installation_key(self, text: "str") -> "bytes":
        """
        A utility function to sign a piece of text with this installation's private key.
        """

        _UniffiConverterString.check_lower(text)
        
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_sign_with_installation_key,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(text))
        )





    def signature_request(self, ) -> "typing.Optional[FfiSignatureRequest]":
        return _UniffiConverterOptionalTypeFfiSignatureRequest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_signature_request,self._uniffi_clone_pointer(),)
        )




    async def sync_preferences(self, ) -> "FfiGroupSyncSummary":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_sync_preferences(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeFfiGroupSyncSummary.lift,
            
    # Error FFI converter
_UniffiConverterTypeGenericError,

        )




    def verify_signed_with_installation_key(self, signature_text: "str",signature_bytes: "bytes") -> None:
        """
        A utility function to easily verify that a piece of text was signed by this installation.
        """

        _UniffiConverterString.check_lower(signature_text)
        
        _UniffiConverterBytes.check_lower(signature_bytes)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_installation_key,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(signature_text),
        _UniffiConverterBytes.lower(signature_bytes))






    def verify_signed_with_public_key(self, signature_text: "str",signature_bytes: "bytes",public_key: "bytes") -> None:
        """
        A utility function to easily verify that a string has been signed by another libXmtp installation.
        Only works for verifying libXmtp public context signatures.
        """

        _UniffiConverterString.check_lower(signature_text)
        
        _UniffiConverterBytes.check_lower(signature_bytes)
        
        _UniffiConverterBytes.check_lower(public_key)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_method_ffixmtpclient_verify_signed_with_public_key,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(signature_text),
        _UniffiConverterBytes.lower(signature_bytes),
        _UniffiConverterBytes.lower(public_key))







class _UniffiConverterTypeFfiXmtpClient:

    @staticmethod
    def lift(value: int):
        return FfiXmtpClient._make_instance_(value)

    @staticmethod
    def check_lower(value: FfiXmtpClient):
        if not isinstance(value, FfiXmtpClient):
            raise TypeError("Expected FfiXmtpClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FfiXmtpClientProtocol):
        if not isinstance(value, FfiXmtpClient):
            raise TypeError("Expected FfiXmtpClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FfiXmtpClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class XmtpApiClientProtocol(typing.Protocol):
    """
    the opaque Xmtp Api Client for iOS/Android bindings
    """

    pass
# XmtpApiClient is a Rust-only trait - it's a wrapper around a Rust implementation.
class XmtpApiClient():
    """
    the opaque Xmtp Api Client for iOS/Android bindings
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_free_xmtpapiclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_clone_xmtpapiclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeXmtpApiClient:

    @staticmethod
    def lift(value: int):
        return XmtpApiClient._make_instance_(value)

    @staticmethod
    def check_lower(value: XmtpApiClient):
        if not isinstance(value, XmtpApiClient):
            raise TypeError("Expected XmtpApiClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: XmtpApiClientProtocol):
        if not isinstance(value, XmtpApiClient):
            raise TypeError("Expected XmtpApiClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: XmtpApiClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)
def _uniffi_trait_interface_call_async(make_call, handle_success, handle_error):
    async def make_call_and_call_callback():
        # Note: it's important we call either `handle_success` or `handle_error` exactly once.  Each
        # call consumes an Arc reference, which means there should be no possibility of a double
        # call.  The following code is structured so that will will never call both `handle_success`
        # and `handle_error`, even in the face of weird exceptions.
        #
        # In extreme circumstances we may not call either, for example if we fail to make the ctypes
        # call to `handle_success`.  This means we will leak the Arc reference, which is better than
        # double-freeing it.
        try:
            call_result = await make_call()
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
        else:
            handle_success(call_result)
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

def _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, error_type, lower_error):
    async def make_call_and_call_callback():
        # See the note in _uniffi_trait_interface_call_async for details on `handle_success` and
        # `handle_error`.
        try:
            try:
                call_result = await make_call()
            except error_type as e:
                handle_error(
                    _UniffiRustCallStatus.CALL_ERROR,
                    lower_error(e),
                )
            else:
                handle_success(call_result)
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

_UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = _UniffiHandleMap()

@_UNIFFI_FOREIGN_FUTURE_FREE
def _uniffi_foreign_future_free(handle):
    (eventloop, task) = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle)
    eventloop.call_soon(_uniffi_foreign_future_do_free, task)

def _uniffi_foreign_future_do_free(task):
    if not task.done():
        task.cancel()
async def apply_signature_request(api: "XmtpApiClient",signature_request: "FfiSignatureRequest") -> None:

    """
    * Static apply a signature request
    """

    _UniffiConverterTypeXmtpApiClient.check_lower(api)
    
    _UniffiConverterTypeFfiSignatureRequest.check_lower(signature_request)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_xmtpv3_fn_func_apply_signature_request(
        _UniffiConverterTypeXmtpApiClient.lower(api),
        _UniffiConverterTypeFfiSignatureRequest.lower(signature_request)),
        _UniffiLib.ffi_xmtpv3_rust_future_poll_void,
        _UniffiLib.ffi_xmtpv3_rust_future_complete_void,
        _UniffiLib.ffi_xmtpv3_rust_future_free_void,
        # lift function
        lambda val: None,
        
        
    # Error FFI converter
_UniffiConverterTypeGenericError,

    )
async def connect_to_backend(v3_host: "str",gateway_host: "typing.Optional[str]",is_secure: "bool",client_mode: "typing.Optional[FfiClientMode]",app_version: "typing.Optional[str]",auth_callback: "typing.Optional[FfiAuthCallback]",auth_handle: "typing.Optional[FfiAuthHandle]") -> "XmtpApiClient":

    """
    connect to the XMTP backend
    specifying `gateway_host` enables the D14n backend
    and assumes `host` is set to the correct
    d14n backend url.
    """

    _UniffiConverterString.check_lower(v3_host)
    
    _UniffiConverterOptionalString.check_lower(gateway_host)
    
    _UniffiConverterBool.check_lower(is_secure)
    
    _UniffiConverterOptionalTypeFfiClientMode.check_lower(client_mode)
    
    _UniffiConverterOptionalString.check_lower(app_version)
    
    _UniffiConverterOptionalTypeFfiAuthCallback.check_lower(auth_callback)
    
    _UniffiConverterOptionalTypeFfiAuthHandle.check_lower(auth_handle)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_xmtpv3_fn_func_connect_to_backend(
        _UniffiConverterString.lower(v3_host),
        _UniffiConverterOptionalString.lower(gateway_host),
        _UniffiConverterBool.lower(is_secure),
        _UniffiConverterOptionalTypeFfiClientMode.lower(client_mode),
        _UniffiConverterOptionalString.lower(app_version),
        _UniffiConverterOptionalTypeFfiAuthCallback.lower(auth_callback),
        _UniffiConverterOptionalTypeFfiAuthHandle.lower(auth_handle)),
        _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
        _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
        _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
        # lift function
        _UniffiConverterTypeXmtpApiClient.lift,
        
    # Error FFI converter
_UniffiConverterTypeGenericError,

    )
async def create_client(api: "XmtpApiClient",sync_api: "XmtpApiClient",db: "typing.Optional[str]",encryption_key: "typing.Optional[bytes]",inbox_id: "str",account_identifier: "FfiIdentifier",nonce: "int",legacy_signed_private_key_proto: "typing.Optional[bytes]",device_sync_server_url: "typing.Optional[str]",device_sync_mode: "typing.Optional[FfiSyncWorkerMode]",allow_offline: "typing.Optional[bool]",fork_recovery_opts: "typing.Optional[FfiForkRecoveryOpts]") -> "FfiXmtpClient":

    """
    It returns a new client of the specified `inbox_id`.
    Note that the `inbox_id` must be either brand new or already associated with the `account_identifier`.
    i.e. `inbox_id` cannot be associated with another account address.

    Prior to calling this function, it's suggested to form `inbox_id`, `account_identifier`, and `nonce` like below.

    ```text
    inbox_id = get_inbox_id_for_address(account_identifier)
    nonce = 0

    // if inbox_id is not associated, we will create new one.
    if !inbox_id {
    if !legacy_key { nonce = random_u64() }
    inbox_id = generate_inbox_id(account_identifier, nonce)
    } // Otherwise, we will just use the inbox and ignore the nonce.
    db_path = $inbox_id-$env

    xmtp.create_client(account_identifier, nonce, inbox_id, Option<legacy_signed_private_key_proto>)
    ```
    """

    _UniffiConverterTypeXmtpApiClient.check_lower(api)
    
    _UniffiConverterTypeXmtpApiClient.check_lower(sync_api)
    
    _UniffiConverterOptionalString.check_lower(db)
    
    _UniffiConverterOptionalBytes.check_lower(encryption_key)
    
    _UniffiConverterString.check_lower(inbox_id)
    
    _UniffiConverterTypeFfiIdentifier.check_lower(account_identifier)
    
    _UniffiConverterUInt64.check_lower(nonce)
    
    _UniffiConverterOptionalBytes.check_lower(legacy_signed_private_key_proto)
    
    _UniffiConverterOptionalString.check_lower(device_sync_server_url)
    
    _UniffiConverterOptionalTypeFfiSyncWorkerMode.check_lower(device_sync_mode)
    
    _UniffiConverterOptionalBool.check_lower(allow_offline)
    
    _UniffiConverterOptionalTypeFfiForkRecoveryOpts.check_lower(fork_recovery_opts)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_xmtpv3_fn_func_create_client(
        _UniffiConverterTypeXmtpApiClient.lower(api),
        _UniffiConverterTypeXmtpApiClient.lower(sync_api),
        _UniffiConverterOptionalString.lower(db),
        _UniffiConverterOptionalBytes.lower(encryption_key),
        _UniffiConverterString.lower(inbox_id),
        _UniffiConverterTypeFfiIdentifier.lower(account_identifier),
        _UniffiConverterUInt64.lower(nonce),
        _UniffiConverterOptionalBytes.lower(legacy_signed_private_key_proto),
        _UniffiConverterOptionalString.lower(device_sync_server_url),
        _UniffiConverterOptionalTypeFfiSyncWorkerMode.lower(device_sync_mode),
        _UniffiConverterOptionalBool.lower(allow_offline),
        _UniffiConverterOptionalTypeFfiForkRecoveryOpts.lower(fork_recovery_opts)),
        _UniffiLib.ffi_xmtpv3_rust_future_poll_pointer,
        _UniffiLib.ffi_xmtpv3_rust_future_complete_pointer,
        _UniffiLib.ffi_xmtpv3_rust_future_free_pointer,
        # lift function
        _UniffiConverterTypeFfiXmtpClient.lift,
        
    # Error FFI converter
_UniffiConverterTypeGenericError,

    )

def decode_actions(bytes: "bytes") -> "FfiActions":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiActions.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_actions,
        _UniffiConverterBytes.lower(bytes)))


def decode_attachment(bytes: "bytes") -> "FfiAttachment":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiAttachment.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_attachment,
        _UniffiConverterBytes.lower(bytes)))


def decode_group_updated(bytes: "bytes") -> "FfiGroupUpdated":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiGroupUpdated.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_group_updated,
        _UniffiConverterBytes.lower(bytes)))


def decode_intent(bytes: "bytes") -> "FfiIntent":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiIntent.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_intent,
        _UniffiConverterBytes.lower(bytes)))


def decode_leave_request(bytes: "bytes") -> "FfiLeaveRequest":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiLeaveRequest.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_leave_request,
        _UniffiConverterBytes.lower(bytes)))


def decode_markdown(bytes: "bytes") -> "str":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterString.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_markdown,
        _UniffiConverterBytes.lower(bytes)))


def decode_multi_remote_attachment(bytes: "bytes") -> "FfiMultiRemoteAttachment":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiMultiRemoteAttachment.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_multi_remote_attachment,
        _UniffiConverterBytes.lower(bytes)))


def decode_reaction(bytes: "bytes") -> "FfiReactionPayload":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiReactionPayload.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_reaction,
        _UniffiConverterBytes.lower(bytes)))


def decode_read_receipt(bytes: "bytes") -> "FfiReadReceipt":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiReadReceipt.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_read_receipt,
        _UniffiConverterBytes.lower(bytes)))


def decode_remote_attachment(bytes: "bytes") -> "FfiRemoteAttachment":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiRemoteAttachment.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_remote_attachment,
        _UniffiConverterBytes.lower(bytes)))


def decode_reply(bytes: "bytes") -> "FfiReply":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiReply.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_reply,
        _UniffiConverterBytes.lower(bytes)))


def decode_text(bytes: "bytes") -> "str":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterString.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_text,
        _UniffiConverterBytes.lower(bytes)))


def decode_transaction_reference(bytes: "bytes") -> "FfiTransactionReference":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiTransactionReference.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_transaction_reference,
        _UniffiConverterBytes.lower(bytes)))


def decode_wallet_send_calls(bytes: "bytes") -> "FfiWalletSendCalls":
    _UniffiConverterBytes.check_lower(bytes)
    
    return _UniffiConverterTypeFfiWalletSendCalls.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_decode_wallet_send_calls,
        _UniffiConverterBytes.lower(bytes)))


def encode_actions(actions: "FfiActions") -> "bytes":
    _UniffiConverterTypeFfiActions.check_lower(actions)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_actions,
        _UniffiConverterTypeFfiActions.lower(actions)))


def encode_attachment(attachment: "FfiAttachment") -> "bytes":
    _UniffiConverterTypeFfiAttachment.check_lower(attachment)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_attachment,
        _UniffiConverterTypeFfiAttachment.lower(attachment)))


def encode_intent(intent: "FfiIntent") -> "bytes":
    _UniffiConverterTypeFfiIntent.check_lower(intent)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_intent,
        _UniffiConverterTypeFfiIntent.lower(intent)))


def encode_leave_request(request: "FfiLeaveRequest") -> "bytes":
    _UniffiConverterTypeFfiLeaveRequest.check_lower(request)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_leave_request,
        _UniffiConverterTypeFfiLeaveRequest.lower(request)))


def encode_markdown(text: "str") -> "bytes":
    _UniffiConverterString.check_lower(text)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_markdown,
        _UniffiConverterString.lower(text)))


def encode_multi_remote_attachment(ffi_multi_remote_attachment: "FfiMultiRemoteAttachment") -> "bytes":
    _UniffiConverterTypeFfiMultiRemoteAttachment.check_lower(ffi_multi_remote_attachment)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_multi_remote_attachment,
        _UniffiConverterTypeFfiMultiRemoteAttachment.lower(ffi_multi_remote_attachment)))


def encode_reaction(reaction: "FfiReactionPayload") -> "bytes":
    _UniffiConverterTypeFfiReactionPayload.check_lower(reaction)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_reaction,
        _UniffiConverterTypeFfiReactionPayload.lower(reaction)))


def encode_read_receipt(read_receipt: "FfiReadReceipt") -> "bytes":
    _UniffiConverterTypeFfiReadReceipt.check_lower(read_receipt)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_read_receipt,
        _UniffiConverterTypeFfiReadReceipt.lower(read_receipt)))


def encode_remote_attachment(remote_attachment: "FfiRemoteAttachment") -> "bytes":
    _UniffiConverterTypeFfiRemoteAttachment.check_lower(remote_attachment)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_remote_attachment,
        _UniffiConverterTypeFfiRemoteAttachment.lower(remote_attachment)))


def encode_reply(reply: "FfiReply") -> "bytes":
    _UniffiConverterTypeFfiReply.check_lower(reply)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_reply,
        _UniffiConverterTypeFfiReply.lower(reply)))


def encode_text(text: "str") -> "bytes":
    _UniffiConverterString.check_lower(text)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_text,
        _UniffiConverterString.lower(text)))


def encode_transaction_reference(reference: "FfiTransactionReference") -> "bytes":
    _UniffiConverterTypeFfiTransactionReference.check_lower(reference)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_transaction_reference,
        _UniffiConverterTypeFfiTransactionReference.lower(reference)))


def encode_wallet_send_calls(wallet_send_calls: "FfiWalletSendCalls") -> "bytes":
    _UniffiConverterTypeFfiWalletSendCalls.check_lower(wallet_send_calls)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_encode_wallet_send_calls,
        _UniffiConverterTypeFfiWalletSendCalls.lower(wallet_send_calls)))


def enter_debug_writer(directory: "str",log_level: "FfiLogLevel",rotation: "FfiLogRotation",max_files: "int",process_type: "FfiProcessType") -> None:
    """
    turns on logging to a file on-disk in the directory specified.
    files will be prefixed with 'libxmtp-v{version}.{commit}.{process_type}.{pid}.log' and suffixed with the timestamp,
    i.e "libxmtp-v1.6.0.abc123.main.12345.log.2025-04-02"
    A maximum of 'max_files' log files are kept.
    """

    _UniffiConverterString.check_lower(directory)
    
    _UniffiConverterTypeFfiLogLevel.check_lower(log_level)
    
    _UniffiConverterTypeFfiLogRotation.check_lower(rotation)
    
    _UniffiConverterUInt32.check_lower(max_files)
    
    _UniffiConverterTypeFfiProcessType.check_lower(process_type)
    
    _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_enter_debug_writer,
        _UniffiConverterString.lower(directory),
        _UniffiConverterTypeFfiLogLevel.lower(log_level),
        _UniffiConverterTypeFfiLogRotation.lower(rotation),
        _UniffiConverterUInt32.lower(max_files),
        _UniffiConverterTypeFfiProcessType.lower(process_type))


def enter_debug_writer_with_level(directory: "str",rotation: "FfiLogRotation",max_files: "int",log_level: "FfiLogLevel",process_type: "FfiProcessType") -> None:
    """
    turns on logging to a file on-disk with a specified log level.
    files will be prefixed with 'libxmtp-v{version}.{commit}.{process_type}.{pid}.log' and suffixed with the timestamp,
    i.e "libxmtp-v1.6.0.abc123.notif.67890.log.2025-04-02"
    A maximum of 'max_files' log files are kept.
    """

    _UniffiConverterString.check_lower(directory)
    
    _UniffiConverterTypeFfiLogRotation.check_lower(rotation)
    
    _UniffiConverterUInt32.check_lower(max_files)
    
    _UniffiConverterTypeFfiLogLevel.check_lower(log_level)
    
    _UniffiConverterTypeFfiProcessType.check_lower(process_type)
    
    _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_enter_debug_writer_with_level,
        _UniffiConverterString.lower(directory),
        _UniffiConverterTypeFfiLogRotation.lower(rotation),
        _UniffiConverterUInt32.lower(max_files),
        _UniffiConverterTypeFfiLogLevel.lower(log_level),
        _UniffiConverterTypeFfiProcessType.lower(process_type))


def ethereum_address_from_pubkey(pubkey: "bytes") -> "str":
    """
    3) Ethereum address from public key (accepts 65-byte 0x04||XY or 64-byte XY).
    """

    _UniffiConverterBytes.check_lower(pubkey)
    
    return _UniffiConverterString.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeFfiCryptoError,_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_address_from_pubkey,
        _UniffiConverterBytes.lower(pubkey)))


def ethereum_generate_public_key(private_key32: "bytes") -> "bytes":
    """
    1) Ethereum compatible public key from 32-byte private key.
    Returns **65-byte uncompressed** (0x04 || X || Y)
    Private key is automatically zeroized after use for security
    """

    _UniffiConverterBytes.check_lower(private_key32)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeFfiCryptoError,_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_generate_public_key,
        _UniffiConverterBytes.lower(private_key32)))


def ethereum_hash_personal(message: "str") -> "bytes":
    """
    4) EIP-191 personal message hash: keccak256("\x19Ethereum Signed Message:\n{len}" || message)
    """

    _UniffiConverterString.check_lower(message)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeFfiCryptoError,_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_hash_personal,
        _UniffiConverterString.lower(message)))


def ethereum_sign_recoverable(msg: "bytes",private_key32: "bytes",hashing: "bool") -> "bytes":
    """
    2) Ethereum recoverable signature (FFI).
    Returns 65 bytes `r || s || v`, with **v  {27,28}**
    (legacy/Electrum encoding where **v = 27 + parity**, parity  {0,1}).
    - If `hashing == true`: signs per **EIP-191**
    ("Ethereum Signed Message:\n{len(msg)}" || msg, then keccak256).
    - If `hashing == false`: `msg` must be a **32-byte** prehash (e.g., keccak256/EIP-712 digest).
    - Private key is automatically zeroized after signing for security
    """

    _UniffiConverterBytes.check_lower(msg)
    
    _UniffiConverterBytes.check_lower(private_key32)
    
    _UniffiConverterBool.check_lower(hashing)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeFfiCryptoError,_UniffiLib.uniffi_xmtpv3_fn_func_ethereum_sign_recoverable,
        _UniffiConverterBytes.lower(msg),
        _UniffiConverterBytes.lower(private_key32),
        _UniffiConverterBool.lower(hashing)))


def exit_debug_writer() -> None:
    """
    Flush loglines from libxmtp log writer to the file, ensuring logs are written.
    This should be called before the program exits, to ensure all the logs in memory have been
    written. this ends the writer thread.
    """

    _uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_exit_debug_writer,)


def generate_inbox_id(account_identifier: "FfiIdentifier",nonce: "int") -> "str":
    _UniffiConverterTypeFfiIdentifier.check_lower(account_identifier)
    
    _UniffiConverterUInt64.check_lower(nonce)
    
    return _UniffiConverterString.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_generate_inbox_id,
        _UniffiConverterTypeFfiIdentifier.lower(account_identifier),
        _UniffiConverterUInt64.lower(nonce)))

async def get_inbox_id_for_identifier(api: "XmtpApiClient",account_identifier: "FfiIdentifier") -> "typing.Optional[str]":

    _UniffiConverterTypeXmtpApiClient.check_lower(api)
    
    _UniffiConverterTypeFfiIdentifier.check_lower(account_identifier)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_xmtpv3_fn_func_get_inbox_id_for_identifier(
        _UniffiConverterTypeXmtpApiClient.lower(api),
        _UniffiConverterTypeFfiIdentifier.lower(account_identifier)),
        _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
        _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
        _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
        # lift function
        _UniffiConverterOptionalString.lift,
        
    # Error FFI converter
_UniffiConverterTypeGenericError,

    )
async def get_newest_message_metadata(api: "XmtpApiClient",group_ids: "typing.List[bytes]") -> "dict[bytes, FfiMessageMetadata]":

    _UniffiConverterTypeXmtpApiClient.check_lower(api)
    
    _UniffiConverterSequenceBytes.check_lower(group_ids)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_xmtpv3_fn_func_get_newest_message_metadata(
        _UniffiConverterTypeXmtpApiClient.lower(api),
        _UniffiConverterSequenceBytes.lower(group_ids)),
        _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
        _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
        _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
        # lift function
        _UniffiConverterMapBytesTypeFfiMessageMetadata.lift,
        
    # Error FFI converter
_UniffiConverterTypeGenericError,

    )

def get_version_info() -> "str":
    return _UniffiConverterString.lift(_uniffi_rust_call(_UniffiLib.uniffi_xmtpv3_fn_func_get_version_info,))

async def inbox_state_from_inbox_ids(api: "XmtpApiClient",inbox_ids: "typing.List[str]") -> "typing.List[FfiInboxState]":

    """
    * Static Get the inbox state for each `inbox_id`.
    """

    _UniffiConverterTypeXmtpApiClient.check_lower(api)
    
    _UniffiConverterSequenceString.check_lower(inbox_ids)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_xmtpv3_fn_func_inbox_state_from_inbox_ids(
        _UniffiConverterTypeXmtpApiClient.lower(api),
        _UniffiConverterSequenceString.lower(inbox_ids)),
        _UniffiLib.ffi_xmtpv3_rust_future_poll_rust_buffer,
        _UniffiLib.ffi_xmtpv3_rust_future_complete_rust_buffer,
        _UniffiLib.ffi_xmtpv3_rust_future_free_rust_buffer,
        # lift function
        _UniffiConverterSequenceTypeFfiInboxState.lift,
        
    # Error FFI converter
_UniffiConverterTypeGenericError,

    )
async def is_connected(api: "XmtpApiClient") -> "bool":

    _UniffiConverterTypeXmtpApiClient.check_lower(api)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_xmtpv3_fn_func_is_connected(
        _UniffiConverterTypeXmtpApiClient.lower(api)),
        _UniffiLib.ffi_xmtpv3_rust_future_poll_i8,
        _UniffiLib.ffi_xmtpv3_rust_future_complete_i8,
        _UniffiLib.ffi_xmtpv3_rust_future_free_i8,
        # lift function
        _UniffiConverterBool.lift,
        
    # Error FFI converter

    None,

    )

def revoke_installations(api: "XmtpApiClient",recovery_identifier: "FfiIdentifier",inbox_id: "str",installation_ids: "typing.List[bytes]") -> "FfiSignatureRequest":
    """
    * Static revoke a list of installations
    """

    _UniffiConverterTypeXmtpApiClient.check_lower(api)
    
    _UniffiConverterTypeFfiIdentifier.check_lower(recovery_identifier)
    
    _UniffiConverterString.check_lower(inbox_id)
    
    _UniffiConverterSequenceBytes.check_lower(installation_ids)
    
    return _UniffiConverterTypeFfiSignatureRequest.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeGenericError,_UniffiLib.uniffi_xmtpv3_fn_func_revoke_installations,
        _UniffiConverterTypeXmtpApiClient.lower(api),
        _UniffiConverterTypeFfiIdentifier.lower(recovery_identifier),
        _UniffiConverterString.lower(inbox_id),
        _UniffiConverterSequenceBytes.lower(installation_ids)))


__all__ = [
    "InternalError",
    "FfiActionStyle",
    "FfiBackupElementSelection",
    "FfiClientMode",
    "FfiConsentEntityType",
    "FfiConsentState",
    "FfiContentType",
    "FfiConversationMessageKind",
    "FfiConversationType",
    "FfiCryptoError",
    "FfiDecodedMessageBody",
    "FfiDecodedMessageContent",
    "FfiDeliveryStatus",
    "FfiDirection",
    "FfiForkRecoveryPolicy",
    "FfiGroupMembershipState",
    "FfiGroupMessageKind",
    "FfiGroupPermissionsOptions",
    "FfiGroupQueryOrderBy",
    "FfiIdentifierKind",
    "FfiLogLevel",
    "FfiLogRotation",
    "FfiMetadataField",
    "FfiPermissionLevel",
    "FfiPermissionPolicy",
    "FfiPermissionUpdateType",
    "FfiPreferenceUpdate",
    "FfiProcessType",
    "FfiReactionAction",
    "FfiReactionSchema",
    "FfiSignatureKind",
    "FfiSortBy",
    "FfiSubscribeError",
    "FfiSyncMetric",
    "FfiSyncWorkerMode",
    "GenericError",
    "IdentityValidationError",
    "SigningError",
    "FfiAction",
    "FfiActions",
    "FfiApiStats",
    "FfiArchiveOptions",
    "FfiAttachment",
    "FfiBackupMetadata",
    "FfiConsent",
    "FfiContentTypeId",
    "FfiConversationDebugInfo",
    "FfiConversationMember",
    "FfiCreateDmOptions",
    "FfiCreateGroupOptions",
    "FfiCredential",
    "FfiCursor",
    "FfiDecodedMessageMetadata",
    "FfiEncodedContent",
    "FfiEnrichedReply",
    "FfiForkRecoveryOpts",
    "FfiGroupSyncSummary",
    "FfiGroupUpdated",
    "FfiHmacKey",
    "FfiIdentifier",
    "FfiIdentityStats",
    "FfiInbox",
    "FfiInboxState",
    "FfiInstallation",
    "FfiIntent",
    "FfiKeyPackageStatus",
    "FfiLeaveRequest",
    "FfiLifetime",
    "FfiListConversationsOptions",
    "FfiListMessagesOptions",
    "FfiMarkdownContent",
    "FfiMessage",
    "FfiMessageDisappearingSettings",
    "FfiMessageMetadata",
    "FfiMessageWithReactions",
    "FfiMetadataFieldChange",
    "FfiMultiRemoteAttachment",
    "FfiPasskeySignature",
    "FfiPermissionPolicySet",
    "FfiReactionPayload",
    "FfiReadReceipt",
    "FfiRemoteAttachment",
    "FfiRemoteAttachmentInfo",
    "FfiReply",
    "FfiSendMessageOpts",
    "FfiTextContent",
    "FfiTransactionMetadata",
    "FfiTransactionReference",
    "FfiUpdateGroupMembershipResult",
    "FfiWalletCall",
    "FfiWalletCallMetadata",
    "FfiWalletSendCalls",
    "apply_signature_request",
    "connect_to_backend",
    "create_client",
    "decode_actions",
    "decode_attachment",
    "decode_group_updated",
    "decode_intent",
    "decode_leave_request",
    "decode_markdown",
    "decode_multi_remote_attachment",
    "decode_reaction",
    "decode_read_receipt",
    "decode_remote_attachment",
    "decode_reply",
    "decode_text",
    "decode_transaction_reference",
    "decode_wallet_send_calls",
    "encode_actions",
    "encode_attachment",
    "encode_intent",
    "encode_leave_request",
    "encode_markdown",
    "encode_multi_remote_attachment",
    "encode_reaction",
    "encode_read_receipt",
    "encode_remote_attachment",
    "encode_reply",
    "encode_text",
    "encode_transaction_reference",
    "encode_wallet_send_calls",
    "enter_debug_writer",
    "enter_debug_writer_with_level",
    "ethereum_address_from_pubkey",
    "ethereum_generate_public_key",
    "ethereum_hash_personal",
    "ethereum_sign_recoverable",
    "exit_debug_writer",
    "generate_inbox_id",
    "get_inbox_id_for_identifier",
    "get_newest_message_metadata",
    "get_version_info",
    "inbox_state_from_inbox_ids",
    "is_connected",
    "revoke_installations",
    "FfiAuthCallback",
    "FfiAuthHandle",
    "FfiConsentCallback",
    "FfiConversation",
    "FfiConversationCallback",
    "FfiConversationListItem",
    "FfiConversationMetadata",
    "FfiConversations",
    "FfiDecodedMessage",
    "FfiGroupPermissions",
    "FfiInboxOwner",
    "FfiMessageCallback",
    "FfiMessageDeletionCallback",
    "FfiPreferenceCallback",
    "FfiSignatureRequest",
    "FfiStreamCloser",
    "FfiSyncWorker",
    "FfiXmtpClient",
    "XmtpApiClient",
]

