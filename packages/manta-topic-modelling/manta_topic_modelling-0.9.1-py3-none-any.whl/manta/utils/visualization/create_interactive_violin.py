# python
import json
from collections import defaultdict
from pathlib import Path
from typing import Optional

import numpy as np
import pandas as pd


def generate_interactive_violin_plot(
    W: np.ndarray,
    S_matrix: Optional[np.ndarray],
    datetime_series: pd.Series,
    table_output_dir: Path,
    table_name: str
) -> Path:
    """
    Generate an interactive HTML violin plot showing topic distribution across years.

    Creates a standalone HTML file with embedded data that allows users to select
    topics via checkboxes and visualize their temporal distribution as violin plots.

    Args:
        W (np.ndarray): Document-topic matrix with shape (n_documents, n_topics).
        S_matrix (Optional[np.ndarray]): Topic-clustering matrix (optional, for NMTF).
        datetime_series (pd.Series): Datetime values for each document.
        table_output_dir (Path): Output directory for saving the HTML file.
        table_name (str): Dataset name for naming the output file.

    Returns:
        Path: Path to the generated HTML file.
    """
    # Look for the temporal CSV file with quarterly data
    csv_path = table_output_dir / f"{table_name}_temporal_topic_dist_quarter.csv"

    if not csv_path.exists():
        raise FileNotFoundError(f"Quarterly temporal CSV not found: {csv_path}")

    # Read the CSV file
    temporal_df = pd.read_csv(csv_path)

    # Get number of topics from columns (exclude 'period' column)
    topic_columns = [col for col in temporal_df.columns if col.startswith('Topic')]
    n_topics = len(topic_columns)

    # Parse period column to extract year and quarter
    # Format is like "2000Q1", "2000Q2", etc.
    temporal_df['year'] = temporal_df['period'].str[:4].astype(int)
    temporal_df['quarter'] = temporal_df['period'].str[-1].astype(int)
    temporal_df['year_decimal'] = temporal_df['year'] + (temporal_df['quarter'] - 1) * 0.25

    # Build topic data: for each topic, create arrays based on CSV counts
    topic_temporal_data = {}
    for topic_col in topic_columns:
        topic_num = topic_col.split()[1]  # Extract number from "Topic X"

        # Create data points: repeat each period according to its count
        periods = []
        years = []
        quarters = []

        for _, row in temporal_df.iterrows():
            count = int(row[topic_col])
            if count > 0:
                # Add data points proportional to count
                periods.extend([row['period']] * count)
                years.extend([row['year_decimal']] * count)
                quarters.extend([f"Q{row['quarter']}"] * count)

        topic_temporal_data[topic_num] = {
            "periods": periods,
            "years": years,
            "quarters": quarters
        }

    # Get year range from the data
    min_year = temporal_df['year'].min()
    max_year = temporal_df['year'].max()

    # Prepare metadata
    metadata = {
        "min_year": int(min_year),
        "max_year": int(max_year),
        "total_periods": len(temporal_df),
        "total_topics": n_topics,
        "data_source": "quarterly_csv"
    }

    # Create embedded data structure
    embedded_data = {
        "topics": topic_temporal_data,
        "metadata": metadata
    }

    # Read HTML template
    template_path = Path(__file__).parent / "templates" / "violin_template.html"
    with open(template_path, "r", encoding="utf-8") as f:
        html_content = f.read()

    # Create JavaScript constant with embedded data
    embedded_js = f"""
    <script>
        // ===== EMBEDDED DATA =====
        // Generated by create_interactive_violin.py
        const VIOLIN_DATA = {json.dumps(embedded_data, ensure_ascii=False, indent=2)};
        // ===== END EMBEDDED DATA =====
    </script>
    """

    # Replace placeholder with embedded data
    html_content = html_content.replace("<!-- EMBEDDED_DATA -->", embedded_js)

    # Write output HTML file
    output_path = table_output_dir / f"{table_name}_violin_plot_interactive.html"
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(html_content)

    return output_path
