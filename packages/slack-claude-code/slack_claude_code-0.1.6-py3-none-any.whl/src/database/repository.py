import json
from contextlib import asynccontextmanager
from datetime import datetime, timezone
from typing import Optional

import aiosqlite

from ..config import config
from .models import (
    CommandHistory,
    GitCheckpoint,
    NotificationSettings,
    ParallelJob,
    QueueItem,
    Session,
    UploadedFile,
)

# Default timeout for database operations (seconds)
DB_TIMEOUT = 30.0


class DatabaseRepository:
    def __init__(self, db_path: str, timeout: float = DB_TIMEOUT):
        self.db_path = db_path
        self.timeout = timeout

    def _get_connection(self) -> aiosqlite.Connection:
        return aiosqlite.connect(self.db_path)

    @asynccontextmanager
    async def _transact(self):
        """Provide a connection with automatic commit on success.

        Usage:
            async with self._transact() as db:
                await db.execute(...)
                # commit happens automatically on exit
        """
        async with self._get_connection() as db:
            try:
                yield db
                await db.commit()
            except Exception:
                await db.rollback()
                raise

    # Session operations
    async def get_or_create_session(
        self, channel_id: str, thread_ts: Optional[str] = None, default_cwd: str = "~"
    ) -> Session:
        """Get existing session for channel/thread or create a new one.

        Uses UPSERT (INSERT ... ON CONFLICT DO UPDATE) for atomic operation
        that handles concurrent requests safely.

        Args:
            channel_id: Slack channel ID
            thread_ts: Slack thread timestamp (None for channel-level session)
            default_cwd: Default working directory for new sessions
        """
        async with self._transact() as db:
            now_iso = datetime.now(timezone.utc).isoformat()

            # UPSERT: Insert new session or update existing one's last_active
            # This is atomic and handles concurrent requests properly
            await db.execute(
                """INSERT INTO sessions (channel_id, thread_ts, working_directory, model, last_active)
                   VALUES (?, ?, ?, ?, ?)
                   ON CONFLICT(channel_id, thread_ts) DO UPDATE SET
                       last_active = excluded.last_active""",
                (channel_id, thread_ts, default_cwd, config.DEFAULT_MODEL, now_iso),
            )

            # Fetch the session (guaranteed to exist now)
            cursor = await db.execute(
                """SELECT id, channel_id, thread_ts, working_directory,
                          claude_session_id, permission_mode, created_at, last_active, model
                   FROM sessions
                   WHERE channel_id = ? AND (
                       (thread_ts = ? AND ? IS NOT NULL) OR
                       (thread_ts IS NULL AND ? IS NULL)
                   )""",
                (channel_id, thread_ts, thread_ts, thread_ts),
            )
            row = await cursor.fetchone()
            return Session.from_row(row)

    async def update_session_cwd(self, channel_id: str, thread_ts: Optional[str], cwd: str) -> None:
        """Update the working directory for a session."""
        async with self._transact() as db:
            await db.execute(
                """UPDATE sessions SET working_directory = ?, last_active = ?
                   WHERE channel_id = ? AND (
                       (thread_ts = ? AND ? IS NOT NULL) OR
                       (thread_ts IS NULL AND ? IS NULL)
                   )""",
                (
                    cwd,
                    datetime.now(timezone.utc).isoformat(),
                    channel_id,
                    thread_ts,
                    thread_ts,
                    thread_ts,
                ),
            )

    async def update_session_claude_id(
        self, channel_id: str, thread_ts: Optional[str], claude_session_id: str
    ) -> None:
        """Update the Claude session ID for resume functionality."""
        async with self._transact() as db:
            await db.execute(
                """UPDATE sessions SET claude_session_id = ?, last_active = ?
                   WHERE channel_id = ? AND (
                       (thread_ts = ? AND ? IS NOT NULL) OR
                       (thread_ts IS NULL AND ? IS NULL)
                   )""",
                (
                    claude_session_id,
                    datetime.now(timezone.utc).isoformat(),
                    channel_id,
                    thread_ts,
                    thread_ts,
                    thread_ts,
                ),
            )

    async def clear_session_claude_id(
        self, channel_id: str, thread_ts: Optional[str] = None
    ) -> None:
        """Clear the Claude session ID to start fresh (used by /clear command)."""
        async with self._transact() as db:
            await db.execute(
                """UPDATE sessions SET claude_session_id = NULL, last_active = ?
                   WHERE channel_id = ? AND (
                       (thread_ts = ? AND ? IS NOT NULL) OR
                       (thread_ts IS NULL AND ? IS NULL)
                   )""",
                (
                    datetime.now(timezone.utc).isoformat(),
                    channel_id,
                    thread_ts,
                    thread_ts,
                    thread_ts,
                ),
            )

    async def update_session_mode(
        self, channel_id: str, thread_ts: Optional[str], permission_mode: str
    ) -> None:
        """Update the permission mode for a session."""
        async with self._transact() as db:
            await db.execute(
                """UPDATE sessions SET permission_mode = ?, last_active = ?
                   WHERE channel_id = ? AND (
                       (thread_ts = ? AND ? IS NOT NULL) OR
                       (thread_ts IS NULL AND ? IS NULL)
                   )""",
                (
                    permission_mode,
                    datetime.now(timezone.utc).isoformat(),
                    channel_id,
                    thread_ts,
                    thread_ts,
                    thread_ts,
                ),
            )

    async def update_session_model(
        self, channel_id: str, thread_ts: Optional[str], model: str
    ) -> None:
        """Update the model for a session."""
        async with self._transact() as db:
            await db.execute(
                """UPDATE sessions SET model = ?, last_active = ?
                   WHERE channel_id = ? AND (
                       (thread_ts = ? AND ? IS NOT NULL) OR
                       (thread_ts IS NULL AND ? IS NULL)
                   )""",
                (
                    model,
                    datetime.now(timezone.utc).isoformat(),
                    channel_id,
                    thread_ts,
                    thread_ts,
                    thread_ts,
                ),
            )

    async def get_sessions_by_channel(self, channel_id: str) -> list[Session]:
        """Get all sessions for a channel (channel + all threads)."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                "SELECT * FROM sessions WHERE channel_id = ? ORDER BY created_at DESC",
                (channel_id,),
            )
            rows = await cursor.fetchall()
            return [Session.from_row(row) for row in rows]

    async def delete_session(self, channel_id: str, thread_ts: Optional[str] = None) -> bool:
        """Delete a specific session."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                """DELETE FROM sessions
                   WHERE channel_id = ? AND (
                       (thread_ts = ? AND ? IS NOT NULL) OR
                       (thread_ts IS NULL AND ? IS NULL)
                   )""",
                (channel_id, thread_ts, thread_ts, thread_ts),
            )
            await db.commit()
            return cursor.rowcount > 0

    async def delete_inactive_sessions(self, inactive_days: int = 30) -> int:
        """Delete sessions inactive for N days."""
        async with self._get_connection() as db:
            cutoff = datetime.now(timezone.utc).timestamp() - (inactive_days * 24 * 3600)
            cursor = await db.execute(
                """DELETE FROM sessions
                   WHERE last_active < datetime(?, 'unixepoch')""",
                (cutoff,),
            )
            await db.commit()
            return cursor.rowcount

    # Command history operations
    async def add_command(self, session_id: int, command: str) -> CommandHistory:
        """Add a new command to history."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                "INSERT INTO command_history (session_id, command, status) VALUES (?, ?, 'pending')",
                (session_id, command),
            )
            await db.commit()

            cursor = await db.execute(
                "SELECT * FROM command_history WHERE id = ?", (cursor.lastrowid,)
            )
            row = await cursor.fetchone()
            return CommandHistory.from_row(row)

    async def update_command_status(
        self,
        command_id: int,
        status: str,
        output: Optional[str] = None,
        error_message: Optional[str] = None,
    ) -> None:
        """Update command status and optionally output."""
        async with self._get_connection() as db:
            if status in ("completed", "failed", "cancelled"):
                await db.execute(
                    """UPDATE command_history
                       SET status = ?, output = ?, error_message = ?, completed_at = ?
                       WHERE id = ?""",
                    (status, output, error_message, datetime.now(timezone.utc).isoformat(), command_id),
                )
            else:
                await db.execute(
                    "UPDATE command_history SET status = ? WHERE id = ?",
                    (status, command_id),
                )
            await db.commit()

    async def append_command_output(self, command_id: int, output_chunk: str) -> None:
        """Append output chunk to command (for streaming)."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                "SELECT output FROM command_history WHERE id = ?", (command_id,)
            )
            row = await cursor.fetchone()
            current_output = row[0] or "" if row else ""

            await db.execute(
                "UPDATE command_history SET output = ? WHERE id = ?",
                (current_output + output_chunk, command_id),
            )
            await db.commit()

    async def get_command_history(
        self, session_id: int, limit: int = 10, offset: int = 0
    ) -> tuple[list[CommandHistory], int]:
        """Get paginated command history for a session."""
        async with self._get_connection() as db:
            # Get total count
            cursor = await db.execute(
                "SELECT COUNT(*) FROM command_history WHERE session_id = ?",
                (session_id,),
            )
            total = (await cursor.fetchone())[0]

            # Get paginated results
            cursor = await db.execute(
                """SELECT * FROM command_history
                   WHERE session_id = ?
                   ORDER BY created_at DESC
                   LIMIT ? OFFSET ?""",
                (session_id, limit, offset),
            )
            rows = await cursor.fetchall()
            return [CommandHistory.from_row(row) for row in rows], total

    async def get_command_by_id(self, command_id: int) -> Optional[CommandHistory]:
        """Get a specific command by ID."""
        async with self._get_connection() as db:
            cursor = await db.execute("SELECT * FROM command_history WHERE id = ?", (command_id,))
            row = await cursor.fetchone()
            return CommandHistory.from_row(row) if row else None

    # Parallel job operations
    async def create_parallel_job(
        self,
        session_id: int,
        channel_id: str,
        job_type: str,
        config: dict,
        message_ts: Optional[str] = None,
    ) -> ParallelJob:
        """Create a new parallel job."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                """INSERT INTO parallel_jobs
                   (session_id, channel_id, job_type, config, results, message_ts, status)
                   VALUES (?, ?, ?, ?, ?, ?, 'pending')""",
                (session_id, channel_id, job_type, json.dumps(config), "[]", message_ts),
            )
            await db.commit()

            cursor = await db.execute(
                "SELECT * FROM parallel_jobs WHERE id = ?", (cursor.lastrowid,)
            )
            row = await cursor.fetchone()
            return ParallelJob.from_row(row)

    async def update_parallel_job(
        self,
        job_id: int,
        status: Optional[str] = None,
        results: Optional[list] = None,
        aggregation_output: Optional[str] = None,
        message_ts: Optional[str] = None,
    ) -> None:
        """Update parallel job fields."""
        async with self._get_connection() as db:
            updates = []
            params = []

            if status:
                updates.append("status = ?")
                params.append(status)
                if status in ("completed", "failed", "cancelled"):
                    updates.append("completed_at = ?")
                    params.append(datetime.now(timezone.utc).isoformat())

            if results is not None:
                updates.append("results = ?")
                params.append(json.dumps(results))

            if aggregation_output is not None:
                updates.append("aggregation_output = ?")
                params.append(aggregation_output)

            if message_ts is not None:
                updates.append("message_ts = ?")
                params.append(message_ts)

            if updates:
                # Build SQL safely with placeholders
                sql = "UPDATE parallel_jobs SET " + ", ".join(updates) + " WHERE id = ?"
                params.append(job_id)
                await db.execute(sql, tuple(params))
                await db.commit()

    async def get_parallel_job(self, job_id: int) -> Optional[ParallelJob]:
        """Get a parallel job by ID."""
        async with self._get_connection() as db:
            cursor = await db.execute("SELECT * FROM parallel_jobs WHERE id = ?", (job_id,))
            row = await cursor.fetchone()
            return ParallelJob.from_row(row) if row else None

    async def get_active_jobs(self, channel_id: Optional[str] = None) -> list[ParallelJob]:
        """Get all active (pending/running) jobs, optionally filtered by channel."""
        async with self._get_connection() as db:
            if channel_id:
                cursor = await db.execute(
                    """SELECT * FROM parallel_jobs
                       WHERE status IN ('pending', 'running') AND channel_id = ?
                       ORDER BY created_at DESC""",
                    (channel_id,),
                )
            else:
                cursor = await db.execute(
                    """SELECT * FROM parallel_jobs
                       WHERE status IN ('pending', 'running')
                       ORDER BY created_at DESC"""
                )
            rows = await cursor.fetchall()
            return [ParallelJob.from_row(row) for row in rows]

    async def cancel_job(self, job_id: int) -> bool:
        """Cancel a job if it's still active."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                """UPDATE parallel_jobs
                   SET status = 'cancelled', completed_at = ?
                   WHERE id = ? AND status IN ('pending', 'running')""",
                (datetime.now(timezone.utc).isoformat(), job_id),
            )
            await db.commit()
            return cursor.rowcount > 0

    # Queue operations
    async def add_to_queue(self, session_id: int, channel_id: str, prompt: str) -> QueueItem:
        """Add a command to the FIFO queue."""
        async with self._get_connection() as db:
            # Get next position for this channel
            cursor = await db.execute(
                """SELECT COALESCE(MAX(position), 0) + 1
                   FROM queue_items WHERE channel_id = ?""",
                (channel_id,),
            )
            position = (await cursor.fetchone())[0]

            cursor = await db.execute(
                """INSERT INTO queue_items
                   (session_id, channel_id, prompt, position, status)
                   VALUES (?, ?, ?, ?, 'pending')""",
                (session_id, channel_id, prompt, position),
            )
            await db.commit()

            cursor = await db.execute("SELECT * FROM queue_items WHERE id = ?", (cursor.lastrowid,))
            row = await cursor.fetchone()
            return QueueItem.from_row(row)

    async def get_pending_queue_items(self, channel_id: str) -> list[QueueItem]:
        """Get all pending queue items for a channel, ordered by position."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                """SELECT * FROM queue_items
                   WHERE channel_id = ? AND status = 'pending'
                   ORDER BY position ASC""",
                (channel_id,),
            )
            rows = await cursor.fetchall()
            return [QueueItem.from_row(row) for row in rows]

    async def get_queue_item(self, item_id: int) -> Optional[QueueItem]:
        """Get a queue item by ID."""
        async with self._get_connection() as db:
            cursor = await db.execute("SELECT * FROM queue_items WHERE id = ?", (item_id,))
            row = await cursor.fetchone()
            return QueueItem.from_row(row) if row else None

    async def update_queue_item_status(
        self,
        item_id: int,
        status: str,
        output: Optional[str] = None,
        error_message: Optional[str] = None,
    ) -> None:
        """Update queue item status."""
        async with self._get_connection() as db:
            if status == "running":
                await db.execute(
                    "UPDATE queue_items SET status = ?, started_at = ? WHERE id = ?",
                    (status, datetime.now(timezone.utc).isoformat(), item_id),
                )
            elif status in ("completed", "failed", "cancelled"):
                await db.execute(
                    """UPDATE queue_items
                       SET status = ?, output = ?, error_message = ?, completed_at = ?
                       WHERE id = ?""",
                    (status, output, error_message, datetime.now(timezone.utc).isoformat(), item_id),
                )
            else:
                await db.execute(
                    "UPDATE queue_items SET status = ? WHERE id = ?",
                    (status, item_id),
                )
            await db.commit()

    async def remove_queue_item(self, item_id: int) -> bool:
        """Remove a queue item (only if pending)."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                "DELETE FROM queue_items WHERE id = ? AND status = 'pending'",
                (item_id,),
            )
            await db.commit()
            return cursor.rowcount > 0

    async def clear_queue(self, channel_id: str) -> int:
        """Clear all pending queue items for a channel."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                "DELETE FROM queue_items WHERE channel_id = ? AND status = 'pending'",
                (channel_id,),
            )
            await db.commit()
            return cursor.rowcount

    async def get_running_queue_item(self, channel_id: str) -> Optional[QueueItem]:
        """Get the currently running queue item for a channel."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                "SELECT * FROM queue_items WHERE channel_id = ? AND status = 'running'",
                (channel_id,),
            )
            row = await cursor.fetchone()
            return QueueItem.from_row(row) if row else None

    # Uploaded file operations
    async def add_uploaded_file(
        self,
        session_id: int,
        slack_file_id: str,
        filename: str,
        local_path: str,
        mimetype: str = "",
        size: int = 0,
    ) -> UploadedFile:
        """Track an uploaded file."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                """INSERT OR REPLACE INTO uploaded_files
                   (session_id, slack_file_id, filename, local_path, mimetype, size)
                   VALUES (?, ?, ?, ?, ?, ?)""",
                (session_id, slack_file_id, filename, local_path, mimetype, size),
            )
            await db.commit()

            cursor = await db.execute(
                "SELECT * FROM uploaded_files WHERE id = ?", (cursor.lastrowid,)
            )
            row = await cursor.fetchone()
            return UploadedFile.from_row(row)

    async def get_session_uploaded_files(self, session_id: int) -> list[UploadedFile]:
        """Get all uploaded files for a session."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                """SELECT * FROM uploaded_files
                   WHERE session_id = ?
                   ORDER BY uploaded_at DESC""",
                (session_id,),
            )
            rows = await cursor.fetchall()
            return [UploadedFile.from_row(row) for row in rows]

    # Git checkpoint operations
    async def create_checkpoint(
        self,
        session_id: int,
        channel_id: str,
        name: str,
        stash_ref: str,
        stash_message: Optional[str] = None,
        description: Optional[str] = None,
        is_auto: bool = False,
    ) -> GitCheckpoint:
        """Create a git checkpoint record."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                """INSERT INTO git_checkpoints
                   (session_id, channel_id, name, stash_ref, stash_message, description, is_auto)
                   VALUES (?, ?, ?, ?, ?, ?, ?)""",
                (
                    session_id,
                    channel_id,
                    name,
                    stash_ref,
                    stash_message,
                    description,
                    1 if is_auto else 0,
                ),
            )
            await db.commit()

            cursor = await db.execute(
                "SELECT * FROM git_checkpoints WHERE id = ?", (cursor.lastrowid,)
            )
            row = await cursor.fetchone()
            return GitCheckpoint.from_row(row)

    async def get_checkpoints(
        self, channel_id: str, include_auto: bool = False
    ) -> list[GitCheckpoint]:
        """Get checkpoints for a channel."""
        async with self._get_connection() as db:
            if include_auto:
                cursor = await db.execute(
                    """SELECT * FROM git_checkpoints
                       WHERE channel_id = ?
                       ORDER BY created_at DESC""",
                    (channel_id,),
                )
            else:
                cursor = await db.execute(
                    """SELECT * FROM git_checkpoints
                       WHERE channel_id = ? AND is_auto = 0
                       ORDER BY created_at DESC""",
                    (channel_id,),
                )
            rows = await cursor.fetchall()
            return [GitCheckpoint.from_row(row) for row in rows]

    async def get_checkpoint_by_name(self, channel_id: str, name: str) -> Optional[GitCheckpoint]:
        """Get a specific checkpoint by name."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                """SELECT * FROM git_checkpoints
                   WHERE channel_id = ? AND name = ?
                   ORDER BY created_at DESC
                   LIMIT 1""",
                (channel_id, name),
            )
            row = await cursor.fetchone()
            return GitCheckpoint.from_row(row) if row else None

    async def delete_checkpoint(self, checkpoint_id: int) -> bool:
        """Delete a checkpoint."""
        async with self._get_connection() as db:
            cursor = await db.execute("DELETE FROM git_checkpoints WHERE id = ?", (checkpoint_id,))
            await db.commit()
            return cursor.rowcount > 0

    async def delete_auto_checkpoints(self, channel_id: str) -> int:
        """Delete all auto checkpoints for a channel."""
        async with self._get_connection() as db:
            cursor = await db.execute(
                "DELETE FROM git_checkpoints WHERE channel_id = ? AND is_auto = 1",
                (channel_id,),
            )
            await db.commit()
            return cursor.rowcount

    # -------------------------------------------------------------------------
    # Notification Settings
    # -------------------------------------------------------------------------

    async def get_notification_settings(self, channel_id: str) -> "NotificationSettings":
        """
        Get notification settings for a channel.

        Returns default settings (all enabled) if no record exists.
        """
        async with self._get_connection() as db:
            cursor = await db.execute(
                "SELECT * FROM notification_settings WHERE channel_id = ?",
                (channel_id,),
            )
            row = await cursor.fetchone()
            if row:
                return NotificationSettings.from_row(row)
            # Return defaults (all notifications enabled)
            return NotificationSettings.default(channel_id)

    async def update_notification_settings(
        self,
        channel_id: str,
        notify_on_completion: bool,
        notify_on_permission: bool,
    ) -> "NotificationSettings":
        """
        Update notification settings for a channel (upsert).

        Creates the record if it doesn't exist.
        """
        async with self._transact() as db:
            # Try to update first
            cursor = await db.execute(
                """UPDATE notification_settings
                   SET notify_on_completion = ?,
                       notify_on_permission = ?,
                       updated_at = CURRENT_TIMESTAMP
                   WHERE channel_id = ?""",
                (notify_on_completion, notify_on_permission, channel_id),
            )

            if cursor.rowcount == 0:
                # Insert new record
                await db.execute(
                    """INSERT INTO notification_settings
                       (channel_id, notify_on_completion, notify_on_permission)
                       VALUES (?, ?, ?)""",
                    (channel_id, notify_on_completion, notify_on_permission),
                )

        # Return the updated settings
        return await self.get_notification_settings(channel_id)
