/**
 * Cross-language tests: decode files generated by Python.
 *
 * Run cross_language_generate.py first to generate the test files.
 */

const { describe, it, before } = require('node:test');
const assert = require('node:assert/strict');
const fs = require('node:fs');
const path = require('node:path');

const {
    fromTytx,
    fromMsgpack,
    fromXml,
    isDecimal,
} = require('../js/src/index.js');

const DATA_DIR = path.join(__dirname, 'cross_language_data');

// Check if msgpack is available
let hasMsgpack = false;
try {
    require('@msgpack/msgpack');
    hasMsgpack = true;
} catch {
    // MessagePack tests will be skipped
}

// Load expected values
let EXPECTED = {};

/**
 * Extract plain value from XML attrs/value structure.
 */
function extractXmlValue(xmlData) {
    if (xmlData === null || xmlData === undefined) {
        return null;
    }

    if (Array.isArray(xmlData)) {
        return xmlData.map(item => extractXmlValue(item));
    }

    if (typeof xmlData === 'object') {
        // Check if it's an attrs/value structure
        if ('attrs' in xmlData && 'value' in xmlData) {
            return extractXmlValue(xmlData.value);
        }

        // Regular object - extract values from each key
        const result = {};
        for (const [key, val] of Object.entries(xmlData)) {
            result[key] = extractXmlValue(val);
        }
        return result;
    }

    // Primitive value
    return xmlData;
}

/**
 * Compare XML decoded value against expected (from Python).
 * XML values have attrs/value structure, so we extract the inner values first.
 */
function assertXmlEquivalent(decoded, expected, path = '') {
    const extractedDecoded = extractXmlValue(decoded);
    assertEquivalent(extractedDecoded, expected, path);
}

/**
 * Compare decoded value against expected (from Python).
 */
function assertEquivalent(decoded, expected, path = '') {
    if (expected === null) {
        assert.strictEqual(decoded, null, `${path}: expected null`);
        return;
    }

    if (expected._type === 'Decimal') {
        assert.ok(
            isDecimal(decoded) || typeof decoded === 'number',
            `${path}: expected Decimal-like, got ${typeof decoded}`
        );
        const decodedStr = decoded.toString();
        // Allow for trailing zero differences (100.50 vs 100.5)
        const expectedNum = parseFloat(expected.value);
        const decodedNum = parseFloat(decodedStr);
        assert.strictEqual(decodedNum, expectedNum, `${path}: Decimal value mismatch`);
        return;
    }

    if (expected._type === 'date') {
        assert.ok(decoded instanceof Date, `${path}: expected Date`);
        const isoDate = decoded.toISOString().slice(0, 10);
        assert.strictEqual(isoDate, expected.value, `${path}: date value mismatch`);
        return;
    }

    if (expected._type === 'datetime') {
        assert.ok(decoded instanceof Date, `${path}: expected Date (datetime)`);
        // Compare year, month, day, hour, minute at minimum
        const expDate = new Date(expected.value);
        assert.strictEqual(decoded.getUTCFullYear(), expDate.getUTCFullYear(), `${path}: year`);
        assert.strictEqual(decoded.getUTCMonth(), expDate.getUTCMonth(), `${path}: month`);
        assert.strictEqual(decoded.getUTCDate(), expDate.getUTCDate(), `${path}: day`);
        assert.strictEqual(decoded.getUTCHours(), expDate.getUTCHours(), `${path}: hour`);
        assert.strictEqual(decoded.getUTCMinutes(), expDate.getUTCMinutes(), `${path}: minute`);
        return;
    }

    if (expected._type === 'time') {
        assert.ok(decoded instanceof Date, `${path}: expected Date (time)`);
        // Time is represented as epoch date in JS
        const parts = expected.value.split(':');
        assert.strictEqual(decoded.getUTCHours(), parseInt(parts[0]), `${path}: hour`);
        assert.strictEqual(decoded.getUTCMinutes(), parseInt(parts[1]), `${path}: minute`);
        return;
    }

    if (Array.isArray(expected)) {
        assert.ok(Array.isArray(decoded), `${path}: expected array`);
        assert.strictEqual(decoded.length, expected.length, `${path}: array length`);
        for (let i = 0; i < expected.length; i++) {
            assertEquivalent(decoded[i], expected[i], `${path}[${i}]`);
        }
        return;
    }

    if (typeof expected === 'object') {
        assert.ok(typeof decoded === 'object' && decoded !== null, `${path}: expected object`);
        const expKeys = Object.keys(expected);
        for (const key of expKeys) {
            assertEquivalent(decoded[key], expected[key], `${path}.${key}`);
        }
        return;
    }

    // Primitives
    assert.strictEqual(decoded, expected, `${path}: primitive mismatch`);
}

describe('Cross-Language Tests (Python -> JS)', () => {
    before(() => {
        // Check if data directory exists
        if (!fs.existsSync(DATA_DIR)) {
            console.log('Run cross_language_generate.py first to generate test files');
            throw new Error('cross_language_data directory not found');
        }

        // Load expected values
        const expectedPath = path.join(DATA_DIR, 'expected.json');
        if (fs.existsSync(expectedPath)) {
            EXPECTED = JSON.parse(fs.readFileSync(expectedPath, 'utf8'));
        }
    });

    describe('JSON Text Format (::JS suffix)', () => {
        const files = fs.readdirSync(DATA_DIR).filter(f => f.endsWith('.tytx.json'));

        for (const file of files) {
            const name = file.replace('.tytx.json', '');
            it(`should decode ${name}`, () => {
                const content = fs.readFileSync(path.join(DATA_DIR, file), 'utf8');
                const decoded = fromTytx(content);
                assertEquivalent(decoded, EXPECTED[name], name);
            });
        }
    });

    describe('MessagePack Format', { skip: !hasMsgpack }, () => {
        const files = fs.readdirSync(DATA_DIR).filter(f => f.endsWith('.tytx.msgpack'));

        for (const file of files) {
            const name = file.replace('.tytx.msgpack', '');
            it(`should decode ${name} from MessagePack`, () => {
                const content = fs.readFileSync(path.join(DATA_DIR, file));
                const decoded = fromMsgpack(content);
                assertEquivalent(decoded, EXPECTED[name], name);
            });
        }
    });

    describe('XML Format', () => {
        const files = fs.readdirSync(DATA_DIR).filter(f => f.endsWith('.tytx.xml'));

        for (const file of files) {
            const name = file.replace('.tytx.xml', '');
            it(`should decode ${name} from XML`, () => {
                const content = fs.readFileSync(path.join(DATA_DIR, file), 'utf8');
                const decoded = fromXml(content);
                // With tytx_root auto-unwrap, XML decoded values have attrs/value structure
                // We need to compare the inner values
                if (EXPECTED[name]) {
                    assertXmlEquivalent(decoded, EXPECTED[name], name);
                } else {
                    // Just verify it decodes without error
                    assert.ok(decoded, `${name}: should decode successfully`);
                }
            });
        }
    });
});
