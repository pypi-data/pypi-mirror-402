###############################################################################
#
# MIT License
#
# Copyright (c) 2025 Advanced Micro Devices, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
###############################################################################
import abc
import copy
import datetime
import logging
from typing import Any, Optional, Union

from nodescraper.constants import DEFAULT_LOGGER
from nodescraper.enums import EventCategory, EventPriority
from nodescraper.models import Event, SystemInfo, TaskResult

from .taskresulthook import TaskResultHook


class SystemCompatibilityError(Exception):
    """Exception raised when system has invalid attributes for the task"""

    pass


class Task(abc.ABC):
    """Parent class for all tasks"""

    TASK_TYPE: str

    def __init__(
        self,
        system_info: SystemInfo,
        logger: Optional[logging.Logger] = None,
        max_event_priority_level: Union[EventPriority, str] = EventPriority.CRITICAL,
        parent: Optional[str] = None,
        task_result_hooks: Optional[list[TaskResultHook]] = None,
        **kwargs: dict[str, Any],
    ):
        if logger is None:
            logger = logging.getLogger(DEFAULT_LOGGER)
        self.system_info = system_info
        self.logger = logger
        self.max_event_priority_level = max_event_priority_level
        self.parent = parent
        if not task_result_hooks:
            task_result_hooks = []
        self.task_result_hooks = task_result_hooks
        self.result: TaskResult = self._init_result()

    @property
    def max_event_priority_level(self) -> EventPriority:
        """maximum priority level for events generated by task

        Returns:
            EventPriority: max priority level enum
        """
        return self._max_event_priority_level

    @max_event_priority_level.setter
    def max_event_priority_level(self, input_value: Union[str, EventPriority]):
        if isinstance(input_value, str):
            value: EventPriority = getattr(EventPriority, input_value)
        elif isinstance(input_value, int):
            value = EventPriority(input_value)
        elif isinstance(input_value, EventPriority):
            value: EventPriority = input_value  # type:ignore
        else:
            raise ValueError(f"Invalid type for max_event_priority_level: {type(input_value)}")

        self._max_event_priority_level = value

    def __init_subclass__(cls, **kwargs) -> None:
        super().__init_subclass__(**kwargs)
        if cls.TASK_TYPE is None:
            raise TypeError(f"No value provided for TASK_TYPE in task class {cls.__name__}")

    def _build_event(
        self,
        category: Union[EventCategory, str],
        description: str,
        priority: EventPriority,
        data: Optional[dict] = None,
        timestamp: Optional[datetime.datetime] = None,
    ) -> Event:

        if data is None:
            data = {"task_name": self.__class__.__name__, "task_type": self.TASK_TYPE}

        else:
            # Copy to avoid mutating the caller's dict
            data = copy.copy(data)
            data["task_name"] = self.__class__.__name__
            data["task_type"] = self.TASK_TYPE

        if self.parent:
            data["parent"] = self.parent

        if self.system_info.metadata:
            data["system_metadata"] = copy.copy(self.system_info.metadata)

        if priority > self.max_event_priority_level:
            priority = self.max_event_priority_level

        event = Event(
            category=category,
            description=description,
            priority=priority,
            data=data,
        )

        if timestamp:
            event.timestamp = timestamp

        return event

    def _log_event(
        self,
        category: Union[EventCategory, str],
        description: str,
        priority: EventPriority,
        data: Optional[dict] = None,
        timestamp: Optional[datetime.datetime] = None,
        console_log: bool = False,
    ):
        event = self._build_event(
            category=category,
            description=description,
            priority=priority,
            data=data,
            timestamp=timestamp,
        )

        if console_log:
            self.logger.log(getattr(logging, priority.name, logging.INFO), description)

        self.result.events.append(event)

    def _init_result(self):
        result = TaskResult(task=self.__class__.__name__, parent=self.parent)
        return result

    def _run_hooks(self, result, **kwargs):
        for hook in self.task_result_hooks:
            hook.process_result(result, **kwargs)
