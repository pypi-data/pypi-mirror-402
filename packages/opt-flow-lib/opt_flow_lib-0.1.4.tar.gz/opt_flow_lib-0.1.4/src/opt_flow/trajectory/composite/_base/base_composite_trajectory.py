from opt_flow.structure import BaseIndividual
from opt_flow.acceptance import BaseAcceptance
from typing import Optional, List
from opt_flow.stopping import BaseStopping
from opt_flow.callback import Callback
from opt_flow.metaheuristic import AlgorithmType
from opt_flow.metaheuristic.factories.trajectory._base import BaseMultipleFactory
from opt_flow.metaheuristic.trajectory_metaheuristic import TrajectoryMetaheuristic
from opt_flow.config import config
class BaseCompositeTrajectory(TrajectoryMetaheuristic):
    
    """
    Base class for composite trajectory metaheuristics.

    This class manages a sequence of trajectory operators applied
    to a individual. Each operator is generated by a provided factory,
    and trajectories are applied in a chain-like manner. The class
    handles acceptance, stopping criteria, and callback execution.
    """
    
    def __init__(
        self,
        trajectory_factory: BaseMultipleFactory,
        acceptance: Optional[BaseAcceptance] = None,
        seed: Optional[int] = None,
        stopping: Optional[BaseStopping] = None,
        callbacks: Optional[List[Callback]] = None,
        **kwargs,
    ):
        super().__init__(stopping=stopping, callbacks=callbacks, seed=seed, default_acceptance=acceptance, **kwargs)
        self._trajectory_factory = trajectory_factory
        self._acceptance = acceptance or config.default_acceptance
        self.num_trajectories = len(trajectory_factory.trajectories)
        
    def iterate(self, individual: BaseIndividual):
        """
        Applies the composite trajectory process to the given individual.

        The method repeatedly generates trajectory operators from the factory,
        applies them sequentially, and uses an acceptance criterion to track
        the best individual. It continues until the stopping criterion or
        the factory signals termination.

        Parameters
        ----------
        individual : BaseIndividual
            The individual to be iterated upon. It will be modified in place
            to reflect the best individual found during the trajectory process.
        """
        from opt_flow.metaheuristic.algorithm import Algorithm
        acceptance = Algorithm(self._acceptance, "acceptance", AlgorithmType.acceptance)
        self.add_algorithm(acceptance)
        last_trajectory = None
        while True:
            trajectory = Algorithm(self._trajectory_factory.create(), "trajectory", AlgorithmType.trajectory)
            self.add_algorithm(trajectory)
            self.connect(trajectory, acceptance)
            if last_trajectory:
                self.connect(last_trajectory, trajectory)
            last_trajectory = trajectory
            self._run_iterate(individual)
            if not self.should_continue(trajectory) or not self._trajectory_factory.should_continue():
                break
            acceptance._reset()
        individual.overwrite_with(acceptance.get_individual())
        
    