{"version":3,"file":"WidgetRecordAudio-BoJeF4CW.js","sources":["../../../../../../../ComfyUI_frontend/src/renderer/extensions/vueNodes/widgets/composables/audio/useAudioPlayback.ts","../../../../../../../ComfyUI_frontend/src/renderer/extensions/vueNodes/widgets/composables/audio/useAudioRecorder.ts","../../../../../../../ComfyUI_frontend/src/renderer/extensions/vueNodes/widgets/composables/audio/useAudioWaveform.ts","../../../../../../../ComfyUI_frontend/src/renderer/extensions/vueNodes/widgets/components/WidgetRecordAudio.vue"],"sourcesContent":["import { nextTick, ref } from 'vue'\nimport type { Ref } from 'vue'\n\ninterface AudioPlaybackOptions {\n  onPlaybackEnded?: () => void\n  onMetadataLoaded?: (duration: number) => void\n}\n\nexport function useAudioPlayback(\n  audioRef: Ref<HTMLAudioElement | undefined>,\n  options: AudioPlaybackOptions = {}\n) {\n  const isPlaying = ref(false)\n  const audioElementKey = ref(0)\n  const playbackTimerInterval = ref<ReturnType<typeof setInterval> | null>(null)\n\n  async function play() {\n    if (!audioRef.value) return false\n\n    try {\n      await audioRef.value.play()\n      isPlaying.value = true\n      return true\n    } catch (error) {\n      console.warn('Audio playback failed:', error)\n      isPlaying.value = false\n      return false\n    }\n  }\n\n  function stop() {\n    if (audioRef.value) {\n      audioRef.value.pause()\n      audioRef.value.currentTime = 0\n    }\n    isPlaying.value = false\n    if (options.onPlaybackEnded) {\n      options.onPlaybackEnded()\n    }\n  }\n\n  function onPlaybackEnded() {\n    isPlaying.value = false\n    if (options.onPlaybackEnded) {\n      options.onPlaybackEnded()\n    }\n  }\n\n  function onMetadataLoaded() {\n    if (audioRef.value?.duration && options.onMetadataLoaded) {\n      options.onMetadataLoaded(audioRef.value.duration)\n    }\n  }\n\n  async function resetAudioElement() {\n    audioElementKey.value += 1\n    await nextTick()\n  }\n\n  function getCurrentTime() {\n    return audioRef.value?.currentTime || 0\n  }\n\n  function getDuration() {\n    return audioRef.value?.duration || 0\n  }\n\n  return {\n    isPlaying,\n    audioElementKey,\n    play,\n    stop,\n    onPlaybackEnded,\n    onMetadataLoaded,\n    resetAudioElement,\n    getCurrentTime,\n    getDuration,\n    playbackTimerInterval\n  }\n}\n","import { MediaRecorder as ExtendableMediaRecorder } from 'extendable-media-recorder'\nimport { onUnmounted, ref } from 'vue'\n\nimport { useAudioService } from '@/services/audioService'\n\ninterface AudioRecorderOptions {\n  onRecordingComplete?: (audioBlob: Blob) => Promise<void>\n  onError?: (error: Error) => void\n}\n\nexport function useAudioRecorder(options: AudioRecorderOptions = {}) {\n  const isRecording = ref(false)\n  const mediaRecorder = ref<MediaRecorder | null>(null)\n  const audioChunks = ref<Blob[]>([])\n  const stream = ref<MediaStream | null>(null)\n  const recordedURL = ref<string | null>(null)\n\n  async function startRecording() {\n    try {\n      // Clean up previous recording\n      if (recordedURL.value?.startsWith('blob:')) {\n        URL.revokeObjectURL(recordedURL.value)\n      }\n\n      // Initialize\n      audioChunks.value = []\n      recordedURL.value = null\n\n      // Register wav encoder and get media stream\n      await useAudioService().registerWavEncoder()\n      stream.value = await navigator.mediaDevices.getUserMedia({ audio: true })\n\n      // Create media recorder\n      mediaRecorder.value = new ExtendableMediaRecorder(stream.value, {\n        mimeType: 'audio/wav'\n      }) as unknown as MediaRecorder\n\n      mediaRecorder.value.ondataavailable = (e) => {\n        audioChunks.value.push(e.data)\n      }\n\n      mediaRecorder.value.onstop = async () => {\n        const blob = new Blob(audioChunks.value, { type: 'audio/wav' })\n\n        // Create blob URL for preview\n        if (recordedURL.value?.startsWith('blob:')) {\n          URL.revokeObjectURL(recordedURL.value)\n        }\n        recordedURL.value = URL.createObjectURL(blob)\n\n        // Notify completion\n        if (options.onRecordingComplete) {\n          await options.onRecordingComplete(blob)\n        }\n\n        cleanup()\n      }\n\n      // Start recording\n      mediaRecorder.value.start(100)\n      isRecording.value = true\n    } catch (err) {\n      if (options.onError) {\n        options.onError(err as Error)\n      }\n      throw err\n    }\n  }\n\n  function stopRecording() {\n    if (mediaRecorder.value && mediaRecorder.value.state !== 'inactive') {\n      mediaRecorder.value.stop()\n    } else {\n      cleanup()\n    }\n  }\n\n  function cleanup() {\n    isRecording.value = false\n\n    if (stream.value) {\n      stream.value.getTracks().forEach((track) => track.stop())\n      stream.value = null\n    }\n  }\n\n  function dispose() {\n    stopRecording()\n    if (recordedURL.value) {\n      URL.revokeObjectURL(recordedURL.value)\n      recordedURL.value = null\n    }\n  }\n\n  onUnmounted(() => {\n    dispose()\n  })\n\n  return {\n    isRecording,\n    recordedURL,\n    mediaRecorder,\n    startRecording,\n    stopRecording,\n    dispose\n  }\n}\n","import { onUnmounted, ref } from 'vue'\nimport type { Ref } from 'vue'\n\ninterface WaveformBar {\n  height: number\n}\n\ninterface AudioWaveformOptions {\n  barCount?: number\n  minHeight?: number\n  maxHeight?: number\n}\n\nexport function useAudioWaveform(options: AudioWaveformOptions = {}) {\n  const { barCount = 18, minHeight = 4, maxHeight = 32 } = options\n\n  const waveformBars = ref<WaveformBar[]>(\n    Array.from({ length: barCount }, () => ({ height: 16 }))\n  )\n  const audioContext = ref<AudioContext | null>(null)\n  const analyser = ref<AnalyserNode | null>(null)\n  const dataArray = ref<Uint8Array | null>(null)\n  const animationId = ref<number | null>(null)\n  const mediaElementSource = ref<MediaElementAudioSourceNode | null>(null)\n\n  function initWaveform() {\n    waveformBars.value = Array.from({ length: barCount }, () => ({\n      height: Math.random() * (maxHeight - minHeight) + minHeight\n    }))\n  }\n\n  function updateWaveform(isActive: Ref<boolean>) {\n    if (!isActive.value) return\n\n    if (analyser.value && dataArray.value) {\n      updateWaveformFromAudio()\n    } else {\n      updateWaveformRandom()\n    }\n\n    animationId.value = requestAnimationFrame(() => updateWaveform(isActive))\n  }\n\n  function updateWaveformFromAudio() {\n    if (!analyser.value || !dataArray.value) return\n\n    analyser.value.getByteFrequencyData(\n      dataArray.value as Uint8Array<ArrayBuffer>\n    )\n    const samplesPerBar = Math.floor(dataArray.value.length / barCount)\n\n    waveformBars.value = waveformBars.value.map((_, i) => {\n      let sum = 0\n      for (let j = 0; j < samplesPerBar; j++) {\n        sum += dataArray.value![i * samplesPerBar + j] || 0\n      }\n      const average = sum / samplesPerBar\n      const normalizedHeight =\n        (average / 255) * (maxHeight - minHeight) + minHeight\n      return { height: normalizedHeight }\n    })\n  }\n\n  function updateWaveformRandom() {\n    waveformBars.value = waveformBars.value.map((bar) => ({\n      height: Math.max(\n        minHeight,\n        Math.min(maxHeight, bar.height + (Math.random() - 0.5) * 4)\n      )\n    }))\n  }\n\n  async function setupAudioContext() {\n    if (audioContext.value && audioContext.value.state !== 'closed') {\n      await audioContext.value.close()\n    }\n    audioContext.value = null\n    mediaElementSource.value = null\n  }\n\n  async function setupRecordingVisualization(stream: MediaStream) {\n    audioContext.value = new window.AudioContext()\n    analyser.value = audioContext.value.createAnalyser()\n    const source = audioContext.value.createMediaStreamSource(stream)\n    source.connect(analyser.value)\n\n    analyser.value.fftSize = 256\n    dataArray.value = new Uint8Array(analyser.value.frequencyBinCount)\n  }\n\n  async function setupPlaybackVisualization(audioElement: HTMLAudioElement) {\n    if (audioContext.value && audioContext.value.state !== 'closed') {\n      await audioContext.value.close()\n    }\n\n    mediaElementSource.value = null\n\n    if (!audioElement) return false\n\n    audioContext.value = new window.AudioContext()\n    analyser.value = audioContext.value.createAnalyser()\n\n    mediaElementSource.value =\n      audioContext.value.createMediaElementSource(audioElement)\n\n    mediaElementSource.value.connect(analyser.value)\n    analyser.value.connect(audioContext.value.destination)\n\n    analyser.value.fftSize = 256\n    dataArray.value = new Uint8Array(analyser.value.frequencyBinCount)\n\n    return true\n  }\n\n  function stopWaveform() {\n    if (animationId.value) {\n      cancelAnimationFrame(animationId.value)\n      animationId.value = null\n    }\n  }\n\n  function dispose() {\n    stopWaveform()\n    if (audioContext.value && audioContext.value.state !== 'closed') {\n      void audioContext.value.close()\n    }\n    audioContext.value = null\n    mediaElementSource.value = null\n  }\n\n  onUnmounted(() => {\n    dispose()\n  })\n\n  return {\n    waveformBars,\n    initWaveform,\n    updateWaveform,\n    setupAudioContext,\n    setupRecordingVisualization,\n    setupPlaybackVisualization,\n    stopWaveform,\n    dispose\n  }\n}\n","<template>\n  <div class=\"relative\">\n    <div class=\"mb-4\">\n      <Button\n        class=\"text-base-foreground w-full border-0 bg-secondary-background hover:bg-secondary-background-hover\"\n        :disabled=\"isRecording || readonly\"\n        @click=\"handleStartRecording\"\n      >\n        {{ t('g.startRecording', 'Start Recording') }}\n        <i-lucide:mic class=\"ml-1\" />\n      </Button>\n    </div>\n    <div\n      v-if=\"isRecording || isPlaying || recordedURL\"\n      class=\"flex h-14 w-full items-center gap-4 rounded-lg px-4 bg-node-component-surface text-text-secondary\"\n    >\n      <!-- Recording Status -->\n      <div class=\"flex min-w-30 items-center gap-2\">\n        <span class=\"min-w-20 text-xs\">\n          {{\n            isRecording\n              ? t('g.listening', 'Listening...')\n              : isPlaying\n                ? t('g.playing', 'Playing...')\n                : recordedURL\n                  ? t('g.ready', 'Ready')\n                  : ''\n          }}\n        </span>\n        <span class=\"min-w-10 text-sm\">{{ formatTime(timer) }}</span>\n      </div>\n\n      <!-- Waveform Visualization -->\n      <div class=\"flex h-8 flex-1 items-center gap-2 overflow-x-clip\">\n        <div\n          v-for=\"(bar, index) in waveformBars\"\n          :key=\"index\"\n          class=\"max-h-8 min-h-1 w-0.75 rounded-[1.5px] bg-slate-100 transition-all duration-100\"\n          :style=\"{ height: bar.height + 'px' }\"\n          :title=\"`Bar ${index + 1}: ${bar.height}px`\"\n        />\n      </div>\n\n      <!-- Control Button -->\n      <button\n        v-if=\"isRecording\"\n        :title=\"t('g.stopRecording', 'Stop Recording')\"\n        class=\"flex size-8 animate-pulse items-center justify-center rounded-full border-0 bg-smoke-500/33 transition-colors\"\n        @click=\"handleStopRecording\"\n      >\n        <div class=\"size-2.5 rounded-sm bg-danger-100\" />\n      </button>\n\n      <button\n        v-else-if=\"!isRecording && recordedURL && !isPlaying\"\n        :title=\"t('g.playRecording') || 'Play Recording'\"\n        class=\"flex size-8 items-center justify-center rounded-full border-0 bg-smoke-500/33 transition-colors\"\n        @click=\"handlePlayRecording\"\n      >\n        <i class=\"text-text-secondary icon-[lucide--play] size-4\" />\n      </button>\n\n      <button\n        v-else-if=\"isPlaying\"\n        :title=\"t('g.stopPlayback') || 'Stop Playback'\"\n        class=\"flex size-8 items-center justify-center rounded-full border-0 bg-smoke-500/33 transition-colors\"\n        @click=\"handleStopPlayback\"\n      >\n        <i class=\"text-text-secondary icon-[lucide--square] size-4\" />\n      </button>\n    </div>\n    <audio\n      v-if=\"recordedURL\"\n      ref=\"audioRef\"\n      :key=\"audioElementKey\"\n      :src=\"recordedURL\"\n      class=\"hidden\"\n      @ended=\"playback.onPlaybackEnded\"\n      @loadedmetadata=\"playback.onMetadataLoaded\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { useIntervalFn } from '@vueuse/core'\nimport { Button } from 'primevue'\nimport { computed, onMounted, onUnmounted, ref } from 'vue'\n\nimport { t } from '@/i18n'\nimport type { LGraphNode } from '@/lib/litegraph/src/LGraphNode'\nimport type { IBaseWidget } from '@/lib/litegraph/src/types/widgets'\nimport { useToastStore } from '@/platform/updates/common/toastStore'\nimport { app } from '@/scripts/app'\nimport { useAudioService } from '@/services/audioService'\n\nimport { useAudioPlayback } from '../composables/audio/useAudioPlayback'\nimport { useAudioRecorder } from '../composables/audio/useAudioRecorder'\nimport { useAudioWaveform } from '../composables/audio/useAudioWaveform'\nimport { formatTime } from '../utils/audioUtils'\n\nconst props = defineProps<{\n  readonly?: boolean\n  nodeId: string\n}>()\n\n// Audio element ref\nconst audioRef = ref<HTMLAudioElement>()\n\n// Keep track of the last uploaded path as a backup\nlet lastUploadedPath = ''\n\n// Composables\nconst recorder = useAudioRecorder({\n  onRecordingComplete: handleRecordingComplete,\n  onError: () => {\n    useToastStore().addAlert(\n      t('g.micPermissionDenied') || 'Microphone permission denied'\n    )\n  }\n})\n\nconst waveform = useAudioWaveform({\n  barCount: 18,\n  minHeight: 4,\n  maxHeight: 32\n})\n\nconst playback = useAudioPlayback(audioRef, {\n  onPlaybackEnded: handlePlaybackEnded,\n  onMetadataLoaded: (duration) => {\n    if (!isPlaying.value && !isRecording.value) {\n      timer.value = Math.floor(duration)\n    }\n  }\n})\n\n// Timer for recording\nconst timer = ref(0)\nconst { pause: pauseTimer, resume: resumeTimer } = useIntervalFn(\n  () => {\n    timer.value += 1\n  },\n  1000,\n  { immediate: false }\n)\n\n// Destructure for template access\nconst { isRecording, recordedURL } = recorder\nconst { waveformBars } = waveform\nconst { isPlaying, audioElementKey } = playback\n\n// Computed for waveform animation\nconst isWaveformActive = computed(() => isRecording.value || isPlaying.value)\n\nconst modelValue = defineModel<string>({ default: '' })\n\nconst litegraphNode = computed(() => {\n  if (!props.nodeId || !app.canvas.graph) return null\n  return app.canvas.graph.getNodeById(props.nodeId) as LGraphNode | null\n})\n\nasync function handleRecordingComplete(blob: Blob) {\n  try {\n    const path = await useAudioService().convertBlobToFileAndSubmit(blob)\n    modelValue.value = path\n    lastUploadedPath = path\n  } catch (e) {\n    useToastStore().addAlert('Failed to upload recorded audio')\n  }\n}\n\nasync function handleStartRecording() {\n  if (props.readonly) return\n\n  try {\n    await waveform.setupAudioContext()\n    await recorder.startRecording()\n\n    // Setup waveform visualization for recording\n    if (recorder.mediaRecorder.value) {\n      const stream = recorder.mediaRecorder.value.stream\n      if (stream) {\n        await waveform.setupRecordingVisualization(stream)\n      }\n    }\n\n    // Start timer\n    timer.value = 0\n    resumeTimer()\n    waveform.initWaveform()\n    waveform.updateWaveform(isWaveformActive)\n  } catch (err) {\n    console.error('Failed to start recording:', err)\n  }\n}\n\nfunction handleStopRecording() {\n  recorder.stopRecording()\n  pauseTimer()\n  waveform.stopWaveform()\n}\n\nasync function handlePlayRecording() {\n  if (!recordedURL.value) return\n\n  // Reset timer\n  timer.value = 0\n\n  // Reset and setup audio element\n  await playback.resetAudioElement()\n\n  // Wait for audio element to be ready\n  await new Promise((resolve) => setTimeout(resolve, 50))\n\n  if (!audioRef.value) return\n\n  // Setup waveform visualization for playback\n  const setupSuccess = await waveform.setupPlaybackVisualization(audioRef.value)\n  if (!setupSuccess) return\n\n  // Start playback\n  await playback.play()\n\n  // Update waveform\n  waveform.initWaveform()\n  waveform.updateWaveform(isWaveformActive)\n\n  // Update timer from audio current time\n  const timerInterval = setInterval(() => {\n    timer.value = Math.floor(playback.getCurrentTime())\n  }, 100)\n\n  // Store interval for cleanup\n  playback.playbackTimerInterval.value = timerInterval\n}\n\nfunction handleStopPlayback() {\n  playback.stop()\n  handlePlaybackEnded()\n}\n\nfunction handlePlaybackEnded() {\n  waveform.stopWaveform()\n\n  // Clear playback timer interval\n  if (playback.playbackTimerInterval.value !== null) {\n    clearInterval(playback.playbackTimerInterval.value)\n    playback.playbackTimerInterval.value = null\n  }\n\n  const duration = playback.getDuration()\n  if (duration) {\n    timer.value = Math.floor(duration)\n  } else {\n    timer.value = 0\n  }\n}\n\n// Serialization function for workflow execution\nasync function serializeValue() {\n  if (isRecording.value && recorder.mediaRecorder.value) {\n    recorder.mediaRecorder.value.stop()\n\n    await new Promise((resolve, reject) => {\n      let attempts = 0\n      const maxAttempts = 50 // 5 seconds max (50 * 100ms)\n      const checkRecording = () => {\n        if (!isRecording.value && modelValue.value) {\n          resolve(undefined)\n        } else if (++attempts >= maxAttempts) {\n          reject(new Error('Recording serialization timeout after 5 seconds'))\n        } else {\n          setTimeout(checkRecording, 100)\n        }\n      }\n      checkRecording()\n    })\n  }\n\n  return modelValue.value || lastUploadedPath || ''\n}\n\nfunction registerWidgetSerialization() {\n  const node = litegraphNode.value\n  if (!node?.widgets) return\n  const targetWidget = node.widgets.find((w: IBaseWidget) => w.name === 'audio')\n  if (targetWidget) {\n    targetWidget.serializeValue = serializeValue\n  }\n}\n\nonMounted(() => {\n  waveform.initWaveform()\n  registerWidgetSerialization()\n})\n\nonUnmounted(() => {\n  if (playback.playbackTimerInterval.value !== null) {\n    clearInterval(playback.playbackTimerInterval.value)\n    playback.playbackTimerInterval.value = null\n  }\n})\n</script>\n"],"names":["useAudioPlayback","audioRef","options","isPlaying","ref","audioElementKey","playbackTimerInterval","play","error","__name","stop","onPlaybackEnded","onMetadataLoaded","resetAudioElement","nextTick","getCurrentTime","getDuration","useAudioRecorder","isRecording","mediaRecorder","audioChunks","stream","recordedURL","startRecording","useAudioService","ExtendableMediaRecorder","e","blob","cleanup","err","stopRecording","track","dispose","onUnmounted","useAudioWaveform","barCount","minHeight","maxHeight","waveformBars","audioContext","analyser","dataArray","animationId","mediaElementSource","initWaveform","updateWaveform","isActive","updateWaveformFromAudio","updateWaveformRandom","samplesPerBar","_","i","sum","j","bar","setupAudioContext","setupRecordingVisualization","setupPlaybackVisualization","audioElement","stopWaveform","props","__props","lastUploadedPath","recorder","handleRecordingComplete","useToastStore","t","waveform","playback","handlePlaybackEnded","duration","timer","pauseTimer","resumeTimer","useIntervalFn","isWaveformActive","computed","modelValue","_useModel","litegraphNode","app","path","handleStartRecording","handleStopRecording","handlePlayRecording","resolve","timerInterval","handleStopPlayback","serializeValue","reject","attempts","maxAttempts","checkRecording","registerWidgetSerialization","node","targetWidget","w","onMounted"],"mappings":"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"}