<html><head><title>main368</title>
<link rel="stylesheet" type="text/css" href="../pythia.css"/>
<link rel="shortcut icon" href="../pythia32.gif"/></head><body><h2>main368</h2>
Back to <a href="../ExampleKeywords.html" target="page">index.</a>
<pre><code class="language-c++">
// main368.cc is a part of the PYTHIA event generator.
// Copyright (C) 2026 Torbjorn Sjostrand.
// PYTHIA is licenced under the GNU GPL v2 or later, see COPYING for details.
// Please respect the MCnet Guidelines, see GUIDELINES for details.

// Authors:
//            <a href="mailto:torbjorn.sjostrand@fysik.lu.se">Torbjorn Sjostrand</a>

// Keywords:
//            <a href="../ExampleKeywords.html#top">Top</a>
//            <a href="../ExampleKeywords.html#toponium">Toponium</a>

// Plot top threshold factors according to chosen parameter settings.
// Based on ttbar Coulomb factors and Green&apos;s functions according to FKS:
// V. Fadin,  V. Khoze and T. Sjostrand, Z. Phys. C48 (1990) 613.

#include &quot;Pythia8/Pythia.h&quot;
using namespace Pythia8;

//==========================================================================

// Implementation of the ttbar Coulomb factors and Green&apos;s functions in
// V. Fadin,  V. Khoze and T. Sjostrand, Z. Phys. C48 (1990) 613.

class TopThr  {

public:

  // Save input values for given scenario.
  void setup( double mtIn, double gammatIn, int alphasOrder,
    double alphasValue) { mt = mtIn; gammat = gammatIn;
    alphas.init(alphasValue, alphasOrder);}

  // Return threshold factor value, at eNow above or below threshold.
  // isGreen true or false gives Green&apos;s function or Coulomb factor.
  // isSinglet gives singlet or octet contribution.
  double value( double eNow, bool isGreen, bool isSinglet) {

    // Negative eNow not allowed in Coulomb.
    if (!isGreen &amp;&amp; eNow &lt;= 0.) return 0.;

    // alpha_strong value.
    double q2Thr = pow2(eNow) + pow2(gammat);
    double q2alp = mt * sqrt(q2Thr);
    alps         = alphas.alphaS(q2alp);
    double beta  = sqrtpos(1. - pow2( 2. * mt / (2. * mt + eNow)));

    // Attractive expressions for singlet case.
    if (isSinglet) {
      if (isGreen) return imGreenSin( eNow);
      double xAttr = (4. / 3.) * M_PI * alps / beta;
      return beta * xAttr / (1. - exp(-xAttr));

    // Repulsive expressions for octet case.
    } else {
      if (isGreen) return imGreenOct( eNow);
      double xRepu = (1. / 6.) * M_PI * alps / beta;
      return beta * xRepu / (exp(xRepu) - 1);
    }

  }

  // Imaginary part of Green&apos;s function for singlet state.
  // Factor m_t^2 / (4 pi) omitted since cancelled when applied for sigma.
  double imGreenSin(double eNow) {

    // Basic expressions.
    double ps   = (2. / 3.) * mt * alps;
    double egrt = sqrt(eNow * eNow + gammat * gammat);
    double p1   = sqrt( 0.5 * mt * (egrt - eNow));
    double p2   = sqrt( 0.5 * mt * (egrt + eNow));

    // Sum over resonance contributions.
    double ressum = 0.;
    for (int n = 1; n &lt; 21; ++n)
      ressum += (gammat * ps * n + p2 * (n*n * egrt + ps * ps / mt))
      / ( pow4(n) * (pow2(eNow + ps * ps / (mt * n*n)) + gammat * gammat) );

    // Combine with non-resonant terms and done.
    return p2 / mt + (2. * ps / mt) * atan(p2 / p1)
      + 2. * pow2(ps / mt) * ressum;
  }

  // Imaginary part of Green&apos;s function for octet state.
  // Factor m_t^2 / (4 pi) omitted since cancelled when applied for sigma.
  double imGreenOct(double eNow) {

    // Basic expressions.
    double p8   = - (1. / 12.) * mt * alps;
    double egrt = sqrt(eNow * eNow + gammat * gammat);
    double p1   = sqrt( 0.5 * mt * (egrt - eNow));
    double p2   = sqrt( 0.5 * mt * (egrt + eNow));

    // Sum over resonance contributions.
    double ressum = 0.;
    for (int n = 1; n &lt; 21; ++n)
      ressum += mt * p2 / (pow2(n * p1 - p8) + pow2(n * p2));

    // Combine with non-resonant terms and done.
    return p2 / mt + (2. * p8 / mt) * atan(p2 / p1)
      + 2. * pow2(p8 / mt) * ressum;
  }

 private:

  // Commonly available variables.
  double mt, gammat, alps;

  // Need alphaStrong with special scale.
  AlphaStrong alphas;

};

//==========================================================================

int main() {

  // useOld = true to reproduce FKS figures, else use more modern values.
  bool useOld = false;

  // showMod = true shows Green&apos;s function also with modified argument.
  // May give too busy figures, so optional.
  bool showMod = false;

  // splitFigs = true gives each figure separately, else as one single file.
  bool splitFigs = false;

  // Generator.
  Pythia pythia;

  // Parameters to set.
  int    alphasOrder;
  double mt, gammat, alphasValue;

  // Old setup from FKS or a more relevent current setup.
  if (useOld) {
    mt            = 200.;
    gammat        = 2.5;
    alphasOrder   = 1;
    alphasValue   = 0.134;
  } else {
    mt            = 172.5;
    gammat        = 1.34;
    alphasOrder   = 2;
    alphasValue   = 0.118;
  }

  // Create and initialize top threshold object.
  TopThr topThr;
  topThr.setup( mt, gammat, alphasOrder, alphasValue);

  // Histograms, for narrower or broader E range around threshold.
  Hist greensin(&quot;imGreen singlet&quot;, 200, -10., 30.);
  Hist greenoct(&quot;imGreen octet&quot;, 200, -10., 30.);
  Hist greensinMod(&quot;imGreen singlet&quot;, 200, -10., 30.);
  Hist greenoctMod(&quot;imGreen octet&quot;, 200, -10., 30.);
  Hist betaval(&quot;beta threshold factor&quot;,200, -10., 30.);
  Hist coulsin(&quot;singlet Coulomb factor&quot;,200, -10., 30.);
  Hist couloct(&quot;octet Coulomb factor&quot;,200, -10., 30.);
  Hist greensin2(&quot;imGreen singlet&quot;, 240, -20., 100.);
  Hist greenoct2(&quot;imGreen octet&quot;, 240, -20., 100.);
  Hist greensin2Mod(&quot;imGreen singlet&quot;, 240, -20., 100.);
  Hist greenoct2Mod(&quot;imGreen octet&quot;, 240, -20., 100.);
  Hist betaval2(&quot;beta threshold factor&quot;,240, -20., 100.);
  Hist coulsin2(&quot;singlet Coulomb factor&quot;,240, -20., 100.);
  Hist couloct2(&quot;octet Coulomb factor&quot;,240, -20., 100.);

  // Loop over energies to plot - narrower range.
  for (int iE = 0; iE &lt; 200; ++iE) {
    double eNow  = -9.9 + 0.2 * iE;
    double beta2 = 1. - pow2( 2. * mt / (2. * mt + eNow));

    // Green&apos;s function expressions.
    double valNowS = topThr.value( eNow, true, true);
    greensin.fill( eNow, valNowS);
    double valNowO = topThr.value( eNow, true, false);
    greenoct.fill( eNow, valNowO);

    // Relativistic argument to Green&apos;s function is equivalent at threshold.
    double eMod  = mt * beta2;
    double valNowSMod = topThr.value( eMod, true, true);
    greensinMod.fill( eNow, valNowSMod);
    double valNowOMod = topThr.value( eMod, true, false);
    greenoctMod.fill( eNow, valNowOMod);

    // For positive energies also beta and Coulomb.
    if (eNow &gt; 0.) {
      double beta = sqrt(beta2);
      betaval.fill( eNow, beta);
      double fAttr = topThr.value( eNow, false, true);
      coulsin.fill( eNow, fAttr);
      double fRepu = topThr.value( eNow, false, false);
      couloct.fill( eNow, fRepu);
    }
  }

  // Loop over energies to plot - broader range.
  for (int iE = 0; iE &lt; 240; ++iE) {
    double eNow = -19.75 + 0.5 * iE;
    double beta2 = 1. - pow2( 2. * mt / (2. * mt + eNow));

    // Green&apos;s function expressions.
    double valNowS = topThr.value( eNow, true, true);
    greensin2.fill( eNow, valNowS);
    double valNowO = topThr.value( eNow, true, false);
    greenoct2.fill( eNow, valNowO);

    // Relativistic argument to Green&apos;s function is equivalent at threshold.
    double eMod  = mt * beta2;
    double valNowSMod = topThr.value( eMod, true, true);
    greensin2Mod.fill( eNow, valNowSMod);
    double valNowOMod = topThr.value( eMod, true, false);
    greenoct2Mod.fill( eNow, valNowOMod);

    // For positive energies also beta and Coulomb.
    if (eNow &gt; 0.) {
      double beta = sqrt(beta2);
      betaval2.fill( eNow, beta);
      double fAttr = topThr.value( eNow, false, true);
      coulsin2.fill( eNow, fAttr);
      double fRepu = topThr.value( eNow, false, false);
      couloct2.fill( eNow, fRepu);
    }
  }

  // Histograms with pyplot. Frame dimensions.
  HistPlot hpl(&quot;plot368&quot;);
  double width  = 4.8;
  double height = 4.8;

  // Singet and octet contribution in -10 &lt; E &lt; 30.
  hpl.frame(splitFigs ? &quot;fig368narrow&quot; : &quot;fig368&quot;, &quot;&quot;, &quot;$E$ (GeV)&quot;,
    &quot;rate (arbitrary units)&quot;, width, height);
  hpl.add( betaval, &quot;-,black&quot;, &quot;pure beta threshold&quot;);
  hpl.add( coulsin, &quot;--,blue&quot;, &quot;singlet Coulomb factor&quot;);
  hpl.add( couloct, &quot;--,cyan&quot;, &quot;octet Coulomb factor&quot;);
  hpl.add( greensin, &quot;--,red&quot;, &quot;singlet Green&apos;s function&quot;);
  hpl.add( greenoct, &quot;--,magenta&quot;, &quot;octet Green&apos;s function&quot;);
  if (showMod) {
    hpl.add( greensinMod, &quot;-.,red&quot;, &quot;modified singlet Green&apos;s function&quot;);
    hpl.add( greenoctMod, &quot;-.,magenta&quot;, &quot;modified octet Green&apos;s function&quot;);
  }
  hpl.plot();

  // Singet and octet contribution in -20 &lt; E &lt; 100.
  hpl.frame(splitFigs ? &quot;fig368wide&quot; : &quot;&quot;, &quot;&quot;, &quot;$E$ (GeV)&quot;,
    &quot;rate (arbitrary units)&quot;, width, height);
  hpl.add( betaval2, &quot;-,black&quot;, &quot;pure beta threshold&quot;);
  hpl.add( coulsin2, &quot;--,blue&quot;, &quot;singlet Coulomb factor&quot;);
  hpl.add( couloct2, &quot;--,cyan&quot;, &quot;octet Coulomb factor&quot;);
  hpl.add( greensin2, &quot;--,red&quot;, &quot;singlet Green&apos;s function&quot;);
  hpl.add( greenoct2, &quot;--,magenta&quot;, &quot;octet Green&apos;s function&quot;);
  if (showMod) {
    hpl.add( greensin2Mod, &quot;-.,red&quot;, &quot;modified singlet Green&apos;s function&quot;);
    hpl.add( greenoct2Mod, &quot;-.,magenta&quot;, &quot;modified octet Green&apos;s function&quot;);
  }
  hpl.plot();

  // Singlet contribution only, for direct comparison with FKS figure.
  hpl.frame(splitFigs ? &quot;fig368singlet&quot; : &quot;&quot;, &quot;&quot;,  &quot;$E$ (GeV)&quot;,
    &quot;rate (arbitrary units)&quot;, width, height);
  hpl.add( betaval, &quot;-,black&quot;, &quot;pure beta threshold&quot;);
  hpl.add( coulsin, &quot;--,blue&quot;, &quot;singlet Coulomb factor&quot;);
  hpl.add( greensin, &quot;-.,red&quot;, &quot;singlet Green&apos;s function&quot;);
  if (showMod &amp;&amp; !useOld) hpl.add( greensinMod, &quot;-.,blue&quot;,
    &quot;modified singlet Green&apos;s function&quot;);
  if (useOld) hpl.plot(-10., 30., 0., 0.74);
  else hpl.plot();

  // Octet contribution only, for direct comparison with FKS figure.
  hpl.frame(splitFigs ? &quot;fig368octet&quot; : &quot;&quot;, &quot;&quot;,  &quot;$E$ (GeV)&quot;,
    &quot;rate (arbitrary units)&quot;, width, height);
  hpl.add( betaval, &quot;-,black&quot;, &quot;pure beta threshold&quot;);
  hpl.add( couloct, &quot;--,cyan&quot;, &quot;octet Coulomb factor&quot;);
  hpl.add( greenoct, &quot;-.,magenta&quot;, &quot;octet Green&apos;s function&quot;);
  if (showMod &amp;&amp; !useOld) hpl.add( greenoctMod, &quot;-.,blue&quot;,
    &quot;octet Green&apos;s function&quot;);
  if (useOld) hpl.plot(-10., 30., 0., 0.37);
  else hpl.plot();

  // Done.
  return 0;
}

//============================================================================
</code></pre></body></html>