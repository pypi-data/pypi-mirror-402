#!/bin/bash
# Extract kernel and initramfs from Alpine linux-virt package
#
# Uses Alpine container with apk to get both vmlinuz-virt AND initramfs-virt
# (initramfs is generated by apk, not included in raw APK file)
#
# Usage:
#   ./scripts/extract-kernel.sh              # Extract for current arch
#   ./scripts/extract-kernel.sh x86_64       # Extract for x86_64
#   ./scripts/extract-kernel.sh aarch64      # Extract for aarch64
#   ./scripts/extract-kernel.sh all          # Extract for both

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
OUTPUT_DIR="$REPO_ROOT/images/dist"
ALPINE_VERSION="${ALPINE_VERSION:-3.21}"

detect_arch() {
    case "$(uname -m)" in
        x86_64|amd64) echo "x86_64" ;;
        aarch64|arm64) echo "aarch64" ;;
        *) echo "Unsupported arch: $(uname -m)" >&2; exit 1 ;;
    esac
}

# =============================================================================
# Cache helpers - content-addressable build caching via .hash sidecar files
# =============================================================================

# Get kernel package version from Alpine's package index (without running Docker)
# This ensures cache invalidation when Alpine updates the kernel package
get_kernel_version() {
    local arch=$1
    local apk_arch
    case "$arch" in
        x86_64)  apk_arch="x86_64" ;;
        aarch64) apk_arch="aarch64" ;;
    esac
    curl -sf "https://dl-cdn.alpinelinux.org/alpine/v${ALPINE_VERSION}/main/${apk_arch}/APKINDEX.tar.gz" 2>/dev/null \
        | tar -xzO APKINDEX 2>/dev/null \
        | grep -A1 "^P:linux-virt$" \
        | grep "^V:" \
        | cut -d: -f2 \
        || echo "unknown"
}

# Compute hash for kernel inputs (Alpine version + arch + kernel package version)
compute_kernel_hash() {
    local arch=$1
    local kernel_ver
    kernel_ver=$(get_kernel_version "$arch")
    echo "alpine=$ALPINE_VERSION arch=$arch kernel=$kernel_ver" | sha256sum | cut -d' ' -f1
}

# Compute hash for initramfs inputs (kernel hash + tiny-init binary + build script)
compute_initramfs_hash() {
    local arch=$1
    local kernel_ver
    kernel_ver=$(get_kernel_version "$arch")
    (
        echo "alpine=$ALPINE_VERSION arch=$arch kernel=$kernel_ver"
        # Include tiny-init binary hash (if it exists)
        sha256sum "$OUTPUT_DIR/tiny-init-$arch" 2>/dev/null || echo "tiny-init-not-built"
        cat "$SCRIPT_DIR/build-initramfs.sh" 2>/dev/null || true
    ) | sha256sum | cut -d' ' -f1
}

# Check if output is up-to-date (hash matches)
cache_hit() {
    local output_file=$1
    local current_hash=$2
    local hash_file="${output_file}.hash"

    if [ -f "$output_file" ] && [ -f "$hash_file" ]; then
        local cached_hash
        cached_hash=$(cat "$hash_file" 2>/dev/null || echo "")
        [ "$cached_hash" = "$current_hash" ]
    else
        return 1
    fi
}

# Save hash after successful build
save_hash() {
    local output_file=$1
    local hash=$2
    echo "$hash" > "${output_file}.hash"
}

# =============================================================================
# Build functions
# =============================================================================

extract_for_arch() {
    local target_arch=$1
    local docker_platform
    local vmlinuz_file="$OUTPUT_DIR/vmlinuz-$target_arch"
    local initramfs_file="$OUTPUT_DIR/initramfs-$target_arch"

    case "$target_arch" in
        x86_64)  docker_platform="linux/amd64" ;;
        aarch64) docker_platform="linux/arm64" ;;
    esac

    # Check cache separately for kernel and initramfs
    local kernel_hash initramfs_hash
    kernel_hash=$(compute_kernel_hash "$target_arch")
    initramfs_hash=$(compute_initramfs_hash "$target_arch")

    local need_kernel=false need_initramfs=false

    if ! cache_hit "$vmlinuz_file" "$kernel_hash"; then
        need_kernel=true
    fi

    if ! cache_hit "$initramfs_file" "$initramfs_hash"; then
        need_initramfs=true
    fi

    if [ "$need_kernel" = false ] && [ "$need_initramfs" = false ]; then
        echo "Kernel up-to-date: $target_arch (cache hit)"
        return 0
    fi

    mkdir -p "$OUTPUT_DIR"

    # Extract kernel from Alpine if needed
    if [ "$need_kernel" = true ]; then
        echo "Extracting kernel for $target_arch (Alpine $ALPINE_VERSION)..."
        docker run --rm \
            -v "$OUTPUT_DIR:/output" \
            --platform "$docker_platform" \
            "alpine:$ALPINE_VERSION" \
            sh -c "
                apk add --no-cache linux-virt >/dev/null 2>&1
                cp /boot/vmlinuz-virt /output/vmlinuz-$target_arch
                chmod 644 /output/vmlinuz-$target_arch
            "
        save_hash "$vmlinuz_file" "$kernel_hash"
    fi

    # Build initramfs if needed
    if [ "$need_initramfs" = true ]; then
        # Build custom minimal initramfs (2MB vs 9MB Alpine stock)
        # This includes only essential modules: virtio_blk, ext4 + dependencies
        "$SCRIPT_DIR/build-initramfs.sh" "$target_arch" "$OUTPUT_DIR"
        save_hash "$initramfs_file" "$initramfs_hash"
    fi

    # Report what was built
    if [ "$need_kernel" = true ] || [ "$need_initramfs" = true ]; then
        local vmlinuz_size initramfs_size
        vmlinuz_size=$(du -h "$vmlinuz_file" | cut -f1)
        initramfs_size=$(du -h "$initramfs_file" | cut -f1)
        echo "Extracted: vmlinuz-$target_arch ($vmlinuz_size), initramfs-$target_arch ($initramfs_size)"
    fi
}

main() {
    local target="${1:-$(detect_arch)}"

    # Check Docker is available
    if ! command -v docker >/dev/null 2>&1; then
        echo "Docker is required" >&2
        exit 1
    fi

    if [ "$target" = "all" ]; then
        extract_for_arch "x86_64"
        extract_for_arch "aarch64"
    else
        extract_for_arch "$target"
    fi
}

main "$@"
