import dataclasses
import enum
from csp_lib.equipment.simulation.curve import CurveProvider
from typing import ClassVar

__all__ = ['MeterMode', 'MeterReading', 'VirtualMeter']

class MeterMode(enum.Enum):
    _new_member_: ClassVar[builtin_function_or_method] = ...
    _use_args_: ClassVar[bool] = ...
    _member_names_: ClassVar[list] = ...
    _member_map_: ClassVar[dict] = ...
    _value2member_map_: ClassVar[dict] = ...
    _hashable_values_: ClassVar[list] = ...
    _unhashable_values_: ClassVar[list] = ...
    _unhashable_values_map_: ClassVar[dict] = ...
    _member_type_: ClassVar[type[object]] = ...
    _value_repr_: ClassVar[None] = ...
    RANDOM: ClassVar[MeterMode] = ...
    TEST_CURVE: ClassVar[MeterMode] = ...
    @staticmethod
    def _generate_next_value_(name, start, count, last_values): ...
    @classmethod
    def __init__(cls, value) -> None: ...

class MeterReading:
    v: ClassVar[float] = ...
    f: ClassVar[float] = ...
    p: ClassVar[float] = ...
    q: ClassVar[float] = ...
    s: ClassVar[float] = ...
    pf: ClassVar[float] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    @classmethod
    def with_power(cls, v: float, f: float, p: float, q: float) -> MeterReading: ...
    def __replace__(self, **changes): ...
    def __hash__(self) -> int: ...
    def __init__(self, v: float = ..., f: float = ..., p: float = ..., q: float = ..., s: float = ..., pf: float = ...) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __setattr__(self, name, value): ...
    def __delattr__(self, name): ...

class VirtualMeter:
    def __init__(self, base_voltage: float = ..., base_frequency: float = ..., voltage_noise: float = ..., frequency_noise: float = ..., curve_provider: CurveProvider | None = ...) -> None: ...
    def get_frequency(self) -> float: ...
    def get_voltage(self) -> float: ...
    def list_available_curves(self) -> list[str]: ...
    def start_test_curve(self, curve_name: str) -> bool: ...
    def stop_test_curve(self) -> None: ...
    def _advance_curve(self) -> bool: ...
    def update(self) -> None: ...
    def _update_random(self) -> None: ...
    def _update_test_curve(self) -> None: ...
    @property
    def mode(self): ...
    @property
    def reading(self): ...
    @property
    def curve_provider(self): ...
