from csp_lib.equipment.alarm.evaluator import AlarmEvaluator as AlarmEvaluator
from csp_lib.equipment.alarm.state import AlarmEventType as AlarmEventType, AlarmState as AlarmState, AlarmStateManager as AlarmStateManager
from csp_lib.equipment.device.config import DeviceConfig as DeviceConfig
from csp_lib.equipment.device.events import ConnectedPayload as ConnectedPayload, DeviceAlarmPayload as DeviceAlarmPayload, DeviceEventEmitter as DeviceEventEmitter, DisconnectPayload as DisconnectPayload, ReadCompletePayload as ReadCompletePayload, ReadErrorPayload as ReadErrorPayload, ValueChangePayload as ValueChangePayload, WriteCompletePayload as WriteCompletePayload, WriteErrorPayload as WriteErrorPayload
from csp_lib.equipment.processing.aggregator import AggregatorPipeline as AggregatorPipeline
from csp_lib.equipment.transport.base import PointGrouper as PointGrouper
from csp_lib.equipment.transport.reader import GroupReader as GroupReader
from csp_lib.equipment.transport.scheduler import ReadScheduler as ReadScheduler
from csp_lib.equipment.transport.writer import ValidatedWriter as ValidatedWriter, WriteResult as WriteResult, WriteStatus as WriteStatus
from typing import Any, AsyncHandler, Callable, ClassVar, Sequence

TYPE_CHECKING: bool
EVENT_ALARM_CLEARED: str
EVENT_ALARM_TRIGGERED: str
EVENT_CONNECTED: str
EVENT_DISCONNECTED: str
EVENT_READ_COMPLETE: str
EVENT_READ_ERROR: str
EVENT_VALUE_CHANGE: str
EVENT_WRITE_COMPLETE: str
EVENT_WRITE_ERROR: str

class AsyncModbusDevice:
    ACTIONS: ClassVar[dict] = ...
    def __init__(self, config: DeviceConfig, client: AsyncModbusClientBase, always_points: Sequence[ReadPoint] = ..., rotating_points: Sequence[Sequence[ReadPoint]] = ..., write_points: Sequence[WritePoint] = ..., alarm_evaluators: Sequence[AlarmEvaluator] = ..., aggregator_pipeline: AggregatorPipeline | None = ...) -> None: ...
    def connect(self) -> None: ...
    def disconnect(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def __aenter__(self) -> AsyncModbusDevice: ...
    def __aexit__(self, exc_type, exc_val, exc_tb) -> None: ...
    def read_once(self) -> dict[str, Any]: ...
    def write(self, name: str, value: Any, verify: bool = ...) -> WriteResult: ...
    def execute_action(self, action: str, **params: Any) -> WriteResult: ...
    def on(self, event: str, handler: AsyncHandler) -> Callable[[], None]: ...
    def emit(self, event: str, payload: Any) -> None: ...
    def clear_alarm(self, code: str) -> None: ...
    def _read_all(self) -> dict[str, Any]: ...
    def _read_loop(self) -> None: ...
    def _process_values(self, values: dict[str, Any]) -> None: ...
    def _evaluate_alarm(self, values: dict[str, Any]) -> None: ...
    @property
    def device_id(self): ...
    @property
    def is_connected(self): ...
    @property
    def is_responsive(self): ...
    @property
    def is_protected(self): ...
    @property
    def is_disconnected(self): ...
    @property
    def is_unreachable(self): ...
    @property
    def is_healthy(self): ...
    @property
    def latest_values(self): ...
    @property
    def active_alarms(self): ...
    @property
    def is_running(self): ...
    @property
    def available_actions(self): ...
