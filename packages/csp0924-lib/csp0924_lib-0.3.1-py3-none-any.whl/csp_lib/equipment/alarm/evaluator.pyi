import _abc
import abc
import dataclasses
import enum
from csp_lib.equipment.alarm.definition import AlarmDefinition
from typing import Any, ClassVar

__all__ = ['AlarmEvaluator', 'BitMaskAlarmEvaluator', 'TableAlarmEvaluator', 'ThresholdAlarmEvaluator', 'ThresholdCondition', 'Operator']

class AlarmEvaluator(abc.ABC):
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    def evaluate(self, value: Any) -> dict[str, bool]: ...
    def get_alarms(self) -> list[AlarmDefinition]: ...

class BitMaskAlarmEvaluator(AlarmEvaluator):
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def evaluate(self, value: Any) -> dict[str, bool]: ...
    def get_alarms(self) -> list[AlarmDefinition]: ...
    def __replace__(self, **changes): ...
    def __init__(self, point_name: str, bit_alarms: dict[int, AlarmDefinition]) -> None: ...
    def __eq__(self, other) -> bool: ...

class TableAlarmEvaluator(AlarmEvaluator):
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def evaluate(self, value: Any) -> dict[str, bool]: ...
    def get_alarms(self) -> list[AlarmDefinition]: ...
    def __replace__(self, **changes): ...
    def __init__(self, point_name: str, table: dict[int, AlarmDefinition]) -> None: ...
    def __eq__(self, other) -> bool: ...

class Operator(enum.Enum):
    _new_member_: ClassVar[builtin_function_or_method] = ...
    _use_args_: ClassVar[bool] = ...
    _member_names_: ClassVar[list] = ...
    _member_map_: ClassVar[dict] = ...
    _value2member_map_: ClassVar[dict] = ...
    _hashable_values_: ClassVar[list] = ...
    _unhashable_values_: ClassVar[list] = ...
    _unhashable_values_map_: ClassVar[dict] = ...
    _member_type_: ClassVar[type[object]] = ...
    _value_repr_: ClassVar[None] = ...
    GT: ClassVar[Operator] = ...
    GE: ClassVar[Operator] = ...
    LT: ClassVar[Operator] = ...
    LE: ClassVar[Operator] = ...
    EQ: ClassVar[Operator] = ...
    NE: ClassVar[Operator] = ...
    @staticmethod
    def _generate_next_value_(name, start, count, last_values): ...
    @classmethod
    def __init__(cls, value) -> None: ...

class ThresholdCondition:
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def check(self, actual_value: float) -> bool: ...
    def __replace__(self, **changes): ...
    def __hash__(self) -> int: ...
    def __init__(self, alarm: AlarmDefinition, operator: Operator, value: float) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __setattr__(self, name, value): ...
    def __delattr__(self, name): ...

class ThresholdAlarmEvaluator(AlarmEvaluator):
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def evaluate(self, value: Any) -> dict[str, bool]: ...
    def get_alarms(self) -> list[AlarmDefinition]: ...
    def __replace__(self, **changes): ...
    def __init__(self, point_name: str, conditions: list[ThresholdCondition]) -> None: ...
    def __eq__(self, other) -> bool: ...
