import dataclasses
from typing import Any, ClassVar, Literal

__all__ = ['CANField', 'CANFrameParser']

class CANField:
    resolution: ClassVar[float] = ...
    offset: ClassVar[float] = ...
    decimals: ClassVar[None] = ...
    as_int: ClassVar[bool] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def __replace__(self, **changes): ...
    def __hash__(self) -> int: ...
    def __init__(self, name: str, start_bit: int, bit_length: int, resolution: float = ..., offset: float = ..., decimals: int | None = ..., as_int: bool = ...) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __setattr__(self, name, value): ...
    def __delattr__(self, name): ...

class CANFrameParser:
    remove_source: ClassVar[bool] = ...
    byte_order: ClassVar[str] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def process(self, values: dict[str, Any]) -> dict[str, Any]: ...
    def _to_bytes(self, raw: int) -> bytes: ...
    def _extract_field(self, raw_bytes: bytes, field: CANField) -> int | float | None: ...
    def __replace__(self, **changes): ...
    def __init__(self, source_name: str, fields: list[CANField], remove_source: bool = ..., byte_order: Literal['big', 'little'] = ...) -> None: ...
    def __eq__(self, other) -> bool: ...
