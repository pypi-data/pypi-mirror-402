import _abc
import dataclasses
import typing
from typing import Any, Callable, ClassVar

__all__ = ['AggregatorPipeline', 'CoilToBitmaskAggregator', 'ComputedValueAggregator']

class Processor(typing.Protocol):
    __parameters__: ClassVar[tuple] = ...
    _is_protocol: ClassVar[bool] = ...
    __abstractmethods__: ClassVar[frozenset] = ...
    _abc_impl: ClassVar[_abc._abc_data] = ...
    __protocol_attrs__: ClassVar[set] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def process(self, values: dict[str, Any]) -> dict[str, Any]: ...
    @classmethod
    def __subclasshook__(cls, other): ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __replace__(self, **changes): ...
    def __eq__(self, other) -> bool: ...

class CoilToBitmaskAggregator:
    remove_source: ClassVar[bool] = ...
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def process(self, values: dict[str, Any]) -> dict[str, Any]: ...
    def __replace__(self, **changes): ...
    def __init__(self, output_name: str, coil_names: list[str], remove_source: bool = ...) -> None: ...
    def __eq__(self, other) -> bool: ...

class ComputedValueAggregator:
    __dataclass_params__: ClassVar[dataclasses._DataclassParams] = ...
    __dataclass_fields__: ClassVar[dict] = ...
    __match_args__: ClassVar[tuple] = ...
    def process(self, values: dict[str, Any]) -> dict[str, Any]: ...
    def __replace__(self, **changes): ...
    def __init__(self, output_name: str, source_names: list[str], compute_fn: Callable[..., Any]) -> None: ...
    def __eq__(self, other) -> bool: ...

class AggregatorPipeline:
    def __init__(self, aggregators: list[Processor]) -> None: ...
    def process(self, values: dict[str, Any]) -> dict[str, Any]: ...
