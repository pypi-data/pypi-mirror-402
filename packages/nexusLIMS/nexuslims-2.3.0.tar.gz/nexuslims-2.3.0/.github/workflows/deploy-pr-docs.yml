name: Deploy PR Documentation

on:
  # Trigger after the test workflow completes for PRs
  workflow_run:
    workflows: ["Unit Tests"]
    types:
      - completed
    branches-ignore:
      - main # Don't trigger for main branch (that's handled by deploy-docs.yml)

jobs:
  check-conditions:
    name: Check Deployment Conditions
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Check if deployment should proceed
        id: check
        run: |
          echo "Workflow run conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo "Workflow run event: ${{ github.event.workflow_run.event }}"

          if [[ "${{ github.event.workflow_run.conclusion }}" == "success" && \
                "${{ github.event.workflow_run.event }}" == "pull_request" ]]; then
            echo "âœ… Conditions met: will deploy PR documentation"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "â­ï¸  Skipping deployment:"
            if [[ "${{ github.event.workflow_run.conclusion }}" != "success" ]]; then
              echo "  - Tests did not pass (conclusion: ${{ github.event.workflow_run.conclusion }})"
            fi
            if [[ "${{ github.event.workflow_run.event }}" != "pull_request" ]]; then
              echo "  - Not triggered by a pull request (event: ${{ github.event.workflow_run.event }})"
            fi
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  deploy-pr-docs:
    name: Build/Deploy PR Docs
    needs: check-conditions
    if: needs.check-conditions.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to push to gh-pages branch
      pull-requests: write # Required to comment on PR
    steps:
      - name: Get PR number
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            // Get the PR number from the workflow_run event
            const pullRequests = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`,
            });

            if (pullRequests.data.length === 0) {
              console.log('No open PR found for this branch - skipping deployment');
              core.setOutput('number', '');
              core.setOutput('found', 'false');
              return;
            }

            const prNumber = pullRequests.data[0].number;
            core.setOutput('number', prNumber);
            core.setOutput('found', 'true');
            console.log(`Found PR #${prNumber}`);

      - name: Checkout gh-pages branch
        # Start from gh-pages to preserve existing PR previews
        if: steps.pr.outputs.found == 'true'
        uses: actions/checkout@v4
        with:
          ref: gh-pages

      - name: Checkout PR code
        # Checkout the PR source code into pr-source subdirectory
        if: steps.pr.outputs.found == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}
          path: pr-source

      - name: Set up uv
        if: steps.pr.outputs.found == 'true'
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: true

      - name: Set up Python
        if: steps.pr.outputs.found == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        if: steps.pr.outputs.found == 'true'
        run: |
          cd pr-source
          uv sync

      - name: Download coverage artifact from test workflow
        # Download coverage artifact from the workflow_run that triggered this
        if: steps.pr.outputs.found == 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.payload.workflow_run.id,
            });

            const coverageArtifact = artifacts.data.artifacts.find(
              artifact => artifact.name === 'coverage-html-3.11'
            );

            if (coverageArtifact) {
              const download = await github.rest.actions.downloadArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: coverageArtifact.id,
                archive_format: 'zip',
              });

              const fs = require('fs');
              fs.mkdirSync('pr-source/tests', { recursive: true });
              fs.writeFileSync('coverage.zip', Buffer.from(download.data));

              // Extract the zip file
              const { execSync } = require('child_process');
              execSync('unzip -q coverage.zip -d pr-source/tests/coverage');
            }

      - name: Generate switcher.json
        # Create version switcher for PyData Sphinx Theme navigation
        if: steps.pr.outputs.found == 'true'
        env:
          GITHUB_EVENT_NAME: pull_request
          GITHUB_REF: refs/pull/${{ steps.pr.outputs.number }}/merge
        run: |
          cd pr-source
          echo "ðŸ” Generating switcher.json for PR #${{ steps.pr.outputs.number }}..."
          echo "Environment:"
          echo "  GITHUB_EVENT_NAME: ${GITHUB_EVENT_NAME}"
          echo "  GITHUB_REF: ${GITHUB_REF}"
          echo "  PR_NUMBER: ${{ steps.pr.outputs.number }}"
          echo ""

          echo "Running generate_switcher_json.py..."
          python scripts/generate_switcher_json.py

          echo ""
          echo "âœ… Generated switcher.json:"
          cat docs/_static/switcher.json
          echo ""
          echo "ðŸ“Š switcher.json contains $(jq 'length' docs/_static/switcher.json) entries"

      - name: Build documentation
        # Build Sphinx documentation for this PR (includes switcher.json from above)
        if: steps.pr.outputs.found == 'true'
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
        run: |
          cd pr-source
          ./scripts/build_docs.sh

      - name: Deploy to PR preview directory
        # Create/update pr-{NUMBER} directory in gh-pages with docs and coverage
        if: steps.pr.outputs.found == 'true'
        run: |
          # Stash any local changes (e.g., uv.lock modifications from uv sync)
          git stash --include-untracked || true

          PR_NUMBER=${{ steps.pr.outputs.number }}
          rm -rf "pr-${PR_NUMBER}"
          mkdir -p "pr-${PR_NUMBER}"
          rsync -avr pr-source/_build/ "pr-${PR_NUMBER}/"

          if [ -d "pr-source/tests/coverage" ]; then
            mkdir -p "pr-${PR_NUMBER}/coverage"
            rsync -avr pr-source/tests/coverage/ "pr-${PR_NUMBER}/coverage/"
          fi

          # Update switcher.json in all version directories
          # This ensures all versions have the latest switcher with all available versions
          echo "Updating switcher.json in all version directories..."
          for dir in */; do
            # Only process directories that look like version directories (X.Y.Z, latest, pr-N)
            # Skip: _build, docs, nexusLIMS (source code), and hidden dirs
            if [ -d "$dir" ] && [ "$dir" != "_build/" ] && \
               [ "$dir" != "docs/" ] && [ "$dir" != "nexusLIMS/" ] && \
               [[ ! "$dir" =~ ^\. ]]; then
              # Check if this looks like a docs directory (has _static subdirectory)
              dir_clean="${dir%/}"
              if [ -d "$dir_clean/_static" ]; then
                mkdir -p "$dir_clean/_static"
                cp pr-source/docs/_static/switcher.json "$dir_clean/_static/switcher.json"
                echo "  Updated switcher.json in $dir"
              fi
            fi
          done

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Clean up temporary pr-source directory to prevent accidental commits
          rm -rf pr-source

          # Commit and push - add all changes in documentation directories
          git add -A "pr-${PR_NUMBER}/" 2>/dev/null || true
          git add -A latest/ 2>/dev/null || true
          git add -A [0-9]*/ 2>/dev/null || true
          git add -A stable/ 2>/dev/null || true
          # Note: We only add the specific pr-${PR_NUMBER} directory above.
          # Do NOT use "pr-*/" pattern as it would also match the temporary "pr-source/" checkout directory.
          git commit -m "Deploy docs preview for PR #${PR_NUMBER} and update switcher.json" || echo "No changes to commit"

          # debugging
          git status
          git diff

          git pull --rebase origin gh-pages
          git push origin gh-pages
          echo "âœ… Documentation preview deployed!"
          echo "ðŸ”— View at: https://datasophos.github.io/NexusLIMS/pr-${PR_NUMBER}/"

      - name: Comment on PR
        # Post a comment with links to the deployed preview and coverage
        if: steps.pr.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};
            const baseUrl = `https://${context.repo.owner}.github.io/${context.repo.repo}`;
            const commentBody = `## ðŸ“š Documentation Preview

            The documentation for this PR has been deployed to:
            - **Docs**: ${baseUrl}/pr-${prNumber}/
            - **Coverage**: ${baseUrl}/pr-${prNumber}/coverage/

            _This preview will be updated on each push to this PR._`;

            // Find existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Documentation Preview')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody,
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody,
              });
            }
