def generate_streamlit_app(model_path, schema, output_path="demo_app.py"):
    """
    Generates a professional Streamlit app that automatically adapts to
    Light or Dark mode (fixing the 'invisible text' issue).
    """
    
    code = f'''
import streamlit as st
import pickle
import pandas as pd
import numpy as np
import time

# --------------------------------------------------
# 1. PAGE CONFIGURATION
# --------------------------------------------------
st.set_page_config(
    page_title="ezyml Enterprise Demo",
    page_icon="‚ö°",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --------------------------------------------------
# 2. CUSTOM CSS STYLING (THEME SAFE)
# --------------------------------------------------
# We removed the forced background colors to ensure text remains visible
# regardless of whether the user is in Light or Dark mode.
st.markdown("""
    <style>
    /* Style the tabs to look pill-shaped but keep default colors */
    .stTabs [data-baseweb="tab-list"] {{
        gap: 8px;
    }}
    .stTabs [data-baseweb="tab"] {{
        height: 50px;
        white-space: pre-wrap;
        border-radius: 4px;
        padding-top: 10px;
        padding-bottom: 10px;
    }}
    
    /* Custom button styling - stands out in both modes */
    div.stButton > button {{
        width: 100%;
        font-weight: bold;
        padding: 0.5rem 1rem;
        border-radius: 8px;
    }}
    
    /* Remove default top padding for a cleaner look */
    .block-container {{
        padding-top: 2rem;
    footer {{visibility: hidden;}}
    </style>
""", unsafe_allow_html=True)

# --------------------------------------------------
# 3. LOAD MODEL
# --------------------------------------------------
@st.cache_resource
def load_model():
    try:
        with open("{model_path}"=model.pkl, "rb") as f:
            return pickle.load(f)
    except FileNotFoundError:
        st.error("Model file not found. Please check path.")
        return None

model = load_model()

# --------------------------------------------------
# 4. SIDEBAR
# --------------------------------------------------
with st.sidebar:
    st.title("üéõÔ∏è ezyml Control")
    st.divider()
    
    st.subheader("Model Status")
    if model:
        st.success("üü¢ Model Active")
    else:
        st.error("üî¥ Model Offline")
        
    st.info("""
    **Mode Selection:**
    1. **Single Predict**: Test one sample.
    2. **Batch Predict**: Upload CSV.
    """)
    
    st.divider()
    st.caption("Generated by ezyml v2.0")

# --------------------------------------------------
# 5. MAIN CONTENT
# --------------------------------------------------

st.title("‚ö° Model Inference Dashboard")
st.markdown("Enter values below to generate predictions.")

tab1, tab2 = st.tabs(["üéØ Single Prediction", "üìÇ Batch Processing"])

# --- TAB 1: SINGLE PREDICTION ---
with tab1:
    st.write("") # Spacer
    
    # Create a container with a border for better visual separation
    with st.container(border=True):
        st.subheader("Configure Inputs")
        
        with st.form("prediction_form"):
            inputs = {{}}
            
            # Use 3 columns for better layout
            cols = st.columns(3)
            schema_keys = {list(schema.keys())}
            
            for i, feature in enumerate(schema_keys):
                col = cols[i % 3]
                with col:
                    inputs[feature] = st.number_input(
                        label=feature,
                        value=0.0,
                        format="%.2f"
                    )
            
            st.markdown("---")
            
            # Using type="primary" makes the button colorful automatically
            submitted = st.form_submit_button("Run Prediction üöÄ", type="primary")

    if submitted and model:
        # Spinner instead of manual progress bar for cleaner UI
        with st.spinner("Calculating..."):
            time.sleep(0.5) # clear visual cue
            
            X = pd.DataFrame([inputs])
            try:
                prediction = model.predict(X)[0]
                
                # Result Container
                st.write("")
                st.subheader("Results")
                
                res_col1, res_col2 = st.columns([1, 1])
                
                with res_col1:
                    # Using a container with border makes it pop
                    with st.container(border=True):
                        st.metric(
                            label="Predicted Value", 
                            value=str(prediction), 
                            delta="Success"
                        )
                
                # Confidence (Optional)
                if hasattr(model, "predict_proba"):
                    with res_col2:
                        try:
                            probs = model.predict_proba(X)[0]
                            confidence = np.max(probs) * 100
                            with st.container(border=True):
                                st.metric(label="Confidence", value=f"{{confidence:.1f}}%")
                                st.progress(int(confidence))
                        except:
                            pass
                
            except Exception as e:
                st.error(f"Prediction Error: {{e}}")

# --- TAB 2: BATCH PREDICTION ---
with tab2:
    st.write("")
    with st.container(border=True):
        st.subheader("Bulk Inference")
        
        uploaded_file = st.file_uploader("Upload CSV", type=["csv"])
        
        if uploaded_file:
            df = pd.read_csv(uploaded_file)
            st.dataframe(df.head(), use_container_width=True)
            
            if st.button("Process Batch", type="primary"):
                with st.spinner("Processing..."):
                    try:
                        preds = model.predict(df)
                        df['Prediction'] = preds
                        
                        st.success("Done!")
                        st.dataframe(df, use_container_width=True)
                        
                        csv = df.to_csv(index=False).encode('utf-8')
                        st.download_button(
                            "‚¨áÔ∏è Download CSV",
                            csv,
                            "predictions.csv",
                            "text/csv"
                        )
                    except Exception as e:
                        st.error(f"Batch failed: {{e}}")
'''
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(code)

    return output_path