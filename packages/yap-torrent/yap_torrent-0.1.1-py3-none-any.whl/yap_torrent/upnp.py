# https://mattscodecave.com/posts/using-python-and-upnp-to-forward-a-port.html

import http.client
import logging
import re
import socket
import urllib.error
import urllib.parse
import urllib.request
from urllib.parse import urlparse
from xml.dom.minidom import Document
from xml.dom.minidom import parseString

logger = logging.getLogger(__name__)

SSDP_ADDR = "239.255.255.250"
SSDP_PORT = 1900
SSDP_MX = 2
SSDP_ST = "urn:schemas-upnp-org:device:InternetGatewayDevice:1"

SSDP_REQUEST = (f"M-SEARCH * HTTP/1.1\r\n"
                f"HOST: {SSDP_ADDR}:{SSDP_PORT}\r\n"
                f"MAN: \"ssdp:discover\"\r\n"
                f"MX: {SSDP_MX}\r\n"
                f"ST: {SSDP_ST}\r\n"
                f"\r\n")


def get_my_ext_ip() -> str:
	services = ["https://ipecho.net/plain", 'https://ident.me']
	for service in services:
		try:
			external_ip = urllib.request.urlopen(service, timeout=1).read().decode('utf8')
			logger.info(f"get external ip {external_ip} from {service}")
			return external_ip
		except Exception as e:
			logger.info(f"external ip service {service} is not available: {e}")

	return ""


def discover(ip):
	logger.info(f'sending ssdp:discover to {ip}')
	with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
		try:
			sock.bind((ip, 0))
			sock.sendto(SSDP_REQUEST.encode('ASCII'), ("239.255.255.250", 1900))
			sock.settimeout(SSDP_MX)
			while True:
				data, addr = sock.recvfrom(1024)
				logger.info("got response from: \r  %s\r  %s", addr, data)
				parsed = re.findall(r'(?P<name>.*?): (?P<value>.*?)\r\n', str(data, 'utf-8'))
				location = [x for x in parsed if x[0].lower() == "location"]
				router_path = location[0][1]
				logger.info("found upnp service on: %s", router_path)
				return router_path
		except socket.error as ex:
			logger.info("got exception: %s", ex)

	return None


def _get_wanip_path(upnp_url):
	# get the profile xml file and read it into a variable
	directory = urllib.request.urlopen(upnp_url).read()

	# create a DOM object that represents the `directory` document
	dom = parseString(directory)

	# find all 'serviceType' elements
	service_types = dom.getElementsByTagName('serviceType')

	# iterate over service_types until we get either WANIPConnection
	# this should also check for WANPPPConnection, which, if I remember correctly
	# exposed a similar SOAP interface on ADSL routers.
	for service in service_types:
		# I'm using the fact that a 'serviceType' element contains a single text node, who's data can
		# be accessed by the 'data' attribute.
		# When I find the right element, I take a step-up into its parent and search for 'controlURL'
		if service.childNodes[0].data.find('WANIPConnection') > 0:
			path = service.parentNode.getElementsByTagName('controlURL')[0].childNodes[0].data
			return path


def open_port(service_url, external_port, internal_client, internal_port=None, protocol='TCP', duration=0,
              description=None, enabled=1):
	wan_ip_path = _get_wanip_path(service_url)
	parsed_url = urlparse(service_url)

	if internal_port is None:
		internal_port = external_port

	if description is None:
		description = 'generated by port-forward.py'

	if not enabled:
		duration = 1

	doc = Document()

	# create the envelope element and set its attributes
	envelope = doc.createElementNS('', 's:Envelope')
	envelope.setAttribute('xmlns:s', 'http://schemas.xmlsoap.org/soap/envelope/')
	envelope.setAttribute('s:encodingStyle', 'http://schemas.xmlsoap.org/soap/encoding/')

	# create the body element
	body = doc.createElementNS('', 's:Body')

	# create the function element and set its attribute
	fn = doc.createElementNS('', 'u:AddPortMapping')
	fn.setAttribute('xmlns:u', 'urn:schemas-upnp-org:service:WANIPConnection:1')

	# set up the argument element names and values
	# using a list of tuples to preserve order
	arguments = [('NewRemoteHost', ""),  # unused - but required
	             ('NewExternalPort', external_port),  # specify port on router
	             ('NewProtocol', protocol),  # specify protocol
	             ('NewInternalPort', internal_port),  # specify port on internal host
	             ('NewInternalClient', internal_client),  # specify IP of internal host
	             ('NewEnabled', enabled),  # turn mapping ON
	             ('NewPortMappingDescription', description),  # add a description
	             ('NewLeaseDuration', duration)]  # how long should it be opened?

	# NewEnabled should be 1 by default, but better supply it.
	# NewPortMappingDescription Can be anything you want, even an empty string.
	# NewLeaseDuration can be any integer BUT some UPnP devices don't support it,
	# so set it to 0 for better compatibility.

	# iterate over arguments, create nodes, create text nodes,
	# append text nodes to nodes, and finally add the ready product
	for k, v in arguments:
		tmp_node = doc.createElement(k)
		tmp_node.appendChild(doc.createTextNode(str(v)))
		fn.appendChild(tmp_node)

	# append function element to the body element
	body.appendChild(fn)

	# append body element to envelope element
	envelope.appendChild(body)

	# append envelope element to document, making it the root element
	doc.appendChild(envelope)

	# our tree is ready, convert it to a string
	pure_xml = doc.toxml()

	# use the object returned by urlparse.urlparse to get the hostname and port
	conn = http.client.HTTPConnection(parsed_url.hostname, parsed_url.port)

	# use the path of WANIPConnection (or WANPPPConnection) to target that service,
	# insert the xml payload,
	# add two headers to make tell the server what we're sending exactly.
	conn.request('POST', wan_ip_path, pure_xml,
	             {'SOAPAction': '"urn:schemas-upnp-org:service:WANIPConnection:1#AddPortMapping"',
	              'Content-Type': 'text/xml'})

	# wait for a response
	resp = conn.getresponse()

	return resp.status, resp.read()


def get_my_ip(router_ip=None) -> str:
	if router_ip is None:
		router_ip = "8.8.8.8"  # default route
	with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
		try:
			s.connect((router_ip, 80))
			return s.getsockname()[0]
		except socket.error as ex:
			logger.error(ex)
	return "127.0.0.1"
