{"version":3,"file":"4358.a5562a0cc0f36443.js","sources":["webpack://insteon-frontend/./homeassistant-frontend/src/components/ha-sortable.ts","webpack://insteon-frontend/./homeassistant-frontend/src/panels/config/helpers/forms/ha-input_select-form.ts","webpack://insteon-frontend/./node_modules/lit-html/src/directives/repeat.ts"],"sourcesContent":["/* eslint-disable lit/prefer-static-styles */\nimport type { PropertyValues } from \"lit\";\nimport { html, LitElement, nothing } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport type { SortableEvent } from \"sortablejs\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport type { SortableInstance } from \"../resources/sortable\";\n\ndeclare global {\n  interface HASSDomEvents {\n    \"item-moved\": {\n      oldIndex: number;\n      newIndex: number;\n    };\n    \"item-added\": {\n      index: number;\n      data: any;\n      item: any;\n    };\n    \"item-removed\": {\n      index: number;\n    };\n    \"drag-start\": undefined;\n    \"drag-end\": undefined;\n  }\n}\n\nexport type HaSortableOptions = Omit<\n  SortableInstance.SortableOptions,\n  \"onStart\" | \"onChoose\" | \"onEnd\" | \"onUpdate\" | \"onAdd\" | \"onRemove\"\n>;\n\n@customElement(\"ha-sortable\")\nexport class HaSortable extends LitElement {\n  private _sortable?: SortableInstance;\n\n  @property({ type: Boolean })\n  public disabled = false;\n\n  @property({ type: Boolean, attribute: \"no-style\" })\n  public noStyle = false;\n\n  @property({ type: String, attribute: \"draggable-selector\" })\n  public draggableSelector?: string;\n\n  @property({ type: String, attribute: \"handle-selector\" })\n  public handleSelector?: string;\n\n  /**\n   * Selectors that do not lead to dragging (String or Function)\n   * https://github.com/SortableJS/Sortable?tab=readme-ov-file#filter-option\n   * */\n  @property({ type: String, attribute: \"filter\" })\n  public filter?: string;\n\n  @property({ type: String })\n  public group?: string | SortableInstance.GroupOptions;\n\n  @property({ type: Boolean, attribute: \"invert-swap\" })\n  public invertSwap = false;\n\n  @property({ attribute: false })\n  public options?: HaSortableOptions;\n\n  @property({ type: Boolean })\n  public rollback = true;\n\n  protected updated(changedProperties: PropertyValues<this>) {\n    if (changedProperties.has(\"disabled\")) {\n      if (this.disabled) {\n        this._destroySortable();\n      } else {\n        this._createSortable();\n      }\n    }\n  }\n\n  // Workaround for connectedCallback just after disconnectedCallback (when dragging sortable with sortable children)\n  private _shouldBeDestroy = false;\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this._shouldBeDestroy = true;\n    setTimeout(() => {\n      if (this._shouldBeDestroy) {\n        this._destroySortable();\n        this._shouldBeDestroy = false;\n      }\n    }, 1);\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    this._shouldBeDestroy = false;\n    if (this.hasUpdated && !this.disabled) {\n      this._createSortable();\n    }\n  }\n\n  protected createRenderRoot() {\n    return this;\n  }\n\n  protected render() {\n    if (this.noStyle) return nothing;\n    return html`\n      <style>\n        .sortable-fallback {\n          display: none !important;\n        }\n\n        .sortable-ghost {\n          box-shadow: 0 0 0 2px var(--primary-color);\n          background: rgba(var(--rgb-primary-color), 0.25);\n          border-radius: var(--ha-border-radius-sm);\n          opacity: 0.4;\n        }\n\n        .sortable-drag {\n          border-radius: var(--ha-border-radius-sm);\n          opacity: 1;\n          background: var(--card-background-color);\n          box-shadow: 0px 4px 8px 3px #00000026;\n          cursor: grabbing;\n        }\n      </style>\n    `;\n  }\n\n  private async _createSortable() {\n    if (this._sortable) return;\n    const container = this.children[0] as HTMLElement | undefined;\n\n    if (!container) return;\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const Sortable = (await import(\"../resources/sortable\")).default;\n\n    const options: SortableInstance.Options = {\n      scroll: true,\n      // Force the autoscroll fallback because it works better than the native one\n      forceAutoScrollFallback: true,\n      scrollSpeed: 20,\n      animation: 150,\n      ...this.options,\n      onChoose: this._handleChoose,\n      onStart: this._handleStart,\n      onEnd: this._handleEnd,\n      onUpdate: this._handleUpdate,\n      onAdd: this._handleAdd,\n      onRemove: this._handleRemove,\n    };\n\n    if (this.draggableSelector) {\n      options.draggable = this.draggableSelector;\n    }\n    if (this.handleSelector) {\n      options.handle = this.handleSelector;\n    }\n    if (this.invertSwap !== undefined) {\n      options.invertSwap = this.invertSwap;\n    }\n    if (this.group) {\n      options.group = this.group;\n    }\n    if (this.filter) {\n      options.filter = this.filter;\n    }\n\n    this._sortable = new Sortable(container, options);\n  }\n\n  private _handleUpdate = (evt) => {\n    fireEvent(this, \"item-moved\", {\n      newIndex: evt.newIndex,\n      oldIndex: evt.oldIndex,\n    });\n  };\n\n  private _handleAdd = (evt) => {\n    fireEvent(this, \"item-added\", {\n      index: evt.newIndex,\n      data: evt.item.sortableData,\n      item: evt.item,\n    });\n  };\n\n  private _handleRemove = (evt) => {\n    fireEvent(this, \"item-removed\", { index: evt.oldIndex });\n  };\n\n  private _handleEnd = async (evt) => {\n    fireEvent(this, \"drag-end\");\n    // put back in original location\n    if (this.rollback && (evt.item as any).placeholder) {\n      (evt.item as any).placeholder.replaceWith(evt.item);\n      delete (evt.item as any).placeholder;\n    }\n  };\n\n  private _handleStart = () => {\n    fireEvent(this, \"drag-start\");\n  };\n\n  private _handleChoose = (evt: SortableEvent) => {\n    if (!this.rollback) return;\n    (evt.item as any).placeholder = document.createComment(\"sort-placeholder\");\n    evt.item.after((evt.item as any).placeholder);\n  };\n\n  private _destroySortable() {\n    if (!this._sortable) return;\n    this._sortable.destroy();\n    this._sortable = undefined;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-sortable\": HaSortable;\n  }\n}\n","import { mdiDelete, mdiDragHorizontalVariant } from \"@mdi/js\";\nimport type { CSSResultGroup } from \"lit\";\nimport { LitElement, css, html, nothing } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { repeat } from \"lit/directives/repeat\";\nimport { fireEvent } from \"../../../../common/dom/fire_event\";\nimport \"../../../../components/ha-button\";\nimport \"../../../../components/ha-icon-button\";\nimport \"../../../../components/ha-icon-picker\";\nimport \"../../../../components/ha-list\";\nimport \"../../../../components/ha-list-item\";\nimport \"../../../../components/ha-sortable\";\nimport \"../../../../components/ha-textfield\";\nimport type { HaTextField } from \"../../../../components/ha-textfield\";\nimport type { InputSelect } from \"../../../../data/input_select\";\nimport { showConfirmationDialog } from \"../../../../dialogs/generic/show-dialog-box\";\nimport { haStyle } from \"../../../../resources/styles\";\nimport type { HomeAssistant } from \"../../../../types\";\n\n@customElement(\"ha-input_select-form\")\nclass HaInputSelectForm extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean }) public new = false;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  private _item?: InputSelect;\n\n  @state() private _name!: string;\n\n  @state() private _icon!: string;\n\n  @state() private _options: string[] = [];\n\n  @query(\"#option_input\", true) private _optionInput?: HaTextField;\n\n  private _optionMoved(ev: CustomEvent): void {\n    ev.stopPropagation();\n    const { oldIndex, newIndex } = ev.detail;\n    const options = this._options.concat();\n    const option = options.splice(oldIndex, 1)[0];\n    options.splice(newIndex, 0, option);\n\n    fireEvent(this, \"value-changed\", {\n      value: { ...this._item, options },\n    });\n  }\n\n  set item(item: InputSelect) {\n    this._item = item;\n    if (item) {\n      this._name = item.name || \"\";\n      this._icon = item.icon || \"\";\n      this._options = item.options || [];\n    } else {\n      this._name = \"\";\n      this._icon = \"\";\n      this._options = [];\n    }\n  }\n\n  public focus() {\n    this.updateComplete.then(() =>\n      (\n        this.shadowRoot?.querySelector(\"[dialogInitialFocus]\") as HTMLElement\n      )?.focus()\n    );\n  }\n\n  protected render() {\n    if (!this.hass) {\n      return nothing;\n    }\n\n    return html`\n      <div class=\"form\">\n        <ha-textfield\n          dialogInitialFocus\n          autoValidate\n          required\n          .validationMessage=${this.hass!.localize(\n            \"ui.dialogs.helper_settings.required_error_msg\"\n          )}\n          .value=${this._name}\n          .label=${this.hass!.localize(\n            \"ui.dialogs.helper_settings.generic.name\"\n          )}\n          .configValue=${\"name\"}\n          @input=${this._valueChanged}\n          .disabled=${this.disabled}\n        ></ha-textfield>\n        <ha-icon-picker\n          .hass=${this.hass}\n          .value=${this._icon}\n          .configValue=${\"icon\"}\n          @value-changed=${this._valueChanged}\n          .label=${this.hass!.localize(\n            \"ui.dialogs.helper_settings.generic.icon\"\n          )}\n          .disabled=${this.disabled}\n        ></ha-icon-picker>\n        <div class=\"header\">\n          ${this.hass!.localize(\n            \"ui.dialogs.helper_settings.input_select.options\"\n          )}:\n        </div>\n        <ha-sortable\n          @item-moved=${this._optionMoved}\n          handle-selector=\".handle\"\n          .disabled=${this.disabled}\n        >\n          <ha-list class=\"options\">\n            ${this._options.length\n              ? repeat(\n                  this._options,\n                  (option) => option,\n                  (option, index) => html`\n                    <ha-list-item class=\"option\" hasMeta>\n                      <div class=\"optioncontent\">\n                        <div class=\"handle\">\n                          <ha-svg-icon\n                            .path=${mdiDragHorizontalVariant}\n                          ></ha-svg-icon>\n                        </div>\n                        ${option}\n                      </div>\n                      <ha-icon-button\n                        slot=\"meta\"\n                        .index=${index}\n                        .label=${this.hass.localize(\n                          \"ui.dialogs.helper_settings.input_select.remove_option\"\n                        )}\n                        @click=${this._removeOption}\n                        .disabled=${this.disabled}\n                        .path=${mdiDelete}\n                      ></ha-icon-button>\n                    </ha-list-item>\n                  `\n                )\n              : html`\n                  <ha-list-item noninteractive>\n                    ${this.hass!.localize(\n                      \"ui.dialogs.helper_settings.input_select.no_options\"\n                    )}\n                  </ha-list-item>\n                `}\n          </ha-list>\n        </ha-sortable>\n        <div class=\"layout horizontal center\">\n          <ha-textfield\n            class=\"flex-auto\"\n            id=\"option_input\"\n            .label=${this.hass!.localize(\n              \"ui.dialogs.helper_settings.input_select.add_option\"\n            )}\n            @keydown=${this._handleKeyAdd}\n            .disabled=${this.disabled}\n          ></ha-textfield>\n          <ha-button\n            size=\"small\"\n            appearance=\"plain\"\n            @click=${this._addOption}\n            .disabled=${this.disabled}\n            >${this.hass!.localize(\n              \"ui.dialogs.helper_settings.input_select.add\"\n            )}</ha-button\n          >\n        </div>\n      </div>\n    `;\n  }\n\n  private _handleKeyAdd(ev: KeyboardEvent) {\n    ev.stopPropagation();\n    if (ev.key !== \"Enter\") {\n      return;\n    }\n    this._addOption();\n  }\n\n  private _addOption() {\n    const input = this._optionInput;\n    if (!input?.value) {\n      return;\n    }\n    fireEvent(this, \"value-changed\", {\n      value: { ...this._item, options: [...this._options, input.value] },\n    });\n    input.value = \"\";\n  }\n\n  private async _removeOption(ev: Event) {\n    const index = (ev.target as any).index;\n    if (\n      !(await showConfirmationDialog(this, {\n        title: this.hass.localize(\n          \"ui.dialogs.helper_settings.input_select.confirm_delete.delete\"\n        ),\n        text: this.hass.localize(\n          \"ui.dialogs.helper_settings.input_select.confirm_delete.prompt\"\n        ),\n        destructive: true,\n      }))\n    ) {\n      return;\n    }\n    const options = [...this._options];\n    options.splice(index, 1);\n    fireEvent(this, \"value-changed\", {\n      value: { ...this._item, options },\n    });\n  }\n\n  private _valueChanged(ev: CustomEvent) {\n    if (!this.new && !this._item) {\n      return;\n    }\n    ev.stopPropagation();\n    const configValue = (ev.target as any).configValue;\n    const value = ev.detail?.value || (ev.target as any).value;\n\n    if (this[`_${configValue}`] === value) {\n      return;\n    }\n    const newValue = { ...this._item };\n    if (!value) {\n      delete newValue[configValue];\n    } else {\n      newValue[configValue] = value;\n    }\n    fireEvent(this, \"value-changed\", {\n      value: newValue,\n    });\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      haStyle,\n      css`\n        .form {\n          color: var(--primary-text-color);\n        }\n        .option {\n          border: 1px solid var(--divider-color);\n          border-radius: var(--ha-border-radius-sm);\n          margin-top: 4px;\n          --mdc-icon-button-size: 24px;\n          --mdc-ripple-color: transparent;\n          --mdc-list-side-padding: 16px;\n          cursor: default;\n          background-color: var(--card-background-color);\n        }\n        ha-textfield {\n          display: block;\n          margin-bottom: 8px;\n        }\n        #option_input {\n          margin-top: 8px;\n        }\n        .header {\n          margin-top: 8px;\n          margin-bottom: 8px;\n        }\n        .handle {\n          cursor: move; /* fallback if grab cursor is unsupported */\n          cursor: grab;\n          padding-right: 12px;\n          padding-inline-end: 12px;\n          padding-inline-start: initial;\n        }\n        .handle ha-svg-icon {\n          pointer-events: none;\n          height: 24px;\n        }\n        .optioncontent {\n          display: flex;\n          align-items: center;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-input_select-form\": HaInputSelectForm;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart, noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\nimport {\n  insertPart,\n  getCommittedValue,\n  removePart,\n  setCommittedValue,\n  setChildPartValue,\n} from '../directive-helpers.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map<unknown, number>();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\nclass RepeatDirective extends Directive {\n  private _itemKeys?: unknown[];\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error('repeat() can only be used in text expressions');\n    }\n  }\n\n  private _getValuesAndKeys<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    let keyFn: KeyFn<T> | undefined;\n    if (template === undefined) {\n      template = keyFnOrTemplate;\n    } else if (keyFnOrTemplate !== undefined) {\n      keyFn = keyFnOrTemplate as KeyFn<T>;\n    }\n    const keys = [];\n    const values = [];\n    let index = 0;\n    for (const item of items) {\n      keys[index] = keyFn ? keyFn(item, index) : index;\n      values[index] = template!(item, index);\n      index++;\n    }\n    return {\n      values,\n      keys,\n    };\n  }\n\n  render<T>(items: Iterable<T>, template: ItemTemplate<T>): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;\n  }\n\n  override update<T>(\n    containerPart: ChildPart,\n    [items, keyFnOrTemplate, template]: [\n      Iterable<T>,\n      KeyFn<T> | ItemTemplate<T>,\n      ItemTemplate<T>,\n    ]\n  ) {\n    // Old part & key lists are retrieved from the last update (which may\n    // be primed by hydration)\n    const oldParts = getCommittedValue(\n      containerPart\n    ) as Array<ChildPart | null>;\n    const {values: newValues, keys: newKeys} = this._getValuesAndKeys(\n      items,\n      keyFnOrTemplate,\n      template\n    );\n\n    // We check that oldParts, the committed value, is an Array as an\n    // indicator that the previous value came from a repeat() call. If\n    // oldParts is not an Array then this is the first render and we return\n    // an array for lit-html's array handling to render, and remember the\n    // keys.\n    if (!Array.isArray(oldParts)) {\n      this._itemKeys = newKeys;\n      return newValues;\n    }\n\n    // In SSR hydration it's possible for oldParts to be an array but for us\n    // to not have item keys because the update() hasn't run yet. We set the\n    // keys to an empty array. This will cause all oldKey/newKey comparisons\n    // to fail and execution to fall to the last nested brach below which\n    // reuses the oldPart.\n    const oldKeys = (this._itemKeys ??= []);\n\n    // New part list will be built up as we go (either reused from\n    // old parts or created for new keys in this update). This is\n    // saved in the above cache at the end of the update.\n    const newParts: ChildPart[] = [];\n\n    // Maps from key to index for current and previous update; these\n    // are generated lazily only when needed as a performance\n    // optimization, since they are only required for multiple\n    // non-contiguous changes in the list, which are less common.\n    let newKeyToIndexMap!: Map<unknown, number>;\n    let oldKeyToIndexMap!: Map<unknown, number>;\n\n    // Head and tail pointers to old parts and new values\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let newHead = 0;\n    let newTail = newValues.length - 1;\n\n    // Overview of O(n) reconciliation algorithm (general approach\n    // based on ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new values (and\n    //   arrays of their respective keys), head/tail pointers into\n    //   each, and we build up the new list of parts by updating\n    //   (and when needed, moving) old parts or creating new ones.\n    //   The initial scenario might look like this (for brevity of\n    //   the diagrams, the numbers in the array reflect keys\n    //   associated with the old parts or new values, although keys\n    //   and parts/values are actually stored in parallel arrays\n    //   indexed using the same head/tail pointers):\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n    //                                      item order\n    //      newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating,\n    //   swapping, or removing parts at the head/tail locations\n    //   until neither head nor tail can move.\n    //\n    // * Example below: keys at head pointers match, so update old\n    //   part 0 in-place (no need to move it) and record part 0 in\n    //   the `newParts` list. The last thing we do is advance the\n    //   `oldHead` and `newHead` pointers (will be reflected in the\n    //   next diagram).\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //      newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail\n    //   pointers do, so update part 6 in place (no need to move\n    //   it), and record part 6 in the `newParts` list. Last,\n    //   advance the `oldTail` and `oldHead` pointers.\n    //\n    //         oldHead v              v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n    //                                      & newTail\n    //         newHead ^              ^ newTail\n    //\n    // * If neither head nor tail match; next check if one of the\n    //   old head/tail items was removed. We first need to generate\n    //   the reverse map of new keys to index (`newKeyToIndexMap`),\n    //   which is done once lazily as a performance optimization,\n    //   since we only hit this case if multiple non-contiguous\n    //   changes were made. Note that for contiguous removal\n    //   anywhere in the list, the head and tails would advance\n    //   from either end and pass each other before we get to this\n    //   case and removals would be handled in the final while loop\n    //   without needing to generate the map.\n    //\n    // * Example below: The key at `oldTail` was removed (no longer\n    //   in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //         oldHead v           v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n    //         newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to\n    //   either new or moved items; if a new key is in the previous\n    //   \"old key to old index\" map, move the old part to the new\n    //   location, otherwise create and insert a new part. Note\n    //   that when moving an old part we null its position in the\n    //   oldParts array if it lies between the head and tail so we\n    //   know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither\n    //   were removed; so find the `newHead` key in the\n    //   `oldKeyToIndexMap`, and move that old part's DOM into the\n    //   next head position (before `oldParts[oldHead]`). Last,\n    //   null the part in the `oldPart` array since it was\n    //   somewhere in the remaining oldParts still to be scanned\n    //   (between the head and tail pointers) so that we know to\n    //   skip that old part on future iterations.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n    //                                      newHead\n    //         newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part\n    //   inserted at the head pointer is inserted before the\n    //   current `oldParts[oldHead]`, and a part inserted at the\n    //   tail pointer is inserted before `newParts[newTail+1]`. The\n    //   seeming asymmetry lies in the fact that new parts are\n    //   moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail\n    //   pointer are new parts.\n    //\n    // * We always restart back from the top of the algorithm,\n    //   allowing matching and simple updates in place to\n    //   continue...\n    //\n    // * Example below: the head pointers once again match, so\n    //   simply update part 1 and record it in the `newParts`\n    //   array.  Last, advance both head pointers.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //            newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of\n    //   being stuck (the final else clause in the code below) are\n    //   marked with null, so we always advance old pointers over\n    //   these so we're comparing the next actual old value on\n    //   either end.\n    //\n    // * Example below: `oldHead` is null (already placed in\n    //   newParts), so advance `oldHead`.\n    //\n    //            oldHead v     v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //               newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they\n    //   are moved from head to tail or tail to head, since they\n    //   will be outside the pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head\n    //   key, so the part at the `oldTail` position and move its\n    //   DOM to the new head position (before `oldParts[oldHead]`).\n    //   Last, advance `oldTail` and `newHead` pointers.\n    //\n    //               oldHead v  v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n    //                                     advance oldTail & newHead\n    //               newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the\n    //   old head part in place, and advance the `oldHead` and\n    //   `newHead` pointers.\n    //\n    //               oldHead v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n    //                                      newHead\n    //                  newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all\n    //   we have left is additions (if old list exhausted) or\n    //   removals (if new list exhausted). Those are handled in the\n    //   final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done\n    //   with the main loop.  Create the remaining part and insert\n    //   it at the new head position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //                     newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not\n    //   important to the algorithm, as long as the null checks\n    //   come first (to ensure we're always working on valid old\n    //   parts) and that the final else clause comes last (since\n    //   that's where the expensive moves occur). The order of\n    //   remaining clauses is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * Note, we could calculate the longest\n    //   increasing subsequence (LIS) of old items in new position,\n    //   and only move those not in the LIS set. However that costs\n    //   O(nlogn) time and adds a bit more code, and only helps\n    //   make rare types of mutations require fewer moves. The\n    //   above handles removes, adds, reversal, swaps, and single\n    //   moves of contiguous items in linear time, in the minimum\n    //   number of moves. As the number of multiple moves where LIS\n    //   might help approaches a random shuffle, the LIS\n    //   optimization becomes less helpful, so it seems not worth\n    //   the code at this point. Could reconsider if a compelling\n    //   case arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldParts[oldHead] === null) {\n        // `null` means old part at head has already been used\n        // below; skip\n        oldHead++;\n      } else if (oldParts[oldTail] === null) {\n        // `null` means old part at tail has already been used\n        // below; skip\n        oldTail--;\n      } else if (oldKeys[oldHead] === newKeys[newHead]) {\n        // Old head matches new head; update in place\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newHead]\n        );\n        oldHead++;\n        newHead++;\n      } else if (oldKeys[oldTail] === newKeys[newTail]) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newTail]\n        );\n        oldTail--;\n        newTail--;\n      } else if (oldKeys[oldHead] === newKeys[newTail]) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newTail]\n        );\n        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]!);\n        oldHead++;\n        newTail--;\n      } else if (oldKeys[oldTail] === newKeys[newHead]) {\n        // Old tail matches new head; update and move to new head\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newHead]\n        );\n        insertPart(containerPart, oldParts[oldHead]!, oldParts[oldTail]!);\n        oldTail--;\n        newHead++;\n      } else {\n        if (newKeyToIndexMap === undefined) {\n          // Lazily generate key-to-index maps, used for removals &\n          // moves below\n          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n        }\n        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n          // Old head is no longer in new list; remove\n          removePart(oldParts[oldHead]!);\n          oldHead++;\n        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n          // Old tail is no longer in new list; remove\n          removePart(oldParts[oldTail]!);\n          oldTail--;\n        } else {\n          // Any mismatches at this point are due to additions or\n          // moves; see if we have an old part we can reuse and move\n          // into place\n          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n          if (oldPart === null) {\n            // No old part for this value; create a new one and\n            // insert it\n            const newPart = insertPart(containerPart, oldParts[oldHead]!);\n            setChildPartValue(newPart, newValues[newHead]);\n            newParts[newHead] = newPart;\n          } else {\n            // Reuse old part\n            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);\n            insertPart(containerPart, oldParts[oldHead]!, oldPart);\n            // This marks the old part as having been used, so that\n            // it will be skipped in the first two checks above\n            oldParts[oldIndex as number] = null;\n          }\n          newHead++;\n        }\n      }\n    }\n    // Add parts for any remaining new values\n    while (newHead <= newTail) {\n      // For all remaining additions, we insert before last new\n      // tail, since old pointers are no longer valid\n      const newPart = insertPart(containerPart, newParts[newTail + 1]);\n      setChildPartValue(newPart, newValues[newHead]);\n      newParts[newHead++] = newPart;\n    }\n    // Remove any remaining unused old parts\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    }\n\n    // Save order of new parts for next round\n    this._itemKeys = newKeys;\n    // Directly set part value, bypassing it's dirty-checking\n    setCommittedValue(containerPart, newParts);\n    return noChange;\n  }\n}\n\nexport interface RepeatDirectiveFn {\n  <T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ): unknown;\n  <T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;\n  <T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): unknown;\n}\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.\n *\n * ```js\n * html`\n *   <ol>\n *     ${repeat(this.items, (item) => item.id, (item, index) => {\n *       return html`<li>${index}: ${item.name}</li>`;\n *     })}\n *   </ol>\n * `\n * ```\n *\n * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive(RepeatDirective) as RepeatDirectiveFn;\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {RepeatDirective};\n"],"names":["HaSortable","_LitElement","_this","_callSuper","concat","args","disabled","noStyle","invertSwap","rollback","_shouldBeDestroy","_handleUpdate","evt","fireEvent","_assertThisInitialized","newIndex","oldIndex","_handleAdd","index","data","item","sortableData","_handleRemove","_handleEnd","_ref","_asyncToGenerator","_regenerator","m","_callee","w","_context","n","placeholder","replaceWith","a","_x","apply","arguments","_handleStart","_handleChoose","document","createComment","after","changedProperties","has","this","_destroySortable","_createSortable","key","value","_this2","_superPropGet","setTimeout","hasUpdated","nothing","html","_templateObject","_taggedTemplateLiteral","_createSortable2","_callee2","container","Sortable","options","_context2","_sortable","children","v","default","Object","assign","scroll","forceAutoScrollFallback","scrollSpeed","animation","onChoose","onStart","onEnd","onUpdate","onAdd","onRemove","draggableSelector","draggable","handleSelector","handle","undefined","group","filter","destroy","LitElement","type","Boolean","attribute","String","HaInputSelectForm","new","_options","ev","stopPropagation","_ev$detail","detail","option","splice","_item","set","_name","name","_icon","icon","updateComplete","then","_this2$shadowRoot","shadowRoot","querySelector","focus","_this3","hass","localize","_valueChanged","_optionMoved","length","repeat","_templateObject2","_removeOption","_templateObject3","_handleKeyAdd","_addOption","input","_optionInput","_toConsumableArray","_removeOption2","target","showConfirmationDialog","title","text","destructive","_ev$detail2","configValue","newValue","get","haStyle","css","_templateObject4","r","Map","l","s","t","e","c","_t","_class","_classCallCheck","Error","_inherits","_createClass","_step","o","i","_iterator","_createForOfIteratorHelper","done","err","f","values","keys","dt","_this$ut","_ref2","_slicedToArray","d","_this$dt","p","Array","isArray","ut","y","h","x","j","k","u"],"mappings":"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"}