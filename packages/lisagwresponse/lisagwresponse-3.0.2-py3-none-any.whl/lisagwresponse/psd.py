"""
Utility PSD functions.

This module provides functions for stationary noise generation.

Authors:
    Quentin Baghi <quentin.baghi@protonmail.com>
    Jean-Baptiste Bayle <j2b.bayle@gmail.com>
"""

from typing import Callable

import numpy as np

#: Type for a stochastic generator.
#:
#: It is a function of the sampling frequency [Hz] and simulation size
#: [samples], and returns a numpy array of the generated noise time series.
Generator = Callable[[float, int], np.ndarray]


def white_generator(psd: float) -> Generator:
    """Returns a Gaussian white-noise generator.

    Args:
        psd: One-sided power spectral density [X^2/Hz].

    Returns:
        A stochastic generator, as a function of the sampling frequency [Hz] and
        simulation size [samples].
    """

    def generator(fs: float, size: int) -> np.ndarray:
        stddev = np.sqrt(psd * fs / 2)
        return np.random.normal(scale=stddev, size=size)

    return generator


def ifft_generator(
    spectrum: Callable[[np.ndarray], np.ndarray], *, zero_avg: bool = True
) -> Generator:
    """Returns a stochastic generator that uses the IFFT method.

    Args:
        spectrum: One-sided power spectral density function [X^2/Hz].
        zero_avg: Sets the average of the time series data generated by the stochastic
            generator to 0. If True, the generator will set ``spectrum(0) = 0``, which
            is important if ``spectrum`` diverges towards `f = 0`. If False, the
            generate will evaluate ``spectrum(0)``, and the user needs to assure this
            is a finite quantity.

    Returns:
        A stochastic generator, as a function of the sampling frequency [Hz] and
        simulation size [samples].
    """

    def generator(fs: float, size: int) -> np.ndarray:
        fs = float(fs)
        size = int(size)

        # Define half of the size
        # If size is odd-valued, add 1 sample to work with even sizes
        half_size = size // 2
        if size % 2:
            half_size += 1  # half_size * 2 = size + 1 for odd size

        # Get real Fourier frequencies (all positive-valued)
        f = np.fft.rfftfreq(2 * half_size, 1.0 / fs)
        psd_sqrt = np.zeros_like(f)
        if zero_avg:
            psd_sqrt[1:] = np.sqrt(spectrum(f[1:]))
        else:
            psd_sqrt[:] = np.sqrt(spectrum(f))

        # Real part of the noise FFT: Gaussian random variable
        noise_tf_real = np.sqrt(0.5) * psd_sqrt * np.random.normal(size=half_size + 1)

        # Imaginary part of the noise FFT: Gaussian random variable
        noise_tf_im = np.sqrt(0.5) * psd_sqrt * np.random.normal(size=half_size + 1)

        # The time-domain signal is real, so the Fourier transform must be real at
        # f = 0 and f = f[half_size] = Nyquist frequency
        noise_tf_real[0] *= np.sqrt(2)
        noise_tf_real[half_size] *= np.sqrt(2)
        noise_tf_im[0] = 0
        noise_tf_im[half_size] = 0

        # Create the NoiseTF complex numbers for positive frequencies
        noise_tf = noise_tf_real + 1j * noise_tf_im

        # Normalize for continous inverse Fourier transform
        noise_tf *= np.sqrt(half_size * fs)

        # Convert to time domain using real-valued IFFT. Return slice with requested
        # size: for odd-valued original size, this drops final sample.
        return np.fft.irfft(noise_tf, n=size)

    return generator
