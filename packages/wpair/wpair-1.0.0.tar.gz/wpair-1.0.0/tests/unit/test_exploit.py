"""Unit tests for exploit engine."""

import pytest
from wpair.core.exploit import (
    FastPairExploit,
    ExploitStrategy,
    ExploitResult,
    DeviceQuirks
)
from wpair.bluetooth.classic_adapter import ClassicBluetoothAdapter


def test_exploit_initialization():
    """Test exploit engine can be initialized."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    assert exploit is not None
    assert not exploit._is_running


def test_build_kbp_request_raw():
    """Test building RAW_KBP request."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    address = "AA:BB:CC:DD:EE:FF"
    request = exploit._build_kbp_request(address, ExploitStrategy.RAW_KBP)

    assert len(request) == 16
    assert request[0] == 0x00  # Message type
    assert request[1] == 0x11  # Flags
    assert request[2:8] == bytes.fromhex("AABBCCDDEEFF")
    assert len(request[8:16]) == 8  # Salt


def test_build_kbp_request_with_seeker():
    """Test building RAW_WITH_SEEKER request."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    address = "11:22:33:44:55:66"
    request = exploit._build_kbp_request(address, ExploitStrategy.RAW_WITH_SEEKER)

    assert len(request) == 16
    assert request[0] == 0x00
    assert request[1] == 0x10  # Different flags


def test_build_kbp_request_extended():
    """Test building EXTENDED_RESPONSE request."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    address = "AA:BB:CC:DD:EE:FF"
    request = exploit._build_kbp_request(address, ExploitStrategy.EXTENDED_RESPONSE)

    assert len(request) == 16
    assert request[1] == 0x01  # Extended response flag


def test_build_kbp_request_retroactive():
    """Test building RETROACTIVE request."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    address = "AA:BB:CC:DD:EE:FF"
    request = exploit._build_kbp_request(address, ExploitStrategy.RETROACTIVE)

    assert len(request) == 16
    assert request[1] == 0x90  # Retroactive flag


def test_extract_address():
    """Test MAC address extraction from bytes."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    data = b'\x00\xAA\xBB\xCC\xDD\xEE\xFF\x00'
    addr = exploit._extract_address(data, 1)

    assert addr == "AA:BB:CC:DD:EE:FF"


def test_extract_address_short_data():
    """Test address extraction with insufficient data."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    data = b'\xAA\xBB\xCC'
    addr = exploit._extract_address(data, 0)

    assert addr == "00:00:00:00:00:00"


def test_is_null_address():
    """Test null address detection."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    assert exploit._is_null_address("00:00:00:00:00:00") is True
    assert exploit._is_null_address("FF:FF:FF:FF:FF:FF") is True
    assert exploit._is_null_address("AA:BB:CC:DD:EE:FF") is False


def test_parse_kbp_response_standard():
    """Test parsing standard KBP response format."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    # Type 0x01 (standard response) + MAC address
    data = bytes([0x01]) + bytes.fromhex("AABBCCDDEEFF")

    addr = exploit._parse_kbp_response(data)

    assert addr == "AA:BB:CC:DD:EE:FF"


def test_parse_kbp_response_extended():
    """Test parsing extended KBP response format."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    # Type 0x02 (extended) + flags + count + MAC
    data = bytes([0x02, 0x00, 0x01]) + bytes.fromhex("112233445566")

    addr = exploit._parse_kbp_response(data)

    assert addr == "11:22:33:44:55:66"


def test_parse_kbp_response_brute_force():
    """Test brute-force MAC address scanning."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    # Data without standard format markers, MAC at start
    data = bytes.fromhex("AABBCCDDEEFF") + b'\x00\x00'

    addr = exploit._parse_kbp_response(data)

    # Should find the valid address
    assert addr == "AA:BB:CC:DD:EE:FF"


def test_parse_kbp_response_null_address():
    """Test that null addresses are rejected."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    # Response with all null bytes (no valid MAC)
    data = bytes.fromhex("000000000000000000")

    addr = exploit._parse_kbp_response(data)

    # Should return None since only null addresses found
    assert addr is None


def test_parse_kbp_response_too_short():
    """Test response parsing with insufficient data."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    data = b'\x01\xAA\xBB'  # Only 3 bytes

    addr = exploit._parse_kbp_response(data)

    assert addr is None


def test_get_device_quirks_sony():
    """Test device quirks for Sony devices."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    model_id = bytes.fromhex("CD8256")  # Sony WF-1000XM4
    quirks = exploit._get_device_quirks(model_id)

    assert quirks.needs_extended_response is True
    assert quirks.delay_before_account_key == 1.0


def test_get_device_quirks_jbl():
    """Test device quirks for JBL devices."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    model_id = bytes.fromhex("F52494")  # JBL Tune Buds
    quirks = exploit._get_device_quirks(model_id)

    assert quirks.delay_before_kbp == 0.2


def test_get_device_quirks_unknown():
    """Test device quirks for unknown device."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    model_id = bytes.fromhex("FFFFFF")  # Unknown
    quirks = exploit._get_device_quirks(model_id)

    # Should return default quirks
    assert quirks.needs_extended_response is False
    assert quirks.delay_before_kbp == 0.0


def test_reset_state():
    """Test state reset."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    # Set some state
    exploit.shared_secret = b'test'
    exploit.provider_br_edr_address = "AA:BB:CC:DD:EE:FF"
    exploit.model_id = b'\x00\x11\x22'

    # Reset
    exploit._reset_state()

    assert exploit.shared_secret is None
    assert exploit.provider_br_edr_address is None
    assert exploit.model_id is None


@pytest.mark.asyncio
async def test_exploit_invalid_address():
    """Test exploit with invalid MAC address."""
    adapter = ClassicBluetoothAdapter()
    exploit = FastPairExploit(adapter)

    result = await exploit.exploit("INVALID_ADDRESS")

    assert result.success is False
    assert "Invalid MAC address" in result.message
