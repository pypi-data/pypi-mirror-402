

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: blickfeld/toolkit/services/event_export.proto, blickfeld/toolkit/services/preset.proto, blickfeld/toolkit/services/record.proto
# plugin: python-betterproto
import asyncio
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    Iterator,
    List,
    Optional,
)

import blickfeld_qb2.betterproto as betterproto
import blickfeld_qb2.betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from blickfeld_qb2.betterproto.grpc.grpclib_server import ServiceBase

from .. import (
    config as _config__,
    data as _data__,
)

if TYPE_CHECKING:
    import grpclib.server
    from blickfeld_qb2.betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class EventExportStreamRequest(betterproto.Message):
    """Request for getting a stream of event export messages"""

    event_ids: List[str] = betterproto.string_field(1)
    """The events to be exported"""

    history_replay_range: int = betterproto.uint32_field(2)
    """The capture window around an event for the historical data"""


@dataclass(eq=False, repr=False)
class EventExportStreamResponse(betterproto.Message):
    """Response for getting a stream of event export messages"""

    file: "_data__.File" = betterproto.message_field(1)
    """File of a event export"""


@dataclass(eq=False, repr=False)
class PresetSetRequest(betterproto.Message):
    """Request for setting the preset"""

    preset: "_config__.Preset" = betterproto.message_field(1)
    """Preset data"""


@dataclass(eq=False, repr=False)
class PresetGetResponse(betterproto.Message):
    """Response when getting the preset"""

    preset: "_config__.Preset" = betterproto.message_field(1)
    """Preset data"""


@dataclass(eq=False, repr=False)
class RecordStreamRequest(betterproto.Message):
    """Request for getting a stream of record messages"""

    pass


@dataclass(eq=False, repr=False)
class RecordStreamResponse(betterproto.Message):
    """Response for getting a stream of record messages"""

    file: "_data__.File" = betterproto.message_field(1)
    """File of a recording"""

    data_loss: bool = betterproto.bool_field(2)
    """Indicates that the internal send buffer is full and drops data."""


class EventExport(betterproto.ServiceStub):
    """
    The event export service allows streaming of event export data to a client.
    It requests and combines all the required data into one stream. The data
    consists of the metadata and one or multiple events. Every event consists
    of an event file and multiple foreground, object and state files. A message
    in the stream consists of a file-path and the corresponding data. That
    means that one message represents one file in an event export archive.
    """

    async def async_stream(
        self,
        *,
        event_ids: Optional[List[str]] = None,
        history_replay_range: int = 0,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["EventExportStreamResponse"]:
        """Get all requested events for the event export."""

        event_ids = event_ids or []

        request = EventExportStreamRequest()
        request.event_ids = event_ids
        request.history_replay_range = history_replay_range

        async for response in self._unary_stream(
            "/blickfeld.toolkit.services.EventExport/Stream",
            request,
            EventExportStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def stream(
        self,
        *,
        event_ids: Optional[List[str]] = None,
        history_replay_range: int = 0,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> Iterator["EventExportStreamResponse"]:
        """Get all requested events for the event export."""

        loop = asyncio.get_event_loop()
        ait = self.async_stream(
            event_ids=event_ids,
            history_replay_range=history_replay_range,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj


class Preset(betterproto.ServiceStub):
    """This service provided basic information about the configured preset"""

    async def async_get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "PresetGetResponse":
        """Get the configured preset"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.toolkit.services.Preset/Get",
            request,
            PresetGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "PresetGetResponse":
        """Get the configured preset"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_set(
        self,
        *,
        preset: "_config__.Preset" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set the selected preset"""

        request = PresetSetRequest()
        if preset is not None:
            request.preset = preset

        return await self._unary_unary(
            "/blickfeld.toolkit.services.Preset/Set",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def set(
        self,
        *,
        preset: "_config__.Preset" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set the selected preset"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_set(
                preset=preset,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class Record(betterproto.ServiceStub):
    """
    The record service allows streaming of recording data to a client. It
    requests and combines all the required recording data (metadata, raw,
    states, vtu, pcd) into one stream. A message in the stream consists of a
    file-path and the corresponding data. That means that one message
    represents one file in a recording archive.
    """

    async def async_stream(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["RecordStreamResponse"]:
        """Get a stream of recording data."""

        request = RecordStreamRequest()

        async for response in self._unary_stream(
            "/blickfeld.toolkit.services.Record/Stream",
            request,
            RecordStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def stream(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> Iterator["RecordStreamResponse"]:
        """Get a stream of recording data."""

        loop = asyncio.get_event_loop()
        ait = self.async_stream(
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj
