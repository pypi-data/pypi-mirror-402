

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: blickfeld/percept_processing/data/detected_object.proto, blickfeld/percept_processing/data/disqualification.proto, blickfeld/percept_processing/data/event.proto, blickfeld/percept_processing/data/flag.proto, blickfeld/percept_processing/data/model_classification.proto, blickfeld/percept_processing/data/objects.proto, blickfeld/percept_processing/data/state.proto, blickfeld/percept_processing/data/states.proto, blickfeld/percept_processing/data/vehicle.proto, blickfeld/percept_processing/data/volume_map.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import (
    Dict,
    List,
)

import blickfeld_qb2.betterproto as betterproto
import blickfeld_qb2.betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import numpy as np

from ...base import (
    config as __base_config__,
    geometry as __base_geometry__,
)
from ...core_processing import data as __core_processing_data__
from ...percept_pipeline import config as __percept_pipeline_config__


@dataclass(eq=False, repr=False)
class Flag(betterproto.Message):
    """Flag which contains state combined with a change detection"""

    state: bool = betterproto.bool_field(1)
    """Current state"""

    since_timestamp: int = betterproto.uint64_field(2)
    """Timestamp since when the state did not change"""

    since_duration: int = betterproto.uint64_field(3)
    """Duration of current state"""


@dataclass(eq=False, repr=False)
class ModelClassification(betterproto.Message):
    """
    Classification result of machine learning object classification model.
    """

    predicted_class: "__percept_pipeline_config__.ObjectClass" = (
        betterproto.message_field(1)
    )
    """Predicted class label."""

    confidence_score: float = betterproto.float_field(2)
    """
    Value in the range of [0, 1] which indicates how confident the model is
    about the predicted label.
    """


@dataclass(eq=False, repr=False)
class DetectedObject(betterproto.Message):
    """
    A message representing exactly one object that is detected in the scene.
    """

    pose: "__base_geometry__.Pose" = betterproto.message_field(1)
    """The position and orientation of the object."""

    shape: "__base_geometry__.Shape" = betterproto.message_field(2)
    """The shape representing the object (bounding box)."""

    properties: "DetectedObjectProperties" = betterproto.message_field(3)
    """Properties of the object."""

    point_cloud: "__core_processing_data__.Frame" = betterproto.message_field(4)
    """The point cloud of the object."""

    timestamp: int = betterproto.uint64_field(5)
    """The timestamps when the object is detected for the first time"""

    lifetime: int = betterproto.uint64_field(11)
    """Lifetime of the object"""

    path: List["__base_geometry__.Pose"] = betterproto.message_field(6)
    """The tracked path of the object."""

    visible_to_sensors: List[str] = betterproto.string_field(7)
    """List of sensors which currently detect the object"""

    intruding: "Flag" = betterproto.message_field(8)
    """
    Active when object is currently detected as intruder in a security zone
    """

    intruder: "Flag" = betterproto.message_field(9)
    """Set when object intruded once in a security zone"""

    velocity: "__base_geometry__.Vector3" = betterproto.message_field(13)
    """Track object velocity"""

    geolocation: "__base_config__.Geolocation" = betterproto.message_field(14)
    """
    The geolocation of the object based on the map and the object position.
    Only set when the geolocation is configured in the data source.
    """

    in_zone_uuids: List[str] = betterproto.string_field(15)
    """
    List of object based security zone uuids in which the object is detected.
    """


@dataclass(eq=False, repr=False)
class DetectedObjectProperties(betterproto.Message):
    """Properties of an object."""

    num_points: int = betterproto.uint32_field(2)
    """Number of measurements that belong to the object point cloud."""

    average_intensity: int = betterproto.uint32_field(3)
    """Average intensity of the measurements from the object point cloud."""

    median_reflectivity: int = betterproto.uint32_field(9)
    """Median reflectivity of the measurements from the object point cloud."""

    bounding_box_2_d_surface: float = betterproto.float_field(4)
    """
    Surface area of the largest xz / yz bounding box plane. This is used for
    the simple object size classification.
    """

    confidence: float = betterproto.float_field(5)
    """
    Confidence value   Value in the range of [0, 1] which indicates how
    confident the tracking algorithm is about the detected object.   NOTE: This
    is preliminary implementation and might change its behavior significantly
    in upcoming releases.
    """

    in_background: bool = betterproto.bool_field(6)
    """
    Set when bounding box of object is mostly located within the background /
    reference frame. This is usually an indication for ground or vegetation
    detections.
    """

    track_length: float = betterproto.float_field(7)
    """The estimated track length of an object."""

    size: "__percept_pipeline_config__.ObjectSize" = betterproto.enum_field(
        1, group="classification_type"
    )
    """Object size classification using rule-based methods."""

    model_classification: "ModelClassification" = betterproto.message_field(
        8, group="classification_type"
    )
    """Object classification based on machine learning."""


@dataclass(eq=False, repr=False)
class Disqualification(betterproto.Message):
    """
    A message that contains different types of disqualifications for a sensor.
    """

    fog: bool = betterproto.bool_field(1)
    """Fog was detected in the point cloud."""

    rain: bool = betterproto.bool_field(2)
    """Rain was detected in the point cloud."""


@dataclass(eq=False, repr=False)
class Vehicle(betterproto.Message):
    """
    A message representing exactly one vehicle that is detected in the scene.
    """

    timestamp: int = betterproto.uint64_field(1)
    """Timestamp of creation"""

    position: "__base_geometry__.Vector2" = betterproto.message_field(2)
    """
    The position of the vehicle (in the local coordinate system of the zone).
    NOTE: The y-coordinate gives the front of the vehicle, not its center.
    """

    dimensions: "__base_geometry__.Vector3" = betterproto.message_field(3)
    """
    Dimensions of the vehicle.   NOTE: The height (z-dimension) is measured
    from the ground, not from the bottom of the traffic lane zone.
    """

    velocity: float = betterproto.float_field(4)
    """Velocity of the vehicle (in y-direction)"""

    point_cloud: "__core_processing_data__.Frame" = betterproto.message_field(5)
    """Point cloud"""

    model_classification: "ModelClassification" = betterproto.message_field(6)
    """Vehicle class"""


@dataclass(eq=False, repr=False)
class State(betterproto.Message):
    """
    A state transmits high-level information about the scene or setup. The
    information it contains depends on the configuration. States will get
    calculated on every frame of measurement.
    """

    generator_name: str = betterproto.string_field(8)
    """The name of the entity generating this state"""

    security: "StateSecurity" = betterproto.message_field(5, group="state_type")
    """The security state contains intrusion information of a zone"""

    volume: "StateVolume" = betterproto.message_field(7, group="state_type")
    """Current volume measured in the selected zone"""

    object_based_security: "StateObjectBasedSecurity" = betterproto.message_field(
        9, group="state_type"
    )
    """
    The object based security state contains intrusion information of a zone
    and the objects that trigger the intrusion
    """

    occupancy: "StateOccupancy" = betterproto.message_field(10, group="state_type")
    """The state contains occupation information of a zone"""

    traversal_security: "StateTraversalSecurity" = betterproto.message_field(
        11, group="state_type"
    )
    """The traversal state"""

    traffic_lane: "StateTrafficLane" = betterproto.message_field(12, group="state_type")
    """The state of a traffic lane zone"""


@dataclass(eq=False, repr=False)
class StateObjectBasedSecurity(betterproto.Message):
    """A message containing an alarm state of a zone."""

    alarm: bool = betterproto.bool_field(1)
    """If there is an alarm or not in the zone."""

    objects: Dict[str, "DetectedObject"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    Map of objects where the key is the UUID of the object that triggered the
    alarm.
    """

    intrusion: "Flag" = betterproto.message_field(3)
    """Active intrusion. Can be used as pre-alarm."""

    intrusion_confidence: float = betterproto.float_field(4)
    """
    Confidence that it is a real intrusion.   Calculates a moving average of
    the intrusion state. The moving average window size can be configured with
    the minimum intruding duration parameter.
    """


@dataclass(eq=False, repr=False)
class StateSecurity(betterproto.Message):
    """A message containing an alarm state of a zone."""

    alarm: bool = betterproto.bool_field(1)
    """If there is an alarm or not in the zone."""

    num_detected_points: int = betterproto.uint32_field(2)
    """The current number of lidar points detected in the zone."""

    point_cloud: "__core_processing_data__.Frame" = betterproto.message_field(3)
    """Foreground point cloud inside zone which triggered the alarm."""

    intrusion: "Flag" = betterproto.message_field(4)
    """Active intrusion. Can be used as pre-alarm."""

    intrusion_confidence: float = betterproto.float_field(5)
    """
    Confidence that it is a real intrusion.   Calculates a moving average of
    the intrusion state. The moving average window size can be configured with
    the minimum intruding duration parameter.
    """


@dataclass(eq=False, repr=False)
class StateVolume(betterproto.Message):
    """
    A message containing the volume state of a zone. This is based on one
    volume zone.
    """

    volume: float = betterproto.float_field(1)
    """The current numerical volume of the zone."""

    coverage: float = betterproto.float_field(5)
    """The current zone volume surface coverage"""


@dataclass(eq=False, repr=False)
class StateOccupancy(betterproto.Message):
    """A message containing the occupancy state of a zone."""

    occupied: bool = betterproto.bool_field(1)
    """True if the zone is occupied."""

    num_detected_points: int = betterproto.uint32_field(2)
    """The current number of lidar points detected in the zone."""

    baseline: float = betterproto.float_field(3)
    """Current baseline."""


@dataclass(eq=False, repr=False)
class StateTraversalSecurity(betterproto.Message):
    """A message containing the traversal state of a zone."""

    alarm: bool = betterproto.bool_field(1)
    """The traversal alarm"""

    objects: Dict[str, "DetectedObject"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """The objects which triggered the inbound alarm"""

    intrusion: "Flag" = betterproto.message_field(3)
    """Active traversal"""


@dataclass(eq=False, repr=False)
class StateTrafficLane(betterproto.Message):
    """A message containing the state of a traffic lane zone."""

    vehicles: Dict[str, "Vehicle"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    All vehicles currently inside the zone (in the local coordinate system of
    the zone)
    """


@dataclass(eq=False, repr=False)
class VolumeMap(betterproto.Message):
    """A message containing the volume map of one volume zone."""

    timestamp: int = betterproto.uint64_field(1)
    """Timestamp of the lidar frame in which the volume map was calculated"""

    generator_uuid: str = betterproto.string_field(2)
    """The uuid of the entity generating this state"""

    generator_name: str = betterproto.string_field(3)
    """The name of the entity generating this state"""

    shape: "__base_geometry__.Shape" = betterproto.message_field(4)
    """
    The shape of the volume map, defining the pose and the dimension of the
    volume map in world frame. The shape is similar to the shape of the input
    zone with the following difference: - shape.pose.position:
    (x=zone.pose.position.x, y=zone.pose.position.y, z=0) -
    shape.pose.rotation: (roll=0, pitch=0, yaw=zone.pose.rotation.yaw) -
    shape.box.dimension: (x=zone.box.dimension.x, y=zone.box.dimension.y,z=0)
    """

    tiles: "VolumeMapTiles" = betterproto.message_field(5)
    """
    Volume map 'tiles' as defined in Tiles, providing information for each tile
    in the volume map.
    """

    tile_size: float = betterproto.float_field(6)
    """
    The tile size of the volume map (dimension of one tile in x and y
    direction)
    """

    volume: float = betterproto.float_field(7)
    """The current volume of the zone"""


@dataclass(eq=False, repr=False)
class VolumeMapTiles(betterproto.Message):
    """Tiles of the volume map"""

    length: int = betterproto.uint32_field(1)
    """Number of tiles"""

    index: np.ndarray = betterproto.bytes_field(2, numpy_dtype="(2,)<i2")
    """
    Volume Map Tile Index X (Int16) and Y (Int16) (can be negative and
    positive) The indices of Volume Tiles are expressed w.r.t the Volume Map
    coordinate system. The tile with index (0,0) will contain the points from
    [0, tile_size), [0, tile_size). That means that (0,0,0) of the Volume Map
    frame does not coincide with the center of the tile with index (0,0) but
    with the crossing of the 4 tiles [(0,0), (0, -1,), (-1,-1), (-1,0)]. Type:
    (Int16, Int16)
    """

    height: np.ndarray = betterproto.bytes_field(3, numpy_dtype="<f4")
    """Height per tile, ordered ascending Type: Float32"""

    std_deviation: np.ndarray = betterproto.bytes_field(4, numpy_dtype="<f4")
    """Standard Deviation per tile Type: Float32"""

    number_points: np.ndarray = betterproto.bytes_field(5, numpy_dtype="<u2")
    """Number Points per tile Type: UInt16"""


@dataclass(eq=False, repr=False)
class Event(betterproto.Message):
    """
    Event which is generated based on continuous zone state.   In contrast to a
    state, an event is emitted only for changes. Thus, an event is often
    directly actionable.
    """

    timestamp: int = betterproto.uint64_field(1)
    """Unix timestamp of event"""

    security_intrusion_started: "EventSecurityIntrusionStarted" = (
        betterproto.message_field(2, group="type")
    )
    """Security: Intrusion started"""

    security_intrusion_ended: "EventSecurityIntrusionEnded" = betterproto.message_field(
        3, group="type"
    )
    """Security: Intrusion ended"""

    security_zone_intrusion_started: "EventSecurityZoneIntrusionStarted" = (
        betterproto.message_field(4, group="type")
    )
    """Security: Zone intrusion started"""

    security_zone_intrusion_ended: "EventSecurityZoneIntrusionEnded" = (
        betterproto.message_field(5, group="type")
    )
    """Security: Zone intrusion ended"""

    disqualification_fog_detected: "EventDisqualificationFog" = (
        betterproto.message_field(6, group="type")
    )
    """Disqualification: Fog detected"""

    disqualification_fog_stopped: "EventDisqualificationFog" = (
        betterproto.message_field(7, group="type")
    )
    """Disqualification: Fog not detected anymore"""

    traffic_vehicle_detected: "EventTrafficVehicleDetected" = betterproto.message_field(
        8, group="type"
    )
    """Traffic: Vehicle detected upon leaving a lane zone"""

    disqualification_rain_detected: "EventDisqualificationRain" = (
        betterproto.message_field(9, group="type")
    )
    """Disqualification: Rain detected"""

    disqualification_rain_stopped: "EventDisqualificationRain" = (
        betterproto.message_field(10, group="type")
    )
    """Disqualification: Rain not detected anymore"""


@dataclass(eq=False, repr=False)
class EventSecurity(betterproto.Message):
    """Container for security-related events"""

    pass


@dataclass(eq=False, repr=False)
class EventSecurityIntrusionStarted(betterproto.Message):
    """An intrusion started in one or multiple security zones."""

    pass


@dataclass(eq=False, repr=False)
class EventSecurityIntrusionEnded(betterproto.Message):
    """An intrusion ended."""

    started_event_id: str = betterproto.string_field(1)
    """ID of the IntrusionStarted event."""

    duration: float = betterproto.float_field(2)
    """Duration of the intrusion event."""


@dataclass(eq=False, repr=False)
class EventSecurityZoneIntrusionStarted(betterproto.Message):
    """An intrusion started in a security zone."""

    zone_uuid: str = betterproto.string_field(1)
    """UUID of the security zone."""

    state: "State" = betterproto.message_field(2)
    """Snapshot of the zone state."""

    disqualification: "Disqualification" = betterproto.message_field(3)
    """Disqualification in the scene during the zone intrusion."""


@dataclass(eq=False, repr=False)
class EventSecurityZoneIntrusionEnded(betterproto.Message):
    """An intrusion of a security zone ended."""

    zone_uuid: str = betterproto.string_field(1)
    """UUID of the security zone."""

    started_event_id: str = betterproto.string_field(2)
    """ID of the ZoneIntrusionStarted event."""

    duration: float = betterproto.float_field(3)
    """Duration of the intrusion event."""


@dataclass(eq=False, repr=False)
class EventTraffic(betterproto.Message):
    """Container for traffic-related events"""

    pass


@dataclass(eq=False, repr=False)
class EventTrafficVehicleDetected(betterproto.Message):
    """A vehicle was detected upon leaving a zone"""

    zone_uuid: str = betterproto.string_field(1)
    """UUID of the traffic lane zone."""

    vehicle: "Vehicle" = betterproto.message_field(2)
    """
    The detected vehicle (in the local coordinate system of the traffic lane
    zone)
    """

    id: str = betterproto.string_field(3)
    """The id of the detected vehicle"""

    disqualification: "Disqualification" = betterproto.message_field(4)
    """Disqualification in the scene during the traffic event."""


@dataclass(eq=False, repr=False)
class EventDisqualification(betterproto.Message):
    """Container for disqualification-related events"""

    pass


@dataclass(eq=False, repr=False)
class EventDisqualificationFog(betterproto.Message):
    """Fog was detected in the point cloud."""

    pass


@dataclass(eq=False, repr=False)
class EventDisqualificationRain(betterproto.Message):
    """Rain was detected in the point cloud."""

    pass


@dataclass(eq=False, repr=False)
class Objects(betterproto.Message):
    """
    A message that contains a map of objects. An object contains the
    information regarding the detected object by the system.
    """

    timestamp: int = betterproto.uint64_field(1)
    """The timestamp of the measurement(s) used to compute the objects."""

    objects: Dict[str, "DetectedObject"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    Map of objects where the key is the UUID of the object. These objects
    should contain the point cloud of each object.
    """


@dataclass(eq=False, repr=False)
class States(betterproto.Message):
    """
    A message that contains a map of states. A state is an information
    generated by the system based on the select zone type or device. For
    example, a state can contain information about the volume or the intrusion
    in the zone.
    """

    timestamp: int = betterproto.uint64_field(1)
    """The timestamp of the measurement(s) used to compute the states."""

    states: Dict[str, "State"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """Map of states where the key is the generator UUID of the state."""
