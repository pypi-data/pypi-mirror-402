

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: blickfeld/percept_processing/services/event.proto, blickfeld/percept_processing/services/health.proto, blickfeld/percept_processing/services/history.proto, blickfeld/percept_processing/services/objects.proto, blickfeld/percept_processing/services/point_cloud.proto, blickfeld/percept_processing/services/states.proto, blickfeld/percept_processing/services/volume_map.proto
# plugin: python-betterproto
import asyncio
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    Iterator,
    Optional,
)

import blickfeld_qb2.betterproto as betterproto
import blickfeld_qb2.betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from blickfeld_qb2.betterproto.grpc.grpclib_server import ServiceBase

from ...base import geometry as __base_geometry__
from ...core_processing import data as __core_processing_data__
from ...percept_pipeline import data as __percept_pipeline_data__
from .. import data as _data__

if TYPE_CHECKING:
    import grpclib.server
    from blickfeld_qb2.betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class EventStreamRequest(betterproto.Message):
    """
    Request for stream method   NOTE: Only a limited amount of events is
    persisted.
    """

    id: str = betterproto.string_field(1)
    """Identifier from which the stream should start."""

    reverse: bool = betterproto.bool_field(2)
    """
    Stream events in reverse. This fetches events from persistent database.
    The events are emitted in batches. When no stream response is returned, no
    more events are available.
    """


@dataclass(eq=False, repr=False)
class EventStreamResponse(betterproto.Message):
    """Response to stream method"""

    id: str = betterproto.string_field(1)
    """
    Unique identifier of event.   The ID has the format: $timestamp-$revision.
    $timestamp is a monotonic counter in seconds. $revision is usually 0 but
    incremented when there a multiple events per second.
    """

    event: "_data__.Event" = betterproto.message_field(2)
    """Event payload."""


@dataclass(eq=False, repr=False)
class EventGetRequest(betterproto.Message):
    """Request for Get method"""

    id: str = betterproto.string_field(1)
    """
    Identifier of the event; see EventStreamRequest and EventStreamResponse for
    more details
    """


@dataclass(eq=False, repr=False)
class EventGetResponse(betterproto.Message):
    """Response to Get method"""

    event: "_data__.Event" = betterproto.message_field(2)
    """Event payload"""


@dataclass(eq=False, repr=False)
class HealthWatchResponse(betterproto.Message):
    """
    A response for getting a stream of health messages about the pipeline
    """

    health: "__percept_pipeline_data__.Health" = betterproto.message_field(1)
    """
    The current health message with information about the state of the pipeline
    """


@dataclass(eq=False, repr=False)
class HealthGetResponse(betterproto.Message):
    """A response for getting an health message about the pipeline"""

    health: "__percept_pipeline_data__.Health" = betterproto.message_field(1)
    """
    The current health message with information about the state of the pipeline
    """


@dataclass(eq=False, repr=False)
class HistoryStreamRangeRequest(betterproto.Message):
    """Request for stream range method"""

    start_id: str = betterproto.string_field(1)
    """ID where the stream should start"""

    end_id: str = betterproto.string_field(2)
    """ID where the stream should stop"""


@dataclass(eq=False, repr=False)
class HistoryStreamRangeResponse(betterproto.Message):
    """Response for stream range method"""

    objects: "_data__.Objects" = betterproto.message_field(1)
    """Historical objects"""

    states: "_data__.States" = betterproto.message_field(2)
    """Historical states"""

    foreground: "__core_processing_data__.Frame" = betterproto.message_field(3)
    """Historical foreground point cloud"""


@dataclass(eq=False, repr=False)
class ObjectsStreamRequest(betterproto.Message):
    """Request message for objects stream"""

    untracked: bool = betterproto.bool_field(1)
    """Fetch object list without tracking"""


@dataclass(eq=False, repr=False)
class ObjectsStreamResponse(betterproto.Message):
    """
    A response for getting a stream of objects messages from the running
    pipeline
    """

    objects: "_data__.Objects" = betterproto.message_field(1)
    """The current objects detected in the scene."""


@dataclass(eq=False, repr=False)
class PointCloudStreamRequest(betterproto.Message):
    """
    A request to receive a stream of point cloud messages. Different point
    clouds can be streamed depending on the set fields: - combined point cloud
    (the full point cloud of all the available devices combined) in the map
    coordinate system - the foreground of the combined point cloud in the map
    coordinate system - the complete raw point cloud coming from one device,
    but only in map coordinate system.
    """

    point_cloud_type: "__percept_pipeline_data__.PointCloudType" = (
        betterproto.enum_field(1)
    )
    """The type of point cloud to stream"""

    coordinate_system: "__percept_pipeline_data__.CoordinateSystem" = (
        betterproto.enum_field(2)
    )
    """
    The coordinate system the point cloud should be expressed in (local or
    transformed/map)
    """

    fqdn: str = betterproto.string_field(3, group="point_cloud_source")
    """fqdn of the data source to get the point cloud from"""

    crop: "__base_geometry__.Shape" = betterproto.message_field(5)
    """If set, point cloud is cropped to given shape"""


@dataclass(eq=False, repr=False)
class PointCloudStreamResponse(betterproto.Message):
    """A response for getting a stream of point cloud messages"""

    point_cloud: "__core_processing_data__.Frame" = betterproto.message_field(1)
    """The required point cloud, based on the fields set in the request"""


@dataclass(eq=False, repr=False)
class StatesStreamResponse(betterproto.Message):
    """
    A response for getting a stream of states messages from the running
    pipeline
    """

    states: "_data__.States" = betterproto.message_field(1)
    """The current states with the information detected in the scene."""


@dataclass(eq=False, repr=False)
class VolumeMapStreamRequest(betterproto.Message):
    """A request to receive a stream of state list messages"""

    zone_uuid: str = betterproto.string_field(2)
    """Volume zone uuid"""


@dataclass(eq=False, repr=False)
class VolumeMapStreamResponse(betterproto.Message):
    """
    A response for getting a stream of volume map messages from the running
    pipeline
    """

    volume_map: "_data__.VolumeMap" = betterproto.message_field(1)
    """The current volume map of the requested zone"""


class Event(betterproto.ServiceStub):
    """Service for actionable events"""

    async def async_stream(
        self,
        *,
        id: str = "",
        reverse: bool = False,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["EventStreamResponse"]:
        """A method to get a stream of events."""

        request = EventStreamRequest()
        request.id = id
        request.reverse = reverse

        async for response in self._unary_stream(
            "/blickfeld.percept_processing.services.Event/Stream",
            request,
            EventStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def stream(
        self,
        *,
        id: str = "",
        reverse: bool = False,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> Iterator["EventStreamResponse"]:
        """A method to get a stream of events."""

        loop = asyncio.get_event_loop()
        ait = self.async_stream(
            id=id,
            reverse=reverse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj

    async def async_get(
        self,
        *,
        id: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EventGetResponse":
        """Method to get one Event by its id"""

        request = EventGetRequest()
        request.id = id

        return await self._unary_unary(
            "/blickfeld.percept_processing.services.Event/Get",
            request,
            EventGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        *,
        id: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "EventGetResponse":
        """Method to get one Event by its id"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                id=id,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class Health(betterproto.ServiceStub):
    """
    An RPC service to request information about the state of the pipeline and
    of the module.
    """

    async def async_watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["HealthWatchResponse"]:
        """
        A method to get a stream of health messages, containing information
        about the state of the pipeline
        """

        request = betterproto_lib_google_protobuf.Empty()

        async for response in self._unary_stream(
            "/blickfeld.percept_processing.services.Health/Watch",
            request,
            HealthWatchResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> Iterator["HealthWatchResponse"]:
        """
        A method to get a stream of health messages, containing information
        about the state of the pipeline
        """

        loop = asyncio.get_event_loop()
        ait = self.async_watch(
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj

    async def async_get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "HealthGetResponse":
        """
        A method to get one health message, containing information about the
        state of the pipeline
        """

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.percept_processing.services.Health/Get",
            request,
            HealthGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "HealthGetResponse":
        """
        A method to get one health message, containing information about the
        state of the pipeline
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class History(betterproto.ServiceStub):
    """
    The history service provides historical data. The data is captured event-
    based e.g. when an intrusion occurs. The capture window is +/- 10 seconds
    around the event. The data is intended for event analysis and fine tuning
    of config.   [NOTE] The data is stored in volatile memory thus it is not
    persisted over a power reset of the device. Additionally, only a limited
    amount is kept.
    """

    async def async_stream_range(
        self,
        *,
        start_id: str = "",
        end_id: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["HistoryStreamRangeResponse"]:
        """
        Stream historical data in the given id range.   Raises a NOT_FOUND
        error when no historical data in the given range is available.
        """

        request = HistoryStreamRangeRequest()
        request.start_id = start_id
        request.end_id = end_id

        async for response in self._unary_stream(
            "/blickfeld.percept_processing.services.History/StreamRange",
            request,
            HistoryStreamRangeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def stream_range(
        self,
        *,
        start_id: str = "",
        end_id: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> Iterator["HistoryStreamRangeResponse"]:
        """
        Stream historical data in the given id range.   Raises a NOT_FOUND
        error when no historical data in the given range is available.
        """

        loop = asyncio.get_event_loop()
        ait = self.async_stream_range(
            start_id=start_id,
            end_id=end_id,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj


class Objects(betterproto.ServiceStub):
    """
    An RPC service to request a stream of objects messages. If a pipeline is
    already running, it will be used to stream the data. If no pipeline is
    running, it will be started first and then the stream will start. NOTE: in
    this second case, the pipeline will also be automatically stopped once
    there are no more clients requesting any stream type from the module.
    """

    async def async_stream(
        self,
        *,
        untracked: bool = False,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ObjectsStreamResponse"]:
        """A method to get a stream of objects messages from the pipeline"""

        request = ObjectsStreamRequest()
        request.untracked = untracked

        async for response in self._unary_stream(
            "/blickfeld.percept_processing.services.Objects/Stream",
            request,
            ObjectsStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def stream(
        self,
        *,
        untracked: bool = False,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> Iterator["ObjectsStreamResponse"]:
        """A method to get a stream of objects messages from the pipeline"""

        loop = asyncio.get_event_loop()
        ait = self.async_stream(
            untracked=untracked,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj


class PointCloud(betterproto.ServiceStub):
    """
    An RPC service to request a stream of point cloud messages. If a pipeline
    is already running, it will be used to stream the data. If no pipeline is
    running, it will be started first and then the stream will start. NOTE: in
    this second case, the pipeline will also be automatically stopped once the
    this second case, the pipeline will also be automatically stopped once
    there are no more clients requesting any stream type from the module.
    """

    async def async_stream(
        self,
        *,
        point_cloud_type: "__percept_pipeline_data__.PointCloudType" = 0,
        coordinate_system: "__percept_pipeline_data__.CoordinateSystem" = 0,
        fqdn: str = "",
        crop: "__base_geometry__.Shape" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["PointCloudStreamResponse"]:
        """
        A method to get a stream of point cloud messages from the pipeline. It
        is possible to stream different point clouds, depending on the fields
        set in the request
        """

        request = PointCloudStreamRequest()
        request.point_cloud_type = point_cloud_type
        request.coordinate_system = coordinate_system
        request.fqdn = fqdn
        if crop is not None:
            request.crop = crop

        async for response in self._unary_stream(
            "/blickfeld.percept_processing.services.PointCloud/Stream",
            request,
            PointCloudStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def stream(
        self,
        *,
        point_cloud_type: "__percept_pipeline_data__.PointCloudType" = 0,
        coordinate_system: "__percept_pipeline_data__.CoordinateSystem" = 0,
        fqdn: str = "",
        crop: "__base_geometry__.Shape" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> Iterator["PointCloudStreamResponse"]:
        """
        A method to get a stream of point cloud messages from the pipeline. It
        is possible to stream different point clouds, depending on the fields
        set in the request
        """

        loop = asyncio.get_event_loop()
        ait = self.async_stream(
            point_cloud_type=point_cloud_type,
            coordinate_system=coordinate_system,
            fqdn=fqdn,
            crop=crop,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj


class States(betterproto.ServiceStub):
    """
    An RPC service to request a stream of states messages. If a pipeline is
    already running, it will be used to stream the data. If no pipeline is
    running, it will be started first and then the stream will start. NOTE: in
    this second case, the pipeline will also be automatically stopped once
    there are no more clients requesting any stream type from the module.
    """

    async def async_stream(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["StatesStreamResponse"]:
        """A method to get a stream of states messages from the pipeline"""

        request = betterproto_lib_google_protobuf.Empty()

        async for response in self._unary_stream(
            "/blickfeld.percept_processing.services.States/Stream",
            request,
            StatesStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def stream(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> Iterator["StatesStreamResponse"]:
        """A method to get a stream of states messages from the pipeline"""

        loop = asyncio.get_event_loop()
        ait = self.async_stream(
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj


class VolumeMap(betterproto.ServiceStub):
    """An RPC service to request a stream of volume map messages."""

    async def async_stream(
        self,
        *,
        zone_uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["VolumeMapStreamResponse"]:
        """
        A method to get a stream of volume map messages of one volume zone from
        the pipeline
        """

        request = VolumeMapStreamRequest()
        request.zone_uuid = zone_uuid

        async for response in self._unary_stream(
            "/blickfeld.percept_processing.services.VolumeMap/Stream",
            request,
            VolumeMapStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def stream(
        self,
        *,
        zone_uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> Iterator["VolumeMapStreamResponse"]:
        """
        A method to get a stream of volume map messages of one volume zone from
        the pipeline
        """

        loop = asyncio.get_event_loop()
        ait = self.async_stream(
            zone_uuid=zone_uuid,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj
