

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: blickfeld/secure/services/account.proto, blickfeld/secure/services/application_key.proto, blickfeld/secure/services/authentication.proto, blickfeld/secure/services/device_credentials.proto, blickfeld/secure/services/firewall.proto, blickfeld/secure/services/health.proto, blickfeld/secure/services/license.proto, blickfeld/secure/services/session.proto
# plugin: python-betterproto
import asyncio
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    Iterator,
    List,
    Optional,
)

import blickfeld_qb2.betterproto as betterproto
import blickfeld_qb2.betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from blickfeld_qb2.betterproto.grpc.grpclib_server import ServiceBase

from .. import (
    config as _config__,
    data as _data__,
)

if TYPE_CHECKING:
    import grpclib.server
    from blickfeld_qb2.betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class ApplicationKeyListRequest(betterproto.Message):
    """Request to list applicaion keys"""

    account_uuid: str = betterproto.string_field(1)
    """
    Optional uuid of the account for which to list the application keys. If not
    provided the uuid from the presented JWT token will be used.
    """


@dataclass(eq=False, repr=False)
class ApplicationKeyListResponse(betterproto.Message):
    """Response for listing existing application keys."""

    application_key: Dict[str, "_config__.ApplicationKey"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    Application key mapping from application-key-uuid (key) to application key
    details (value).
    """


@dataclass(eq=False, repr=False)
class ApplicationKeyCreateRequest(betterproto.Message):
    """Request to create an application key."""

    account_uuid: str = betterproto.string_field(1)
    """
    Optional uuid of the account to which the application key is associated. If
    not provided the uuid from the presented JWT token will be used.
    """

    application_key: "_config__.ApplicationKey" = betterproto.message_field(2)
    """
    The application key to create. Minimum (optional) input is the value set in
    the `purpose` field. Everything else will be generated and added on the
    server side.
    """


@dataclass(eq=False, repr=False)
class ApplicationKeyCreateResponse(betterproto.Message):
    """
    Response containing the plain-text key information of the generated
    application key.   [NOTE] ==== The generated key in plain text will be
    returned only once. ====
    """

    uuid: str = betterproto.string_field(2)
    """The uuid of the application key."""

    key: str = betterproto.string_field(1)
    """
    The generated key in plain text. This key has to be used whenever an
    application needs a token for authenticated access.
    """


@dataclass(eq=False, repr=False)
class ApplicationKeyDeleteRequest(betterproto.Message):
    """Request to delete an application key."""

    uuid: str = betterproto.string_field(1)
    """
    The uuid of the application key to delete. Once the application key has
    been deleted all future authentication attempts with this application key
    will be blocked.
    """


@dataclass(eq=False, repr=False)
class AccountListResponse(betterproto.Message):
    """Response for list of accounts"""

    account: Dict[str, "_config__.Account"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """Accounts mapping from account-uuid (key) to account details (value)."""


@dataclass(eq=False, repr=False)
class AccountCreateRequest(betterproto.Message):
    """Request to create a new user"""

    account: "_config__.Account" = betterproto.message_field(1)
    """the account to create"""


@dataclass(eq=False, repr=False)
class AccountCreateResponse(betterproto.Message):
    """
    Response after account has been created.   [NOTE] ==== The generated
    activation password in plain text will be returned only once. ====
    """

    activation_password: str = betterproto.string_field(1)
    """the activation password in plain text"""

    uuid: str = betterproto.string_field(2)
    """the uuid of the account"""


@dataclass(eq=False, repr=False)
class AccountBlockRequest(betterproto.Message):
    """Request to block an existing account"""

    uuid: str = betterproto.string_field(1)
    """the uuid of the account to block"""


@dataclass(eq=False, repr=False)
class AccountResetRequest(betterproto.Message):
    """Request to reset an existing account"""

    uuid: str = betterproto.string_field(1)
    """the uuid of the account to reset"""


@dataclass(eq=False, repr=False)
class AccountResetResponse(betterproto.Message):
    """
    Response after account has been reset.   [NOTE] ==== The generated
    activation password in plain text will be returned only once. ====
    """

    activation_password: str = betterproto.string_field(1)
    """the activation password in plain text"""


@dataclass(eq=False, repr=False)
class AccountDeleteRequest(betterproto.Message):
    """Request to delete an Account"""

    uuid: str = betterproto.string_field(1)
    """
    Optional uuid of the account to delete. If left empty the uuid from the
    presented JWT token will be used.
    """


@dataclass(eq=False, repr=False)
class AccountGetRequest(betterproto.Message):
    """Request to query account details"""

    uuid: str = betterproto.string_field(1)
    """
    Optional uuid of the account to get. If left empty the uuid from the
    presented JWT token will be used.
    """


@dataclass(eq=False, repr=False)
class AccountGetResponse(betterproto.Message):
    """Response for the currently authenticated account."""

    account: "_config__.Account" = betterproto.message_field(1)
    """The account details"""

    uuid: str = betterproto.string_field(2)
    """The uuid of the account"""


@dataclass(eq=False, repr=False)
class AccountStoreRequest(betterproto.Message):
    """Store updated account details."""

    uuid: str = betterproto.string_field(1)
    """
    Optional uuid of the account to store. If not provided the uuid from the
    presented JWT token will be used.
    """

    account: "_config__.Account" = betterproto.message_field(2)
    """Optional account data to store."""

    password_update: "AccountStoreRequestPasswordUpdate" = betterproto.message_field(3)
    """Optional password update for the account to store."""


@dataclass(eq=False, repr=False)
class AccountStoreRequestPasswordUpdate(betterproto.Message):
    """Password update message"""

    current: str = betterproto.string_field(1)
    """the current password"""

    new: str = betterproto.string_field(2)
    """the new password"""


@dataclass(eq=False, repr=False)
class AuthenticationLoginRequest(betterproto.Message):
    """Request for authentication"""

    user: "AuthenticationLoginRequestUser" = betterproto.message_field(
        1, group="credentials"
    )
    """Authenticate with user credentials"""

    application: "AuthenticationLoginRequestApplication" = betterproto.message_field(
        2, group="credentials"
    )
    """Authenticate with application key credentials"""


@dataclass(eq=False, repr=False)
class AuthenticationLoginRequestUser(betterproto.Message):
    """User credentials"""

    name: str = betterproto.string_field(1)
    """the username (can be left out in case of default factory state)"""

    password: str = betterproto.string_field(2)
    """the password of the user in plain text"""


@dataclass(eq=False, repr=False)
class AuthenticationLoginRequestApplication(betterproto.Message):
    """Application Key credentials"""

    key: str = betterproto.string_field(1)
    """the key in plain text"""


@dataclass(eq=False, repr=False)
class AuthenticationLoginResponse(betterproto.Message):
    """Response containing the issued JWT token."""

    token: str = betterproto.string_field(1)
    """
    The JWT token which needs to be sent with the key "token" in the metadata
    of a gRPC call. The token is bound to a
    xref:blickfeld/secure/services/session.adoc[].
    """


@dataclass(eq=False, repr=False)
class DeviceCredentialsSetFactoryRequest(betterproto.Message):
    """
    Request with device credentials   The device credentials should only be set
    once in production.
    """

    device_credentials: "_config__.DeviceCredentials" = betterproto.message_field(1)
    """
    Cryptographic device credentials which were generated by the blickfeld-
    secure-authority.
    """


@dataclass(eq=False, repr=False)
class DeviceCredentialsSetRequest(betterproto.Message):
    """Request with device credentials"""

    device_credentials: "_config__.DeviceCredentials" = betterproto.message_field(1)
    """
    Cryptographic device credentials used to establish secured TLS connection
    between client and Qb2 device.
    """


@dataclass(eq=False, repr=False)
class DeviceCredentialsGetResponse(betterproto.Message):
    """Response with device credentials"""

    device_credentials: "_config__.DeviceCredentials" = betterproto.message_field(1)
    """
    Cryptographic device credentials used to establish secured TLS connection
    between client and Qb2 device.
    """


@dataclass(eq=False, repr=False)
class DeviceCredentialsGetCertificatesResponse(betterproto.Message):
    """Response message which delivers public device certificate"""

    certificates: List["_config__.Certificate"] = betterproto.message_field(1)
    """
    Certificate chain which is deployed at Qb2 device and is used during the
    TLS handshake.
    """


@dataclass(eq=False, repr=False)
class FirewallSetRequest(betterproto.Message):
    """Set configuration request"""

    config: "_config__.Firewall" = betterproto.message_field(1)
    """Configuration"""


@dataclass(eq=False, repr=False)
class FirewallGetResponse(betterproto.Message):
    """Get configuration response"""

    config: "_config__.Firewall" = betterproto.message_field(1)
    """Configuration"""


@dataclass(eq=False, repr=False)
class HealthGetResponse(betterproto.Message):
    """Response to Health Get request"""

    health: "_data__.Health" = betterproto.message_field(1)
    """Health state"""


@dataclass(eq=False, repr=False)
class HealthWatchResponse(betterproto.Message):
    """Response to Health Watch request"""

    health: "_data__.Health" = betterproto.message_field(1)
    """Health state"""


@dataclass(eq=False, repr=False)
class LicenseSetRequest(betterproto.Message):
    """Request to assign license to this Qb2"""

    token: str = betterproto.string_field(1)
    """JWT license string"""


@dataclass(eq=False, repr=False)
class LicenseGetResponse(betterproto.Message):
    """Response containing licensed product variant and metadata"""

    license: "_data__.License" = betterproto.message_field(1)
    """The configured license"""


@dataclass(eq=False, repr=False)
class SessionGetNonceResponse(betterproto.Message):
    """Response for GetNonce request."""

    nonce: str = betterproto.string_field(1)
    """Cryptographic session nonce."""


class ApplicationKey(betterproto.ServiceStub):
    """Service for managing application keys."""

    async def async_list(
        self,
        *,
        account_uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ApplicationKeyListResponse":
        """List existing application keys for the authenticated account."""

        request = ApplicationKeyListRequest()
        request.account_uuid = account_uuid

        return await self._unary_unary(
            "/blickfeld.secure.services.ApplicationKey/List",
            request,
            ApplicationKeyListResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def list(
        self,
        *,
        account_uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ApplicationKeyListResponse":
        """List existing application keys for the authenticated account."""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_list(
                account_uuid=account_uuid,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_create(
        self,
        *,
        account_uuid: str = "",
        application_key: "_config__.ApplicationKey" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ApplicationKeyCreateResponse":
        """Create an application key for the authenticated account."""

        request = ApplicationKeyCreateRequest()
        request.account_uuid = account_uuid
        if application_key is not None:
            request.application_key = application_key

        return await self._unary_unary(
            "/blickfeld.secure.services.ApplicationKey/Create",
            request,
            ApplicationKeyCreateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def create(
        self,
        *,
        account_uuid: str = "",
        application_key: "_config__.ApplicationKey" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ApplicationKeyCreateResponse":
        """Create an application key for the authenticated account."""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_create(
                account_uuid=account_uuid,
                application_key=application_key,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_delete(
        self,
        *,
        uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Delete an application key from the authenticated account."""

        request = ApplicationKeyDeleteRequest()
        request.uuid = uuid

        return await self._unary_unary(
            "/blickfeld.secure.services.ApplicationKey/Delete",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def delete(
        self,
        *,
        uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Delete an application key from the authenticated account."""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_delete(
                uuid=uuid,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class Account(betterproto.ServiceStub):
    """
    This service supports the complete lifecycle of accounts which are managed
    by the current Qb2 device.
    """

    async def async_list(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AccountListResponse":
        """List registered accounts."""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.secure.services.Account/List",
            request,
            AccountListResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def list(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "AccountListResponse":
        """List registered accounts."""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_list(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_create(
        self,
        *,
        account: "_config__.Account" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AccountCreateResponse":
        """Create a new account."""

        request = AccountCreateRequest()
        if account is not None:
            request.account = account

        return await self._unary_unary(
            "/blickfeld.secure.services.Account/Create",
            request,
            AccountCreateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def create(
        self,
        *,
        account: "_config__.Account" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AccountCreateResponse":
        """Create a new account."""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_create(
                account=account,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_block(
        self,
        *,
        uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Block account by setting the state to BLOCKED. Use the Reset method to
        un-block the account.
        """

        request = AccountBlockRequest()
        request.uuid = uuid

        return await self._unary_unary(
            "/blickfeld.secure.services.Account/Block",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def block(
        self,
        *,
        uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Block account by setting the state to BLOCKED. Use the Reset method to
        un-block the account.
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_block(
                uuid=uuid,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_reset(
        self,
        *,
        uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AccountResetResponse":
        """
        Reset account by setting the state to WAITING_FOR_ACTIVATION &
        generating a new activation password.
        """

        request = AccountResetRequest()
        request.uuid = uuid

        return await self._unary_unary(
            "/blickfeld.secure.services.Account/Reset",
            request,
            AccountResetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def reset(
        self,
        *,
        uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AccountResetResponse":
        """
        Reset account by setting the state to WAITING_FOR_ACTIVATION &
        generating a new activation password.
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_reset(
                uuid=uuid,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_delete(
        self,
        *,
        uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Delete an Account."""

        request = AccountDeleteRequest()
        request.uuid = uuid

        return await self._unary_unary(
            "/blickfeld.secure.services.Account/Delete",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def delete(
        self,
        *,
        uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Delete an Account."""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_delete(
                uuid=uuid,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_get(
        self,
        *,
        uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AccountGetResponse":
        """Get Account information."""

        request = AccountGetRequest()
        request.uuid = uuid

        return await self._unary_unary(
            "/blickfeld.secure.services.Account/Get",
            request,
            AccountGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        *,
        uuid: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AccountGetResponse":
        """Get Account information."""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                uuid=uuid,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_store(
        self,
        *,
        uuid: str = "",
        account: "_config__.Account" = None,
        password_update: "AccountStoreRequestPasswordUpdate" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Store updated account data.   [NOTE] ==== During account activation
        this method can be accessed using a JWT token with access level
        `LEVEL_PUBLIC`. It will fail with `UNAUTHENTICATED` if no JWT token is
        presented. ====
        """

        request = AccountStoreRequest()
        request.uuid = uuid
        if account is not None:
            request.account = account
        if password_update is not None:
            request.password_update = password_update

        return await self._unary_unary(
            "/blickfeld.secure.services.Account/Store",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def store(
        self,
        *,
        uuid: str = "",
        account: "_config__.Account" = None,
        password_update: "AccountStoreRequestPasswordUpdate" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Store updated account data.   [NOTE] ==== During account activation
        this method can be accessed using a JWT token with access level
        `LEVEL_PUBLIC`. It will fail with `UNAUTHENTICATED` if no JWT token is
        presented. ====
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_store(
                uuid=uuid,
                account=account,
                password_update=password_update,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class Authentication(betterproto.ServiceStub):
    """Service for authentication to the Qb2 device."""

    async def async_login(
        self,
        *,
        user: "AuthenticationLoginRequestUser" = None,
        application: "AuthenticationLoginRequestApplication" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AuthenticationLoginResponse":
        """
        User-Accounts managed by Qb2 have to use the Login method with an
        existing account in order to receive a JWT Token for access to
        priviliged parts of the device API.   The factory user has the username
        "admin". The password is printed on the device label.
        """

        request = AuthenticationLoginRequest()
        if user is not None:
            request.user = user
        if application is not None:
            request.application = application

        return await self._unary_unary(
            "/blickfeld.secure.services.Authentication/Login",
            request,
            AuthenticationLoginResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def login(
        self,
        *,
        user: "AuthenticationLoginRequestUser" = None,
        application: "AuthenticationLoginRequestApplication" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AuthenticationLoginResponse":
        """
        User-Accounts managed by Qb2 have to use the Login method with an
        existing account in order to receive a JWT Token for access to
        priviliged parts of the device API.   The factory user has the username
        "admin". The password is printed on the device label.
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_login(
                user=user,
                application=application,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class DeviceCredentials(betterproto.ServiceStub):
    """
    Set device credentials for the secure TLS connection of the Qb2 device.
    """

    async def async_set(
        self,
        *,
        device_credentials: "_config__.DeviceCredentials" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Set device credentials.   [WARN] This will override the factory SSL
        certificate which is provided by the device. It will cause problems
        with inter-device communication, authentication, and Blickfeld client
        libraries. Blickfeld client libraries expect a root certificate which
        is signed by the Blickfeld device root authority. The expected root
        certificate must then be manually provided via configuration options in
        the client libraries.
        """

        request = DeviceCredentialsSetRequest()
        if device_credentials is not None:
            request.device_credentials = device_credentials

        return await self._unary_unary(
            "/blickfeld.secure.services.DeviceCredentials/Set",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def set(
        self,
        *,
        device_credentials: "_config__.DeviceCredentials" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Set device credentials.   [WARN] This will override the factory SSL
        certificate which is provided by the device. It will cause problems
        with inter-device communication, authentication, and Blickfeld client
        libraries. Blickfeld client libraries expect a root certificate which
        is signed by the Blickfeld device root authority. The expected root
        certificate must then be manually provided via configuration options in
        the client libraries.
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_set(
                device_credentials=device_credentials,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_get_certificates(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DeviceCredentialsGetCertificatesResponse":
        """Get device credentials certificates."""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.secure.services.DeviceCredentials/GetCertificates",
            request,
            DeviceCredentialsGetCertificatesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get_certificates(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "DeviceCredentialsGetCertificatesResponse":
        """Get device credentials certificates."""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get_certificates(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_clear(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Clear device credentials. The device credentials will reset to the
        factory device credentials.
        """

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.secure.services.DeviceCredentials/Clear",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def clear(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Clear device credentials. The device credentials will reset to the
        factory device credentials.
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_clear(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class Firewall(betterproto.ServiceStub):
    """Service for configuring firewall parameters"""

    async def async_set(
        self,
        *,
        config: "_config__.Firewall" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set configuration"""

        request = FirewallSetRequest()
        if config is not None:
            request.config = config

        return await self._unary_unary(
            "/blickfeld.secure.services.Firewall/Set",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def set(
        self,
        *,
        config: "_config__.Firewall" = None,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set configuration"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_set(
                config=config,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "FirewallGetResponse":
        """Get configuration"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.secure.services.Firewall/Get",
            request,
            FirewallGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "FirewallGetResponse":
        """Get configuration"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class Health(betterproto.ServiceStub):
    """
    The health service provides methods to monitor operational status of the
    secure module
    """

    async def async_get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "HealthGetResponse":
        """Returns the current health status of the secure module"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.secure.services.Health/Get",
            request,
            HealthGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "HealthGetResponse":
        """Returns the current health status of the secure module"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> AsyncIterator["HealthWatchResponse"]:
        """
        Continously returns the current health status of the secure module
        """

        request = betterproto_lib_google_protobuf.Empty()

        async for response in self._unary_stream(
            "/blickfeld.secure.services.Health/Watch",
            request,
            HealthWatchResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    def watch(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> Iterator["HealthWatchResponse"]:
        """
        Continously returns the current health status of the secure module
        """

        loop = asyncio.get_event_loop()
        ait = self.async_watch(
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ).__aiter__()

        async def get_next():
            try:
                obj = await ait.__anext__()
                return False, obj
            except StopAsyncIteration:
                return True, None

        while True:
            done, obj = loop.run_until_complete(get_next())
            if done:
                break
            yield obj


class License(betterproto.ServiceStub):
    """
    License service to assign a product variant and metadata to a Qb2.   The
    license is cryptographically singed and configured during production. A
    configured license can only be replaced by another valid license for this
    device.   A license contains the specific product variant and can
    additionally contain arbitrary metadata for the specfic customer or
    application.
    """

    async def async_get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "LicenseGetResponse":
        """Get configured license"""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.secure.services.License/Get",
            request,
            LicenseGetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "LicenseGetResponse":
        """Get configured license"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_set(
        self,
        *,
        token: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set license"""

        request = LicenseSetRequest()
        request.token = token

        return await self._unary_unary(
            "/blickfeld.secure.services.License/Set",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def set(
        self,
        *,
        token: str = "",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "betterproto_lib_google_protobuf.Empty":
        """Set license"""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_set(
                token=token,
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )


class Session(betterproto.ServiceStub):
    """
    Session service which implements all methods for session-bound security
    features.   A session is recreated after the following events: * Power-
    cycle of the device * Every day (UTC) * Manual invalidation via gRPC call
    """

    async def async_get_nonce(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "SessionGetNonceResponse":
        """Get cryptographic session nonce."""

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.secure.services.Session/GetNonce",
            request,
            SessionGetNonceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def get_nonce(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "SessionGetNonceResponse":
        """Get cryptographic session nonce."""

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_get_nonce(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )

    async def async_invalidate(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Invalidates the current session. A new session will be created
        automatically.
        """

        request = betterproto_lib_google_protobuf.Empty()

        return await self._unary_unary(
            "/blickfeld.secure.services.Session/Invalidate",
            request,
            betterproto_lib_google_protobuf.Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    def invalidate(
        self,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None,
    ) -> "betterproto_lib_google_protobuf.Empty":
        """
        Invalidates the current session. A new session will be created
        automatically.
        """

        loop = asyncio.get_event_loop()
        return loop.run_until_complete(
            self.async_invalidate(
                timeout=timeout,
                deadline=deadline,
                metadata=metadata,
            )
        )
