

# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: blickfeld/diagnostics/data/health.proto, blickfeld/diagnostics/data/log.proto, blickfeld/diagnostics/data/self_test_report.proto, blickfeld/diagnostics/data/time_series.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import blickfeld_qb2.betterproto as betterproto
import blickfeld_qb2.betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import numpy as np

from ... import base as __base__
from ...base import data as __base_data__
from .. import config as _config__


class LogEntryLevel(betterproto.Enum):
    """The log level represents the priority of the log."""

    LEVEL_UNSPECIFIED = 0
    """No level is set"""

    LEVEL_ERROR = 1
    """
    An error condition was detected   Includes the systemd levels: EMERGENCY,
    ALERT, CRITICAL, ERROR
    """

    LEVEL_WARNING = 2
    """
    The message indicates that an error will occur if no action is taken
    Includes the systemd levels: NOTICE, WARNING
    """

    LEVEL_INFO = 3
    """
    Normal operational messages that require no action   Includes the systemd
    levels: INFORMATIONAL
    """


class SelfTestReportResultFlag(betterproto.Enum):
    """Result flags which indicate if test was successful."""

    FLAG_UNSPECIFIED = 0
    """Unknown result."""

    FLAG_SUCCESS = 1
    """The test was successful."""

    FLAG_WARNING = 2
    """
    The test succeeded but it raised some warnings. Please report if this
    happens during production and the root-cause is unknown.
    """

    FLAG_FAILURE = 3
    """The test failed. The tested module is most probably not functional."""


@dataclass(eq=False, repr=False)
class Health(betterproto.Message):
    """Qb2 modules"""

    state: "__base_data__.HealthState" = betterproto.enum_field(1)
    """
    High-level aggregated health state of the device (if one of the modules
    reports FAILED -> aggregated state is also FAILED)
    """

    state_reason: str = betterproto.string_field(2)
    """
    Reason for given state (user-friendly). Is not set if state is STATE_OK.
    Aggregated string from modules state reasons
    """

    module: "HealthModule" = betterproto.message_field(3)
    """Qb2 modules"""


@dataclass(eq=False, repr=False)
class HealthModule(betterproto.Message):
    """Qb2 modules"""

    laser: "HealthModuleHealth" = betterproto.message_field(1)
    """health of laser module"""

    detector: "HealthModuleHealth" = betterproto.message_field(2)
    """health of detector module"""

    beam_deflection_control_vertical: "HealthModuleHealth" = betterproto.message_field(
        3
    )
    """health of beam deflection control module (vertical)"""

    beam_deflection_control_horizontal: "HealthModuleHealth" = (
        betterproto.message_field(4)
    )
    """health of beam deflection control module (horizontal)"""

    system: "HealthModuleHealth" = betterproto.message_field(6)
    """health of the Blickfeld system module"""

    core_processing: "HealthModuleHealth" = betterproto.message_field(7)
    """health of the Blickfeld core processing module"""

    percept_pipeline: "HealthModuleHealth" = betterproto.message_field(9)
    """health of percept pipeline"""

    push: "HealthModuleHealth" = betterproto.message_field(10)
    """Health of the Blickfeld Push module"""

    secure: "HealthModuleHealth" = betterproto.message_field(11)
    """Health of the Blickfeld Secure module"""

    video: "HealthModuleHealth" = betterproto.message_field(12)
    """Health of the Blickfeld Video module"""

    compute_module: "HealthModuleHealth" = betterproto.message_field(13)
    """Health of the Blickfeld Compute module"""

    onvif: "HealthModuleHealth" = betterproto.message_field(14)
    """Health of the Blickfeld onvif module"""


@dataclass(eq=False, repr=False)
class HealthModuleHealth(betterproto.Message):
    """Message representing health of a Qb2 module"""

    state: "__base_data__.HealthState" = betterproto.enum_field(1)
    """High-level health state of the module"""

    state_reason: str = betterproto.string_field(2)
    """
    Reason for given state (user-friendly). Is not set if state is STATE_OK.
    """


@dataclass(eq=False, repr=False)
class Log(betterproto.Message):
    """
    This message aggregates the data structures related to the log service.
    """

    pass


@dataclass(eq=False, repr=False)
class LogEntry(betterproto.Message):
    """The log entry contains the message and metadata of a log."""

    boot_uuid: str = betterproto.string_field(1)
    """UUID of the boot during which the log was written."""

    cursor: "LogEntryCursor" = betterproto.message_field(2)
    """Cursor used to index log entries and to navigate through the logs."""

    timestamp: int = betterproto.uint64_field(3)
    """
    The wallclock time at the point in time the entry was received by the
    journal, in nanoseconds since the epoch UTC.
    """

    module: "_config__.LogFilterSoftwareModule" = betterproto.enum_field(4)
    """The module which has written the log."""

    level: "LogEntryLevel" = betterproto.enum_field(5)
    """The log level of the log."""

    message: str = betterproto.string_field(6)
    """The message which has been logged."""


@dataclass(eq=False, repr=False)
class LogEntryCursor(betterproto.Message):
    """The cursor uniquely identifies a log entry in the logs."""

    sequence_number_id: str = betterproto.string_field(1)
    """
    The sequence number ID is used to reference a set of log entries generated
    by the same systemd-journald instance.
    """

    sequence_number: int = betterproto.uint64_field(2)
    """
    The sequence number is assigned to a log entry by the systemd-journald
    instance when they are written to disk. Every instance numbers their
    entries sequentially, starting from 1 for the first entry written after
    subsystem initialization.
    """


@dataclass(eq=False, repr=False)
class SelfTestReport(betterproto.Message):
    """Report which contains the results of the selected self tests."""

    result_flag: "SelfTestReportResultFlag" = betterproto.enum_field(1)
    """
    Aggregated result flag which is FLAG_SUCCESS if all tests passed without
    warnings
    """

    results: List["SelfTestReportResult"] = betterproto.message_field(2)
    """List of test results"""


@dataclass(eq=False, repr=False)
class SelfTestReportResult(betterproto.Message):
    """Result of test."""

    test: "_config__.SelfTest" = betterproto.enum_field(1)
    """Test case"""

    identifier: str = betterproto.string_field(5)
    """Unique identifier of test case"""

    flag: "SelfTestReportResultFlag" = betterproto.enum_field(2)
    """Flag which states test result"""

    reason: str = betterproto.string_field(3)
    """
    Human-readable reason for test warning or failure. Is not set if test was
    successful.
    """

    duration: float = betterproto.float_field(4)
    """Duration of test run"""


@dataclass(eq=False, repr=False)
class TimeSeries(betterproto.Message):
    """
    Lifetime data series   This data is collected over the whole lifetime of
    the product. Currently the minimum, average, and maximum values are stored
    for 30 min intervals.
    """

    binary: "TimeSeriesBinary" = betterproto.message_field(1)
    """Binary data"""

    meta: "TimeSeriesMeta" = betterproto.message_field(2)
    """Meta information"""


@dataclass(eq=False, repr=False)
class TimeSeriesMeta(betterproto.Message):
    """Meta information about the lifetime series"""

    module: str = betterproto.string_field(1)
    """Module from which the data was collected"""

    type: "__base__.LifeTimeDiagnosticsType" = betterproto.enum_field(2)
    """Type of data"""


@dataclass(eq=False, repr=False)
class TimeSeriesBinary(betterproto.Message):
    """
    The fields of the series are encoded as binary arrays. Binary types instead
    of native Protobuf types are used to improve the performance.   NOTE: All
    byte arrays are encoded in Little Endian.
    """

    length: int = betterproto.uint32_field(1)
    """Number of entries in arrays below."""

    timestamp: np.ndarray = betterproto.bytes_field(2, numpy_dtype="<u8")
    """Timestamps of time series.   Type: UInt64"""

    minimum: np.ndarray = betterproto.bytes_field(3, numpy_dtype="<f4")
    """Aggregated minimum values.   Type: Float32"""

    average: np.ndarray = betterproto.bytes_field(4, numpy_dtype="<f4")
    """Aggregated average values.   Type: Float32"""

    maximum: np.ndarray = betterproto.bytes_field(5, numpy_dtype="<f4")
    """Aggregated average values.   Type: Float32"""
