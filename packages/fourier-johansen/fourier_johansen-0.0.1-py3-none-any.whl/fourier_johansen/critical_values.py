"""
Critical values for Johansen and Johansen-Fourier cointegration tests.

All critical values are taken from:
1. Johansen (1991) for standard tests
2. Pascalau, Lee, Nazlioglu & Lu (2022) Online Appendix Tables 1-8 for Fourier tests
3. Harris et al. (2016) for SC-VECM tests

All values are at 5% significance level unless otherwise noted.
"""

import numpy as np


# =============================================================================
# STANDARD JOHANSEN CRITICAL VALUES (5%)
# =============================================================================

# Model: 1=None, 2=RC, 3=UC, 4=RT, 5=UT
# Columns: r=1, r=2, r=3, r=4, r=5, r=6
CV_JOHANSEN_TRACE = {
    1: np.array([4.157, 12.271, 24.116, 39.977, 59.682, 83.424]),
    2: np.array([9.133, 20.264, 35.060, 53.750, 76.447, 103.126]),
    3: np.array([3.860, 15.465, 29.701, 47.559, 69.362, 94.989]),
    4: np.array([12.500, 25.760, 42.682, 63.455, 87.999, 116.611]),
    5: np.array([3.852, 18.223, 34.825, 54.812, 78.599, 106.395]),
}


# =============================================================================
# FOURIER TRACE CRITICAL VALUES - SINGLE FREQUENCY (5%)
# =============================================================================

# Model 1: Constant model (Unrestricted constant)
# Rows: frequency 1-5, Columns: r=1 to r=5
CV_FOURIER_TRACE_SINGLE = {
    1: np.array([
        [14.30840, 28.18929, 46.02544, 67.68133, 93.91098],
        [10.51359, 22.60040, 38.91366, 60.67533, 86.50896],
        [9.4069, 20.71316, 35.77095, 56.38972, 81.37919],
        [8.85902, 19.7394, 34.62302, 53.82681, 78.36771],
        [8.62743, 19.13382, 33.64254, 52.29388, 76.0114]
    ]),
    2: np.array([
        [18.09039, 35.55617, 56.49866, 81.12916, 109.17405],
        [15.86571, 31.17837, 50.74269, 74.78432, 102.38793],
        [14.21382, 28.55989, 46.79052, 69.25963, 96.24529],
        [13.22626, 26.89691, 44.13739, 66.35955, 92.48682],
        [12.58547, 25.83584, 43.00055, 64.33425, 89.88038]
    ]),
    3: np.array([
        [14.74275, 29.58587, 48.92995, 71.81054, 99.11298],
        [11.22645, 24.46542, 42.119, 65.00828, 91.92876],
        [10.24255, 22.83348, 39.16091, 60.81107, 86.83963],
        [9.85987, 21.88533, 37.84303, 58.23366, 83.59189],
        [9.53509, 21.32864, 36.9486, 56.82161, 81.6248]
    ]),
    4: np.array([
        [18.90748, 37.47358, 59.39504, 85.16574, 114.20359],
        [16.37934, 33.03774, 53.42384, 78.86507, 107.71686],
        [14.82827, 30.20683, 49.80522, 73.87547, 101.74087],
        [13.83531, 28.82023, 47.18157, 70.47044, 97.87634],
        [13.2854, 27.72151, 45.80354, 68.30843, 95.16862]
    ])
}


# =============================================================================
# FOURIER TRACE CRITICAL VALUES - CUMULATIVE FREQUENCY (5%)
# =============================================================================

CV_FOURIER_TRACE_CUMULATIVE = {
    1: np.array([
        [14.3084, 28.18929, 46.02544, 67.68133, 93.91098],
        [19.73892, 37.92253, 59.84259, 86.58413, 117.05128],
        [25.34511, 47.78119, 73.55901, 104.83568, 140.70307],
        [30.39381, 57.38707, 87.96552, 123.44607, 163.66453],
        [35.78632, 67.11283, 102.21303, 142.35412, 187.47393]
    ]),
    2: np.array([
        [18.09039, 35.55617, 56.49866, 81.12916, 109.17405],
        [24.65593, 46.81503, 72.96398, 103.00425, 136.41383],
        [30.28825, 58.41858, 89.82574, 125.17419, 163.80433],
        [36.91493, 69.48224, 106.815, 145.99311, 190.71159],
        [42.74488, 80.94095, 122.9247, 168.06434, 217.45626]
    ]),
    3: np.array([
        [18.09039, 35.55617, 56.49866, 81.12916, 109.17405],
        [24.65593, 46.81503, 72.96398, 103.00425, 136.41383],
        [30.28825, 58.41858, 89.82574, 125.17419, 163.80433],
        [36.91493, 69.48224, 106.815, 145.99311, 190.71159],
        [42.74488, 80.94095, 122.9247, 168.06434, 217.45626]
    ]),
    4: np.array([
        [17.36134, 34.86245, 56.15881, 81.32806, 111.08734],
        [25.51318, 48.98605, 76.33016, 109.20236, 144.88705],
        [32.82653, 62.79299, 96.91238, 135.64276, 179.15233],
        [40.45318, 77.00024, 116.93661, 162.08337, 212.44297],
        [47.73399, 90.84489, 137.39421, 189.81457, 246.32093]
    ])
}


# =============================================================================
# FOURIER LAMBDA-MAX CRITICAL VALUES - SINGLE FREQUENCY (5%)
# =============================================================================

CV_FOURIER_LAMBDA_SINGLE = {
    1: np.array([
        [14.3084, 21.81952, 28.35264, 34.91794, 41.17167],
        [10.51359, 19.05594, 26.30747, 33.44158, 40.27457],
        [9.4069, 17.35662, 24.69282, 32.11669, 38.74516],
        [8.85902, 16.54828, 23.96644, 30.86204, 37.83603],
        [8.62743, 16.0725, 22.72801, 30.08076, 36.78717]
    ]),
    2: np.array([
        [18.09039, 25.46954, 32.22024, 38.25462, 44.55845],
        [15.86571, 24.05796, 30.45904, 37.58944, 43.98831],
        [14.21382, 22.17946, 29.614, 36.66324, 42.69462],
        [13.22626, 20.99576, 28.10436, 35.01388, 41.95523],
        [12.58547, 20.27764, 27.17991, 34.32537, 41.09012]
    ]),
    3: np.array([
        [14.74275, 22.19508, 28.89295, 35.39524, 41.54859],
        [11.22645, 19.6962, 26.90804, 34.01138, 40.76375],
        [10.24255, 18.08373, 25.11247, 32.64265, 39.36979],
        [9.85987, 17.23072, 24.46652, 31.35129, 38.52174],
        [9.53509, 16.79633, 23.3704, 30.58855, 37.49176]
    ]),
    4: np.array([
        [18.90748, 26.44461, 33.03344, 39.23833, 45.38248],
        [16.37934, 24.68322, 30.95725, 38.1791, 44.72682],
        [14.82827, 22.90663, 30.23652, 37.2978, 43.44843],
        [13.83531, 21.73118, 28.57067, 35.63663, 42.66692],
        [13.2854, 20.8269, 27.77769, 35.0607, 41.73858]
    ])
}


# =============================================================================
# FOURIER LAMBDA-MAX CRITICAL VALUES - CUMULATIVE FREQUENCY (5%)
# =============================================================================

CV_FOURIER_LAMBDA_CUMULATIVE = {
    1: np.array([
        [14.3084, 21.81952, 28.35264, 34.91794, 41.17167],
        [19.73892, 27.76404, 35.04145, 41.93187, 48.45197],
        [25.34511, 33.8306, 41.42773, 48.46413, 55.34988],
        [30.39381, 39.85131, 47.92928, 55.3712, 62.26346],
        [35.78632, 45.91888, 54.4122, 61.89791, 69.0094]
    ]),
    2: np.array([
        [18.09039, 25.46954, 32.22024, 38.25462, 44.55845],
        [24.65593, 32.06307, 38.79872, 45.22149, 52.11245],
        [30.28825, 38.466, 45.62627, 52.60794, 59.17533],
        [36.91493, 44.757, 52.37514, 59.21325, 65.76993],
        [42.74488, 51.04538, 58.6176, 65.85758, 72.81402]
    ]),
    3: np.array([
        [17.36134, 25.09009, 31.81531, 38.66757, 45.12572],
        [25.51318, 34.10673, 41.3475, 48.25683, 55.09165],
        [32.82653, 42.475, 50.36196, 57.50662, 64.95132],
        [40.45318, 50.95535, 59.10846, 67.01418, 73.76121],
        [47.73399, 59.52646, 67.9576, 75.93939, 83.23137]
    ]),
    4: np.array([
        [18.09039, 25.46954, 32.22024, 38.25462, 44.55845],
        [24.65593, 32.06307, 38.79872, 45.22149, 52.11245],
        [30.28825, 38.466, 45.62627, 52.60794, 59.17533],
        [36.91493, 44.757, 52.37514, 59.21325, 65.76993],
        [42.74488, 51.04538, 58.6176, 65.85758, 72.81402]
    ])
}


# =============================================================================
# EXTENDED FOURIER TRACE CRITICAL VALUES FOR SBC (up to 8 variables)
# =============================================================================

# Single frequency - critical values for n-r = 1 to 8
CV_FOURIER_TRACE_SINGLE_EXT = {
    1: {
        1: np.array([14.117, 28.593, 47.072, 70.398, 98.796, 132.166, 171.083, 215.080]),
        2: np.array([10.527, 22.876, 40.767, 63.726, 91.314, 125.268, 163.699, 208.404]),
        3: np.array([9.333, 20.737, 37.299, 58.357, 85.710, 118.207, 156.739, 200.448]),
        4: np.array([8.627, 19.645, 35.272, 55.829, 82.353, 113.624, 151.605, 194.788]),
        5: np.array([8.414, 19.154, 34.488, 54.485, 80.568, 110.982, 147.695, 190.192])
    },
    2: {
        1: np.array([18.066, 36.168, 58.130, 84.108, 114.828, 151.096, 192.500, 238.201]),
        2: np.array([15.894, 31.380, 51.673, 78.088, 108.315, 143.854, 185.650, 231.050]),
        3: np.array([13.877, 28.321, 47.543, 72.313, 101.699, 137.220, 178.260, 223.866]),
        4: np.array([12.780, 26.765, 45.495, 69.226, 97.321, 132.100, 171.303, 217.486]),
        5: np.array([12.295, 25.626, 43.392, 66.375, 94.402, 127.996, 167.265, 212.655])
    },
    3: {
        1: np.array([14.606, 30.190, 50.120, 75.141, 104.731, 140.302, 179.385, 223.922]),
        2: np.array([11.349, 25.070, 44.167, 68.496, 98.032, 132.872, 172.776, 218.192]),
        3: np.array([10.320, 23.258, 40.884, 63.286, 92.112, 126.409, 165.460, 211.024]),
        4: np.array([9.536, 21.932, 38.987, 61.237, 88.461, 121.819, 160.053, 204.858]),
        5: np.array([9.623, 21.534, 38.242, 59.605, 86.673, 118.679, 157.064, 200.604])
    },
    4: {
        1: np.array([19.154, 38.267, 60.998, 88.708, 121.003, 157.309, 200.216, 247.712]),
        2: np.array([16.406, 33.456, 55.200, 82.641, 114.408, 151.427, 194.192, 241.852]),
        3: np.array([14.718, 30.415, 50.968, 76.321, 107.973, 143.811, 185.699, 234.357]),
        4: np.array([13.971, 28.746, 48.826, 73.364, 103.414, 139.529, 180.062, 227.532]),
        5: np.array([13.329, 27.769, 47.133, 71.439, 100.261, 135.931, 176.113, 222.930])
    }
}

# Cumulative frequency
CV_FOURIER_TRACE_CUMULATIVE_EXT = {
    1: {
        1: np.array([13.703, 28.447, 47.119, 70.480, 98.527, 132.319, 170.753, 214.582]),
        2: np.array([19.548, 38.342, 61.598, 89.729, 122.956, 161.907, 205.609, 254.866]),
        3: np.array([25.505, 48.275, 75.414, 108.950, 146.853, 192.098, 240.077, 295.206]),
        4: np.array([31.263, 58.495, 89.382, 128.623, 172.685, 222.315, 277.490, 336.049]),
        5: np.array([35.989, 68.189, 105.094, 148.180, 197.220, 251.807, 313.082, 379.463])
    },
    2: {
        1: np.array([18.172, 36.368, 57.995, 84.218, 114.957, 151.277, 191.997, 237.819]),
        2: np.array([24.652, 47.900, 75.394, 107.071, 142.894, 183.965, 230.907, 282.249]),
        3: np.array([31.258, 59.996, 92.695, 130.321, 172.256, 217.533, 269.745, 327.729]),
        4: np.array([37.596, 72.184, 110.387, 153.219, 201.261, 252.884, 310.388, 373.675]),
        5: np.array([43.847, 84.623, 128.324, 176.137, 229.613, 287.270, 351.627, 421.029])
    },
    3: {
        1: np.array([14.649, 29.687, 49.350, 72.737, 100.815, 133.126, 170.062, 210.562]),
        2: np.array([19.939, 38.986, 62.943, 91.131, 123.612, 160.954, 202.269, 247.611]),
        3: np.array([25.737, 49.241, 76.960, 110.179, 147.973, 189.559, 236.357, 287.495]),
        4: np.array([31.248, 58.803, 91.438, 128.517, 171.394, 217.895, 268.986, 326.326]),
        5: np.array([36.438, 69.063, 105.884, 147.869, 195.106, 246.480, 303.363, 364.899])
    },
    4: {
        1: np.array([19.147, 37.763, 59.724, 86.185, 116.758, 151.298, 189.563, 233.257]),
        2: np.array([25.709, 49.893, 76.938, 108.308, 143.976, 182.964, 226.308, 274.477]),
        3: np.array([31.710, 61.252, 93.693, 130.465, 170.552, 215.205, 263.488, 316.319]),
        4: np.array([37.917, 72.817, 111.053, 152.003, 197.800, 247.788, 301.601, 359.470]),
        5: np.array([43.925, 84.642, 127.695, 174.955, 225.235, 280.043, 339.052, 403.589])
    }
}


# =============================================================================
# SC-VECM CRITICAL VALUES
# =============================================================================

# Critical values for trace test without breaks (with trend)
CV_SCVECM_NO_BREAK = np.array([11.417, 23.453, 40.093, 60.511, 84.266, 113.479, 148.181, 181.694])

# Critical values for trace test with breaks at different break fractions
# Rows: break fraction (0.20, 0.25, ..., 0.80)
# Columns: n-r = 1 to 8
CV_SCVECM_BREAK = np.array([
    [18.238, 35.592, 54.792, 80.841, 109.971, 144.105, 181.728, 221.975],  # 0.20
    [18.675, 35.496, 56.462, 82.441, 111.072, 145.295, 183.790, 224.711],  # 0.25
    [19.060, 36.346, 58.111, 83.015, 112.578, 146.397, 183.065, 225.524],  # 0.30
    [18.953, 37.514, 58.143, 84.500, 113.961, 148.633, 185.059, 226.288],  # 0.35
    [19.052, 37.772, 59.125, 83.779, 114.942, 147.862, 183.674, 228.352],  # 0.40
    [19.386, 37.161, 60.049, 85.043, 114.669, 147.522, 184.661, 228.268],  # 0.45
    [19.433, 37.630, 59.589, 85.410, 115.677, 149.247, 186.269, 227.513],  # 0.50
    [19.151, 37.473, 60.148, 84.451, 114.448, 148.469, 186.010, 228.331],  # 0.55
    [19.188, 38.139, 59.113, 84.792, 114.127, 147.147, 186.128, 226.948],  # 0.60
    [18.810, 37.276, 57.609, 84.144, 113.760, 147.268, 184.999, 224.648],  # 0.65
    [19.047, 36.215, 57.709, 83.754, 113.414, 146.012, 183.213, 226.712],  # 0.70
    [18.334, 36.155, 56.317, 82.000, 111.022, 145.528, 183.468, 225.314],  # 0.75
    [17.886, 35.112, 55.102, 81.178, 109.589, 143.111, 179.543, 222.283]   # 0.80
])

# Break fraction values corresponding to rows
SCVECM_BREAK_FRACTIONS = np.array([0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 
                                    0.55, 0.60, 0.65, 0.70, 0.75, 0.80])


# =============================================================================
# UNION TEST SCALE VALUES
# =============================================================================

# Scale values for union test at T=100
# Dict keys: (n_vars, freq, lambda_loc)
# Values: [10%, 5%, 1%] scale factors
UNION_SCALE_T100 = {
    # lambda = 0.25
    (2, 1, 0.25): [1.090, 1.082, 1.063],
    (2, 2, 0.25): [1.093, 1.077, 1.050],
    (2, 3, 0.25): [1.085, 1.075, 1.060],
    (3, 1, 0.25): [1.067, 1.058, 1.047],
    (3, 2, 0.25): [1.065, 1.058, 1.039],
    (3, 3, 0.25): [1.065, 1.055, 1.045],
    (4, 1, 0.25): [1.053, 1.045, 1.043],
    (4, 2, 0.25): [1.050, 1.044, 1.037],
    (4, 3, 0.25): [1.048, 1.041, 1.034],
    (5, 1, 0.25): [1.045, 1.039, 1.029],
    (5, 2, 0.25): [1.043, 1.038, 1.028],
    (5, 3, 0.25): [1.041, 1.037, 1.028],
    (6, 1, 0.25): [1.036, 1.032, 1.031],
    (6, 2, 0.25): [1.036, 1.031, 1.025],
    (6, 3, 0.25): [1.034, 1.031, 1.022],
    # lambda = 0.50
    (2, 1, 0.50): [1.084, 1.074, 1.062],
    (2, 2, 0.50): [1.087, 1.072, 1.063],
    (2, 3, 0.50): [1.089, 1.076, 1.061],
    (3, 1, 0.50): [1.064, 1.059, 1.052],
    (3, 2, 0.50): [1.062, 1.056, 1.044],
    (3, 3, 0.50): [1.060, 1.053, 1.037],
    (4, 1, 0.50): [1.051, 1.047, 1.034],
    (4, 2, 0.50): [1.050, 1.042, 1.035],
    (4, 3, 0.50): [1.049, 1.042, 1.033],
    (5, 1, 0.50): [1.042, 1.038, 1.031],
    (5, 2, 0.50): [1.040, 1.036, 1.031],
    (5, 3, 0.50): [1.041, 1.035, 1.031],
    (6, 1, 0.50): [1.036, 1.034, 1.026],
    (6, 2, 0.50): [1.036, 1.031, 1.025],
    (6, 3, 0.50): [1.033, 1.031, 1.026],
    # lambda = 0.75
    (2, 1, 0.75): [1.087, 1.080, 1.062],
    (2, 2, 0.75): [1.087, 1.079, 1.055],
    (2, 3, 0.75): [1.086, 1.078, 1.054],
    (3, 1, 0.75): [1.068, 1.060, 1.048],
    (3, 2, 0.75): [1.062, 1.055, 1.046],
    (3, 3, 0.75): [1.063, 1.061, 1.042],
    (4, 1, 0.75): [1.052, 1.046, 1.042],
    (4, 2, 0.75): [1.053, 1.046, 1.034],
    (4, 3, 0.75): [1.050, 1.042, 1.038],
    (5, 1, 0.75): [1.043, 1.038, 1.036],
    (5, 2, 0.75): [1.042, 1.036, 1.028],
    (5, 3, 0.75): [1.040, 1.036, 1.027],
    (6, 1, 0.75): [1.037, 1.033, 1.026],
    (6, 2, 0.75): [1.035, 1.032, 1.027],
    (6, 3, 0.75): [1.035, 1.033, 1.022],
}

# Scale values for union test at T=400
UNION_SCALE_T400 = {
    # lambda = 0.25
    (2, 1, 0.25): [1.080, 1.081, 1.059],
    (2, 2, 0.25): [1.089, 1.073, 1.063],
    (2, 3, 0.25): [1.085, 1.075, 1.056],
    (3, 1, 0.25): [1.060, 1.054, 1.046],
    (3, 2, 0.25): [1.063, 1.056, 1.041],
    (3, 3, 0.25): [1.062, 1.047, 1.042],
    (4, 1, 0.25): [1.049, 1.047, 1.033],
    (4, 2, 0.25): [1.046, 1.046, 1.029],
    (4, 3, 0.25): [1.046, 1.047, 1.038],
    (5, 1, 0.25): [1.038, 1.036, 1.027],
    (5, 2, 0.25): [1.039, 1.033, 1.029],
    (5, 3, 0.25): [1.038, 1.034, 1.029],
    (6, 1, 0.25): [1.030, 1.031, 1.024],
    (6, 2, 0.25): [1.033, 1.030, 1.029],
    (6, 3, 0.25): [1.036, 1.031, 1.022],
    # lambda = 0.50
    (2, 1, 0.50): [1.084, 1.071, 1.051],
    (2, 2, 0.50): [1.082, 1.072, 1.060],
    (2, 3, 0.50): [1.081, 1.071, 1.063],
    (3, 1, 0.50): [1.062, 1.055, 1.047],
    (3, 2, 0.50): [1.056, 1.055, 1.043],
    (3, 3, 0.50): [1.061, 1.051, 1.045],
    (4, 1, 0.50): [1.048, 1.042, 1.032],
    (4, 2, 0.50): [1.046, 1.044, 1.037],
    (4, 3, 0.50): [1.048, 1.044, 1.031],
    (5, 1, 0.50): [1.038, 1.036, 1.025],
    (5, 2, 0.50): [1.041, 1.032, 1.034],
    (5, 3, 0.50): [1.038, 1.034, 1.034],
    (6, 1, 0.50): [1.033, 1.028, 1.025],
    (6, 2, 0.50): [1.032, 1.029, 1.022],
    (6, 3, 0.50): [1.034, 1.030, 1.026],
    # lambda = 0.75
    (2, 1, 0.75): [1.093, 1.080, 1.051],
    (2, 2, 0.75): [1.083, 1.076, 1.068],
    (2, 3, 0.75): [1.085, 1.075, 1.067],
    (3, 1, 0.75): [1.062, 1.052, 1.046],
    (3, 2, 0.75): [1.065, 1.054, 1.040],
    (3, 3, 0.75): [1.062, 1.052, 1.040],
    (4, 1, 0.75): [1.049, 1.048, 1.033],
    (4, 2, 0.75): [1.046, 1.043, 1.032],
    (4, 3, 0.75): [1.049, 1.041, 1.027],
    (5, 1, 0.75): [1.038, 1.043, 1.030],
    (5, 2, 0.75): [1.037, 1.036, 1.030],
    (5, 3, 0.75): [1.038, 1.036, 1.032],
    (6, 1, 0.75): [1.033, 1.029, 1.029],
    (6, 2, 0.75): [1.031, 1.030, 1.024],
    (6, 3, 0.75): [1.033, 1.029, 1.024],
}


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def get_johansen_cv(model: int, n_vars: int) -> float:
    """
    Get critical value for standard Johansen trace test.
    
    Parameters
    ----------
    model : int
        Model type (1-5)
    n_vars : int
        Number of variables (1-6)
        
    Returns
    -------
    float
        Critical value at 5% level
    """
    if model not in CV_JOHANSEN_TRACE:
        raise ValueError(f"Model must be 1-5, got {model}")
    if n_vars < 1 or n_vars > 6:
        raise ValueError(f"n_vars must be 1-6, got {n_vars}")
    
    return CV_JOHANSEN_TRACE[model][n_vars - 1]


def get_fourier_trace_cv(model: int, freq: int, n_vars: int, option: int = 1) -> float:
    """
    Get critical value for Fourier trace test.
    
    Parameters
    ----------
    model : int
        Model type (1-4)
    freq : int
        Frequency (1-5)
    n_vars : int
        Number of variables (1-5)
    option : int
        1 = Single frequency, 2 = Cumulative frequency
        
    Returns
    -------
    float
        Critical value at 5% level
    """
    if freq < 1 or freq > 5:
        raise ValueError(f"Frequency must be 1-5, got {freq}")
    if n_vars < 1 or n_vars > 5:
        raise ValueError(f"n_vars must be 1-5, got {n_vars}")
    
    if option == 1:
        cv_table = CV_FOURIER_TRACE_SINGLE
    else:
        cv_table = CV_FOURIER_TRACE_CUMULATIVE
    
    if model not in cv_table:
        raise ValueError(f"Model must be 1-4, got {model}")
    
    return cv_table[model][freq - 1, n_vars - 1]


def get_fourier_lambda_cv(model: int, freq: int, n_vars: int, option: int = 1) -> float:
    """
    Get critical value for Fourier lambda-max test.
    
    Parameters
    ----------
    model : int
        Model type (1-4)
    freq : int
        Frequency (1-5)
    n_vars : int
        Number of variables (1-5)
    option : int
        1 = Single frequency, 2 = Cumulative frequency
        
    Returns
    -------
    float
        Critical value at 5% level
    """
    if freq < 1 or freq > 5:
        raise ValueError(f"Frequency must be 1-5, got {freq}")
    if n_vars < 1 or n_vars > 5:
        raise ValueError(f"n_vars must be 1-5, got {n_vars}")
    
    if option == 1:
        cv_table = CV_FOURIER_LAMBDA_SINGLE
    else:
        cv_table = CV_FOURIER_LAMBDA_CUMULATIVE
    
    if model not in cv_table:
        raise ValueError(f"Model must be 1-4, got {model}")
    
    return cv_table[model][freq - 1, n_vars - 1]


def get_scvecm_cv(break_fraction: float, n_minus_r: int, has_break: bool = True) -> float:
    """
    Get critical value for SC-VECM test.
    
    Parameters
    ----------
    break_fraction : float
        Break location as fraction of sample (0.2-0.8)
    n_minus_r : int
        Number of variables minus rank (1-8)
    has_break : bool
        Whether model has a break
        
    Returns
    -------
    float
        Critical value at 5% level
    """
    if n_minus_r < 1 or n_minus_r > 8:
        raise ValueError(f"n_minus_r must be 1-8, got {n_minus_r}")
    
    if not has_break:
        return CV_SCVECM_NO_BREAK[n_minus_r - 1]
    
    # Find closest break fraction
    idx = np.argmin(np.abs(SCVECM_BREAK_FRACTIONS - break_fraction))
    return CV_SCVECM_BREAK[idx, n_minus_r - 1]


def get_union_scale(n_vars: int, freq: int, lambda_loc: float, 
                    T: int, alpha: float = 0.05) -> float:
    """
    Get scale value for union test.
    
    Parameters
    ----------
    n_vars : int
        Number of variables (2-6)
    freq : int
        Frequency (1-3)
    lambda_loc : float
        Break location fraction (0.25, 0.50, or 0.75)
    T : int
        Sample size
    alpha : float
        Significance level (0.01, 0.05, or 0.10)
        
    Returns
    -------
    float
        Scale factor for critical values
    """
    # Determine alpha index
    if alpha == 0.10:
        alpha_idx = 0
    elif alpha == 0.05:
        alpha_idx = 1
    elif alpha == 0.01:
        alpha_idx = 2
    else:
        alpha_idx = 1  # Default to 5%
    
    # Find closest lambda_loc
    lambda_options = [0.25, 0.50, 0.75]
    closest_lambda = min(lambda_options, key=lambda x: abs(x - lambda_loc))
    
    key = (min(n_vars, 6), min(freq, 3), closest_lambda)
    
    # Choose table based on sample size
    scale_table = UNION_SCALE_T400 if T >= 200 else UNION_SCALE_T100
    
    if key in scale_table:
        return scale_table[key][alpha_idx]
    else:
        # Fallback to default scale
        return 1.05
