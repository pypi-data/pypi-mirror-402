from pydantic import BaseModel, Field, field_validator
from typing import Any, Dict, List, Optional, Tuple
import numpy as np
import torch

class cfgAMG(BaseModel):
    """Configuration for SAM2 Automatic Mask Generator."""
    
    npoints: int = Field(gt=0, default=32, description="Number of points to sample")
    points_per_batch: int = Field(gt=0, default=64)
    pred_iou_thresh: float = Field(gt=0, le=1.0, default=0.7)
    stability_score_thresh: float = Field(ge=0, le=1.0, default=0.92)
    stability_score_offset: float = Field(default=0.7)
    crop_n_layers: int = Field(ge=0, default=2)
    box_nms_thresh: float = Field(gt=0, le=1.0, default=0.7)
    crop_n_points_downscale_factor: int = Field(gt=0, default=2)
    use_m2m: bool = Field(default=True)
    multimask_output: bool = Field(default=True)
    sam2_cfg: str  = Field(default='small')
    
    @field_validator('sam2_cfg')
    @classmethod
    def validate_sam2_cfg(cls, v: str) -> str:
        """Validate SAM2 config string is a known config."""
        valid_configs = ['tiny', 'small', 'base', 'large']
        if v not in valid_configs:
            raise ValueError(f"sam2_cfg must be one of {valid_configs}, got {v}")
        return v
    
    def dict(self, *args: Any, **kwargs: Any) -> Dict[str, Any]:
        """
        Pydantic-style dict export, backed by model_dump for Pydantic v2.
        Accepts the same arguments as BaseModel.dict/model_dump.
        """
        return self.model_dump(*args, **kwargs)
    
    def to_dict(self, *args: Any, **kwargs: Any) -> Dict[str, Any]:
        """Convert to dictionary for SAM2 (wrapper around .dict())."""
        return self.dict(*args, **kwargs)

class MaskFilteringUtils:
    """
    MIT Licensed utilities for post-processing and filtering masks.
    These utilities can be applied to masks generated by any segmentation model.
    """
    
    @staticmethod
    def filter_masks_by_relative_box_size(
        mask_annotations: List[Dict[str, Any]],
        max_rel_box_size: Optional[float] = None,
        min_rel_box_size: Optional[float] = None,
        image_height: int = None,
        image_width: int = None
    ) -> List[Dict[str, Any]]:
        """
        Filter mask annotations based on relative bounding box size.
        
        Args:
            mask_annotations: List of mask dictionaries from automatic mask generator
            max_rel_box_size: Maximum relative box size (as fraction of image dimensions)
            min_rel_box_size: Minimum relative box size (as fraction of image dimensions)
            image_height: Height of the source image
            image_width: Width of the source image
            
        Returns:
            Filtered list of mask annotations
        """
        if max_rel_box_size is None and min_rel_box_size is None:
            return mask_annotations
            
        if image_height is None or image_width is None:
            raise ValueError("image_height and image_width must be provided for relative size filtering")
        
        filtered_annotations = []
        
        for ann in mask_annotations:
            # Extract bbox in XYWH format
            bbox = ann.get('bbox', None)
            if bbox is None:
                continue
                
            x, y, w, h = bbox
            
            # Calculate relative sizes
            rel_width = w / image_width
            rel_height = h / image_height
            
            # Apply size filters
            width_ok = True
            height_ok = True
            
            if max_rel_box_size is not None:
                width_ok = width_ok and (rel_width < max_rel_box_size)
                height_ok = height_ok and (rel_height < max_rel_box_size)
                
            if min_rel_box_size is not None:
                width_ok = width_ok and (rel_width > min_rel_box_size)
                height_ok = height_ok and (rel_height > min_rel_box_size)
            
            if width_ok and height_ok:
                filtered_annotations.append(ann)
                
        return filtered_annotations
    
    @staticmethod
    def filter_masks_by_area(
        mask_annotations: List[Dict[str, Any]],
        min_area: Optional[int] = None,
        max_area: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Filter mask annotations based on absolute area.
        
        Args:
            mask_annotations: List of mask dictionaries
            min_area: Minimum area in pixels
            max_area: Maximum area in pixels
            
        Returns:
            Filtered list of mask annotations
        """
        if min_area is None and max_area is None:
            return mask_annotations
            
        filtered_annotations = []
        
        for ann in mask_annotations:
            area = ann.get('area', 0)
            
            area_ok = True
            if min_area is not None:
                area_ok = area_ok and (area >= min_area)
            if max_area is not None:
                area_ok = area_ok and (area <= max_area)
                
            if area_ok:
                filtered_annotations.append(ann)
                
        return filtered_annotations
    
    @staticmethod
    def filter_masks_by_score(
        mask_annotations: List[Dict[str, Any]],
        min_predicted_iou: Optional[float] = None,
        min_stability_score: Optional[float] = None
    ) -> List[Dict[str, Any]]:
        """
        Filter mask annotations based on quality scores.
        
        Args:
            mask_annotations: List of mask dictionaries
            min_predicted_iou: Minimum predicted IoU threshold
            min_stability_score: Minimum stability score threshold
            
        Returns:
            Filtered list of mask annotations
        """
        filtered_annotations = []
        
        for ann in mask_annotations:
            iou_ok = True
            stability_ok = True
            
            if min_predicted_iou is not None:
                predicted_iou = ann.get('predicted_iou', 0.0)
                iou_ok = predicted_iou >= min_predicted_iou
                
            if min_stability_score is not None:
                stability_score = ann.get('stability_score', 0.0)
                stability_ok = stability_score >= min_stability_score
                
            if iou_ok and stability_ok:
                filtered_annotations.append(ann)
                
        return filtered_annotations


class FilteredSAM2MaskGenerator:
    """
    MIT Licensed wrapper that enhances any automatic mask generator with additional
    filtering capabilities. Uses composition to avoid license mixing.
    """
    
    def __init__(
        self,
        base_generator,
        min_rel_box_size: Optional[float] = None,
        max_rel_box_size: Optional[float] = None,
        min_area_filter: Optional[int] = None,
        max_area_filter: Optional[int] = None,
    ):
        """
        Initialize the enhanced mask generator.
        
        Args:
            base_generator: Any mask generator with a .generate(image) method
            min_rel_box_size: Minimum relative box size filter
            max_rel_box_size: Maximum relative box size filter
            min_area_filter: Minimum area filter (pixels)
        """
        self.base_generator = base_generator
        self.max_rel_box_size = max_rel_box_size
        self.min_rel_box_size = min_rel_box_size
        self.min_area_filter = min_area_filter
        self.max_area_filter = max_area_filter
        self.filter_utils = MaskFilteringUtils()
    
    def generate(self, image: np.ndarray) -> List[Dict[str, Any]]:
        """
        Generate masks with enhanced filtering.
        
        Args:
            image: Input image as numpy array (HWC format)
            
        Returns:
            List of filtered mask annotations
        """
        # Generate masks using the base generator
        mask_annotations = self.base_generator.generate(image)
        
        # Get image dimensions for relative size filtering
        image_height, image_width = image.shape[:2]
        
        # Apply filtering in sequence
        filtered_masks = mask_annotations
        
        # Filter by relative box size
        if self.max_rel_box_size is not None or self.min_rel_box_size is not None:
            filtered_masks = self.filter_utils.filter_masks_by_relative_box_size(
                filtered_masks,
                max_rel_box_size=self.max_rel_box_size,
                min_rel_box_size=self.min_rel_box_size,
                image_height=image_height,
                image_width=image_width
            )
        
        # Filter by area
        if self.min_area_filter is not None or self.max_area_filter is not None:
            filtered_masks = self.filter_utils.filter_masks_by_area(
                filtered_masks,
                min_area=self.min_area_filter,
                max_area=self.max_area_filter
            )
        
        return filtered_masks
    
    def set_filters(
        self,
        min_rel_box_size: Optional[float] = None,
        max_rel_box_size: Optional[float] = None,
        min_area_filter: Optional[int] = None,
    ):
        """
        Update filter parameters after initialization.
        """
        if min_rel_box_size is not None:
            self.min_rel_box_size = min_rel_box_size        
        if max_rel_box_size is not None:
            self.max_rel_box_size = max_rel_box_size
        if min_area_filter is not None:
            self.min_area_filter = min_area_filter
    
    # Delegate any other methods to the base generator
    def __getattr__(self, name):
        """Delegate unknown attributes to the base generator."""
        return getattr(self.base_generator, name)
