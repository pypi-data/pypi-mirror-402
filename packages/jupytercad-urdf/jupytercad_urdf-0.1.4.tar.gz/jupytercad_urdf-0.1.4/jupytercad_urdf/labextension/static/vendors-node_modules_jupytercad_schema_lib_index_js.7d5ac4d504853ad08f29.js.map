{"version":3,"file":"vendors-node_modules_jupytercad_schema_lib_index_js.7d5ac4d504853ad08f29.js","mappings":";;;;;;;;;;;;;AAAO;;;;;;;;;;;;;;;;;;;;;;;;ACAmC;AACE;AACD;AAClB;AAC6B;AAC/C,4BAA4B,oDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sDAAO;AAC7C,yBAAyB;AACzB,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,4CAA4C,uBAAuB;AACnE;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qDAAM;AAC1C,mCAAmC,qDAAM;AACzC,mCAAmC,qDAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAc;AAC7B;AACA;AACA,8CAA8C,sDAAO;AACrD;AACA;AACA;AACA,eAAe,sDAAO;AACtB;AACA;AACA,eAAe,sDAAO;AACtB;AACA;AACA,eAAe,sDAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oCAAK;AAC7C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oCAAK;AACjD;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvR6B;AACL;AACA;AACF;AACgC;;;;;;;;;;;;;;;;;ACJtD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA,CAAC,8DAA8D;;;;;;;;;;;;;;;;;;;;;AC1BpB;AACrB;AACgB;AACM;AAC5C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAM;AACtC,6BAA6B,qDAAM;AACnC,mCAAmC,qDAAM;AACzC,iCAAiC,qDAAM;AACvC,iCAAiC,qDAAM;AACvC,uCAAuC,qDAAM;AAC7C,0CAA0C,qDAAM;AAChD,yCAAyC,qDAAM;AAC/C,yCAAyC,qDAAM;AAC/C,uCAAuC,qDAAM;AAC7C,gBAAgB,gDAAgD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAM;AACtC,oCAAoC,qDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iCAAiC;AAC9D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAG;AAC3B,qCAAqC,8CAAU;AAC/C;AACA;AACA;AACA;AACA,8BAA8B,SAAS,IAAI,oBAAoB,EAAE,cAAc;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG;AACnG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,oDAAoD;AACpD;AACA;AACA,eAAe,+CAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1V0C;AACnC,kCAAkC,oDAAK;AACvC,6BAA6B,oDAAK;AAClC,qCAAqC,oDAAK;AAC1C,yCAAyC,oDAAK;AAC9C,8CAA8C,oDAAK","sources":["webpack://@jupytercad/jupytercad-urdf/./node_modules/@jupytercad/schema/lib/_interface/version.js","webpack://@jupytercad/jupytercad-urdf/./node_modules/@jupytercad/schema/lib/doc.js","webpack://@jupytercad/jupytercad-urdf/./node_modules/@jupytercad/schema/lib/index.js","webpack://@jupytercad/jupytercad-urdf/./node_modules/@jupytercad/schema/lib/interfaces.js","webpack://@jupytercad/jupytercad-urdf/./node_modules/@jupytercad/schema/lib/model.js","webpack://@jupytercad/jupytercad-urdf/./node_modules/@jupytercad/schema/lib/token.js"],"sourcesContent":["export const SCHEMA_VERSION = '3.0.0';\n","import { YDocument } from '@jupyter/ydoc';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport * as Y from 'yjs';\nimport { SCHEMA_VERSION } from './_interface/version';\nexport class JupyterCadDoc extends YDocument {\n    constructor() {\n        super();\n        this.editable = true;\n        this._objectsObserver = (events) => {\n            const changes = [];\n            let needEmit = false;\n            events.forEach(event => {\n                const name = event.target.get('name');\n                if (name) {\n                    event.keys.forEach((change, key) => {\n                        if (!needEmit && key !== 'shapeMetadata') {\n                            needEmit = true;\n                        }\n                        changes.push({\n                            name,\n                            key: key,\n                            newValue: JSONExt.deepCopy(event.target.toJSON())\n                        });\n                    });\n                }\n            });\n            needEmit = changes.length === 0 ? true : needEmit;\n            if (needEmit) {\n                this._objectsChanged.emit({ objectChange: changes });\n            }\n            this._changed.emit({ objectChange: changes });\n        };\n        this._metaObserver = (event) => {\n            this._metadataChanged.emit(event.keys);\n        };\n        this._optionsObserver = (event) => {\n            this._optionsChanged.emit(event.keys);\n        };\n        this._metadataChanged = new Signal(this);\n        this._optionsChanged = new Signal(this);\n        this._objectsChanged = new Signal(this);\n        this._options = this.ydoc.getMap('options');\n        this._objects = this.ydoc.getArray('objects');\n        this._metadata = this.ydoc.getMap('metadata');\n        this._outputs = this.ydoc.getMap('outputs');\n        this.undoManager.addToScope(this._objects);\n        this._objects.observeDeep(this._objectsObserver);\n        this._metadata.observe(this._metaObserver);\n        this._options.observe(this._optionsObserver);\n    }\n    dispose() {\n        super.dispose();\n    }\n    get version() {\n        return SCHEMA_VERSION;\n    }\n    get objects() {\n        const objs = this._objects.map(obj => JSONExt.deepCopy(obj.toJSON()));\n        return objs;\n    }\n    get options() {\n        return JSONExt.deepCopy(this._options.toJSON());\n    }\n    get metadata() {\n        return JSONExt.deepCopy(this._metadata.toJSON());\n    }\n    get outputs() {\n        return JSONExt.deepCopy(this._outputs.toJSON());\n    }\n    get objectsChanged() {\n        return this._objectsChanged;\n    }\n    get optionsChanged() {\n        return this._optionsChanged;\n    }\n    getSource() {\n        const objects = this._objects.toJSON();\n        const options = this._options.toJSON();\n        const metadata = this._metadata.toJSON();\n        const outputs = this._outputs.toJSON();\n        return { objects, options, metadata, outputs };\n    }\n    setSource(source) {\n        if (!source) {\n            return;\n        }\n        let value;\n        if (typeof source === 'string') {\n            value = JSON.parse(source);\n        }\n        else {\n            value = source;\n        }\n        this.transact(() => {\n            var _a, _b, _c, _d;\n            const objects = ((_a = value['objects']) !== null && _a !== void 0 ? _a : []);\n            objects.forEach(obj => {\n                this._objects.push([new Y.Map(Object.entries(obj))]);\n            });\n            const options = (_b = value['options']) !== null && _b !== void 0 ? _b : {};\n            Object.entries(options).forEach(([key, val]) => this._options.set(key, val));\n            const metadata = (_c = value['metadata']) !== null && _c !== void 0 ? _c : {};\n            Object.entries(metadata).forEach(([key, val]) => this._metadata.set(key, val));\n            const outputs = (_d = value['outputs']) !== null && _d !== void 0 ? _d : {};\n            Object.entries(outputs).forEach(([key, val]) => this._outputs.set(key, val));\n        });\n    }\n    get metadataChanged() {\n        return this._metadataChanged;\n    }\n    objectExists(name) {\n        return Boolean(this._getObjectAsYMapByName(name));\n    }\n    getObjectByName(name) {\n        const obj = this._getObjectAsYMapByName(name);\n        if (obj) {\n            return JSONExt.deepCopy(obj.toJSON());\n        }\n        return undefined;\n    }\n    getDependants(name) {\n        const dependants = [];\n        const dependantMap = new Map();\n        for (const obj of this._objects) {\n            const deps = obj.get('dependencies') || [];\n            const objName = obj.get('name');\n            deps.forEach(dep => {\n                const currentSet = dependantMap.get(dep);\n                if (currentSet) {\n                    currentSet.add(objName);\n                }\n                else {\n                    dependantMap.set(dep, new Set([objName]));\n                }\n            });\n        }\n        const selectedDeps = dependantMap.get(name);\n        if (!selectedDeps) {\n            return [];\n        }\n        while (selectedDeps.size) {\n            const depsList = [...selectedDeps];\n            depsList.forEach(it => {\n                var _a;\n                dependants.push(it);\n                selectedDeps.delete(it);\n                (_a = dependantMap.get(it)) === null || _a === void 0 ? void 0 : _a.forEach(newIt => selectedDeps.add(newIt));\n            });\n        }\n        return dependants;\n    }\n    removeObjects(names) {\n        this.transact(() => {\n            for (const name of names) {\n                this.removeObjectByName(name);\n            }\n        });\n    }\n    removeObjectByName(name) {\n        // Get object index\n        let index = 0;\n        for (const obj of this._objects) {\n            if (obj.get('name') === name) {\n                break;\n            }\n            index++;\n        }\n        if (this._objects.length > index) {\n            this._objects.delete(index);\n            this.removeOutput(name);\n        }\n    }\n    addObject(value) {\n        this.addObjects([value]);\n    }\n    addObjects(value) {\n        this.transact(() => {\n            value.map(obj => {\n                if (!this.objectExists(obj.name)) {\n                    this._objects.push([new Y.Map(Object.entries(obj))]);\n                }\n                else {\n                    console.error('There is already an object with the name:', obj.name);\n                }\n            });\n        });\n    }\n    updateObjectByName(name, payload) {\n        const obj = this._getObjectAsYMapByName(name);\n        if (!obj) {\n            return;\n        }\n        const { key, value } = payload.data;\n        this.transact(() => {\n            // Special case for changing parameters, we may need to update dependencies\n            if (key === 'parameters') {\n                switch (obj.get('shape')) {\n                    case 'Part::Cut': {\n                        obj.set('dependencies', [value['Base'], value['Tool']]);\n                        break;\n                    }\n                    case 'Part::Extrusion':\n                    case 'Part::Fillet':\n                    case 'Part::Chamfer': {\n                        obj.set('dependencies', [value['Base']]);\n                        break;\n                    }\n                    case 'Part::MultiCommon':\n                    case 'Part::MultiFuse': {\n                        obj.set('dependencies', value['Shapes']);\n                        break;\n                    }\n                    default:\n                        break;\n                }\n            }\n            obj.set(key, value);\n            if (payload.meta) {\n                obj.set('shapeMetadata', payload.meta);\n            }\n        });\n    }\n    getOption(key) {\n        const content = this._options.get(key);\n        if (!content) {\n            return;\n        }\n        return JSONExt.deepCopy(content);\n    }\n    setOption(key, value) {\n        this.transact(() => void this._options.set(key, value));\n    }\n    setOptions(options) {\n        this.transact(() => {\n            for (const [key, value] of Object.entries(options)) {\n                this._options.set(key, value);\n            }\n        });\n    }\n    getMetadata(key) {\n        return this._metadata.get(key);\n    }\n    setMetadata(key, value) {\n        this.transact(() => void this._metadata.set(key, value));\n    }\n    removeMetadata(key) {\n        if (this._metadata.has(key)) {\n            this._metadata.delete(key);\n        }\n    }\n    getOutput(key) {\n        return this._outputs.get(key);\n    }\n    setOutput(key, value) {\n        this.transact(() => void this._outputs.set(key, value));\n    }\n    removeOutput(key) {\n        if (this._outputs.has(key)) {\n            this._outputs.delete(key);\n        }\n    }\n    setShapeMeta(name, meta) {\n        const obj = this._getObjectAsYMapByName(name);\n        if (meta && obj) {\n            this.transact(() => void obj.set('shapeMetadata', meta));\n        }\n    }\n    static create() {\n        return new JupyterCadDoc();\n    }\n    _getObjectAsYMapByName(name) {\n        for (const obj of this._objects) {\n            if (obj.get('name') === name) {\n                return obj;\n            }\n        }\n        return undefined;\n    }\n}\n","export * from './interfaces';\nexport * from './model';\nexport * from './token';\nexport * from './doc';\nexport { SCHEMA_VERSION } from './_interface/version';\n","/**\n * Action definitions for worker\n */\nexport var WorkerAction;\n(function (WorkerAction) {\n    WorkerAction[\"DRY_RUN\"] = \"DRY_RUN\";\n    WorkerAction[\"LOAD_FILE\"] = \"LOAD_FILE\";\n    WorkerAction[\"SAVE_FILE\"] = \"SAVE_FILE\";\n    WorkerAction[\"REGISTER\"] = \"REGISTER\";\n    WorkerAction[\"POSTPROCESS\"] = \"POSTPROCESS\";\n})(WorkerAction || (WorkerAction = {}));\n/**\n * Action definitions for main thread\n */\nexport var MainAction;\n(function (MainAction) {\n    MainAction[\"DISPLAY_SHAPE\"] = \"DISPLAY_SHAPE\";\n    MainAction[\"INITIALIZED\"] = \"INITIALIZED\";\n    MainAction[\"DISPLAY_POST\"] = \"DISPLAY_POST\";\n    MainAction[\"DRY_RUN_RESPONSE\"] = \"DRY_RUN_RESPONSE\";\n})(MainAction || (MainAction = {}));\nexport var JCadWorkerSupportedFormat;\n(function (JCadWorkerSupportedFormat) {\n    JCadWorkerSupportedFormat[\"BREP\"] = \"BREP\";\n    JCadWorkerSupportedFormat[\"GLTF\"] = \"GLTF\";\n    JCadWorkerSupportedFormat[\"STL\"] = \"STL\";\n})(JCadWorkerSupportedFormat || (JCadWorkerSupportedFormat = {}));\n","import { Signal } from '@lumino/signaling';\nimport Ajv from 'ajv';\nimport { JupyterCadDoc } from './doc';\nimport jcadSchema from './schema/jcad.json';\nconst SETTINGS_ID = '@jupytercad/jupytercad-core:jupytercad-settings';\nexport class JupyterCadModel {\n    constructor(options) {\n        this.collaborative = true;\n        this._onSharedModelChanged = (sender, changes) => {\n            var _a;\n            if (changes && ((_a = changes === null || changes === void 0 ? void 0 : changes.objectChange) === null || _a === void 0 ? void 0 : _a.length)) {\n                this._contentChanged.emit(void 0);\n                this.dirty = true;\n            }\n        };\n        this._onClientStateChanged = changed => {\n            const clients = this.sharedModel.awareness.getStates();\n            this._clientStateChanged.emit(clients);\n            if (changed.added.length || changed.removed.length) {\n                this._userChanged.emit(this.users);\n            }\n        };\n        this.defaultKernelName = '';\n        this.defaultKernelLanguage = '';\n        this._dirty = false;\n        this._readOnly = false;\n        this._isDisposed = false;\n        this._jcadSettings = {\n            showAxesHelper: false,\n            cameraType: 'Perspective'\n        };\n        this._userChanged = new Signal(this);\n        this._disposed = new Signal(this);\n        this._contentChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._themeChanged = new Signal(this);\n        this._clientStateChanged = new Signal(this);\n        this._sharedMetadataChanged = new Signal(this);\n        this._sharedOptionsChanged = new Signal(this);\n        this._sharedObjectsChanged = new Signal(this);\n        this._sharedModelSwapped = new Signal(this);\n        const { annotationModel, sharedModel, settingRegistry } = options;\n        if (sharedModel) {\n            this._sharedModel = sharedModel;\n        }\n        else {\n            this._sharedModel = this.createSharedModel();\n        }\n        this._connectSignal();\n        this.annotationModel = annotationModel;\n        this.settingRegistry = settingRegistry;\n        this._copiedObject = null;\n        this._pathChanged = new Signal(this);\n        this._settingsChanged = new Signal(this);\n    }\n    /**\n     * Initialize custom settings for JupyterLab.\n     */\n    async initSettings() {\n        if (this.settingRegistry) {\n            try {\n                const setting = await this.settingRegistry.load(SETTINGS_ID);\n                this._settings = setting;\n                this._updateLocalSettings();\n                setting.changed.connect(this._onSettingsChanged, this);\n            }\n            catch (error) {\n                console.error(`Failed to load settings for ${SETTINGS_ID}:`, error);\n                this._jcadSettings = {\n                    showAxesHelper: false,\n                    cameraType: 'Perspective'\n                };\n            }\n        }\n        else {\n            this._jcadSettings = {\n                showAxesHelper: false,\n                cameraType: 'Perspective'\n            };\n        }\n    }\n    _onSettingsChanged() {\n        const oldSettings = this._jcadSettings;\n        this._updateLocalSettings();\n        const newSettings = this._jcadSettings;\n        if (oldSettings.showAxesHelper !== newSettings.showAxesHelper) {\n            this._settingsChanged.emit('showAxesHelper');\n        }\n        if (oldSettings.cameraType !== newSettings.cameraType) {\n            this._settingsChanged.emit('cameraType');\n        }\n    }\n    _updateLocalSettings() {\n        var _a, _b;\n        const composite = this._settings.composite;\n        this._jcadSettings = {\n            showAxesHelper: (_a = composite.showAxesHelper) !== null && _a !== void 0 ? _a : false,\n            cameraType: (_b = composite.cameraType) !== null && _b !== void 0 ? _b : 'Perspective'\n        };\n    }\n    get jcadSettings() {\n        return this._jcadSettings;\n    }\n    /**\n     * Expose the settingsChanged signal for external use.\n     */\n    get settingsChanged() {\n        return this._settingsChanged;\n    }\n    emitSettingChanged(settingName) {\n        this._settingsChanged.emit(settingName);\n    }\n    /**\n     * Return stored settings.\n     */\n    async getSettings() {\n        return this._settings;\n    }\n    get sharedModel() {\n        return this._sharedModel;\n    }\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    get contentChanged() {\n        return this._contentChanged;\n    }\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    get themeChanged() {\n        return this._themeChanged;\n    }\n    get currentUserId() {\n        var _a;\n        return (_a = this.sharedModel) === null || _a === void 0 ? void 0 : _a.awareness.clientID;\n    }\n    get users() {\n        var _a;\n        this._usersMap = (_a = this.sharedModel) === null || _a === void 0 ? void 0 : _a.awareness.getStates();\n        const users = [];\n        if (this._usersMap) {\n            this._usersMap.forEach((val, key) => {\n                users.push({ userId: key, userData: val.user });\n            });\n        }\n        return users;\n    }\n    get userChanged() {\n        return this._userChanged;\n    }\n    get dirty() {\n        return this._dirty;\n    }\n    set dirty(value) {\n        this._dirty = value;\n    }\n    get readOnly() {\n        return this._readOnly;\n    }\n    set readOnly(value) {\n        this._readOnly = value;\n    }\n    get localState() {\n        return this.sharedModel.awareness.getLocalState();\n    }\n    /**\n     * Getter for the contents manager.\n     */\n    get contentsManager() {\n        return this._contentsManager;\n    }\n    /**\n     * Setter for the contents manager.\n     * Also updates the file path.\n     */\n    set contentsManager(manager) {\n        this._contentsManager = manager;\n    }\n    get clientStateChanged() {\n        return this._clientStateChanged;\n    }\n    get sharedMetadataChanged() {\n        return this._sharedMetadataChanged;\n    }\n    get sharedOptionsChanged() {\n        return this._sharedOptionsChanged;\n    }\n    get sharedObjectsChanged() {\n        return this._sharedObjectsChanged;\n    }\n    get sharedModelSwapped() {\n        return this._sharedModelSwapped;\n    }\n    /**\n     * Getter for the file path associated with the contents manager.\n     */\n    get filePath() {\n        return this._filePath;\n    }\n    /**\n     * Setter for the file path associated with the contents manager.\n     */\n    set filePath(path) {\n        this._filePath = path;\n        this._pathChanged.emit(path);\n    }\n    get pathChanged() {\n        return this._pathChanged;\n    }\n    get disposed() {\n        return this._disposed;\n    }\n    swapSharedModel(newSharedModel) {\n        this._disconnectSignal();\n        this._sharedModel.dispose();\n        this._sharedModel = newSharedModel;\n        this._connectSignal();\n        this._sharedObjectsChanged.emit({ objectChange: [] });\n        this._sharedModelSwapped.emit();\n    }\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disconnectSignal();\n        this._sharedModel.dispose();\n        this._disposed.emit();\n        Signal.clearData(this);\n    }\n    toString() {\n        return JSON.stringify(this.getContent(), null, 2);\n    }\n    fromString(data) {\n        const jsonData = JSON.parse(data);\n        const ajv = new Ajv();\n        const validate = ajv.compile(jcadSchema);\n        const valid = validate(jsonData);\n        if (!valid) {\n            let errorMsg = 'JupyterCAD File format invalid:\\n';\n            for (const error of validate.errors || []) {\n                errorMsg = `${errorMsg}- ${error.instancePath} ${error.message}\\n`;\n            }\n            console.warn(errorMsg);\n        }\n        this.sharedModel.transact(() => {\n            var _a;\n            this.sharedModel.addObjects(jsonData.objects);\n            this.sharedModel.setOptions((_a = jsonData.options) !== null && _a !== void 0 ? _a : {});\n        });\n        this.dirty = true;\n    }\n    toJSON() {\n        return JSON.parse(this.toString());\n    }\n    fromJSON(data) {\n        // nothing to do\n    }\n    initialize() {\n        //\n    }\n    getWorker() {\n        return JupyterCadModel.worker;\n    }\n    getContent() {\n        return {\n            objects: this.sharedModel.objects,\n            options: this.sharedModel.options\n        };\n    }\n    getAllObject() {\n        return this.sharedModel.objects;\n    }\n    syncPointer(pointer, emitter) {\n        this.sharedModel.awareness.setLocalStateField('pointer', {\n            value: pointer,\n            emitter: emitter\n        });\n    }\n    syncCamera(camera, emitter) {\n        this.sharedModel.awareness.setLocalStateField('camera', {\n            value: camera,\n            emitter: emitter\n        });\n    }\n    syncSelected(value, emitter) {\n        this.sharedModel.awareness.setLocalStateField('selected', {\n            value,\n            emitter: emitter\n        });\n    }\n    syncSelectedPropField(data) {\n        this.sharedModel.awareness.setLocalStateField('selectedPropField', data);\n    }\n    setUserToFollow(userId) {\n        if (this.sharedModel) {\n            this.sharedModel.awareness.setLocalStateField('remoteUser', userId);\n        }\n    }\n    syncFormData(form) {\n        if (this.sharedModel) {\n            this.sharedModel.awareness.setLocalStateField('toolbarForm', form);\n        }\n    }\n    getClientId() {\n        return this.sharedModel.awareness.clientID;\n    }\n    addMetadata(key, value) {\n        this.sharedModel.setMetadata(key, value);\n    }\n    removeMetadata(key) {\n        this.sharedModel.removeMetadata(key);\n    }\n    setCopiedObject(object) {\n        this._copiedObject = object ? Object.assign({}, object) : null;\n    }\n    getCopiedObject() {\n        return this._copiedObject ? Object.assign({}, this._copiedObject) : null;\n    }\n    createSharedModel() {\n        return JupyterCadDoc.create();\n    }\n    _connectSignal() {\n        this._sharedModel.changed.connect(this._onSharedModelChanged);\n        this._sharedModel.awareness.on('change', this._onClientStateChanged);\n        this._sharedModel.metadataChanged.connect(this._metadataChangedHandler, this);\n        this._sharedModel.optionsChanged.connect(this._optionsChangedHandler, this);\n        this._sharedModel.objectsChanged.connect(this._objectsChangedHandler, this);\n    }\n    _disconnectSignal() {\n        this._sharedModel.changed.disconnect(this._onSharedModelChanged);\n        this._sharedModel.awareness.off('change', this._onClientStateChanged);\n        this._sharedModel.metadataChanged.disconnect(this._metadataChangedHandler, this);\n        this._sharedModel.optionsChanged.disconnect(this._optionsChangedHandler, this);\n        this._sharedModel.objectsChanged.disconnect(this._objectsChangedHandler, this);\n    }\n    _metadataChangedHandler(_, args) {\n        this._sharedMetadataChanged.emit(args);\n    }\n    _optionsChangedHandler(_, args) {\n        this._sharedOptionsChanged.emit(args);\n    }\n    _objectsChangedHandler(_, args) {\n        this._sharedObjectsChanged.emit(args);\n    }\n}\n","import { Token } from '@lumino/coreutils';\nexport const IJupyterCadDocTracker = new Token('jupyterCadDocTracker');\nexport const IAnnotationToken = new Token('jupytercadAnnotationModel');\nexport const IJCadWorkerRegistryToken = new Token('jupytercadWorkerRegistry');\nexport const IJCadFormSchemaRegistryToken = new Token('jupytercadFormSchemaRegistry');\nexport const IJCadExternalCommandRegistryToken = new Token('jupytercadExternalCommandRegistry');\n"],"names":[],"sourceRoot":""}