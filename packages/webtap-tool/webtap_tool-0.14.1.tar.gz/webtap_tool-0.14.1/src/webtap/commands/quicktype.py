"""Generate types and schemas from HTTP request/response bodies using quicktype.

Uses the quicktype CLI to generate TypeScript, Python, Go, and other type definitions
from JSON response bodies.
"""

import json
import shutil
import subprocess
from datetime import datetime
from pathlib import Path
from webtap.app import app
from webtap.commands._builders import success_response, error_response
from webtap.commands._code_generation import (
    ensure_output_directory,
    parse_json,
    extract_json_path,
    validate_generation_data,
)
from webtap.commands._utils import evaluate_expression, fetch_body_content
from webtap.commands._tips import get_mcp_description


mcp_desc = get_mcp_description("quicktype")

# Header template for generated files
HEADER_TEMPLATE = """Generated by WebTap from request {row_id}
Source: {url}
Method: {method}
Generated: {timestamp}

Do not edit manually."""

# Comment syntax per language
COMMENT_STYLES = {
    "TypeScript": "//",
    "Python": "#",
    "Go": "//",
    "Rust": "//",
    "Java": "//",
    "Kotlin": "//",
    "Swift": "//",
    "C#": "//",
    "C++": "//",
    "Dart": "//",
    "Ruby": "#",
    "JSON Schema": None,
}


def _run_quicktype(
    json_data: dict | list,
    output: str,
    type_name: str = None,  # pyright: ignore[reportArgumentType]
    just_types: bool = True,
    prefer_types: bool = True,
    options: dict = None,  # pyright: ignore[reportArgumentType]
) -> tuple[bool, str]:
    """Run quicktype CLI with given parameters.

    Returns:
        Tuple of (success: bool, error_message: str)
    """
    if not shutil.which("quicktype"):
        return False, "quicktype CLI not found. Install with: npm install -g quicktype"

    output_path = Path(output)
    ext = output_path.suffix.lower()

    cmd = ["quicktype", "-o", str(output), "--src-lang", "json", "--top-level", type_name]

    if just_types:
        cmd.append("--just-types")

    if ext in {".ts", ".tsx"} and prefer_types:
        cmd.append("--prefer-types")

    for key, val in (options or {}).items():
        flag = f"--{key.replace('_', '-')}"
        if val is True:
            cmd.append(flag)
        elif val is not False and val is not None:
            cmd.extend([flag, str(val)])

    try:
        subprocess.run(
            cmd,
            input=json.dumps(json_data, indent=2),
            capture_output=True,
            text=True,
            check=True,
            timeout=30,
        )
        return True, ""
    except subprocess.CalledProcessError as e:
        return False, f"quicktype failed: {e.stderr.strip() if e.stderr else str(e)}"
    except subprocess.TimeoutExpired:
        return False, "quicktype timed out (>30s)"
    except Exception as e:
        return False, f"Unexpected error: {str(e)}"


def _insert_header(row_id: int, har_entry: dict, output_path: Path, language: str) -> None:
    """Insert language-aware header comment into generated file.

    Args:
        row_id: HAR row ID for reference.
        har_entry: HAR entry with request metadata.
        output_path: Path to generated file.
        language: Target language (e.g., "TypeScript", "Python").
    """
    if not HEADER_TEMPLATE or language not in COMMENT_STYLES:
        return

    comment_prefix = COMMENT_STYLES[language]
    if not comment_prefix:
        return

    try:
        request = har_entry.get("request", {})
        metadata = {
            "row_id": row_id,
            "url": request.get("url", "N/A"),
            "method": request.get("method", "N/A"),
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        }

        header_text = HEADER_TEMPLATE.format(**metadata)
        header_lines = [
            f"{comment_prefix} {line}" if line.strip() else comment_prefix for line in header_text.split("\n")
        ]
        header = "\n".join(header_lines)

        content = output_path.read_text()
        output_path.write_text(header + "\n\n" + content)
    except Exception:
        pass


@app.command(
    display="markdown",
    typer={"enabled": False},
    fastmcp={"type": "tool", "mime_type": "text/markdown", "description": mcp_desc or ""},
)
def quicktype(
    state,
    id: int,
    output: str,
    type_name: str,
    field: str = "response.content",
    json_path: str = None,  # pyright: ignore[reportArgumentType]
    expr: str = None,  # pyright: ignore[reportArgumentType]
    just_types: bool = True,
    prefer_types: bool = True,
    options: dict = None,  # pyright: ignore[reportArgumentType]
) -> dict:  # pyright: ignore[reportArgumentType]
    """Generate types/schemas from request or response body using quicktype CLI.

    Args:
        id: Row ID from network() output
        output: Output file path (extension determines language: .ts, .py, .go, etc.)
        type_name: Top-level type name (e.g., "User", "ApiResponse")
        field: Body to use - "response.content" (default) or "request.postData"
        json_path: Optional JSON path to extract nested data (e.g., "data[0]")
        expr: Optional Python expression to transform data (has 'body' variable)
        just_types: Generate only types, no serializers (default: True)
        prefer_types: Use 'type' instead of 'interface' for TypeScript (default: True)
        options: Additional quicktype flags as dict

    Examples:
        quicktype(5, "types/User.ts", "User")
        quicktype(5, "models/customer.py", "Customer")
        quicktype(5, "api.go", "ApiResponse")
        quicktype(5, "types.ts", "User", json_path="data[0]")
        quicktype(5, "types/Form.ts", "Form", field="request.postData")
        quicktype(5, "types.ts", "User", options={"readonly": True})

    Returns:
        Success message with generation details
    """
    # Get HAR entry via RPC - need full entry with request_id for body fetch
    try:
        result = state.client.call("request", id=id, fields=["*"])
        har_entry = result.get("entry")
    except Exception as e:
        return error_response(f"Failed to get request: {e}")

    if not har_entry:
        return error_response(f"Request {id} not found")

    # Fetch body content
    body_content, err = fetch_body_content(state, har_entry, field)
    if err or body_content is None:
        return error_response(
            err or "Failed to fetch body",
            suggestions=[
                f"Field '{field}' could not be fetched",
                "For response body: field='response.content'",
                "For POST data: field='request.postData'",
            ],
        )

    # Transform via expression or parse as JSON
    if expr:
        try:
            namespace = {"body": body_content}
            data, _ = evaluate_expression(expr, namespace)
        except Exception as e:
            return error_response(
                f"Expression failed: {e}",
                suggestions=[
                    "Variable available: 'body' (str)",
                    "Example: json.loads(body)['data'][0]",
                    "Example: dict(urllib.parse.parse_qsl(body))",
                ],
            )
    else:
        if not body_content.strip():
            return error_response("Body is empty")

        data, parse_err = parse_json(body_content)
        if parse_err:
            return error_response(
                parse_err,
                suggestions=[
                    "Body must be valid JSON, or use expr to transform it",
                    'For form data: expr="dict(urllib.parse.parse_qsl(body))"',
                ],
            )

    # Extract nested path if specified
    if json_path:
        data, err = extract_json_path(data, json_path)
        if err:
            return error_response(
                err,
                suggestions=[
                    f"Path '{json_path}' not found in body",
                    'Try a simpler path like "data" or "data[0]"',
                ],
            )

    # Validate structure
    is_valid, validation_err = validate_generation_data(data)
    if not is_valid:
        return error_response(
            validation_err or "Invalid data structure",
            suggestions=[
                "Code generation requires dict or list structure",
                "Use json_path or expr to extract a complex object",
            ],
        )

    # Ensure output directory exists
    output_path = ensure_output_directory(output)

    # Run quicktype
    success, error_msg = _run_quicktype(
        json_data=data,
        output=str(output_path),
        type_name=type_name,
        just_types=just_types,
        prefer_types=prefer_types,
        options=options,
    )

    if not success:
        return error_response(
            error_msg,
            suggestions=[
                "Check that quicktype is installed: npm install -g quicktype",
                "Verify the JSON structure is valid",
                "Try simplifying with json_path",
            ],
        )

    # Detect language and insert header
    ext = output_path.suffix.lower()
    lang_map = {
        ".ts": "TypeScript",
        ".tsx": "TypeScript",
        ".py": "Python",
        ".go": "Go",
        ".rs": "Rust",
        ".java": "Java",
        ".kt": "Kotlin",
        ".swift": "Swift",
        ".cs": "C#",
        ".cpp": "C++",
        ".dart": "Dart",
        ".rb": "Ruby",
        ".json": "JSON Schema",
    }
    language = lang_map.get(ext, "Unknown")

    _insert_header(id, har_entry, output_path, language)

    # Count lines
    try:
        file_content = output_path.read_text()
        line_count = len(file_content.splitlines())
    except Exception:
        line_count = "unknown"

    return success_response(
        "Types generated successfully",
        details={
            "Output": str(output_path),
            "Language": language,
            "Type Name": type_name,
            "Lines": line_count,
            "Size": f"{output_path.stat().st_size} bytes",
        },
    )


__all__ = ["quicktype"]
