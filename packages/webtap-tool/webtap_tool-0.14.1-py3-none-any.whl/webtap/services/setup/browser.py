"""Browser wrapper script installation service (cross-platform).

PUBLIC API:
  - BrowserSetupService: Install browser wrappers for Chrome/Edge
"""

import logging
import os
from typing import Any

from .platform import (
    get_platform_info,
    ensure_directories,
    get_browser_info,
    find_browser_path,
    SUPPORTED_BROWSERS,
)

logger = logging.getLogger(__name__)

_LINUX_BINDFS_WRAPPER = """#!/bin/bash
# {browser_name} Debug Launcher for Linux (bindfs mode)
# Generated by webtap setup-browser --bindfs
# Mounts your real {browser_name} profile via bindfs for debugging with full session state

DEBUG_DIR="$HOME/.config/{config_dir}-debug"
REAL_DIR="$HOME/.config/{config_dir}"
PORT=${{WEBTAP_PORT:-9222}}
BROWSER_BIN="{browser_path}"

# Check if bindfs is installed
if ! command -v bindfs &>/dev/null; then
    echo "Error: bindfs not installed. Install with:" >&2
    echo "  Ubuntu/Debian: sudo apt install bindfs" >&2
    echo "  Arch: yay -S bindfs" >&2
    echo "  Fedora: sudo dnf install bindfs" >&2
    exit 1
fi

# Check if real browser profile exists
if [ ! -d "$REAL_DIR" ]; then
    echo "Error: {browser_name} profile not found at $REAL_DIR" >&2
    echo "Please run {browser_name} normally first to create a profile" >&2
    exit 1
fi

# Mount real profile via bindfs if not already mounted
if ! mountpoint -q "$DEBUG_DIR" 2>/dev/null; then
    mkdir -p "$DEBUG_DIR"
    if ! bindfs --no-allow-other "$REAL_DIR" "$DEBUG_DIR"; then
        echo "Error: Failed to mount {browser_name} profile via bindfs" >&2
        exit 1
    fi
    echo "{browser_name} debug profile mounted. To unmount: fusermount -u $DEBUG_DIR" >&2
fi

# Launch browser with debugging on bindfs mount
exec "$BROWSER_BIN" \\
    --remote-debugging-port="$PORT" \\
    --remote-allow-origins='*' \\
    --user-data-dir="$DEBUG_DIR" \\
    "$@"
"""

_LINUX_STANDARD_WRAPPER = """#!/bin/bash
# {browser_name} Debug Launcher for Linux
# Generated by webtap setup-browser

# Configuration
PORT=${{WEBTAP_PORT:-9222}}
PROFILE_BASE="{profile_dir}"
BROWSER_BIN="{browser_path}"

# Profile handling
if [ "$1" = "--temp" ]; then
    PROFILE_DIR="$(mktemp -d /tmp/webtap-{config_dir}-XXXXXX)"
    shift
    echo "Using temporary profile: $PROFILE_DIR" >&2
else
    PROFILE_DIR="$PROFILE_BASE/default"
    mkdir -p "$PROFILE_DIR"
fi

# Launch browser with debugging
exec "$BROWSER_BIN" \\
    --remote-debugging-port="$PORT" \\
    --remote-allow-origins='*' \\
    --user-data-dir="$PROFILE_DIR" \\
    --no-first-run \\
    --no-default-browser-check \\
    "$@"
"""

_MACOS_WRAPPER = """#!/bin/bash
# {browser_name} Debug Launcher for macOS
# Generated by webtap setup-browser

# Configuration
PORT=${{WEBTAP_PORT:-9222}}
PROFILE_BASE="{profile_dir}"
BROWSER_APP="{browser_path}"

# Profile handling
if [ "$1" = "--temp" ]; then
    PROFILE_DIR="$(mktemp -d /tmp/webtap-{config_dir}-XXXXXX)"
    shift
    echo "Using temporary profile: $PROFILE_DIR" >&2
else
    PROFILE_DIR="$PROFILE_BASE/default"
    mkdir -p "$PROFILE_DIR"
fi

# Launch browser with debugging
exec "$BROWSER_APP" \\
    --remote-debugging-port="$PORT" \\
    --remote-allow-origins='*' \\
    --user-data-dir="$PROFILE_DIR" \\
    --no-first-run \\
    --no-default-browser-check \\
    "$@"
"""


class BrowserSetupService:
    """Browser wrapper installation service (cross-platform)."""

    def __init__(self):
        self.info = get_platform_info()
        self.paths = self.info["paths"]

        # Profile locations
        self.profile_dir = self.paths["data_dir"] / "profiles"
        self.temp_profile_dir = self.paths["runtime_dir"] / "profiles"
        self.wrapper_dir = self.paths["bin_dir"]

    def install(self, browser_id: str, force: bool = False, bindfs: bool = False) -> dict[str, Any]:
        """Install browser wrapper script appropriate for platform.

        Args:
            browser_id: Browser ID (e.g., 'chrome', 'edge')
            force: Overwrite existing wrapper
            bindfs: Use bindfs to mount real browser profile (Linux only)

        Returns:
            Installation result
        """
        # Get browser config
        browser_config = get_browser_info(browser_id)
        if not browser_config:
            return {
                "success": False,
                "message": f"Unsupported browser: {browser_id}",
                "details": f"Supported: {', '.join(SUPPORTED_BROWSERS.keys())}",
            }

        # Verify browser is installed
        browser_path = find_browser_path(browser_id)
        if not browser_path:
            return {
                "success": False,
                "message": f"{browser_config['name']} not found on system",
                "details": f"Please install {browser_config['name']} first",
            }

        wrapper_name = browser_config["wrapper"]
        wrapper_path = self.wrapper_dir / wrapper_name

        if wrapper_path.exists() and not force:
            return {
                "success": False,
                "message": f"Wrapper already exists at {wrapper_path}",
                "details": "Use --force to overwrite",
                "path": str(wrapper_path),
            }

        # Ensure directories exist
        ensure_directories()
        self.wrapper_dir.mkdir(parents=True, exist_ok=True)

        # Generate platform-specific wrapper
        if self.info["is_macos"]:
            wrapper_content = self._generate_macos_wrapper(browser_path, browser_config)
        else:
            wrapper_content = self._generate_linux_wrapper(browser_path, browser_config, bindfs=bindfs)

        wrapper_path.write_text(wrapper_content)
        wrapper_path.chmod(0o755)

        # Check if wrapper dir is in PATH
        path_dirs = os.environ.get("PATH", "").split(os.pathsep)
        in_path = str(self.wrapper_dir) in path_dirs

        logger.info(f"Installed {browser_config['name']} wrapper to {wrapper_path}")

        # Build detailed message with PATH setup instructions
        if in_path:
            details = f"Run '{wrapper_name}' to launch {browser_config['name']} with debugging"
        else:
            shell = os.environ.get("SHELL", "/bin/bash")
            if "zsh" in shell:
                rc_file = "~/.zshrc"
            elif "fish" in shell:
                rc_file = "~/.config/fish/config.fish"
            else:
                rc_file = "~/.bashrc"

            details = (
                f"Add to PATH to use from terminal:\n"
                f"echo 'export PATH=\"$HOME/.local/bin:$PATH\"' >> {rc_file}\n"
                f"source {rc_file}\n\n"
                f"Or run directly: ~/.local/bin/{wrapper_name}\n"
                f"GUI launcher will work regardless (uses full path)"
            )

        return {
            "success": True,
            "message": f"{browser_config['name']} wrapper '{wrapper_name}' installed successfully",
            "path": str(wrapper_path),
            "details": details,
            "browser": browser_config,
        }

    def _generate_linux_wrapper(
        self,
        browser_path: str,
        browser_config: dict,
        bindfs: bool = False,
    ) -> str:
        """Generate Linux wrapper script with optional bindfs support.

        Args:
            browser_path: Full path to browser executable
            browser_config: Browser configuration dict
            bindfs: If True, use bindfs to mount real browser profile

        Returns:
            Wrapper script content
        """
        format_args = {
            "browser_name": browser_config["name"],
            "browser_path": browser_path,
            "config_dir": browser_config["config_dir"],
            "profile_dir": self.profile_dir,
        }

        if bindfs:
            return _LINUX_BINDFS_WRAPPER.format(**format_args)
        else:
            return _LINUX_STANDARD_WRAPPER.format(**format_args)

    def _generate_macos_wrapper(self, browser_path: str, browser_config: dict) -> str:
        """Generate macOS wrapper script.

        Args:
            browser_path: Full path to browser executable
            browser_config: Browser configuration dict

        Returns:
            Wrapper script content
        """
        format_args = {
            "browser_name": browser_config["name"],
            "browser_path": browser_path,
            "config_dir": browser_config["config_dir"],
            "profile_dir": self.profile_dir,
        }

        return _MACOS_WRAPPER.format(**format_args)


__all__ = ["BrowserSetupService"]
