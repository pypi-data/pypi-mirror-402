# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: Constants.proto, Core.proto, Datawatch.proto, FeatureProviders.proto, Forecast.proto, ModelService.proto, Temporal.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List, Optional

import betterproto
import grpclib


class MonitorRunDataType(betterproto.Enum):
    MONITOR_RUN_DATA_TYPE_UNDEFINED = 0
    MONITOR_RUN_DATA_TYPE_NUMERIC = 1
    MONITOR_RUN_DATA_TYPE_PASS_FAIL = 2


class MonitorType(betterproto.Enum):
    MONITOR_TYPE_UNDEFINED = 0
    MONITOR_TYPE_METRIC = 1
    MONITOR_TYPE_DBT_TEST = 2


class ExternalMonitorType(betterproto.Enum):
    EXTERNAL_MONITOR_TYPE_UNDEFINED = 0
    EXTERNAL_MONITOR_TYPE_DBT_TEST = 1


class PredefinedMetricName(betterproto.Enum):
    UNDEFINED_PREDEFINED_METRIC_NAME = 0
    PERCENT_NULL = 1
    COUNT_NULL = 2
    PERCENT_EMPTY_STRING = 3
    COUNT_EMPTY_STRING = 4
    PERCENT_UNIQUE = 5
    PERCENT_VALUE_IN_LIST = 6
    AVERAGE = 7
    MIN = 8
    MAX = 9
    SUM = 10
    COUNT_ROWS = 11
    COUNT_DISTINCT = 12
    HOURS_SINCE_MAX_DATE = 13
    HOURS_SINCE_MAX_TIMESTAMP = 14
    COUNT_TRUE = 15
    PERCENT_TRUE = 16
    COUNT_FALSE = 17
    PERCENT_FALSE = 18
    COUNT_USA_PHONE = 19
    PERCENT_USA_PHONE = 20
    COUNT_USA_ZIP_CODE = 21
    PERCENT_USA_ZIP_CODE = 22
    PERCENT_UUID = 23
    COUNT_TIMESTAMP_STRING = 24
    PERCENT_TIMESTAMP_STRING = 25
    COUNT_DUPLICATES = 26
    COUNT_USA_STATE_CODE = 27
    PERCENT_USA_STATE_CODE = 28
    VARIANCE = 29
    SKEW = 30
    KURTOSIS = 31
    GEOMETRIC_MEAN = 32
    HARMONIC_MEAN = 33
    COUNT_UUID = 34
    COUNT_CUSIP = 35
    PERCENT_CUSIP = 36
    COUNT_SEDOL = 37
    PERCENT_SEDOL = 38
    COUNT_ISIN = 39
    PERCENT_ISIN = 40
    COUNT_LEI = 41
    PERCENT_LEI = 42
    COUNT_FIGI = 43
    PERCENT_FIGI = 44
    COUNT_PERM_ID = 45
    PERCENT_PERM_ID = 46
    COUNT_NAN = 47
    PERCENT_NAN = 48
    COUNT_LONGITUDE = 49
    PERCENT_LONGITUDE = 50
    COUNT_LATITUDE = 51
    PERCENT_LATITUDE = 52
    COUNT_NOT_IN_FUTURE = 53
    PERCENT_NOT_IN_FUTURE = 54
    COUNT_DATE_NOT_IN_FUTURE = 55
    PERCENT_DATE_NOT_IN_FUTURE = 56
    MEDIAN = 57
    PERCENTILE = 58
    COUNT_NOT_NULL = 59
    STRING_LENGTH_AVERAGE = 60
    STRING_LENGTH_MIN = 61
    STRING_LENGTH_MAX = 62
    COUNT_SSN = 63
    PERCENT_SSN = 64
    COUNT_EMAIL = 65
    PERCENT_EMAIL = 66
    ROWS_INSERTED = 67
    HOURS_SINCE_LAST_LOAD = 68
    COUNT_READ_QUERIES = 69
    PERCENT_NOT_NULL = 70
    FRESHNESS = 71
    VOLUME = 72
    FRESHNESS_DATA = 73
    VOLUME_DATA = 74
    COUNT_VALUE_IN_LIST = 75
    PERCENT_DISTINCT = 76
    PERCENT_DUPLICATES = 77
    HOURS_SINCE_MAX_STRING = 78


class FieldType(betterproto.Enum):
    FIELD_TYPE_UNSPECIFIED = 0
    FIELD_TYPE_STRING = 1
    FIELD_TYPE_UUID = 2
    FIELD_TYPE_BINARY = 3
    FIELD_TYPE_NUMERIC = 4
    FIELD_TYPE_DATE_LIKE = 5
    FIELD_TYPE_TIMESTAMP_LIKE = 6
    FIELD_TYPE_ANY = 7
    FIELD_TYPE_BOOLEAN = 8
    FIELD_TYPE_UNKNOWN = 9
    FIELD_TYPE_ARRAY = 10
    FIELD_TYPE_STRUCT = 11


class WarehouseType(betterproto.Enum):
    DATABASE_TYPE_UNSPECIFIED = 0
    DATABASE_TYPE_AWS_ATHENA = 1
    DATABASE_TYPE_BIGQUERY = 2
    DATABASE_TYPE_DATABRICKS = 3
    DATABASE_TYPE_MYSQL = 4
    DATABASE_TYPE_ORACLE = 5
    DATABASE_TYPE_POSTGRES = 6
    DATABASE_TYPE_PRESTO = 7
    DATABASE_TYPE_REDSHIFT = 8
    DATABASE_TYPE_SAP_HANA = 9
    DATABASE_TYPE_SNOWFLAKE = 10
    DATABASE_TYPE_SQL_SERVER = 11
    DATABASE_TYPE_SYNAPSE = 12
    DATABASE_TYPE_ROCKSET = 13
    DATABASE_TYPE_VERTICA = 14
    DATABASE_TYPE_AVATICA = 15
    DATABASE_TYPE_DB2 = 16
    DATABASE_TYPE_TERADATA = 17
    DATABASE_TYPE_NETEZZA = 18


class ConfigValueType(betterproto.Enum):
    VALUE_TYPE_UNSPECIFIED = 0
    VALUE_TYPE_STRING = 1
    VALUE_TYPE_BOOL = 2
    VALUE_TYPE_INTEGER = 3
    VALUE_TYPE_DECIMAL = 4


class CatalogEntityType(betterproto.Enum):
    CATALOG_ENTITY_TYPE_UNSPECIFIED = 0
    CATALOG_ENTITY_TYPE_SOURCE = 1
    CATALOG_ENTITY_TYPE_SCHEMA = 2
    CATALOG_ENTITY_TYPE_DATASET = 3
    CATALOG_ENTITY_TYPE_FIELD = 4
    CATALOG_ENTITY_TYPE_DATA_NODE_ENTITY = 5
    CATALOG_ENTITY_TYPE_META_CENTER_ENTITY = 6


class OwnableType(betterproto.Enum):
    OWNABLE_TYPE_UNSPECIFIED = 0
    OWNABLE_TYPE_SOURCE = 1
    OWNABLE_TYPE_SCHEMA = 2
    OWNABLE_TYPE_DATASET = 3
    OWNABLE_TYPE_FIELD = 4
    OWNABLE_TYPE_METRIC = 5
    OWNABLE_TYPE_CUSTOM_RULE = 6
    OWNABLE_TYPE_CUSTOM_REPOSITORY = 7
    OWNABLE_TYPE_META_CENTER_ENTITY = 8
    OWNABLE_TYPE_DATA_NODE_ENTITY = 9
    OWNABLE_TYPE_META_CENTER_REPOSITORY = 10
    OWNABLE_TYPE_INTEGRATION = 11


class TaggableEntityType(betterproto.Enum):
    TAGGABLE_ENTITY_TYPE_UNSPECIFIED = 0
    TAGGABLE_ENTITY_TYPE_SOURCE = 1
    TAGGABLE_ENTITY_TYPE_SCHEMA = 2
    TAGGABLE_ENTITY_TYPE_DATASET = 3
    TAGGABLE_ENTITY_TYPE_METRIC = 4
    TAGGABLE_ENTITY_TYPE_DELTA = 5
    TAGGABLE_ENTITY_TYPE_COLUMN = 6
    TAGGABLE_ENTITY_TYPE_SLA = 7
    TAGGABLE_ENTITY_TYPE_BI_TOOL = 8
    TAGGABLE_ENTITY_TYPE_TABLEAU_WORKBOOK = 9
    TAGGABLE_ENTITY_TYPE_N_WAY_DELTA = 10
    TAGGABLE_ENTITY_TYPE_VIRTUAL_TABLE = 11
    TAGGABLE_ENTITY_TYPE_INTEGRATION = 12
    TAGGABLE_ENTITY_TYPE_DBT_PROJECT = 13
    TAGGABLE_ENTITY_TYPE_DBT_JOB = 14
    TAGGABLE_ENTITY_TYPE_CUSTOM_RULE = 15
    TAGGABLE_ENTITY_TYPE_META_CENTER_ENTITY = 16
    TAGGABLE_ENTITY_TYPE_DATA_NODE_ENTITY = 17
    TAGGABLE_ENTITY_TYPE_META_CENTER_REPOSITORY = 18
    TAGGABLE_ENTITY_TYPE_CUSTOM_REPOSITORY = 19


class TableType(betterproto.Enum):
    TABLE_TYPE_UNSPECIFIED = 0
    TABLE_TYPE_TABLE = 1
    TABLE_TYPE_VIEW = 2
    TABLE_TYPE_VIRTUAL = 3
    TABLE_TYPE_CUSTOM_RULE = 4


class AgentApiKeyType(betterproto.Enum):
    AGENT_API_KEY_TYPE_UNSPECIFIED = 0
    AGENT_API_KEY_TYPE_AGENT = 1
    AGENT_API_KEY_TYPE_INTEGRATION = 2


class AppName(betterproto.Enum):
    APP_NAME_UNSPECIFIED = 0
    APP_NAME_DATAWATCH = 1
    APP_NAME_SCHEDULER = 2
    APP_NAME_MONOCLE = 3
    APP_NAME_TORETTO = 4


class RoleType(betterproto.Enum):
    ROLE_TYPE_UNSPECIFIED = 0
    ROLE_TYPE_ADMIN = 1
    ROLE_TYPE_MANAGE = 2
    ROLE_TYPE_EDIT = 3
    ROLE_TYPE_VIEW = 4
    ROLE_TYPE_CUSTOM = 5


class SimpleBoundType(betterproto.Enum):
    UNDEFINED_SIMPLE_BOUND_TYPE = 0
    LOWER_BOUND_SIMPLE_BOUND_TYPE = 1
    UPPER_BOUND_SIMPLE_BOUND_TYPE = 2


class ForecastModelType(betterproto.Enum):
    UNDEFINED_THRESHOLD_MODEL_TYPE = 0
    BOOTSTRAP_THRESHOLD_MODEL_TYPE = 1
    ARIMA_MODEL_TYPE = 2
    ETS_MODEL_TYPE = 3
    THETA_MODEL_TYPE = 4
    PROPHET_MODEL_TYPE = 5
    ETS_AZA_MODEL_TYPE = 6
    ETS_AZZ_MODEL_TYPE = 7
    ARIMA_X_MODEL_TYPE = 8
    ETS_AAZ_MODEL_TYPE = 9
    ETS_AAA_MODEL_TYPE = 10
    COLD_START_MODEL_TYPE = 11
    HIGH_VOLATILITY_MODEL_TYPE = 12
    STD_DEV_OVERRIDE_MODEL_TYPE = 13
    LAST_RUN_OVERRIDE_MODEL_TYPE = 14
    LARGE_VALUE_MODEL_TYPE = 15
    ETS_STL_MODEL_TYPE = 16
    SNAIVE_MODEL_TYPE = 17
    FREQ_INTERVAL_MODEL_TYPE = 18
    STABLE_MODEL = 19


class TimeIntervalType(betterproto.Enum):
    UNDEFINED_TIME_INTERVAL_TYPE = 0
    HOURS_TIME_INTERVAL_TYPE = 1
    MINUTES_TIME_INTERVAL_TYPE = 2
    SECONDS_TIME_INTERVAL_TYPE = 3
    DAYS_TIME_INTERVAL_TYPE = 4
    WEEKDAYS_TIME_INTERVAL_TYPE = 5
    MARKET_DAYS_TIME_INTERVAL_TYPE = 6
    MONTHS_TIME_INTERVAL_TYPE = 7
    WEEKS_TIME_INTERVAL_TYPE = 8
    YEARS_TIME_INTERVAL_TYPE = 9


class AggregationType(betterproto.Enum):
    UNDEFINED_AGGREGATION_TYPE = 0
    COUNT_AGGREGATION_TYPE = 1
    PERCENT_AGGREGATION_TYPE = 2
    MIN_AGGREGATION_TYPE = 3
    MAX_AGGREGATION_TYPE = 4
    AVG_AGGREGATION_TYPE = 5
    SUM_AGGREGATION_TYPE = 6


class MetricCategory(betterproto.Enum):
    """
    Note: The enum order is also the sorting order when sorting issues by
    metric category
    """

    METRIC_CATEGORY_UNSPECIFIED = 0
    METRIC_CATEGORY_PIPELINE_RELIABILITY = 1
    METRIC_CATEGORY_UNIQUENESS = 2
    METRIC_CATEGORY_COMPLETENESS = 3
    METRIC_CATEGORY_DISTRIBUTIONS = 4
    METRIC_CATEGORY_VALIDITY = 5
    METRIC_CATEGORY_CUSTOM = 6


class LookbackType(betterproto.Enum):
    UNDEFINED_LOOKBACK_TYPE = 0
    DATA_TIME_LOOKBACK_TYPE = 1
    CLOCK_TIME_LOOKBACK_TYPE = 2
    METRIC_TIME_LOOKBACK_TYPE = 3


class MetricCreationState(betterproto.Enum):
    METRIC_CREATION_STATE_UNSPECIFIED = 0
    METRIC_CREATION_STATE_MANUAL = 1
    METRIC_CREATION_STATE_SUGGESTED_AUTO = 2
    METRIC_CREATION_STATE_ACCEPTED_AUTO = 3
    METRIC_CREATION_STATE_REJECTED_AUTO = 4
    METRIC_CREATION_STATE_COMPARISON = 5
    METRIC_CREATION_STATE_AUTOMATIC_SETUP = 6
    METRIC_CREATION_STATE_SUITE = 7
    METRIC_CREATION_STATE_CUSTOM_RULE = 8
    METRIC_CREATION_STATE_INTEGRATION = 9


class AutothresholdSensitivity(betterproto.Enum):
    AUTOTHRESHOLD_SENSITIVITY_UNSPECIFIED = 0
    AUTOTHRESHOLD_SENSITIVITY_NARROW = 1
    AUTOTHRESHOLD_SENSITIVITY_MEDIUM = 2
    AUTOTHRESHOLD_SENSITIVITY_WIDE = 3
    AUTOTHRESHOLD_SENSITIVITY_XWIDE = 4


class CollectionInfoSortField(betterproto.Enum):
    COLLECTION_SORT_FIELD_UNSPECIFIED = 0
    COLLECTION_SORT_FIELD_FAVORITE = 1
    COLLECTION_SORT_FIELD_ISSUE_COUNT = 2
    COLLECTION_SORT_FIELD_METRIC_COUNT = 3
    COLLECTION_SORT_FIELD_UPDATED_AT = 4
    COLLECTION_SORT_FIELD_NAME = 5


class CollectionInfoV2SortField(betterproto.Enum):
    COLLECTION_INFO_V2_SORT_FIELD_UNSPECIFIED = 0
    COLLECTION_INFO_V2_SORT_FIELD_FAVORITE = 1
    COLLECTION_INFO_V2_SORT_FIELD_ISSUE_COUNT = 2
    COLLECTION_INFO_V2_SORT_FIELD_METRIC_COUNT = 3
    COLLECTION_INFO_V2_SORT_FIELD_NAME = 4


class MetricRunStatus(betterproto.Enum):
    # deprecated in favor of MetricStatus
    METRIC_RUN_STATUS_UNSPECIFIED = 0
    METRIC_RUN_STATUS_UPPERBOUND_CRITICAL = 1
    METRIC_RUN_STATUS_LOWERBOUND_CRITICAL = 2
    METRIC_RUN_STATUS_OK = 3
    # METRIC_RUN_STATUS_GROUPS_CRITICAL is not a valid value for MetricRun.status
    # (it only applies to MetricInfo.status)
    METRIC_RUN_STATUS_GROUPS_CRITICAL = 4
    # METRIC_RUN_STATUS_NO_RUNS is not a valid value for MetricRun.status (it
    # only applies to MetricInfo.status)
    METRIC_RUN_STATUS_NO_RUNS = 5
    METRIC_RUN_STATUS_UNKNOWN = 6
    METRIC_RUN_STATUS_MUTABLE_UNKNOWN = 7
    METRIC_RUN_STATUS_MUTABLE_UPPERBOUND_CRITICAL = 8
    METRIC_RUN_STATUS_MUTABLE_LOWERBOUND_CRITICAL = 9
    METRIC_RUN_STATUS_MUTABLE_OK = 10
    METRIC_RUN_STATUS_GROUPS_LIMIT_FAILED = 11


class MetricRunFailureReason(betterproto.Enum):
    METRIC_RUN_FAILURE_REASON_UNKNOWN = 0
    METRIC_RUN_FAILURE_REASON_QUERY_FAILED = 1
    METRIC_RUN_FAILURE_REASON_CONNECTION_FAILURE = 2
    METRIC_RUN_FAILURE_REASON_QUERY_TIMEOUT = 3
    METRIC_RUN_FAILURE_REASON_INVALID_CREDS = 4
    METRIC_RUN_FAILURE_REASON_NO_LOOKBACK_DATA = 5
    METRIC_RUN_FAILURE_REASON_LOOKBACK_VALUE_NOT_FOUND = 6
    METRIC_RUN_FAILURE_REASON_NO_OBSERVED_VALUE = 7
    METRIC_RUN_FAILURE_REASON_DATA_ACCESS_EXCEPTION = 8
    METRIC_RUN_FAILURE_REASON_BIGEYE_IP_NOT_WHITELISTED = 9
    METRIC_RUN_FAILURE_REASON_MAX_METRIC_TIME_NOT_FOUND = 10
    METRIC_RUN_FAILURE_REASON_DIMENSION_NOT_FOUND = 11
    METRIC_RUN_FAILURE_REASON_GROUPS_OVER_LIMIT = 12
    METRIC_RUN_FAILURE_REASON_BLOB_SIZE_LIMIT = 13
    METRIC_RUN_FAILURE_REASON_GRPC_SIZE_LIMIT = 14
    METRIC_RUN_FAILURE_REASON_UNHEALTHY_AGENT = 15


class MetricRunLabel(betterproto.Enum):
    METRIC_RUN_LABEL_UNSPECIFIED = 0
    METRIC_RUN_LABEL_TRUE_NEGATIVE = 1
    METRIC_RUN_LABEL_FALSE_NEGATIVE = 2
    METRIC_RUN_LABEL_TRUE_POSITIVE = 3
    METRIC_RUN_LABEL_FALSE_POSITIVE = 4
    METRIC_RUN_LABEL_UNDETERMINED = 5
    METRIC_RUN_LABEL_EXPECTED = 6


class CompanionMetricType(betterproto.Enum):
    TYPE_FRESHNESS_VOLUME = 0


class MetricRunSortField(betterproto.Enum):
    METRIC_RUN_SORT_FIELD_UNSPECIFIED = 0
    METRIC_RUN_SORT_FIELD_RAN_AT = 1
    METRIC_RUN_SORT_FIELD_GRAIN_START = 2


class VisibilityOperation(betterproto.Enum):
    VISIBILITY_OPERATION_UNSPECIFIED = 0
    VISIBILITY_OPERATION_HIDE = 1
    VISIBILITY_OPERATION_UNHIDE = 2


class DataNodeType(betterproto.Enum):
    DATA_NODE_TYPE_UNSPECIFIED = 0
    DATA_NODE_TYPE_TABLE = 1
    DATA_NODE_TYPE_TABLEAU_WORKBOOK = 2
    DATA_NODE_TYPE_COLUMN = 3
    DATA_NODE_TYPE_SCHEMA = 4
    DATA_NODE_TYPE_MC_TABLEAU_PROJECT = 5
    DATA_NODE_TYPE_MC_TABLEAU_WORKBOOK = 6
    DATA_NODE_TYPE_MC_TABLEAU_STORY = 7
    DATA_NODE_TYPE_MC_TABLEAU_SHEET = 8
    DATA_NODE_TYPE_MC_TABLEAU_DASHBOARD = 9
    DATA_NODE_TYPE_MC_POWERBI_WORKSPACE = 10
    DATA_NODE_TYPE_MC_POWERBI_REPORT = 11
    DATA_NODE_TYPE_MC_POWERBI_PAGE = 12
    DATA_NODE_TYPE_MC_POWERBI_DASHBOARD = 13
    DATA_NODE_TYPE_MC_POWERCENTER_WORKFLOW = 14
    DATA_NODE_TYPE_MC_POWERCENTER_TARGET = 15
    DATA_NODE_TYPE_MC_POWERCENTER_TARGET_FIELD = 16
    DATA_NODE_TYPE_MC_SSIS_PACKAGE = 17
    DATA_NODE_TYPE_MC_SSIS_DESTINATION = 18
    DATA_NODE_TYPE_MC_SSIS_DESTINATION_FIELD = 19
    DATA_NODE_TYPE_CUSTOM = 20
    DATA_NODE_TYPE_CUSTOM_ENTRY = 21
    DATA_NODE_TYPE_MC_COGNOS_FOLDER = 22
    DATA_NODE_TYPE_MC_COGNOS_REPORT = 23
    DATA_NODE_TYPE_MC_COGNOS_QUERY = 24
    DATA_NODE_TYPE_MC_SAP_BO_FOLDER = 25
    DATA_NODE_TYPE_MC_SAP_BO_REPORT = 26
    DATA_NODE_TYPE_MC_FDS_FOLDER = 27
    DATA_NODE_TYPE_MC_FDS_FILE = 28
    DATA_NODE_TYPE_MC_FDS_FIELD = 29
    DATA_NODE_TYPE_MC_QLIK_REPLICATE_SCHEMA = 30
    DATA_NODE_TYPE_MC_QLIK_REPLICATE_TABLE = 31
    DATA_NODE_TYPE_MC_QLIK_REPLICATE_COLUMN = 32
    DATA_NODE_TYPE_MC_LOOKER_FOLDER = 33
    DATA_NODE_TYPE_MC_LOOKER_BOARD = 34
    DATA_NODE_TYPE_MC_LOOKER_LOOK = 35
    DATA_NODE_TYPE_MC_LOOKER_DASHBOARD = 36
    DATA_NODE_TYPE_MC_LOOKER_VISUALIZATION = 37
    DATA_NODE_TYPE_MC_CDM_TARGET = 38
    DATA_NODE_TYPE_MC_CDM_TARGET_FIELD = 39
    DATA_NODE_TYPE_MC_CDM_TEMP_TABLE = 40
    DATA_NODE_TYPE_MC_CDM_TEMP_FIELD = 41
    DATA_NODE_TYPE_MC_CDM_TRANSFORM_FILE = 42
    DATA_NODE_TYPE_MC_SNAPLOGIC_PIPELINE = 43
    DATA_NODE_TYPE_MC_SNAPLOGIC_WRITE = 44
    DATA_NODE_TYPE_MC_SNAPLOGIC_FIELD = 45
    DATA_NODE_TYPE_MC_DATASTAGE_OUTPUT = 46
    DATA_NODE_TYPE_MC_DATASTAGE_OUTPUT_FIELD = 47
    DATA_NODE_TYPE_MC_SSRS_FOLDER = 48
    DATA_NODE_TYPE_MC_SSRS_REPORT = 49
    DATA_NODE_TYPE_MC_QLIK_SENSE_VIS_DIMENSION = 50
    DATA_NODE_TYPE_MC_QLIK_SENSE_VIS_MEASURE = 51
    DATA_NODE_TYPE_MC_QLIK_SENSE_APPLICATION = 52
    DATA_NODE_TYPE_MC_QLIK_SENSE_SHEET = 53
    # STRATEGY Formerly known as MicroStrategy
    DATA_NODE_TYPE_MC_STRATEGY_FOLDER = 54
    DATA_NODE_TYPE_MC_STRATEGY_DOSSIER = 55
    DATA_NODE_TYPE_MC_STRATEGY_GRAPH = 56
    DATA_NODE_TYPE_MC_STRATEGY_GRID = 57
    DATA_NODE_TYPE_MC_STRATEGY_GRIDGRAPH = 58
    DATA_NODE_TYPE_MC_ADF_STORED_PROC = 59
    DATA_NODE_TYPE_MC_ADF_TARGET_TABLE = 60
    DATA_NODE_TYPE_MC_ADF_COPY_SINK = 61
    DATA_NODE_TYPE_MC_ADF_FIELD = 62
    DATA_NODE_TYPE_MC_MATILLION_COMPONENT = 63
    DATA_NODE_TYPE_MC_MATILLION_TARGET_TABLE = 64
    DATA_NODE_TYPE_MC_MATILLION_TARGET_FIELD = 65
    DATA_NODE_TYPE_SOURCE = 66
    DATA_NODE_TYPE_DBT_CLOUD = 67
    DATA_NODE_TYPE_DBT_CORE = 68
    DATA_NODE_TYPE_TABLEAU_PROJECT = 69
    DATA_NODE_TYPE_MC_REPOSITORY = 70
    DATA_NODE_TYPE_DBT_PROJECT = 71
    DATA_NODE_TYPE_CUSTOM_REPOSITORY = 72


class RelationshipType(betterproto.Enum):
    RELATIONSHIP_TYPE_UNSPECIFIED = 0
    RELATIONSHIP_TYPE_LINEAGE = 1
    RELATIONSHIP_TYPE_CONTAINMENT = 2


class LineageDirection(betterproto.Enum):
    """this enum is used only for the purposes of documentation"""

    ALL = 0
    UPSTREAM = 1
    DOWNSTREAM = 2


class CatalogEntitySortField(betterproto.Enum):
    CATALOG_ENTITY_SORT_FIELD_UNSPECIFIED = 0
    CATALOG_ENTITY_SORT_FIELD_FAVORITE = 1
    CATALOG_ENTITY_SORT_FIELD_POPULARITY = 2
    CATALOG_ENTITY_SORT_FIELD_NAME = 3


class DataNodeSortField(betterproto.Enum):
    DATA_NODE_SORT_FIELD_UNSPECIFIED = 0
    DATA_NODE_SORT_FIELD_NAME = 1
    DATA_NODE_SORT_FIELD_UPDATED_AT = 2


class LineageRelationshipSortField(betterproto.Enum):
    LINEAGE_RELATIONSHIP_SORT_FIELD_UNSPECIFIED = 0
    LINEAGE_RELATIONSHIP_SORT_FIELD_UPSTREAM_ID = 1
    LINEAGE_RELATIONSHIP_SORT_FIELD_UPDATED_AT = 2


class IntegrationPartner(betterproto.Enum):
    INTEGRATION_PARTNER_UNSPECIFIED = 0
    INTEGRATION_PARTNER_TABLEAU = 1
    INTEGRATION_PARTNER_DBT_CLOUD = 2
    INTEGRATION_PARTNER_METACENTER = 3
    INTEGRATION_PARTNER_DBT_CORE = 4
    INTEGRATION_PARTNER_POWERBI = 5
    INTEGRATION_PARTNER_POWERCENTER = 6
    INTEGRATION_PARTNER_SSIS = 7
    INTEGRATION_PARTNER_COGNOS = 8
    INTEGRATION_PARTNER_SAP_BUSINESS_OBJECTS = 9
    INTEGRATION_PARTNER_FDS = 10
    INTEGRATION_PARTNER_QLIK_REPLICATE = 11
    INTEGRATION_PARTNER_LOOKER = 12
    INTEGRATION_PARTNER_CDM = 13
    INTEGRATION_PARTNER_SNAPLOGIC = 14
    INTEGRATION_PARTNER_DATASTAGE = 15
    INTEGRATION_PARTNER_SSRS = 16
    INTEGRATION_PARTNER_QLIK_SENSE = 17
    INTEGRATION_PARTNER_STRATEGY = 18
    INTEGRATION_PARTNER_ADF = 19
    INTEGRATION_PARTNER_MATILLION = 20


class IntegrationType(betterproto.Enum):
    INTEGRATION_TYPE_UNSPECIFIED = 0
    INTEGRATION_TYPE_BI_TOOL = 1
    INTEGRATION_TYPE_ETL_TOOL = 2
    INTEGRATION_TYPE_DATABASE = 3


class DbtProjectSortField(betterproto.Enum):
    DBT_PROJECT_SORT_FIELD_UNSPECIFIED = 0
    DBT_PROJECT_SORT_FIELD_NAME = 1
    DBT_PROJECT_SORT_FIELD_FAVORITE = 2
    DBT_PROJECT_SORT_FIELD_UPDATED_AT = 3


class ThreeLeggedBoolean(betterproto.Enum):
    """
    We need this for isMuted filters as unspecified == no filter, but the
    generated typescript file is setting null to false so there is no way for
    the receiver to tell if there is no filter, or if the filter is set to
    false.
    """

    THREE_LEGGED_BOOLEAN_UNSPECIFIED = 0
    THREE_LEGGED_BOOLEAN_TRUE = 1
    THREE_LEGGED_BOOLEAN_FALSE = 2


class SortDirection(betterproto.Enum):
    """Unspecified will default to ASCENDING"""

    SORT_DIRECTION_UNSPECIFIED = 0
    SORT_DIRECTION_ASCENDING = 1
    SORT_DIRECTION_DESCENDING = 2


class LineageType(betterproto.Enum):
    LINEAGE_TYPE_UNSPECIFIED = 1
    LINEAGE_TYPE_SOURCE = 2
    LINEAGE_TYPE_INTEGRATION = 3


class MetricBackfillRunStatus(betterproto.Enum):
    METRIC_BACKFILL_RUN_STATUS_UNSPECIFIED = 0
    METRIC_BACKFILL_RUN_STATUS_QUEUED = 1
    METRIC_BACKFILL_RUN_STATUS_FAILED = 2
    METRIC_BACKFILL_RUN_STATUS_SUCCEEDED = 3


class ComparisonMetricStatus(betterproto.Enum):
    COMPARISON_METRIC_STATUS_UNKNOWN = 1
    COMPARISON_METRIC_STATUS_OK = 2
    COMPARISON_METRIC_STATUS_ALERT = 3
    COMPARISON_METRIC_STATUS_OK_NO_RUNS = 4


class ComparisonTableSortField(betterproto.Enum):
    COMPARISON_TABLE_SORT_FIELD_UNSPECIFIED = 0
    COMPARISON_TABLE_SORT_FIELD_RAN_AT = 1
    COMPARISON_TABLE_SORT_FIELD_NAME = 2
    COMPARISON_TABLE_SORT_FIELD_FAVORITE = 3


class AggregateField(betterproto.Enum):
    AGGREGATE_FIELD_UNSPECIFIED = 0
    AGGREGATE_FIELD_WAREHOUSES = 1
    AGGREGATE_FIELD_SCHEMAS = 2
    AGGREGATE_FIELD_TABLES = 3
    AGGREGATE_FIELD_COLUMNS = 4
    AGGREGATE_FIELD_METRICS = 5
    AGGREGATE_FIELD_METRICS_ALERTING = 6
    AGGREGATE_FIELD_METRICS_FAILED = 7
    AGGREGATE_FIELD_METRICS_MUTED = 8
    AGGREGATE_FIELD_METRICS_HEALTHY = 9
    AGGREGATE_FIELD_GROUP_METRIC_STATUS = 11
    AGGREGATE_FIELD_ALERTS = 12
    AGGREGATE_FIELD_ISSUES = 13
    AGGREGATE_FIELD_INTEGRATIONS = 14
    AGGREGATE_FIELD_BI_TOOLS = 15
    AGGREGATE_FIELD_ETL_TOOLS = 16
    AGGREGATE_FIELD_CUSTOM_RULES = 17
    AGGREGATE_FIELD_ISSUE_TYPE = 18
    AGGREGATE_FIELD_IS_ROOT_CAUSE = 19
    AGGREGATE_FIELD_LINKED_METRICS = 20
    AGGREGATE_FIELD_LINKED_CUSTOM_RULES = 21
    AGGREGATE_FIELD_DIMENSION = 22
    AGGREGATE_FIELD_CHILD_ENTITIES = 23
    AGGREGATE_FIELD_SENSITIVE_COLUMNS = 24


class GroupByEntityType(betterproto.Enum):
    GROUP_BY_ENTITY_TYPE_UNSPECIFIED = 0
    GROUP_BY_ENTITY_TYPE_WAREHOUSE = 1
    GROUP_BY_ENTITY_TYPE_SCHEMA = 2
    GROUP_BY_ENTITY_TYPE_TABLE = 3
    GROUP_BY_ENTITY_TYPE_COLUMN = 4
    GROUP_BY_ENTITY_TYPE_SLA = 5
    GROUP_BY_ENTITY_TYPE_SCHEMA_ID = 6
    GROUP_BY_ENTITY_TYPE_METRIC_RUN_LABEL = 7
    GROUP_BY_ENTITY_TYPE_TABLE_ID = 8
    GROUP_BY_ENTITY_TYPE_ISSUE_PRIORITY = 9
    GROUP_BY_ENTITY_TYPE_ISSUE_STATUS = 10
    GROUP_BY_ENTITY_TYPE_METRIC_STATUS = 11
    GROUP_BY_ENTITY_TYPE_METRIC_TYPE = 12
    GROUP_BY_ENTITY_TYPE_METRIC_CATEGORY = 13
    GROUP_BY_ENTITY_TYPE_OWNER = 14
    GROUP_BY_ENTITY_TYPE_ISSUE_TYPE = 15
    GROUP_BY_ENTITY_TYPE_IS_ROOT_CAUSE = 16
    GROUP_BY_ENTITY_TYPE_DIMENSION = 17
    GROUP_BY_ENTITY_TYPE_MONITOR_TYPE = 18


class IssueStatus(betterproto.Enum):
    ISSUE_STATUS_UNSPECIFIED = 0
    ISSUE_STATUS_NEW = 1
    ISSUE_STATUS_ACKNOWLEDGED = 2
    ISSUE_STATUS_CLOSED = 3
    ISSUE_STATUS_MONITORING = 4
    ISSUE_STATUS_MERGED = 5


class IssueType(betterproto.Enum):
    ISSUE_TYPE_UNSPECIFIED = 0
    ISSUE_TYPE_ISSUE = 1
    ISSUE_TYPE_INCIDENT = 2


class IssuePriority(betterproto.Enum):
    ISSUE_PRIORITY_UNSPECIFIED = 0
    ISSUE_PRIORITY_LOW = 1
    ISSUE_PRIORITY_MED = 2
    ISSUE_PRIORITY_HIGH = 3


class IssueAiUpdateType(betterproto.Enum):
    ISSUE_AI_UPDATE_TYPE_UNSPECIFIED = 0
    ISSUE_AI_UPDATE_TYPE_OVERVIEW = 1
    ISSUE_AI_UPDATE_TYPE_RESOLUTION_SUGGESTION = 2
    ISSUE_AI_UPDATE_TYPE_DATA_DESCRIPTION = 3
    ISSUE_AI_UPDATE_TYPE_ETL_ANALYSIS = 4
    ISSUE_AI_UPDATE_TYPE_PREVIOUS_RESOLUTIONS = 5
    ISSUE_AI_UPDATE_TYPE_OVERVIEW_RESTRICTED = 6


class IssueResolutionStepStatus(betterproto.Enum):
    ISSUE_RESOLUTION_STEP_STATUS_UNSPECIFIED = 0
    ISSUE_RESOLUTION_STEP_STATUS_IRRELEVANT = 1
    ISSUE_RESOLUTION_STEP_STATUS_UNSUCCESSFUL = 2
    ISSUE_RESOLUTION_STEP_STATUS_SUCCESSFUL = 3


class IssuePreventionStepStatus(betterproto.Enum):
    ISSUE_PREVENTION_STEP_STATUS_UNSPECIFIED = 0
    ISSUE_PREVENTION_STEP_STATUS_IRRELEVANT = 1
    ISSUE_PREVENTION_STEP_STATUS_COMPLETED = 2


class IssueMergeUpdateType(betterproto.Enum):
    ISSUE_MERGE_UPDATE_TYPE_UNSPECIFIED = 0
    ISSUE_MERGE_UPDATE_TYPE_MERGE = 1
    ISSUE_MERGE_UPDATE_TYPE_UNMERGE = 2


class IssueSortField(betterproto.Enum):
    ISSUE_SORT_FIELD_UNSPECIFIED = 0
    ISSUE_SORT_FIELD_CREATED_AT = 1
    ISSUE_SORT_FIELD_PRIORITY = 2
    ISSUE_SORT_FIELD_CLOSED_AT = 3
    ISSUE_SORT_FIELD_NEW_COUNT = 4
    ISSUE_SORT_FIELD_ACKNOWLEDGED_COUNT = 5
    ISSUE_SORT_FIELD_CLOSED_COUNT = 6
    ISSUE_SORT_FIELD_TABLE_NAME = 7
    ISSUE_SORT_FIELD_SCHEMA_NAME = 8
    ISSUE_SORT_FIELD_MONITORING_COUNT = 9
    ISSUE_SORT_FIELD_STATUS = 10
    ISSUE_SORT_FIELD_METRIC_CATEGORY = 11
    ISSUE_SORT_FIELD_ASSIGNEE = 12
    ISSUE_SORT_FIELD_IS_ROOT_CAUSE = 13
    ISSUE_SORT_FIELD_DIMENSION = 14


class MetricSortField(betterproto.Enum):
    METRIC_SORT_FIELD_UNSPECIFIED = 0
    METRIC_SORT_FIELD_METRIC_NAME = 1
    METRIC_SORT_FIELD_RAN_AT = 2
    METRIC_SORT_FIELD_ALERTING = 3
    METRIC_SORT_FIELD_SCHEMA = 4
    METRIC_SORT_FIELD_TABLE = 5
    METRIC_SORT_FIELD_COLUMN = 6
    METRIC_SORT_FIELD_FAVORITE = 7
    METRIC_SORT_FIELD_CREATED_AT = 8
    METRIC_SORT_FIELD_BIGCONFIG = 9


class MetricStatus(betterproto.Enum):
    METRIC_STATUS_UNSPECIFIED = 0
    METRIC_STATUS_ALERTING = 1
    METRIC_STATUS_FAILED = 2
    METRIC_STATUS_HEALTHY = 3
    METRIC_STATUS_NO_OBSERVED_VALUE = 4
    METRIC_STATUS_GROUPS_MIXED_STATUS = 5


class ExternalTicketProvider(betterproto.Enum):
    EXTERNAL_TICKET_PROVIDER_UNSPECIFIED = 0
    EXTERNAL_TICKET_PROVIDER_JIRA = 1
    EXTERNAL_TICKET_PROVIDER_SERVICENOW = 2


class CacheOperation(betterproto.Enum):
    CACHE_OPERATION_UNSPECIFIED = 0
    CACHE_OPERATION_CLEAR_CONFIG = 1
    CACHE_OPERATION_CLEAR_USERS = 2
    CACHE_OPERATION_CLEAR_KEYS = 3


class MetricGroupSortField(betterproto.Enum):
    METRIC_GROUP_SORT_FIELD_UNSPECIFIED = 0
    METRIC_GROUP_SORT_FIELD_GROUP_NAME = 1
    METRIC_GROUP_SORT_FIELD_ALERTING = 2
    METRIC_GROUP_SORT_FIELD_LOWER_THRESHOLD = 3
    METRIC_GROUP_SORT_FIELD_OBSERVED_VALUE = 4
    METRIC_GROUP_SORT_FIELD_UPPER_THRESHOLD = 5


class NamedScheduleSortField(betterproto.Enum):
    NAMED_SCHEDULE_SORT_UNSPECIFIED = 0
    NAMED_SCHEDULE_SORT_NAME = 1


class MetricTemplateParameterType(betterproto.Enum):
    METRIC_TEMPLATE_PARAMETER_TYPE_UNSPECIFIED = 0
    METRIC_TEMPLATE_PARAMETER_TYPE_COLUMN_REFERENCE = 1
    METRIC_TEMPLATE_PARAMETER_TYPE_NUMBER = 2
    METRIC_TEMPLATE_PARAMETER_TYPE_STRING = 3


class MetricTemplateSortField(betterproto.Enum):
    METRIC_TEMPLATE_SORT_UNSPECIFIED = 0
    METRIC_TEMPLATE_SORT_ID = 1
    METRIC_TEMPLATE_SORT_NAME = 2
    METRIC_TEMPLATE_SORT_SOURCE_NAME = 3


class IdProvider(betterproto.Enum):
    ID_PROVIDER_UNSPECIFIED = 0
    ID_PROVIDER_LOCAL = 1
    ID_PROVIDER_OKTA = 2
    ID_PROVIDER_GOOGLE = 3
    ID_PROVIDER_AZURE_AD = 4
    ID_PROVIDER_PING = 5
    ID_PROVIDER_DIRECT_OIDC = 6
    ID_PROVIDER_AUTH0 = 7


class AgentHealthStatus(betterproto.Enum):
    AGENT_HEALTH_STATUS_UNSPECIFIED = 0
    AGENT_HEALTH_STATUS_HEALTHY = 1
    AGENT_HEALTH_STATUS_SLOW_BUT_UP = 2
    AGENT_HEALTH_STATUS_DOWN = 3
    AGENT_HEALTH_STATUS_NO_DATA = 4


class AuthType(betterproto.Enum):
    AUTH_TYPE_UNSPECIFIED = 0
    AUTH_TYPE_PAT = 1
    AUTH_TYPE_OAUTH2_M2M = 2
    AUTH_TYPE_KEYPAIR = 3
    AUTH_TYPE_ACTIVE_DIR = 4


class SourceSortField(betterproto.Enum):
    SOURCE_SORT_FIELD_UNSPECIFIED = 0
    SOURCE_SORT_FIELD_NAME = 1
    SOURCE_SORT_FIELD_FAVORITE = 2


class SourcePermissionType(betterproto.Enum):
    SOURCE_PERMISSION_TYPE_UNSPECIFIED = 0
    SOURCE_PERMISSION_TYPE_QUERY_TABLES = 1
    SOURCE_PERMISSION_TYPE_RUN_METADATA_METRICS = 2


class SchemaSortField(betterproto.Enum):
    SCHEMA_SORT_FIELD_UNSPECIFIED = 0
    SCHEMA_SORT_FIELD_NAME = 1
    SCHEMA_SORT_FIELD_LAST_SCHEMA_CHANGE = 2
    SCHEMA_SORT_FIELD_FAVORITE = 3
    SCHEMA_SORT_FIELD_LAST_UPDATED = 4
    SCHEMA_SORT_FIELD_POPULARITY = 5


class TableSortField(betterproto.Enum):
    TABLE_SORT_FIELD_UNSPECIFIED = 0
    TABLE_SORT_FIELD_NAME = 1
    TABLE_SORT_FIELD_LAST_SCHEMA_CHANGE = 2
    TABLE_SORT_FIELD_FAVORITE = 3
    TABLE_SORT_FIELD_LAST_UPDATED = 4
    TABLE_SORT_FIELD_POPULARITY = 5
    TABLE_SORT_FIELD_NAME_LENGTH = 6


class SourceConnectionType(betterproto.Enum):
    SOURCE_CONNECTION_TYPE_UNSPECIFIED = 0
    SOURCE_CONNECTION_TYPE_DIRECT_CONNECT = 1
    SOURCE_CONNECTION_TYPE_AGENT = 2


class ColumnSortField(betterproto.Enum):
    COLUMN_SORT_FIELD_UNSPECIFIED = 0
    COLUMN_SORT_FIELD_NAME = 1
    COLUMN_SORT_FIELD_FAVORITE = 2


class VirtualTableSortField(betterproto.Enum):
    VIRTUAL_TABLE_SORT_FIELD_UNSPECIFIED = 0
    VIRTUAL_TABLE_SORT_FIELD_NAME = 1
    VIRTUAL_TABLE_SORT_FIELD_LAST_SCHEMA_CHANGE = 2
    VIRTUAL_TABLE_SORT_FIELD_FAVORITE = 3


class WorkflowProcessingStatus(betterproto.Enum):
    WORKFLOW_PROCESSING_STATUS_UNSPECIFIED = 0
    WORKFLOW_PROCESSING_STATUS_QUEUED = 1
    WORKFLOW_PROCESSING_STATUS_IN_PROGRESS = 2
    WORKFLOW_PROCESSING_STATUS_COMPLETED = 3
    WORKFLOW_PROCESSING_STATUS_PARTIAL_FAILURE = 4
    WORKFLOW_PROCESSING_STATUS_FAILED = 5
    WORKFLOW_PROCESSING_STATUS_TIMED_OUT = 6


class WorkflowProcessingType(betterproto.Enum):
    WORKFLOW_PROCESSING_TYPE_UNSPECIFIED = 0
    WORKFLOW_PROCESSING_TYPE_CATALOG_INDEX_SOURCE = 1
    WORKFLOW_PROCESSING_TYPE_CATALOG_INDEX_SCHEMA = 2
    WORKFLOW_PROCESSING_TYPE_CATALOG_INDEX_DATASET = 3
    WORKFLOW_PROCESSING_TYPE_LINEAGE = 4
    WORKFLOW_PROCESSING_TYPE_METADATA_METRICS = 5
    WORKFLOW_PROCESSING_TYPE_GENERATE_POP_SCORES = 7
    WORKFLOW_PROCESSING_TYPE_CATALOG_INDEX_INTEGRATION = 8
    WORKFLOW_PROCESSING_TYPE_APPLY_BIGCONFIG = 9
    WORKFLOW_PROCESSING_TYPE_RUN_DELTA = 10
    WORKFLOW_PROCESSING_TYPE_RUN_COMPARISON_TABLE = 11
    WORKFLOW_PROCESSING_TYPE_RUN_METRIC_BATCH = 12
    WORKFLOW_PROCESSING_TYPE_PLAN_BIGCONFIG = 13
    WORKFLOW_PROCESSING_TYPE_METRIC_DEPLOY = 14
    WORKFLOW_PROCESSING_TYPE_CATALOG_INDEX_INTEGRATION_ENTITY = 15


class CatalogIndexOperationType(betterproto.Enum):
    CATALOG_INDEX_OPERATION_TYPE_UNSPECIFIED = 0
    CATALOG_INDEX_OPERATION_TYPE_ADD = 1
    CATALOG_INDEX_OPERATION_TYPE_UPDATE = 2
    CATALOG_INDEX_OPERATION_TYPE_DELETE = 3


class SchemaChangeOperation(betterproto.Enum):
    SCHEMA_CHANGE_OPERATION_UNSPECIFIED = 0
    SCHEMA_CHANGE_OPERATION_CREATED = 1
    SCHEMA_CHANGE_OPERATION_DELETED = 2
    SCHEMA_CHANGE_OPERATION_TYPE_CHANGED = 3


class SchemaChangeSortField(betterproto.Enum):
    SCHEMA_CHANGE_SORT_FIELD_UNSPECIFIED = 0
    SCHEMA_CHANGE_SORT_FIELD_CHANGE_TYPE = 1
    SCHEMA_CHANGE_SORT_FIELD_SCHEMA = 2
    SCHEMA_CHANGE_SORT_FIELD_TABLE = 3
    SCHEMA_CHANGE_SORT_FIELD_COLUMN = 4
    SCHEMA_CHANGE_SORT_FIELD_NEW = 5
    SCHEMA_CHANGE_SORT_FIELD_PREVIOUS = 6
    SCHEMA_CHANGE_SORT_FIELD_DETECTED_TIME = 7


class DeltaType(betterproto.Enum):
    DELTA_TYPE_UNSPECIFIED = 0
    DELTA_TYPE_METRIC = 1
    DELTA_TYPE_ROW = 2


class RevisionType(betterproto.Enum):
    REVISION_TYPE_UNSPECIFIED = 0
    REVISION_TYPE_CREATE = 1
    REVISION_TYPE_UPDATE = 2
    REVISION_TYPE_DELETE = 3


class DashboardDataPointType(betterproto.Enum):
    DASHBOARD_DATA_POINT_TYPE_UNSPECIFIED = 0
    DASHBOARD_DATA_POINT_TYPE_NUMBER_OPEN_ISSUES = 1
    DASHBOARD_DATA_POINT_TYPE_AVERAGE_ISSUE_TIME_TO_ACTION = 2
    DASHBOARD_DATA_POINT_TYPE_AVERAGE_ISSUE_TIME_TO_CLOSE = 3
    DASHBOARD_DATA_POINT_TYPE_NUMBER_OPEN_ISSUES_BY_COLLECTION = 4
    DASHBOARD_DATA_POINT_TYPE_NUMBER_METRICS_BY_COLLECTION = 5
    DASHBOARD_DATA_POINT_TYPE_NUMBER_ISSUES_CLOSED_BY_USER = 6
    DASHBOARD_DATA_POINT_TYPE_NUMBER_BILLABLE_TABLES = 7
    DASHBOARD_DATA_POINT_TYPE_NUMBER_ISSUES_CLOSED = 8
    DASHBOARD_DATA_POINT_TYPE_TOTAL_HOURS_TO_CLOSE = 9
    DASHBOARD_DATA_POINT_TYPE_NUMBER_METRICS_WITH_ISSUE_BY_CATEGORY = 10
    DASHBOARD_DATA_POINT_TYPE_NUMBER_METRICS_BY_CATEGORY = 11
    DASHBOARD_DATA_POINT_TYPE_PCT_METRICS_WO_ISSUE_BY_CATEGORY = 12
    DASHBOARD_DATA_POINT_TYPE_TOTAL_TABLES = 13
    DASHBOARD_DATA_POINT_TYPE_TOTAL_TABLES_WITH_METRICS = 14
    DASHBOARD_DATA_POINT_TYPE_PCT_TABLES_WITH_METRICS = 15
    DASHBOARD_DATA_POINT_TYPE_TOTAL_TABLES_WITH_METRICS_BY_CATEGORY = 16
    DASHBOARD_DATA_POINT_TYPE_PCT_TABLES_WITH_METRICS_BY_CATEGORY = 17
    DASHBOARD_DATA_POINT_TYPE_TOTAL_TABLES_WITH_ISSUE_BY_CATEGORY = 18
    DASHBOARD_DATA_POINT_TYPE_NUMBER_ISSUES_INTERACTED = 19
    DASHBOARD_DATA_POINT_TYPE_NUMBER_ISSUES_OPENED = 20
    DASHBOARD_DATA_POINT_TYPE_PCT_ISSUES_INTERACTED = 21
    DASHBOARD_DATA_POINT_TYPE_PCT_TABLES_WITHOUT_ISSUE_BY_CATEGORY = 22
    DASHBOARD_DATA_POINT_TYPE_TOTAL_TABLES_WITHOUT_ISSUE_BY_CATEGORY = 23
    DASHBOARD_DATA_POINT_TYPE_PCT_METRICS_WO_ISSUE_BY_DIMENSION = 24
    DASHBOARD_DATA_POINT_TYPE_NUMBER_METRICS_WITH_ISSUE_BY_DIMENSION = 25
    DASHBOARD_DATA_POINT_TYPE_NUMBER_METRICS_BY_DIMENSION = 26
    DASHBOARD_DATA_POINT_TYPE_PCT_TABLES_WITH_METRICS_BY_DIMENSION = 27
    DASHBOARD_DATA_POINT_TYPE_TOTAL_TABLES_WITH_METRICS_BY_DIMENSION = 28
    DASHBOARD_DATA_POINT_TYPE_PCT_TABLES_WO_ISSUE_BY_DIMENSION = 29
    DASHBOARD_DATA_POINT_TYPE_TOTAL_TABLES_WITH_ISSUE_BY_DIMENSION = 30
    DASHBOARD_DATA_POINT_TYPE_TOTAL_TABLES_WITHOUT_ISSUE_BY_DIMENSION = 31


class DashboardDateAggregationType(betterproto.Enum):
    DASHBOARD_DATE_AGGREGATION_TYPE_DAY = 0
    DASHBOARD_DATE_AGGREGATION_TYPE_WEEK = 1
    DASHBOARD_DATE_AGGREGATION_TYPE_MONTH = 2


class GroupMembershipVia(betterproto.Enum):
    GROUP_MEMBERSHIP_VIA_UNSPECIFIED = 0
    GROUP_MEMBERSHIP_VIA_MANUAL_ASSIGNMENT = 1
    GROUP_MEMBERSHIP_VIA_IDP_GROUPS = 2


class GroupUserOperation(betterproto.Enum):
    GROUP_USER_OPERATION_UNSPECIFIED = 0
    GROUP_USER_OPERATION_ADD = 1
    GROUP_USER_OPERATION_REMOVE = 2


class PermissionDomain(betterproto.Enum):
    PERMISSION_DOMAIN_UNSPECIFIED = 0
    PERMISSION_DOMAIN_ALL = 1
    PERMISSION_DOMAIN_TABLE = 2
    PERMISSION_DOMAIN_CUSTOM_RULE = 3
    PERMISSION_DOMAIN_COLLECTION = 4
    PERMISSION_DOMAIN_WORKSPACE_TAG = 5
    PERMISSION_DOMAIN_WORKSPACE_TAG_ENTITY = 6
    PERMISSION_DOMAIN_PROFILE = 7
    PERMISSION_DOMAIN_SCAN_JOB = 8
    PERMISSION_DOMAIN_DATA_CLASS = 9
    PERMISSION_DOMAIN_CLASSIFIER = 10


class PermissionAction(betterproto.Enum):
    PERMISSION_ACTION_UNSPECIFIED = 0
    PERMISSION_ACTION_ALL = 1
    PERMISSION_ACTION_PREVIEW = 2
    PERMISSION_ACTION_WRITE = 3
    PERMISSION_ACTION_EXECUTE = 4
    PERMISSION_ACTION_READ = 5


class RoleOperation(betterproto.Enum):
    ROLE_OPERATION_UNSPECIFIED = 0
    ROLE_OPERATION_GRANT = 1
    ROLE_OPERATION_REVOKE = 2


class DbtJobRunStatus(betterproto.Enum):
    DBT_JOB_RUN_STATUS_UNSPECIFIED = 0
    DBT_JOB_RUN_STATUS_SUCCESS = 1
    DBT_JOB_RUN_STATUS_ERROR = 2
    DBT_JOB_RUN_STATUS_QUEUED = 3
    DBT_JOB_RUN_STATUS_STARTING = 4
    DBT_JOB_RUN_STATUS_RUNNING = 5
    DBT_JOB_RUN_STATUS_CANCELLED = 6


class SchedulingMechanism(betterproto.Enum):
    # To be removed in PLAT-1706
    SCHEDULING_MECHANISM_UNSPECIFIED = 0
    SCHEDULING_MECHANISM_SCHEDULER = 1
    SCHEDULING_MECHANISM_TEMPORAL = 2


class JoinType(betterproto.Enum):
    JOIN_TYPE_UNSPECIFIED = 0
    JOIN_TYPE_INNER = 1
    JOIN_TYPE_LEFT = 2
    JOIN_TYPE_RIGHT = 3
    JOIN_TYPE_FULL = 4


class CustomRuleType(betterproto.Enum):
    CUSTOM_RULE_TYPE_UNSPECIFIED = 0
    CUSTOM_RULE_TYPE_SQL_RULE = 1
    CUSTOM_RULE_TYPE_JOIN_RULE = 2


class CustomRulesThresholdType(betterproto.Enum):
    CUSTOM_RULES_THRESHOLD_TYPE_UNSPECIFIED = 0
    CUSTOM_RULES_THRESHOLD_TYPE_COUNT = 1
    CUSTOM_RULES_THRESHOLD_TYPE_VALUE = 2
    CUSTOM_RULES_THRESHOLD_TYPE_PERCENT_MATCH = 3


class CustomRuleSortField(betterproto.Enum):
    CUSTOM_RULE_SORT_FIELD_UNSPECIFIED = 0
    CUSTOM_RULE_SORT_FIELD_FAVORITE = 1
    CUSTOM_RULE_SORT_FIELD_NAME = 2
    CUSTOM_RULE_SORT_FIELD_TYPE = 3
    CUSTOM_RULE_SORT_FIELD_LEFT_TABLE = 4
    CUSTOM_RULE_SORT_FIELD_RIGHT_TABLE = 5
    CUSTOM_RULE_SORT_FIELD_JOIN_TYPE = 6
    CUSTOM_RULE_SORT_FIELD_KEYS = 7


class JoinSortField(betterproto.Enum):
    JOIN_SORT_FIELD_UNSPECIFIED = 0
    JOIN_SORT_FIELD_LEFT_TABLE = 1
    JOIN_SORT_FIELD_RIGHT_TABLE = 2
    JOIN_SORT_FIELD_KEYS = 3


class SystemSearchType(betterproto.Enum):
    SYSTEM_SEARCH_TYPE_UNSPECIFIED = 0
    SYSTEM_SEARCH_TYPE_COLLECTION = 1
    SYSTEM_SEARCH_TYPE_DELTA = 2
    SYSTEM_SEARCH_TYPE_ISSUE = 3


class TagSortField(betterproto.Enum):
    TAG_SORT_FIELD_UNSPECIFIED = 0
    TAG_SORT_FIELD_NAME = 1
    TAG_SORT_FIELD_COLOR = 2
    TAG_SORT_FIELD_UPDATED_AT = 3


class TableProfileStatus(betterproto.Enum):
    TABLE_PROFILE_STATUS_UNSPECIFIED = 0
    TABLE_PROFILE_STATUS_SUCCESS = 1
    TABLE_PROFILE_STATUS_FAILED = 2


class SampleMethod(betterproto.Enum):
    SAMPLE_METHOD_UNSPECIFIED = 0
    SAMPLE_METHOD_SIMPLE_LIMIT = 1
    SAMPLE_METHOD_FULL_TABLE_SCAN = 2
    SAMPLE_METHOD_STRONGLY_RANDOM_SAMPLE = 3


class TopLevelCategory(betterproto.Enum):
    """Dimensions"""

    TOP_LEVEL_CATEGORY_UNSPECIFIED = 0
    TOP_LEVEL_CATEGORY_PIPELINE_RELIABILITY = 1
    TOP_LEVEL_CATEGORY_DATA_QUALITY = 2


class DimensionInstanceType(betterproto.Enum):
    DIMENSION_INSTANCE_TYPE_UNSPECIFIED = 0
    DIMENSION_INSTANCE_TYPE_METRIC = 1
    DIMENSION_INSTANCE_TYPE_DELTA = 2
    DIMENSION_INSTANCE_TYPE_ROW_LEVEL_DELTA = 3
    DIMENSION_INSTANCE_TYPE_CUSTOM_RULE = 4
    DIMENSION_INSTANCE_TYPE_JOIN_RULE = 5
    DIMENSION_INSTANCE_TYPE_TEMPLATE_METRIC = 6


class SqlStatementType(betterproto.Enum):
    UNSPECIFIED = 0
    SELECT = 1
    INSERT = 2
    UPDATE = 3
    DELETE = 4
    CREATE_TABLE = 5
    CREATE_VIEW = 6
    DROP = 7
    ALTER = 8
    MERGE = 9
    TRUNCATE = 10


class ScanType(betterproto.Enum):
    SCAN_TYPE_UNSPECIFIED = 0
    SCAN_TYPE_AUTO = 1
    SCAN_TYPE_FULL = 2
    SCAN_TYPE_INCREMENTAL = 3
    SCAN_TYPE_SAMPLED = 4


class ScanJobStatus(betterproto.Enum):
    SCAN_JOB_STATUS_UNSPECIFIED = 0
    SCAN_JOB_STATUS_SCANNED = 1
    SCAN_JOB_STATUS_SCANNING = 2
    SCAN_JOB_STATUS_NO_RUNS = 3
    SCAN_JOB_STATUS_CANCELLED = 4
    SCAN_JOB_STATUS_FAILED = 5


class ScanJobSortField(betterproto.Enum):
    SCAN_JOB_SORT_FIELD_UNSPECIFIED = 0
    SCAN_JOB_SORT_FIELD_NAME = 1
    SCAN_JOB_SORT_FIELD_TYPE = 2
    SCAN_JOB_SORT_FIELD_LAST_RUN = 3
    SCAN_JOB_SORT_FIELD_NEXT_RUN = 4
    SCAN_JOB_SORT_FIELD_STATUS = 5


class ScanRunSortField(betterproto.Enum):
    SCAN_RUN_SORT_FIELD_UNSPECIFIED = 0
    SCAN_RUN_SORT_FIELD_DISPLAY_NAME = 1
    SCAN_RUN_SORT_FIELD_SCAN_JOB_NAME = 2
    SCAN_RUN_SORT_FIELD_STATUS = 3
    SCAN_RUN_SORT_FIELD_STARTED_AT = 4
    SCAN_RUN_SORT_FIELD_COMPLETED_AT = 5
    SCAN_RUN_SORT_FIELD_DURATION = 6
    SCAN_RUN_SORT_FIELD_ROWS_SCANNED = 7
    SCAN_RUN_SORT_FIELD_SCAN_TYPE = 8


class ScanFindingSortField(betterproto.Enum):
    SCAN_FINDING_SORT_FIELD_UNSPECIFIED = 0
    SCAN_FINDING_SORT_FIELD_SCAN_JOB_NAME = 1
    SCAN_FINDING_SORT_FIELD_SCAN_RUN_STARTED_AT = 2
    SCAN_FINDING_SORT_FIELD_SOURCE_NAME = 3
    SCAN_FINDING_SORT_FIELD_SCHEMA_NAME = 4
    SCAN_FINDING_SORT_FIELD_TABLE_NAME = 5
    SCAN_FINDING_SORT_FIELD_COLUMN_NAME = 6
    SCAN_FINDING_SORT_FIELD_CLASSIFIER_NAME = 7
    SCAN_FINDING_SORT_FIELD_DATA_CLASS_NAME = 8
    SCAN_FINDING_SORT_FIELD_ROWS_SCANNED = 9
    SCAN_FINDING_SORT_FIELD_ROWS_MATCHED = 10
    SCAN_FINDING_SORT_FIELD_POSITIVE_FIRST = 11
    SCAN_FINDING_SORT_FIELD_SENSITIVITY = 12
    SCAN_FINDING_SORT_FIELD_EARLIEST_SCAN_AT = 13
    SCAN_FINDING_SORT_FIELD_LATEST_SCAN_AT = 14


class ResetScanAction(betterproto.Enum):
    RESET_SCAN_ACTION_UNSPECIFIED = 0
    RESET_SCAN_ACTION_MARK_FOR_RESET_SCAN = 1
    RESET_SCAN_ACTION_UNMARK_FOR_RESET_SCAN = 2


class DataSensitivity(betterproto.Enum):
    DATA_SENSITIVITY_UNSPECIFIED = 0
    DATA_SENSITIVITY_PUBLIC = 1
    DATA_SENSITIVITY_INTERNAL = 2
    DATA_SENSITIVITY_CONFIDENTIAL = 3
    DATA_SENSITIVITY_RESTRICTED = 4


class DataClassSortField(betterproto.Enum):
    DATA_CLASS_SORT_FIELD_UNSPECIFIED = 0
    DATA_CLASS_SORT_FIELD_NAME = 1
    DATA_CLASS_SORT_FIELD_SENSITIVITY = 2
    DATA_CLASS_SORT_FIELD_CREATOR = 3
    DATA_CLASS_SORT_FIELD_NUMBER_OF_CLASSIFIERS = 4


class DetectorCombinator(betterproto.Enum):
    DETECTOR_COMBINATOR_UNSPECIFIED = 0
    DETECTOR_COMBINATOR_AND = 1
    DETECTOR_COMBINATOR_OR = 2


class DetectorTarget(betterproto.Enum):
    DETECTOR_TARGET_UNSPECIFIED = 0
    DETECTOR_TARGET_DATA = 1
    DETECTOR_TARGET_COLUMN_NAME = 2


class ClassifierSortField(betterproto.Enum):
    CLASSIFIER_SORT_FIELD_UNSPECIFIED = 0
    CLASSIFIER_SORT_FIELD_NAME = 1
    CLASSIFIER_SORT_FIELD_DATA_CLASS_NAME = 2
    CLASSIFIER_SORT_FIELD_SENSITIVITY = 3
    CLASSIFIER_SORT_FIELD_CREATOR = 4
    CLASSIFIER_SORT_FIELD_DETECTOR_TYPE = 5
    CLASSIFIER_SORT_FIELD_NUMBER_OF_SCAN_JOBS = 6


class ModelTypes(betterproto.Enum):
    MODEL_TYPE_UNDEFINED = 0
    MODEL_TYPE_MONOCLE = 1


class MetadataOperation(betterproto.Enum):
    METADATA_OPERATION_UNSPECIFIED = 0
    METADATA_OPERATION_GET_TABLE_INDICIES = 1
    METADATA_OPERATION_GET_TABLE_METADATA = 2
    METADATA_OPERATION_GET_TABLE_LIST = 3
    METADATA_OPERATION_GET_SCHEMA_LIST = 4
    METADATA_OPERATION_GET_SQL_SERVER_TABLE_LIST = 5
    METADATA_OPERATION_GET_BIGQUERY_LOCATION = 6
    METADATA_OPERATION_GET_BIGQUERY_HISTORY_TABLE = 7


class QueryErrorType(betterproto.Enum):
    QUERY_ERROR_TYPE_UNSPECIFIED = 0
    QUERY_ERROR_TYPE_CONNECTION_FAILURE = 1
    QUERY_ERROR_TYPE_QUERY_FAILURE = 2
    QUERY_ERROR_TYPE_METADATA_QUERY_FAILURE = 3
    QUERY_ERROR_TYPE_RESULTSET_CONVERSION_FAILURE = 4


class AgentType(betterproto.Enum):
    AGENT_TYPE_UNSPECIFIED = 0
    AGENT_TYPE_DATA_SOURCE = 1
    AGENT_TYPE_CROSS_SOURCE = 2
    AGENT_TYPE_SENSITIVE_DATA = 3


class TableSplitStrategy(betterproto.Enum):
    TABLE_SPLIT_STRATEGY_UNSPECIFIED = 0
    TABLE_SPLIT_STRATEGY_NONE = 1
    TABLE_SPLIT_STRATEGY_TIMESTAMP = 2
    TABLE_SPLIT_STRATEGY_INTEGER = 3
    TABLE_SPLIT_STRATEGY_HASH_MOD = 4
    TABLE_SPLIT_STRATEGY_REQUIRED_PARTITION_FILTER = 5
    TABLE_SPLIT_STRATEGY_AUTO_OR_INCREMENTAL = 6


@dataclass
class VersionInfo(betterproto.Message):
    app_name: "AppName" = betterproto.enum_field(1)
    version: str = betterproto.string_field(2)
    git_sha: str = betterproto.string_field(3)
    build_time: str = betterproto.string_field(4)


@dataclass
class StringMessage(betterproto.Message):
    message: str = betterproto.string_field(1)


@dataclass
class UserAuth(betterproto.Message):
    authed: bool = betterproto.bool_field(1)
    admin: bool = betterproto.bool_field(2)
    superadmin: bool = betterproto.bool_field(3)
    owner: bool = betterproto.bool_field(4)
    name: str = betterproto.string_field(5)
    email: str = betterproto.string_field(6)
    hmac: str = betterproto.string_field(7)
    company_id: int = betterproto.int32_field(8)
    company_name: str = betterproto.string_field(9)
    company_uuid: str = betterproto.string_field(10)
    id: int = betterproto.int32_field(11)
    advanced_configs: List["ConfigValue"] = betterproto.message_field(12)
    tos_accepted_epoch_seconds: int = betterproto.int64_field(13)
    is_v2_admin: bool = betterproto.bool_field(14)
    workspaces: List["WorkspaceIdNameAndRole"] = betterproto.message_field(15)
    last_csat_taken_at: int = betterproto.int64_field(16)


@dataclass
class WorkspaceIdNameAndRole(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    role_name: str = betterproto.string_field(3)
    role_type: "RoleType" = betterproto.enum_field(4)
    role_permissions: List["RolePermission"] = betterproto.message_field(5)


@dataclass
class User(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    email: str = betterproto.string_field(3)
    groups: List["IdAndDisplayName"] = betterproto.message_field(5)
    picture_url: str = betterproto.string_field(6)
    idp_groups: List[str] = betterproto.string_field(7)
    last_login_at: int = betterproto.int64_field(8)


@dataclass
class UserInviteRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    email: str = betterproto.string_field(2)
    group_ids: List[int] = betterproto.int32_field(3)


@dataclass
class SinglePathParamUserIdRequest(betterproto.Message):
    user_id: int = betterproto.int32_field(1)


@dataclass
class UpdateUserRequestWrapper(betterproto.Message):
    user_id: int = betterproto.int32_field(1)
    request: "UpdateUserRequest" = betterproto.message_field(2)


@dataclass
class UpdateUserRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    group_ids: List[int] = betterproto.int32_field(2)


@dataclass
class UpdateUserResponse(betterproto.Message):
    user: "User" = betterproto.message_field(1)


@dataclass
class SetCsatParticipationRequest(betterproto.Message):
    csat_taken_at: int = betterproto.int64_field(1)


@dataclass
class UpdateCompanyRequest(betterproto.Message):
    name: str = betterproto.string_field(1)


@dataclass
class UpdateCompanyRequestWrapper(betterproto.Message):
    company_id: int = betterproto.int32_field(1)
    request: "UpdateCompanyRequest" = betterproto.message_field(2)


@dataclass
class Company(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)


@dataclass
class SimpleBound(betterproto.Message):
    bound_type: "SimpleBoundType" = betterproto.enum_field(1)
    # Value of the threshold. For AutoThreshold types this is ignored.
    value: float = betterproto.double_field(2)


@dataclass
class AutoThreshold(betterproto.Message):
    bound: "SimpleBound" = betterproto.message_field(1)
    # This field is ignored for configuration purposes.
    model_type: "ForecastModelType" = betterproto.enum_field(2)
    forecast_time: int = betterproto.int32_field(3)
    sensitivity: "AutothresholdSensitivity" = betterproto.enum_field(4)
    # This field is ignored for configuration purposes.
    forecast_value: float = betterproto.double_field(5)


@dataclass
class ConstantThreshold(betterproto.Message):
    bound: "SimpleBound" = betterproto.message_field(1)


@dataclass
class RelativeThreshold(betterproto.Message):
    lookback: "TimeInterval" = betterproto.message_field(1)
    bound: "SimpleBound" = betterproto.message_field(2)


@dataclass
class StandardDeviationThreshold(betterproto.Message):
    lookback: "TimeInterval" = betterproto.message_field(1)
    bound: "SimpleBound" = betterproto.message_field(2)


@dataclass
class FreshnessScheduleThreshold(betterproto.Message):
    cron: str = betterproto.string_field(1)
    timezone: str = betterproto.string_field(2)
    bound: "SimpleBound" = betterproto.message_field(3)
    delay_at_update: "TimeInterval" = betterproto.message_field(4)


@dataclass
class NoneThreshold(betterproto.Message):
    pass


@dataclass
class Threshold(betterproto.Message):
    # Flat value threshold
    constant_threshold: "ConstantThreshold" = betterproto.message_field(
        1, group="threshold_type"
    )
    # Threshold with a fixed lookback window. Only valid for tables that have
    # Metric Time set.
    relative_threshold: "RelativeThreshold" = betterproto.message_field(
        2, group="threshold_type"
    )
    auto_threshold: "AutoThreshold" = betterproto.message_field(
        3, group="threshold_type"
    )
    freshness_schedule_threshold: "FreshnessScheduleThreshold" = (
        betterproto.message_field(4, group="threshold_type")
    )
    standard_deviation_threshold: "StandardDeviationThreshold" = (
        betterproto.message_field(5, group="threshold_type")
    )
    none_threshold: "NoneThreshold" = betterproto.message_field(
        6, group="threshold_type"
    )


@dataclass
class SlackChannelInfo(betterproto.Message):
    channel_id: str = betterproto.string_field(1)
    channel_name: str = betterproto.string_field(2)
    thread_ts: str = betterproto.string_field(3)
    issue_thread_permalink: str = betterproto.string_field(4)


@dataclass
class TestEmailRequest(betterproto.Message):
    email_address: str = betterproto.string_field(1)


@dataclass
class TestSlackRequest(betterproto.Message):
    channel_name: str = betterproto.string_field(1)
    metric_id: int = betterproto.int32_field(2)
    collection_id: int = betterproto.int32_field(3)
    delta_id: int = betterproto.int32_field(4)
    scan_job_id: int = betterproto.int64_field(5)


@dataclass
class WebhookHeader(betterproto.Message):
    key: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)


@dataclass
class Webhook(betterproto.Message):
    webhook_url: str = betterproto.string_field(1)
    webhook_headers: List["WebhookHeader"] = betterproto.message_field(2)


@dataclass
class NotificationChannel(betterproto.Message):
    email: str = betterproto.string_field(1, group="notification_channel")
    webhook: "Webhook" = betterproto.message_field(3, group="notification_channel")
    slack_channel_info: "SlackChannelInfo" = betterproto.message_field(
        4, group="notification_channel"
    )
    external_ticket_info: "IssueExternalTicketInfo" = betterproto.message_field(
        5, group="notification_channel"
    )


@dataclass
class TimeInterval(betterproto.Message):
    interval_type: "TimeIntervalType" = betterproto.enum_field(1)
    interval_value: int = betterproto.int32_field(2)


@dataclass
class MetricParameter(betterproto.Message):
    key: str = betterproto.string_field(1)
    string_value: str = betterproto.string_field(2, group="value")
    column_name: str = betterproto.string_field(3, group="value")
    number_value: float = betterproto.double_field(4, group="value")


@dataclass
class PredefinedMetric(betterproto.Message):
    metric_name: "PredefinedMetricName" = betterproto.enum_field(1)


@dataclass
class TemplateMetric(betterproto.Message):
    template_id: int = betterproto.int32_field(1)
    aggregation_type: "AggregationType" = betterproto.enum_field(2)
    template_name: str = betterproto.string_field(3)


@dataclass
class MetricType(betterproto.Message):
    predefined_metric: "PredefinedMetric" = betterproto.message_field(
        1, group="metric_type"
    )
    template_metric: "TemplateMetric" = betterproto.message_field(
        2, group="metric_type"
    )
    external_monitor: "ExternalMonitor" = betterproto.message_field(
        5, group="metric_type"
    )
    is_metadata_metric: bool = betterproto.bool_field(3)
    is_table_metric: bool = betterproto.bool_field(4)


@dataclass
class ExternalMonitor(betterproto.Message):
    type: "ExternalMonitorType" = betterproto.enum_field(1)


@dataclass
class MetricGroupOverride(betterproto.Message):
    group_dimensions: List["MetricGroupDimension"] = betterproto.message_field(1)
    thresholds: List["Threshold"] = betterproto.message_field(2)
    group_name: str = betterproto.string_field(4)


@dataclass
class MetricSchedule(betterproto.Message):
    schedule_frequency: "TimeInterval" = betterproto.message_field(1, group="schedule")
    named_schedule: "NamedSchedule" = betterproto.message_field(2, group="schedule")


@dataclass
class ScanSchedule(betterproto.Message):
    schedule_frequency: "ScanScheduleFrequency" = betterproto.message_field(
        1, group="schedule"
    )
    named_schedule: "NamedSchedule" = betterproto.message_field(2, group="schedule")


@dataclass
class ScanScheduleFrequency(betterproto.Message):
    time_interval: "TimeInterval" = betterproto.message_field(1)
    start_time_epoch_seconds: int = betterproto.int64_field(2)


@dataclass
class MetricConfiguration(betterproto.Message):
    id: int = betterproto.int32_field(1)
    schedule_frequency: "TimeInterval" = betterproto.message_field(2)
    # Each filter evaluates to a valid SQL boolean expression
    filters: List[str] = betterproto.string_field(3)
    # Each group by is a column name from the table for this metric
    group_bys: List[str] = betterproto.string_field(4)
    thresholds: List["Threshold"] = betterproto.message_field(5)
    notification_channels: List["NotificationChannel"] = betterproto.message_field(6)
    warehouse_id: int = betterproto.int32_field(7)
    # Bigeye ID for the table which this metric is run on
    dataset_id: int = betterproto.int32_field(8)
    # Determines if this is a predefined metric or a template metric
    metric_type: "MetricType" = betterproto.message_field(9)
    parameters: List["MetricParameter"] = betterproto.message_field(10)
    # Lookback interval supports only DAYS_TIME_INTERVAL_TYPE for now.
    lookback: "TimeInterval" = betterproto.message_field(11)
    # Lookback type for metrics on tables with metric time enabled. The default
    # is DATA_TIME_LOOKBACK_TYPE
    lookback_type: "LookbackType" = betterproto.enum_field(12)
    metric_creation_state: "MetricCreationState" = betterproto.enum_field(13)
    # width of METRIC_TIME based metric intervals
    grain_seconds: int = betterproto.int32_field(14)
    muted_until_epoch_seconds: int = betterproto.int64_field(15)
    name: str = betterproto.string_field(16)
    description: str = betterproto.string_field(17)
    is_table_metric: bool = betterproto.bool_field(18)
    metric_group_overrides: List["MetricGroupOverride"] = betterproto.message_field(19)
    metric_schedule: "MetricSchedule" = betterproto.message_field(20)
    rct_override: str = betterproto.string_field(21)
    is_lookback_using_current_time: bool = betterproto.bool_field(22)
    bigconfig_namespace: str = betterproto.string_field(23)
    dimension: "IdAndDisplayName" = betterproto.message_field(24)
    profiling_suggestion_for_column: "IdAndDisplayName" = betterproto.message_field(25)
    metric_observed_column_response: List["MetricObservedColumnResponse"] = (
        betterproto.message_field(26)
    )
    monitor_type: "MonitorType" = betterproto.enum_field(27)


@dataclass
class MetricConfigurationWithSLAs(betterproto.Message):
    metric_configuration: "MetricConfiguration" = betterproto.message_field(1)
    collection_ids: List[int] = betterproto.int32_field(2)
    tags: List[str] = betterproto.string_field(3)
    owner_id: int = betterproto.int32_field(4)


@dataclass
class MetricConfigurationWithValidation(betterproto.Message):
    metric_configuration: "MetricConfiguration" = betterproto.message_field(1)
    validation: "MetricValidationResult" = betterproto.message_field(2)


@dataclass
class BatchRunMetricsRequest(betterproto.Message):
    # IDs of the metrics to be run -- only metrics with the same dataset, grain
    # size, groups, and lookback type can be run as a batch
    metric_ids: List[int] = betterproto.int32_field(1)
    should_write_to_metric_run_start: bool = betterproto.bool_field(2)
    where: "WhereClause" = betterproto.message_field(3)


@dataclass
class QueuedMetricsRequest(betterproto.Message):
    workflow_id: int = betterproto.int64_field(1)
    workflow_process_id: int = betterproto.int64_field(2)
    metric_ids: List[int] = betterproto.int32_field(3)


@dataclass
class WorkflowInfo(betterproto.Message):
    workflow_id: int = betterproto.int64_field(1)
    workflow_process_id: int = betterproto.int64_field(2)
    workflow_processing_type: "WorkflowProcessingType" = betterproto.enum_field(3)


@dataclass
class AsyncBatchRunMetricsRequest(betterproto.Message):
    batch_run_metrics_request: "BatchRunMetricsRequest" = betterproto.message_field(1)
    workflow_info: "WorkflowInfo" = betterproto.message_field(2)


@dataclass
class BatchRunMetricsResponse(betterproto.Message):
    metric_infos: List["MetricInfo"] = betterproto.message_field(1)
    metrics_not_run: List["MetricInfo"] = betterproto.message_field(2)


@dataclass
class BatchDeleteMetricsRequest(betterproto.Message):
    metric_ids: List[int] = betterproto.int32_field(1)


@dataclass
class BatchMetricConfigRequest(betterproto.Message):
    metric_ids: List[int] = betterproto.int32_field(1)
    metric_configuration: "MetricConfiguration" = betterproto.message_field(2)


@dataclass
class FailedMetricEdit(betterproto.Message):
    metric_id: int = betterproto.int32_field(1)
    reason: str = betterproto.string_field(2)


@dataclass
class BatchMetricConfigResponse(betterproto.Message):
    successful_metric_ids: List[int] = betterproto.int32_field(1)
    failed_metric_edits: List["FailedMetricEdit"] = betterproto.message_field(2)


@dataclass
class BatchGetMetricResponse(betterproto.Message):
    metrics: List["MetricConfiguration"] = betterproto.message_field(1)


@dataclass
class ColumnMetricProfile(betterproto.Message):
    id: int = betterproto.int32_field(1)
    column_id: int = betterproto.int32_field(2)
    metric_name: str = betterproto.string_field(3)
    min: float = betterproto.double_field(4)
    max: float = betterproto.double_field(5)
    p25: float = betterproto.double_field(6)
    p75: float = betterproto.double_field(7)
    mean: float = betterproto.double_field(8)
    standard_deviation: float = betterproto.double_field(9)


@dataclass
class ColumnMetricProfileList(betterproto.Message):
    profiles: List["ColumnMetricProfile"] = betterproto.message_field(1)


@dataclass
class SinglePathParamTableIdRequest(betterproto.Message):
    table_id: int = betterproto.int32_field(1)


@dataclass
class SinglePathParamColumnIdRequest(betterproto.Message):
    column_id: int = betterproto.int32_field(1)


@dataclass
class SchemaSearchRequest(betterproto.Message):
    warehouse_id: List[int] = betterproto.int32_field(1)
    schema_name: List[str] = betterproto.string_field(2)
    schema_id: List[int] = betterproto.int32_field(3)
    workspace_id: int = betterproto.int32_field(4)


@dataclass
class TableAndColumnIdRequest(betterproto.Message):
    table_id: int = betterproto.int32_field(1)
    column_id: int = betterproto.int32_field(2)


@dataclass
class TableSearchRequest(betterproto.Message):
    warehouse_id: List[int] = betterproto.int32_field(1)
    schema: List[str] = betterproto.string_field(2)
    table_name: List[str] = betterproto.string_field(3)
    ids: List[int] = betterproto.int32_field(4)
    schema_id: List[int] = betterproto.int32_field(5)
    include_favorites: bool = betterproto.bool_field(6)
    ignore_fields: bool = betterproto.bool_field(7)
    workspace_id: int = betterproto.int32_field(8)
    include_data_node_ids: bool = betterproto.bool_field(9)


@dataclass
class MetricHistoryDataPoint(betterproto.Message):
    epoch_seconds: int = betterproto.int64_field(1)
    value: float = betterproto.double_field(2)
    lower_threshold: float = betterproto.double_field(3)
    upper_threshold: float = betterproto.double_field(4)
    run_status: "MetricRunStatus" = betterproto.enum_field(5)
    should_use_for_training: bool = betterproto.bool_field(6)
    rows_scanned: int = betterproto.int64_field(7)
    rows_matched: int = betterproto.int64_field(8)


@dataclass
class SlackInfo(betterproto.Message):
    is_registered: bool = betterproto.bool_field(1)
    slack_registration_button_html: str = betterproto.string_field(2)
    slack_authorize_url: str = betterproto.string_field(3)
    slack_scope: str = betterproto.string_field(4)
    slack_state: str = betterproto.string_field(5)
    client_id: str = betterproto.string_field(6)
    redirect_uri: str = betterproto.string_field(7)


@dataclass
class CollectionMetricStatus(betterproto.Message):
    metrics_count: int = betterproto.int32_field(1)
    alerting_metrics_count: int = betterproto.int32_field(2)
    earliest_updated_metric_seconds: int = betterproto.int64_field(3)
    latest_updated_metric_seconds: int = betterproto.int64_field(4)
    open_issues_count: int = betterproto.int32_field(5)
    triage_issues_count: int = betterproto.int32_field(6)
    acknowledge_issues_count: int = betterproto.int32_field(7)
    monitoring_issues_count: int = betterproto.int32_field(8)


@dataclass
class CollectionInfo(betterproto.Message):
    collection_configuration: "Collection" = betterproto.message_field(1)
    collection_metric_status: "CollectionMetricStatus" = betterproto.message_field(2)


@dataclass
class GetCollectionInfoResponse(betterproto.Message):
    collection_info: "CollectionInfo" = betterproto.message_field(1)


@dataclass
class GetAllCollectionInfosRequest(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)


@dataclass
class GetAllCollectionInfosResponse(betterproto.Message):
    collection_infos: List["CollectionInfo"] = betterproto.message_field(1)


@dataclass
class GetPaginatedCollectionInfosRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_field: "CollectionInfoSortField" = betterproto.enum_field(3)
    sort_direction: "SortDirection" = betterproto.enum_field(4)
    search: str = betterproto.string_field(5)
    workspace_id: int = betterproto.int32_field(6)


@dataclass
class GetPaginatedCollectionInfosV2Request(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_field: "CollectionInfoV2SortField" = betterproto.enum_field(3)
    sort_direction: "SortDirection" = betterproto.enum_field(4)
    search: str = betterproto.string_field(5)
    workspace_id: int = betterproto.int32_field(6)


@dataclass
class GetPaginatedCollectionInfosResponse(betterproto.Message):
    collection_infos: List["CollectionInfo"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class Collection(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    description: str = betterproto.string_field(3)
    entity_info: "EntityInfo" = betterproto.message_field(4)
    owner: int = betterproto.int32_field(5)
    metric_ids: List[int] = betterproto.int32_field(6)
    notification_channels: List["NotificationChannel"] = betterproto.message_field(7)
    muted_until_timestamp: int = betterproto.int32_field(8)
    is_favorite: bool = betterproto.bool_field(9)
    tags: List["Tag"] = betterproto.message_field(10)


@dataclass
class CreateCollectionResponse(betterproto.Message):
    collection: "Collection" = betterproto.message_field(1)
    failed_metric_edits: List["FailedMetricEdit"] = betterproto.message_field(2)


@dataclass
class GetCollectionResponse(betterproto.Message):
    collection: "Collection" = betterproto.message_field(1)


@dataclass
class GetCollectionsRequest(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)


@dataclass
class GetCollectionsResponse(betterproto.Message):
    collections: List["Collection"] = betterproto.message_field(1)


@dataclass
class BulkCollectionUpdate(betterproto.Message):
    where: "WhereClause" = betterproto.message_field(1)
    is_delete: bool = betterproto.bool_field(2)
    notification_channels: List["NotificationChannel"] = betterproto.message_field(3)
    mute_request: "MuteRequest" = betterproto.message_field(4)


@dataclass
class EditCollectionWrapper(betterproto.Message):
    collection_id: int = betterproto.int32_field(1)
    body: "EditCollectionRequest" = betterproto.message_field(2)


@dataclass
class EditCollectionRequest(betterproto.Message):
    collection_name: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    metric_ids: List[int] = betterproto.int32_field(3)
    notification_channels: List["NotificationChannel"] = betterproto.message_field(4)
    muted_until_timestamp: int = betterproto.int32_field(5)
    workspace_id: int = betterproto.int32_field(6)


@dataclass
class EditCollectionResponse(betterproto.Message):
    collection: "Collection" = betterproto.message_field(1)
    failed_metric_edits: List["FailedMetricEdit"] = betterproto.message_field(2)


@dataclass
class SinglePathParamCollectionIdRequest(betterproto.Message):
    collection_id: int = betterproto.int32_field(1)


@dataclass
class EntityInfo(betterproto.Message):
    created_by: int = betterproto.int32_field(1)
    created_epoch_seconds: int = betterproto.int64_field(2)
    updated_by: int = betterproto.int32_field(3)
    updated_epoch_seconds: int = betterproto.int64_field(4)


@dataclass
class CollectionRevision(betterproto.Message):
    revision_info: "RevisionInfo" = betterproto.message_field(1)
    collection: "Collection" = betterproto.message_field(2)


@dataclass
class GetCollectionRevisionsResponse(betterproto.Message):
    revisions: List["CollectionRevision"] = betterproto.message_field(1)


@dataclass
class MetricRunAnnotation(betterproto.Message):
    id: int = betterproto.int32_field(1)
    metric_run_id: int = betterproto.int32_field(2)
    metric_run_label: "MetricRunLabel" = betterproto.enum_field(3)
    entity_info: "EntityInfo" = betterproto.message_field(4)


@dataclass
class MetricRun(betterproto.Message):
    run_at_epoch_seconds: int = betterproto.int64_field(1)
    status: "MetricRunStatus" = betterproto.enum_field(2)
    observed_value: float = betterproto.double_field(3)
    thresholds: List["ConstantThreshold"] = betterproto.message_field(4)
    failure_reason: "MetricRunFailureReason" = betterproto.enum_field(5)
    # start of grain for METRIC_TIME based runs
    grain_start_epoch_seconds: int = betterproto.int64_field(6)
    # end of grain for METRIC_TIME based runs
    grain_end_epoch_seconds: int = betterproto.int64_field(7)
    metric_run_annotation: "MetricRunAnnotation" = betterproto.message_field(8)
    group_dimensions: List["MetricGroupDimension"] = betterproto.message_field(9)
    id: int = betterproto.int32_field(10)
    group_name: str = betterproto.string_field(11)
    exception_class: str = betterproto.string_field(12)
    exception_message: str = betterproto.string_field(13)
    summary_status: "MetricStatus" = betterproto.enum_field(14)
    is_posthoc: bool = betterproto.bool_field(15)
    rows_scanned: int = betterproto.int64_field(16)
    rows_matched: int = betterproto.int64_field(17)
    has_row_counts: bool = betterproto.bool_field(18)
    has_rows_matched: bool = betterproto.bool_field(19)


@dataclass
class MetricMetadata(betterproto.Message):
    statistic_name: str = betterproto.string_field(1)
    statistic_full_name: str = betterproto.string_field(2)
    dataset_name: str = betterproto.string_field(3)
    field_id: int = betterproto.int32_field(4)
    field_name: str = betterproto.string_field(5)
    dataset_time_column_name: str = betterproto.string_field(6)
    warehouse_name: str = betterproto.string_field(7)
    schema_id: int = betterproto.int32_field(8)
    schema_name: str = betterproto.string_field(9)
    warehouse_id: int = betterproto.int32_field(10)
    dataset_id: int = betterproto.int32_field(11)
    created_at: int = betterproto.int64_field(12)
    companion_metrics: List["CompanionMetric"] = betterproto.message_field(13)
    is_favorite: bool = betterproto.bool_field(14)
    metric_history_begin_at: int = betterproto.int64_field(15)
    current_metric_status: "MetricStatus" = betterproto.enum_field(16)
    workspace_id: int = betterproto.int32_field(17)
    metric_history_end_at: int = betterproto.int64_field(18)
    run_at: int = betterproto.int64_field(19)
    updated_at: int = betterproto.int64_field(20)


@dataclass
class CompanionMetric(betterproto.Message):
    id: int = betterproto.int32_field(1)
    type: "CompanionMetricType" = betterproto.enum_field(2)
    metric_info: "IdAndDisplayName" = betterproto.message_field(3)


@dataclass
class MetricInfo(betterproto.Message):
    metric_configuration: "MetricConfiguration" = betterproto.message_field(1)
    metric_metadata: "MetricMetadata" = betterproto.message_field(2)
    # Latest metric run results
    latest_metric_runs: List["MetricRun"] = betterproto.message_field(3)
    is_snoozed: bool = betterproto.bool_field(4)
    status: "MetricRunStatus" = betterproto.enum_field(5)
    group_count: int = betterproto.int32_field(6)
    critical_group_count: int = betterproto.int32_field(7)
    can_backfill: bool = betterproto.bool_field(8)
    collections: List["IdAndDisplayName"] = betterproto.message_field(9)
    active_issue: "IdAndDisplayName" = betterproto.message_field(10)
    is_backfill_destructive: bool = betterproto.bool_field(11)
    reason_cannot_backfill: str = betterproto.string_field(12)
    no_value_group_count: int = betterproto.int32_field(13)
    tags: List["Tag"] = betterproto.message_field(14)


@dataclass
class MetricRunningStatus(betterproto.Message):
    """to differentiate from MetricRunStatus"""

    metric_id: int = betterproto.int32_field(1)
    is_running: bool = betterproto.bool_field(2)


@dataclass
class MetricsRunningStatuses(betterproto.Message):
    metrics_running_statuses: List["MetricRunningStatus"] = betterproto.message_field(1)


@dataclass
class MetricsRunningStatusesRequest(betterproto.Message):
    metric_ids: List[int] = betterproto.int32_field(1)


@dataclass
class MetricGroupDimension(betterproto.Message):
    column_name: str = betterproto.string_field(1)
    column_value: str = betterproto.string_field(2)


@dataclass
class MetricIdentifier(betterproto.Message):
    metric_id: int = betterproto.int32_field(1)
    group_dimensions: List["MetricGroupDimension"] = betterproto.message_field(2)


@dataclass
class MetricRunHistory(betterproto.Message):
    metric_identifier: "MetricIdentifier" = betterproto.message_field(1)
    metric_timeseries: List["MetricHistoryDataPoint"] = betterproto.message_field(2)


@dataclass
class GetMetricRunHistoryRequest(betterproto.Message):
    metric_identifier: "MetricIdentifier" = betterproto.message_field(1)
    days_of_history: int = betterproto.int32_field(2)
    include_failed_runs: bool = betterproto.bool_field(3)
    max_number_of_points: int = betterproto.int32_field(4)
    exclude_mutable_point: bool = betterproto.bool_field(5)


@dataclass
class GetCustomRuleRunsRequest(betterproto.Message):
    custom_rule_id: int = betterproto.int32_field(1)
    runs_request: "GetMetricRunsRequest" = betterproto.message_field(2)


@dataclass
class GetMetricRunsResponse(betterproto.Message):
    metric_identifier: "MetricIdentifier" = betterproto.message_field(1)
    metric_runs: List["MetricRun"] = betterproto.message_field(2)
    pagination_info: "PaginationInfo" = betterproto.message_field(3)


@dataclass
class MetadataMetricSchemaRequest(betterproto.Message):
    schema_ids: List[int] = betterproto.int32_field(1)


@dataclass
class GetMetricRunsRequest(betterproto.Message):
    metric_identifier: "MetricIdentifier" = betterproto.message_field(1)
    days_of_history: int = betterproto.int32_field(2)
    page_size: int = betterproto.int32_field(8)
    page_cursor: str = betterproto.string_field(9)
    sort_field: "MetricRunSortField" = betterproto.enum_field(10)
    sort_direction: "SortDirection" = betterproto.enum_field(14)
    issue_id: int = betterproto.int32_field(15)
    start_epoch_seconds: int = betterproto.int64_field(16)
    end_epoch_seconds: int = betterproto.int64_field(17)


@dataclass
class GetMetricRunsBulkRequest(betterproto.Message):
    metric_identifier: List["MetricIdentifier"] = betterproto.message_field(1)
    days_of_history: int = betterproto.int32_field(2)
    start_epoch_seconds: int = betterproto.int64_field(3)
    end_epoch_seconds: int = betterproto.int64_field(4)


@dataclass
class MetricWithRuns(betterproto.Message):
    metric_identifier: "MetricIdentifier" = betterproto.message_field(1)
    metric_runs: List["MetricRun"] = betterproto.message_field(2)


@dataclass
class GetMetricRunsBulkResponse(betterproto.Message):
    metrics: List["MetricWithRuns"] = betterproto.message_field(1)


@dataclass
class MetricSuiteRequest(betterproto.Message):
    metric_suite: "MetricSuite" = betterproto.message_field(1)
    workflow_info: "WorkflowInfo" = betterproto.message_field(2)
    is_apply: bool = betterproto.bool_field(3)


@dataclass
class MetricSuite(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    definitions: List["CohortAndMetricDefinition"] = betterproto.message_field(2)
    row_creation_cohorts: List["CohortDefinition"] = betterproto.message_field(3)
    auto_apply_on_indexing: bool = betterproto.bool_field(4)
    namespace: str = betterproto.string_field(5)
    invoking_user: int = betterproto.int32_field(6)


@dataclass
class CohortAndMetricDefinition(betterproto.Message):
    cohorts: List["CohortDefinition"] = betterproto.message_field(1)
    metrics: List["MetricDefinition"] = betterproto.message_field(2)


@dataclass
class CohortDefinition(betterproto.Message):
    entity_type: "CatalogEntityType" = betterproto.enum_field(1)
    schema_name_pattern: str = betterproto.string_field(2)
    table_name_pattern: str = betterproto.string_field(3)
    column_name_pattern: str = betterproto.string_field(4)
    column_type: "FieldType" = betterproto.enum_field(5)
    schema_exclude_pattern: str = betterproto.string_field(6)
    table_exclude_pattern: str = betterproto.string_field(7)
    column_exclude_pattern: str = betterproto.string_field(8)
    use_raw_regex: bool = betterproto.bool_field(9)
    schema_exclusions: List[str] = betterproto.string_field(10)
    table_exclusions: List[str] = betterproto.string_field(11)
    column_exclusions: List[str] = betterproto.string_field(12)
    tags: List[str] = betterproto.string_field(13)
    manage_tags: bool = betterproto.bool_field(14)


@dataclass
class MetricRunCounts(betterproto.Message):
    date_in_millis: int = betterproto.int64_field(1)
    healthy_count: int = betterproto.int32_field(2)
    alerting_count: int = betterproto.int32_field(3)


@dataclass
class MetricCategoryHistory(betterproto.Message):
    metric_category: "MetricCategory" = betterproto.enum_field(1)
    metric_run_counts: List["MetricRunCounts"] = betterproto.message_field(2)


@dataclass
class GetMetricRunsByCategoryResponse(betterproto.Message):
    histories: List["MetricCategoryHistory"] = betterproto.message_field(1)


@dataclass
class MetricScorecardCounts(betterproto.Message):
    # timestamp of the day for these counts
    run_at_minute: int = betterproto.int64_field(1)
    # number of true positive issues on this day
    true_positive_issues_opened: int = betterproto.int32_field(2)
    # if metrics were deployed on this day
    had_metrics_deployed: bool = betterproto.bool_field(3)


@dataclass
class MetricCategoryScorecard(betterproto.Message):
    # category of the metrics for this scorecard
    metric_category: "MetricCategory" = betterproto.enum_field(1)
    # daily count data for this scorecard
    metric_run_counts: List["MetricScorecardCounts"] = betterproto.message_field(2)


@dataclass
class GetMetricScorecardRequest(betterproto.Message):
    # Number of days of scorecard history to get, max 90
    days_of_history: int = betterproto.int32_field(1)
    # Filter by source, schema, table, or column.
    where: "WhereClause" = betterproto.message_field(2)


@dataclass
class GetMetricScorecardResponse(betterproto.Message):
    scorecards: List["MetricCategoryScorecard"] = betterproto.message_field(1)


@dataclass
class DimensionScorecard(betterproto.Message):
    dimension: "Dimension" = betterproto.message_field(1)
    metric_run_counts: List["MetricScorecardCounts"] = betterproto.message_field(2)


@dataclass
class GetDimensionScorecardResponse(betterproto.Message):
    scorecards: List["DimensionScorecard"] = betterproto.message_field(1)


@dataclass
class GetCurrentDimensionScorecardRequest(betterproto.Message):
    where: "WhereClause" = betterproto.message_field(1)


@dataclass
class GetCurrentDimensionScorecardResponse(betterproto.Message):
    items: List["CurrentDimensionScorecardItem"] = betterproto.message_field(1)


@dataclass
class CurrentDimensionScorecardItem(betterproto.Message):
    dimension: "Dimension" = betterproto.message_field(1)
    metric_type: "MetricType" = betterproto.message_field(2)
    num_metrics: int = betterproto.int64_field(3)
    num_issues: int = betterproto.int64_field(4)


@dataclass
class DefaultDimensionRequest(betterproto.Message):
    create_dimensions: bool = betterproto.bool_field(1)
    assign_default_dimensions: bool = betterproto.bool_field(2)
    backfill_scorecards: bool = betterproto.bool_field(3)


@dataclass
class MetricDefinition(betterproto.Message):
    schedule_frequency: "TimeInterval" = betterproto.message_field(2)
    filters: List[str] = betterproto.string_field(3)
    group_bys: List[str] = betterproto.string_field(4)
    thresholds: List["Threshold"] = betterproto.message_field(5)
    notification_channels: List["NotificationChannel"] = betterproto.message_field(6)
    metric_type: "MetricType" = betterproto.message_field(9)
    parameters: List["MetricParameter"] = betterproto.message_field(10)
    lookback: "TimeInterval" = betterproto.message_field(11)
    lookback_type: "LookbackType" = betterproto.enum_field(12)
    grain_seconds: int = betterproto.int32_field(13)
    muted_until_epoch_seconds: int = betterproto.int64_field(14)
    name: str = betterproto.string_field(15)
    description: str = betterproto.string_field(16)
    is_table_metric: bool = betterproto.bool_field(17)
    metric_group_overrides: List["MetricGroupOverride"] = betterproto.message_field(18)
    collection_ids: List[int] = betterproto.int32_field(19)
    metric_schedule: "MetricSchedule" = betterproto.message_field(20)
    tags: List[str] = betterproto.string_field(21)
    rct_overrides: List[str] = betterproto.string_field(22)
    owner_id: int = betterproto.int32_field(23)


@dataclass
class DateColumn(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    is_current_metric_time: bool = betterproto.bool_field(3)
    is_recommended_metric_time: bool = betterproto.bool_field(4)


@dataclass
class TableInfoWithColumns(betterproto.Message):
    id: int = betterproto.int32_field(1)
    schema_name: str = betterproto.string_field(2)
    table_name: str = betterproto.string_field(3)
    columns: List["DateColumn"] = betterproto.message_field(4)
    has_user_selected_none_rct: bool = betterproto.bool_field(5)
    warehouse_name: str = betterproto.string_field(6)
    warehouse_id: int = betterproto.int32_field(7)
    warehouse_type: "WarehouseType" = betterproto.enum_field(8)


@dataclass
class TableInfoWithColumnsRequest(betterproto.Message):
    where: "WhereClause" = betterproto.message_field(1)


@dataclass
class TableInfoWithColumnsResponse(betterproto.Message):
    info: List["TableInfoWithColumns"] = betterproto.message_field(1)
    failures: List["RowCreationTimeFailure"] = betterproto.message_field(2)


@dataclass
class SetDateColumnRequest(betterproto.Message):
    column_ids: List[int] = betterproto.int32_field(1)
    table_ids_with_none_rct: List[int] = betterproto.int32_field(2)


@dataclass
class RowCreationTimeFailure(betterproto.Message):
    failed_columns: List["IdAndDisplayName"] = betterproto.message_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class RowCreationTimeResponse(betterproto.Message):
    columns_set_as_row_creation_time: List["IdAndDisplayName"] = (
        betterproto.message_field(1)
    )
    row_creation_time_upsert_failures: List["RowCreationTimeFailure"] = (
        betterproto.message_field(2)
    )
    tables_with_row_creation_time_set: List["IdAndDisplayName"] = (
        betterproto.message_field(3)
    )


@dataclass
class MetricSuiteResponse(betterproto.Message):
    created_metrics: List["MetricConfigurationWithSLAs"] = betterproto.message_field(1)
    updated_metrics: List["MetricConfigurationWithSLAs"] = betterproto.message_field(2)
    deleted_metrics: List["MetricConfigurationWithSLAs"] = betterproto.message_field(3)
    metric_application_errors: List["InvalidAssetMetricDefinitionApplication"] = (
        betterproto.message_field(4)
    )
    invalid_cohort_errors: List["InvalidCohort"] = betterproto.message_field(5)
    row_creation_time_response: "RowCreationTimeResponse" = betterproto.message_field(6)
    unchanged_metrics: List["MetricConfigurationWithSLAs"] = betterproto.message_field(
        7
    )
    warnings: List[str] = betterproto.string_field(8)
    catalog_tag_infos: List["CatalogTagInfo"] = betterproto.message_field(9)


@dataclass
class BulkSchemaVisibilityRequest(betterproto.Message):
    schema_ids: List[int] = betterproto.int32_field(1)
    operation: "VisibilityOperation" = betterproto.enum_field(2)
    user_id: int = betterproto.int32_field(3)


@dataclass
class CatalogTagInfo(betterproto.Message):
    catalog_entity_type: "CatalogEntityType" = betterproto.enum_field(1)
    entity_info: "IdAndDisplayName" = betterproto.message_field(2)
    added_tags: List[str] = betterproto.string_field(3)
    unchanged_tags: List[str] = betterproto.string_field(4)
    removed_tags: List[str] = betterproto.string_field(5)


@dataclass
class InvalidAssetMetricDefinitionApplication(betterproto.Message):
    from_cohort: "CohortDefinition" = betterproto.message_field(1)
    fq_asset_name: str = betterproto.string_field(2)
    metric: "MetricDefinition" = betterproto.message_field(3)
    error_messages: List[str] = betterproto.string_field(4)


@dataclass
class InvalidCohort(betterproto.Message):
    invalid_cohort: "CohortDefinition" = betterproto.message_field(1)
    error_message: str = betterproto.string_field(2)


@dataclass
class Warehouse(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    warehouse_vendor: "WarehouseType" = betterproto.enum_field(3)


@dataclass
class TableLineageResponse(betterproto.Message):
    nodes: Dict[int, "LineageNavigationNodeResponse"] = betterproto.map_field(
        1, betterproto.TYPE_INT32, betterproto.TYPE_MESSAGE
    )


@dataclass
class LineageNavigationNodeResponse(betterproto.Message):
    data_node: "DataNode" = betterproto.message_field(1)
    upstream_edges: List["LineageRelationshipSimple"] = betterproto.message_field(2)
    downstream_edges: List["LineageRelationshipSimple"] = betterproto.message_field(3)
    issue_count: int = betterproto.int32_field(4)
    is_root_cause: bool = betterproto.bool_field(5)
    is_critical_entity: bool = betterproto.bool_field(6)
    applicable_filters: List[str] = betterproto.string_field(7)
    downstream_open_issue_count: int = betterproto.int32_field(8)
    metric_count: int = betterproto.int32_field(9)
    priority_score: int = betterproto.int32_field(10)
    is_upstream: bool = betterproto.bool_field(11)
    is_downstream: bool = betterproto.bool_field(12)


@dataclass
class TableLineageV2Response(betterproto.Message):
    nodes: Dict[int, "LineageNavigationNodeV2Response"] = betterproto.map_field(
        1, betterproto.TYPE_INT32, betterproto.TYPE_MESSAGE
    )
    partial_response: bool = betterproto.bool_field(2)


@dataclass
class LineageNavigationNodeV2Response(betterproto.Message):
    lineage_node: "LineageNodeV2" = betterproto.message_field(1)
    upstream_edges: List["LineageRelationshipSimple"] = betterproto.message_field(2)
    downstream_edges: List["LineageRelationshipSimple"] = betterproto.message_field(3)
    issue_count: int = betterproto.int32_field(4)
    applicable_filters: List[str] = betterproto.string_field(5)
    metric_count: int = betterproto.int32_field(6)
    priority_score: int = betterproto.int32_field(7)
    is_upstream: bool = betterproto.bool_field(8)
    is_downstream: bool = betterproto.bool_field(9)


@dataclass
class LineageRelationship(betterproto.Message):
    """* represents relationships between DataNodes"""

    id: int = betterproto.int32_field(1)
    company_id: int = betterproto.int32_field(2)
    upstream: "DataNode" = betterproto.message_field(3)
    downstream: "DataNode" = betterproto.message_field(4)
    created_at: int = betterproto.int64_field(5)
    updated_at: int = betterproto.int64_field(6)


@dataclass
class LineageRelationshipSimple(betterproto.Message):
    upstream_id: int = betterproto.int32_field(1)
    downstream_id: int = betterproto.int32_field(2)
    relationship_type: "RelationshipType" = betterproto.enum_field(3)


@dataclass
class LineageRelationshipResponse(betterproto.Message):
    relationships: List["LineageRelationship"] = betterproto.message_field(1)


@dataclass
class DataNode(betterproto.Message):
    id: int = betterproto.int32_field(1)
    company_id: int = betterproto.int32_field(2)
    node_type: "DataNodeType" = betterproto.enum_field(3)
    node_entity_id: int = betterproto.int32_field(4)
    node_name: str = betterproto.string_field(5)
    node_container_name: str = betterproto.string_field(6)
    created_at: int = betterproto.int64_field(7)
    updated_at: int = betterproto.int64_field(8)
    integration_id: int = betterproto.int32_field(9)
    warehouse_type: "WarehouseType" = betterproto.enum_field(10, group="source_type")
    integration_type: "IntegrationPartner" = betterproto.enum_field(
        11, group="source_type"
    )
    node_container_entity_id: int = betterproto.int32_field(12)


@dataclass
class CreateDataNodeRequest(betterproto.Message):
    node_type: "DataNodeType" = betterproto.enum_field(1)
    node_entity_id: int = betterproto.int32_field(2)
    node_name: str = betterproto.string_field(3)
    node_container_name: str = betterproto.string_field(4)
    workspace_id: int = betterproto.int32_field(5)
    rebuild_graph: bool = betterproto.bool_field(6)
    node_container_entity_id: int = betterproto.int32_field(7)


@dataclass
class LineageNodeV2(betterproto.Message):
    id: int = betterproto.int32_field(1)
    node_type: "DataNodeType" = betterproto.enum_field(2)
    node_entity_id: int = betterproto.int32_field(3)
    node_name: str = betterproto.string_field(4)
    created_at: int = betterproto.int64_field(5)
    updated_at: int = betterproto.int64_field(6)
    source: "CatalogSource" = betterproto.message_field(7)
    catalog_path: "CatalogPath" = betterproto.message_field(8)
    custom_node_type: "CustomNodeType" = betterproto.message_field(9)


@dataclass
class CreateLineageNodeV2Request(betterproto.Message):
    node_type: "DataNodeType" = betterproto.enum_field(1)
    node_entity_id: int = betterproto.int32_field(2)
    node_name: str = betterproto.string_field(3)
    workspace_id: int = betterproto.int32_field(4)
    node_container_name: str = betterproto.string_field(5)
    rebuild_graph: bool = betterproto.bool_field(6)
    icon_url: str = betterproto.string_field(7)
    node_container_entity_id: int = betterproto.int32_field(8)
    custom_repository_id: int = betterproto.int32_field(9)
    custom_node_type_id: int = betterproto.int64_field(10)
    external_id: str = betterproto.string_field(11)


@dataclass
class CreateLineageNodeV2BulkRequest(betterproto.Message):
    nodes: List["CreateLineageNodeV2Request"] = betterproto.message_field(1)


@dataclass
class CustomCatalogSource(betterproto.Message):
    name: str = betterproto.string_field(1)
    icon_url: str = betterproto.string_field(3)


@dataclass
class CatalogSource(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    warehouse_vendor: "WarehouseType" = betterproto.enum_field(
        3, group="catalogSourceType"
    )
    integration_partner: "IntegrationPartner" = betterproto.enum_field(
        4, group="catalogSourceType"
    )
    custom_catalog_source: "CustomCatalogSource" = betterproto.message_field(
        5, group="catalogSourceType"
    )
    custom_repository: "CustomRepository" = betterproto.message_field(
        6, group="catalogSourceType"
    )


@dataclass
class LineageEdgeV2(betterproto.Message):
    id: int = betterproto.int32_field(1)
    upstream: "LineageNodeV2" = betterproto.message_field(2)
    downstream: "LineageNodeV2" = betterproto.message_field(3)
    relationship_type: "RelationshipType" = betterproto.enum_field(4)
    created_at: int = betterproto.int64_field(5)
    updated_at: int = betterproto.int64_field(6)


@dataclass
class LineageEdgeV2Response(betterproto.Message):
    edges: List["LineageEdgeV2"] = betterproto.message_field(1)


@dataclass
class CreateLineageEdgeV2Request(betterproto.Message):
    upstream_data_node_id: int = betterproto.int32_field(1)
    downstream_data_node_id: int = betterproto.int32_field(2)
    relationship_type: "RelationshipType" = betterproto.enum_field(3)
    rebuild_graph: bool = betterproto.bool_field(4)


@dataclass
class CreateLineageEdgeV2BulkRequest(betterproto.Message):
    edges: List["CreateLineageEdgeV2Request"] = betterproto.message_field(1)


@dataclass
class SinglePathParamDataNodeIdRequest(betterproto.Message):
    data_node_id: int = betterproto.int32_field(1)


@dataclass
class SinglePathParamEdgeIdRequest(betterproto.Message):
    edge_id: int = betterproto.int32_field(1)


@dataclass
class LineageV2GraphRequest(betterproto.Message):
    data_node_id: int = betterproto.int32_field(1)
    depth: int = betterproto.int32_field(2)
    direction: "LineageDirection" = betterproto.enum_field(3)


@dataclass
class CatalogEntityPathElement(betterproto.Message):
    id: int = betterproto.int64_field(1)
    display_name: str = betterproto.string_field(2)
    type: "DataNodeType" = betterproto.enum_field(3)


@dataclass
class CatalogEntity(betterproto.Message):
    # ID from data_node table
    lineage_id: int = betterproto.int32_field(1)
    # ID from table with entity such as dataset, data_node_entity,
    # meta_center_entity
    entity_id: int = betterproto.int32_field(2)
    node_type: "DataNodeType" = betterproto.enum_field(3)
    node_name: str = betterproto.string_field(4)
    created_at: int = betterproto.int64_field(5)
    updated_at: int = betterproto.int64_field(6)
    source: "CatalogSource" = betterproto.message_field(7)
    catalog_path: List["CatalogEntityPathElement"] = betterproto.message_field(8)
    tags: List["Tag"] = betterproto.message_field(9)
    is_favorite: bool = betterproto.bool_field(10)
    popularity_score: float = betterproto.double_field(11)
    uses_agent: bool = betterproto.bool_field(12)
    agent_health_status: "AgentHealthStatus" = betterproto.enum_field(13)
    cross_source_agent_health_status: "AgentHealthStatus" = betterproto.enum_field(14)
    num_queries_latest_period: int = betterproto.int32_field(15)
    table_type: "TableType" = betterproto.enum_field(16)
    column_type: "FieldType" = betterproto.enum_field(17)
    custom_node_type: "CustomNodeType" = betterproto.message_field(18)
    sensitive_data_agent_health_status: "AgentHealthStatus" = betterproto.enum_field(19)


@dataclass
class GetCatalogEntityResponse(betterproto.Message):
    entity: "CatalogEntity" = betterproto.message_field(1)


@dataclass
class CatalogEntitySortOption(betterproto.Message):
    sort_direction: "SortDirection" = betterproto.enum_field(1)
    sort_field: "CatalogEntitySortField" = betterproto.enum_field(2)


@dataclass
class GetCatalogEntityChildrenRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_options: List["CatalogEntitySortOption"] = betterproto.message_field(3)
    search: str = betterproto.string_field(4)
    tag_ids: List[int] = betterproto.int32_field(5)


@dataclass
class GetCatalogEntityChildrenResponse(betterproto.Message):
    entities: List["CatalogEntity"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class CustomIntegrationType(betterproto.Message):
    id: int = betterproto.int64_field(1)
    name: str = betterproto.string_field(2)
    description: str = betterproto.string_field(3)
    icon_url: str = betterproto.string_field(4)
    type: "IntegrationType" = betterproto.enum_field(5)
    entity_info: "EntityInfo" = betterproto.message_field(6)


@dataclass
class GetCustomIntegrationTypesResponse(betterproto.Message):
    types: List["CustomIntegrationType"] = betterproto.message_field(1)


@dataclass
class CustomRepository(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    integration_type: "CustomIntegrationType" = betterproto.message_field(3)
    entity_info: "EntityInfo" = betterproto.message_field(4)
    workspace_id: int = betterproto.int64_field(5)


@dataclass
class GetCustomRepositoriesResponse(betterproto.Message):
    repositories: List["CustomRepository"] = betterproto.message_field(1)


@dataclass
class CustomNodeType(betterproto.Message):
    id: int = betterproto.int64_field(1)
    name: str = betterproto.string_field(2)
    integration_type: "CustomIntegrationType" = betterproto.message_field(3)
    entity_info: "EntityInfo" = betterproto.message_field(4)
    name_plural: str = betterproto.string_field(5)
    allowed_parent_types: List["CustomNodeType"] = betterproto.message_field(6)
    allowed_child_types: List["CustomNodeType"] = betterproto.message_field(7)
    # If true, this node type will be displayed as a column in lineage UIs
    is_column_display: bool = betterproto.bool_field(8)


@dataclass
class NodeType(betterproto.Message):
    custom_node_type: "CustomNodeType" = betterproto.message_field(1, group="nodeType")
    data_node_type: "DataNodeType" = betterproto.enum_field(2, group="nodeType")


@dataclass
class BulkCreateCustomNodeTypesRequest(betterproto.Message):
    types: List["CustomNodeType"] = betterproto.message_field(1)


@dataclass
class GetCustomNodeTypesResponse(betterproto.Message):
    types: List["CustomNodeType"] = betterproto.message_field(1)


@dataclass
class CustomRepositorySyncRequest(betterproto.Message):
    custom_repository_id: int = betterproto.int32_field(1)
    workspace_id: int = betterproto.int32_field(2)
    nodes: List["CustomRepositorySyncNode"] = betterproto.message_field(3)
    edges: List["CustomRepositorySyncEdge"] = betterproto.message_field(4)
    cleanup_stale: bool = betterproto.bool_field(5)
    user_id: int = betterproto.int32_field(6)


@dataclass
class CustomRepositorySyncNode(betterproto.Message):
    # External identifier for matching (required for sync logic)
    external_id: str = betterproto.string_field(1)
    # Node properties
    node_name: str = betterproto.string_field(2)
    custom_node_type_id: int = betterproto.int64_field(3)
    container_external_id: str = betterproto.string_field(4)
    # Set catalog attributes that are tied to repository, if omitted we'll leave
    # it alone
    attributes: List["CatalogAttribute"] = betterproto.message_field(5)
    is_attributes_empty: bool = betterproto.bool_field(6)


@dataclass
class CustomRepositorySyncNodeLookup(betterproto.Message):
    node_id: int = betterproto.int32_field(1)
    node_name: str = betterproto.string_field(2)
    node_container_name: str = betterproto.string_field(3)
    source_id: int = betterproto.int32_field(4)
    source_node_type: "DataNodeType" = betterproto.enum_field(5)


@dataclass
class CustomRepositorySyncEdge(betterproto.Message):
    upstream_external_id: str = betterproto.string_field(1, group="upstream")
    upstream_node: "CustomRepositorySyncNodeLookup" = betterproto.message_field(
        2, group="upstream"
    )
    downstream_external_id: str = betterproto.string_field(3, group="downstream")
    downstream_node: "CustomRepositorySyncNodeLookup" = betterproto.message_field(
        4, group="downstream"
    )
    relationship_type: "RelationshipType" = betterproto.enum_field(5)


@dataclass
class CustomRepositorySyncResponse(betterproto.Message):
    workflow_v2_id: "WorkflowV2Id" = betterproto.message_field(1)


@dataclass
class GetDataNodesRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_by: "DataNodeSortField" = betterproto.enum_field(3)
    sort_direction: "SortDirection" = betterproto.enum_field(4)


@dataclass
class GetDataNodesResponse(betterproto.Message):
    data_nodes: List["DataNode"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GetLineageRelationshipsRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_by: "LineageRelationshipSortField" = betterproto.enum_field(3)
    sort_direction: "SortDirection" = betterproto.enum_field(4)


@dataclass
class GetLineageRelationshipsResponse(betterproto.Message):
    relationships: List["LineageRelationship"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class IssueListResponse(betterproto.Message):
    issues: List["Issue"] = betterproto.message_field(1)


@dataclass
class IssueRootCauseAnalysis(betterproto.Message):
    issue: int = betterproto.int32_field(1)
    root_cause_tables: List["IssueRootCauseAnalysisObject"] = betterproto.message_field(
        2
    )
    root_cause_columns: List["IssueRootCauseAnalysisObject"] = (
        betterproto.message_field(3)
    )
    impacted_tables: List["IssueRootCauseAnalysisObject"] = betterproto.message_field(4)
    impacted_reports: List["IssueImpactedReport"] = betterproto.message_field(5)
    impacted_owners: List["IdAndDisplayName"] = betterproto.message_field(6)
    num_at_risk_tables: int = betterproto.int32_field(7)


@dataclass
class IssueResolutionInfo(betterproto.Message):
    issue: int = betterproto.int32_field(1)
    etl_job_name: str = betterproto.string_field(2)
    etl_sql: str = betterproto.string_field(3)
    etl_analysis: str = betterproto.string_field(4)
    data_diagnosis: str = betterproto.string_field(5)
    previous_resolutions: str = betterproto.string_field(6)
    latest_created_epoch_seconds: int = betterproto.int64_field(7)


@dataclass
class IssueRootCauseAnalysisObject(betterproto.Message):
    data_node_id: int = betterproto.int32_field(1)
    data_node_type: "DataNodeType" = betterproto.enum_field(2)
    warehouse_type: "WarehouseType" = betterproto.enum_field(3)
    warehouse: "IdAndDisplayName" = betterproto.message_field(4)
    schema: "IdAndDisplayName" = betterproto.message_field(5)
    table: "IdAndDisplayName" = betterproto.message_field(6)
    column: "IdAndDisplayName" = betterproto.message_field(7)


@dataclass
class IssueImpactedReport(betterproto.Message):
    data_node_id: int = betterproto.int32_field(1)
    data_node_type: "DataNodeType" = betterproto.enum_field(2)
    integration_partner: "IntegrationPartner" = betterproto.enum_field(3)
    id: int = betterproto.int32_field(4)
    display_name: str = betterproto.string_field(5)


@dataclass
class CreateLineageRelationshipRequest(betterproto.Message):
    upstream_data_node_id: int = betterproto.int32_field(1)
    downstream_data_node_id: int = betterproto.int32_field(2)


@dataclass
class GetLineageRelationshipsForNodeResponse(betterproto.Message):
    upstream: List["LineageRelationship"] = betterproto.message_field(1)
    downstream: List["LineageRelationship"] = betterproto.message_field(2)


@dataclass
class DeleteLineageRelationshipsForNodeResponse(betterproto.Message):
    deleted: List["LineageRelationship"] = betterproto.message_field(1)


@dataclass
class GetDownstreamDataNodesRequest(betterproto.Message):
    applicable_filters: List[str] = betterproto.string_field(1)
    node_id_filters: List[int] = betterproto.int32_field(2)
    node_type_filters: List["DataNodeType"] = betterproto.enum_field(3)


@dataclass
class GetDownstreamDataNodesRequestWrapper(betterproto.Message):
    data_node_id: int = betterproto.int32_field(1)
    request: "GetDownstreamDataNodesRequest" = betterproto.message_field(2)


@dataclass
class GetDownstreamDataNodesResponse(betterproto.Message):
    nodes: List["DataNode"] = betterproto.message_field(1)


@dataclass
class Integration(betterproto.Message):
    id: int = betterproto.int32_field(1)
    company_id: int = betterproto.int32_field(2)
    name: str = betterproto.string_field(3)
    integration_partner: "IntegrationPartner" = betterproto.enum_field(4)
    api_base_uri: str = betterproto.string_field(5)
    api_port: int = betterproto.int32_field(6)
    web_base_uri: str = betterproto.string_field(7)
    web_port: int = betterproto.int32_field(8)
    namespace: str = betterproto.string_field(9)
    credentials_public: str = betterproto.string_field(10)
    credentials_private: str = betterproto.string_field(11)
    timeout: int = betterproto.int32_field(12)
    created_by_id: int = betterproto.int32_field(13)
    created_at: int = betterproto.int64_field(14)
    updated_by_id: int = betterproto.int32_field(15)
    updated_at: int = betterproto.int64_field(16)
    integration_entities_count: int = betterproto.int32_field(17)
    is_favorite: bool = betterproto.bool_field(18)
    integration_type: "IntegrationType" = betterproto.enum_field(19)
    most_recent_scan_at: int = betterproto.int64_field(20)
    tags: List["Tag"] = betterproto.message_field(21)
    exception_message: str = betterproto.string_field(22)


@dataclass
class CreateOrUpdateIntegrationRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    integration_partner: "IntegrationPartner" = betterproto.enum_field(2)
    api_base_uri: str = betterproto.string_field(3)
    api_port: int = betterproto.int32_field(4)
    web_base_uri: str = betterproto.string_field(5)
    web_port: int = betterproto.int32_field(6)
    namespace: str = betterproto.string_field(7)
    credentials_public: str = betterproto.string_field(8)
    credentials_private: str = betterproto.string_field(9)
    timeout: int = betterproto.int32_field(10)
    workspace_id: int = betterproto.int32_field(11)


@dataclass
class IntegrationsResponse(betterproto.Message):
    integrations: List["Integration"] = betterproto.message_field(1)


@dataclass
class GetIntegrationEntitiesResponse(betterproto.Message):
    integration_partner: "IntegrationPartner" = betterproto.enum_field(1)
    tableau_workbooks: List["TableauWorkbook"] = betterproto.message_field(2)
    dbt_projects: List["DbtProject"] = betterproto.message_field(3)
    metacenter_repositories: List["MetaCenterRepository"] = betterproto.message_field(4)


@dataclass
class UpsertDbtProject(betterproto.Message):
    id: int = betterproto.int32_field(1)
    account_id: int = betterproto.int32_field(2)
    name: str = betterproto.string_field(3)
    integration_entity_id: str = betterproto.string_field(4)
    integration_id: int = betterproto.int32_field(5)
    company_id: int = betterproto.int32_field(6)
    workspace_id: int = betterproto.int32_field(7)


@dataclass
class SinglePathParamDbtProjectIdRequest(betterproto.Message):
    dbt_project_id: int = betterproto.int32_field(1)


@dataclass
class DbtProject(betterproto.Message):
    id: int = betterproto.int32_field(1)
    account_id: int = betterproto.int32_field(2)
    name: str = betterproto.string_field(3)
    job_count: int = betterproto.int32_field(4)
    is_favorite: bool = betterproto.bool_field(5)
    company_id: int = betterproto.int32_field(6)
    integration_entity_id: str = betterproto.string_field(7)
    integration_id: int = betterproto.int32_field(8)
    workspace_id: int = betterproto.int32_field(9)
    created_at: int = betterproto.int64_field(10)
    updated_at: int = betterproto.int64_field(11)
    url: str = betterproto.string_field(12)
    tags: List["Tag"] = betterproto.message_field(13)


@dataclass
class DbtProjectSortOption(betterproto.Message):
    sort_direction: "SortDirection" = betterproto.enum_field(1)
    sort_field: "DbtProjectSortField" = betterproto.enum_field(2)


@dataclass
class GetDbtProjectsRequest(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)
    page_size: int = betterproto.int32_field(2)
    page_cursor: str = betterproto.string_field(3)
    sort_options: List["DbtProjectSortOption"] = betterproto.message_field(4)
    search: str = betterproto.string_field(5)
    workspace_id: int = betterproto.int32_field(6)
    tag_ids: List[int] = betterproto.int32_field(7)


@dataclass
class GetDbtProjectsResponse(betterproto.Message):
    projects: List["DbtProject"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class SendDbtCoreRunInfoRequest(betterproto.Message):
    project_name: str = betterproto.string_field(1)
    job_name: str = betterproto.string_field(2)
    job_run_id: str = betterproto.string_field(3)
    workspace_id: int = betterproto.int32_field(4)
    manifest_json: str = betterproto.string_field(5)
    run_results_json: str = betterproto.string_field(6)
    project_url: str = betterproto.string_field(7)
    job_url: str = betterproto.string_field(8)
    job_run_url: str = betterproto.string_field(9)


@dataclass
class SendDbtCoreRunInfoResponse(betterproto.Message):
    dbt_project: "DbtProject" = betterproto.message_field(1)
    dbt_job: "DbtJob" = betterproto.message_field(2)


@dataclass
class SinglePathParamIntegrationIdRequest(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)


@dataclass
class SinglePathParamTableauWorkbookIdRequest(betterproto.Message):
    tableau_workbook_id: int = betterproto.int32_field(1)


@dataclass
class TableauWorkbook(betterproto.Message):
    id: int = betterproto.int32_field(1)
    company_id: int = betterproto.int32_field(2)
    name: str = betterproto.string_field(3)
    project: str = betterproto.string_field(4)
    owner: str = betterproto.string_field(5)
    sheets_count: int = betterproto.int32_field(6)
    dashboards_count: int = betterproto.int32_field(7)
    integration_entity_id: str = betterproto.string_field(8)
    web_id: str = betterproto.string_field(9)
    integration_id: int = betterproto.int32_field(10)
    views_count: int = betterproto.int32_field(11)
    popularity_score: float = betterproto.double_field(12)
    last_edited_at: int = betterproto.int64_field(13)
    created_at: int = betterproto.int64_field(14)
    updated_at: int = betterproto.int64_field(15)
    data_node_id: int = betterproto.int32_field(16)
    is_favorite: bool = betterproto.bool_field(17)
    workspace_id: int = betterproto.int32_field(18)
    tags: List["Tag"] = betterproto.message_field(19)


@dataclass
class MetaCenterRepository(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    type: str = betterproto.string_field(3)
    integration_partner: "IntegrationPartner" = betterproto.enum_field(4)
    copy_disabled: bool = betterproto.bool_field(5)


@dataclass
class UpdateLineagePlusRepositoryBulkRequest(betterproto.Message):
    repository_updates: List["UpdateLineagePlusRepositoryRequest"] = (
        betterproto.message_field(1)
    )


@dataclass
class UpdateLineagePlusRepositoryRequest(betterproto.Message):
    id: int = betterproto.int32_field(1)
    skip_copy: bool = betterproto.bool_field(2)


@dataclass
class UpdateIntegrationRequestWrapper(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)
    request: "CreateOrUpdateIntegrationRequest" = betterproto.message_field(2)


@dataclass
class SinglePathParamLineageRelationshipIdRequest(betterproto.Message):
    lineage_relationship_id: int = betterproto.int32_field(1)


@dataclass
class Schema(betterproto.Message):
    """* Representation of a schema in a warehouse."""

    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    warehouse_id: int = betterproto.int32_field(3)
    is_virtual: bool = betterproto.bool_field(4)
    popularity_score: float = betterproto.double_field(5)
    num_queries_latest_period: int = betterproto.int32_field(6)
    schema_change_info: "SchemaChangeInfo" = betterproto.message_field(7)
    is_favorite: bool = betterproto.bool_field(8)
    data_node_id: int = betterproto.int32_field(9)
    latest_metric_time_value: int = betterproto.int64_field(10)
    warehouse_name: str = betterproto.string_field(11)
    database_type: "WarehouseType" = betterproto.enum_field(12)
    tags: List["Tag"] = betterproto.message_field(13)
    index_by_table: bool = betterproto.bool_field(14)


@dataclass
class UpdateSchemaRequest(betterproto.Message):
    index_by_table: bool = betterproto.bool_field(1)


@dataclass
class SchemaList(betterproto.Message):
    """* Representation of a list of tables for API purposes"""

    schemas: List["Schema"] = betterproto.message_field(1)


@dataclass
class Table(betterproto.Message):
    """* Representation of a table in a warehouse."""

    id: int = betterproto.int32_field(1)
    database_name: str = betterproto.string_field(2)
    schema_name: str = betterproto.string_field(3)
    name: str = betterproto.string_field(4)
    warehouse_id: int = betterproto.int32_field(5)
    columns: List["TableColumn"] = betterproto.message_field(6)
    metric_time_column: "TableColumn" = betterproto.message_field(7)
    latest_metric_time_value: int = betterproto.int64_field(8)
    schema_id: int = betterproto.int32_field(9)
    schema: "Schema" = betterproto.message_field(10)
    popularity_score: float = betterproto.double_field(11)
    warehouse_name: str = betterproto.string_field(12)
    warehouse_vendor: "WarehouseType" = betterproto.enum_field(14)
    data_node_id: int = betterproto.int32_field(15)
    num_queries_latest_period: int = betterproto.int32_field(16)
    schema_change_info: "SchemaChangeInfo" = betterproto.message_field(17)
    table_type: "TableType" = betterproto.enum_field(18)
    is_favorite: bool = betterproto.bool_field(19)
    requires_partition_filter: bool = betterproto.bool_field(20)
    tags: List["Tag"] = betterproto.message_field(21)
    uses_agent: bool = betterproto.bool_field(22)


@dataclass
class VirtualTable(betterproto.Message):
    """*Representation of a virtual table made from a SQL query"""

    table: "Table" = betterproto.message_field(1)
    sql_query: str = betterproto.string_field(2)
    tags: List["Tag"] = betterproto.message_field(3)


@dataclass
class TableColumn(betterproto.Message):
    """* Representation of a column in a table."""

    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    type: str = betterproto.string_field(3)
    parent_column_id: int = betterproto.int32_field(4)
    is_metric_time: bool = betterproto.bool_field(5)
    can_be_metric_time: bool = betterproto.bool_field(6)
    schema_change_info: "SchemaChangeInfo" = betterproto.message_field(7)
    full_type: str = betterproto.string_field(8)
    is_favorite: bool = betterproto.bool_field(9)
    is_partition_field: bool = betterproto.bool_field(10)
    data_node_id: int = betterproto.int32_field(11)
    is_nullable: bool = betterproto.bool_field(12)
    tags: List["Tag"] = betterproto.message_field(13)
    is_key_in_join: bool = betterproto.bool_field(14)
    extended_type: str = betterproto.string_field(15)


@dataclass
class TableList(betterproto.Message):
    """* Representation of a list of tables for API purposes"""

    tables: List["Table"] = betterproto.message_field(1)


@dataclass
class VirtualTableList(betterproto.Message):
    """*Representation of a list of virtual tables for API purposes"""

    virtual_tables: List["VirtualTable"] = betterproto.message_field(1)


@dataclass
class MetricInfoList(betterproto.Message):
    """* Representation of a list of MetricInfo for API purposes"""

    metrics: List["MetricInfo"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GeneratePopScoresJob(betterproto.Message):
    warehouse_id: int = betterproto.int32_field(1)


@dataclass
class UpdateWarehouseCatalogModelsJob(betterproto.Message):
    warehouse_id: int = betterproto.int32_field(1)


@dataclass
class UpdateIntegrationCatalogJob(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)


@dataclass
class RunMetricBatchJob(betterproto.Message):
    dataset_id: int = betterproto.int32_field(1)
    interval: int = betterproto.int32_field(2)
    interval_type: str = betterproto.string_field(3)
    lookback_days: int = betterproto.int32_field(4)
    lookback_type: str = betterproto.string_field(5)
    grain_size: int = betterproto.int32_field(6)
    metric_batches: List["BatchRunMetricsRequest"] = betterproto.message_field(7)
    batch_key: str = betterproto.string_field(8)
    warehouse_id: int = betterproto.int32_field(9)
    workspace_id: int = betterproto.int32_field(10)
    company_id: int = betterproto.int32_field(11)


@dataclass
class RunDeltaJob(betterproto.Message):
    delta_id: int = betterproto.int32_field(1)


@dataclass
class SinglePathParamComparisonTableIdRequest(betterproto.Message):
    comparison_table_id: int = betterproto.int32_field(1)


@dataclass
class ReconcileSchedulesJob(betterproto.Message):
    pass


@dataclass
class RunDashboardJob(betterproto.Message):
    pass


@dataclass
class RunScanJobBatchJob(betterproto.Message):
    company_id: int = betterproto.int32_field(1)
    cron: str = betterproto.string_field(2)
    batch_key: str = betterproto.string_field(3)


@dataclass
class JobDefinition(betterproto.Message):
    update_warehouse_catalog_models_job: "UpdateWarehouseCatalogModelsJob" = (
        betterproto.message_field(5, group="job")
    )
    run_metric_batch_job: "RunMetricBatchJob" = betterproto.message_field(
        6, group="job"
    )
    reconcile_schedules_job: "ReconcileSchedulesJob" = betterproto.message_field(
        7, group="job"
    )
    generate_pop_scores_job: "GeneratePopScoresJob" = betterproto.message_field(
        12, group="job"
    )
    update_integration_catalog_job: "UpdateIntegrationCatalogJob" = (
        betterproto.message_field(13, group="job")
    )
    run_delta_job: "RunDeltaJob" = betterproto.message_field(14, group="job")
    run_dashboard_job: "RunDashboardJob" = betterproto.message_field(15, group="job")
    run_scan_job_batch_job: "RunScanJobBatchJob" = betterproto.message_field(
        16, group="job"
    )


@dataclass
class ScheduleRequest(betterproto.Message):
    job_definition: "JobDefinition" = betterproto.message_field(1)
    cron: str = betterproto.string_field(2, group="schedule")
    interval_seconds: int = betterproto.int32_field(3, group="schedule")


@dataclass
class ScheduleRequests(betterproto.Message):
    requests: List["ScheduleRequest"] = betterproto.message_field(1)


@dataclass
class GeneratePopScoresRequest(betterproto.Message):
    warehouse_id: int = betterproto.int32_field(1)
    workflow_info: "WorkflowInfo" = betterproto.message_field(2)


@dataclass
class GetMetricsCountResponse(betterproto.Message):
    count: int = betterproto.int32_field(1)


@dataclass
class GetMetricInfoListRequest(betterproto.Message):
    metric_ids: List[int] = betterproto.int32_field(1)
    # If searching by table name or schema name, at least one warehouse ID must
    # be present
    warehouse_ids: List[int] = betterproto.int32_field(2)
    table_ids: List[int] = betterproto.int32_field(3)
    table_name: str = betterproto.string_field(4)
    # Valid statuses are: healthy, alerting, unknown
    status: str = betterproto.string_field(5)
    metric_creation_states: List["MetricCreationState"] = betterproto.enum_field(6)
    muted: "ThreeLeggedBoolean" = betterproto.enum_field(7)
    page_size: int = betterproto.int32_field(8)
    page_cursor: str = betterproto.string_field(9)
    sort_field: "MetricSortField" = betterproto.enum_field(10)
    schema_name: str = betterproto.string_field(11)
    column_ids: List[int] = betterproto.int32_field(12)
    search: str = betterproto.string_field(13)
    sort_direction: "SortDirection" = betterproto.enum_field(14)
    schema_id: int = betterproto.int32_field(15)
    metric_types: List["PredefinedMetricName"] = betterproto.enum_field(16)
    include_latest_metric_runs: bool = betterproto.bool_field(17)
    workspace_id: int = betterproto.int32_field(18)
    tag_ids: List[int] = betterproto.int32_field(19)
    dimension_ids: List[int] = betterproto.int32_field(20)
    template_ids: List[int] = betterproto.int32_field(21)
    monitor_types: List["MonitorType"] = betterproto.enum_field(22)


@dataclass
class SearchMetricConfigurationRequest(betterproto.Message):
    ids: List[int] = betterproto.int32_field(1)
    # If searching by table name, at least one warehouse ID must be present
    warehouse_ids: List[int] = betterproto.int32_field(2)
    table_ids: List[int] = betterproto.int32_field(3)
    table_name: str = betterproto.string_field(4)
    # Valid statuses are: healthy, alerting, unknown
    status: str = betterproto.string_field(5)
    muted: bool = betterproto.bool_field(6)


@dataclass
class SinglePathParamMetricIdRequest(betterproto.Message):
    # The ID of the metric
    metric_id: int = betterproto.int32_field(1)


@dataclass
class LineageWorkflowRequest(betterproto.Message):
    entity_id: int = betterproto.int32_field(1)
    entity_type: "LineageType" = betterproto.enum_field(2)
    workflow_process_id: int = betterproto.int64_field(3)


@dataclass
class SinglePathParamLineageIdRequest(betterproto.Message):
    lineage_id: int = betterproto.int32_field(1)


@dataclass
class SnoozeTableResponse(betterproto.Message):
    metric_ids: List[int] = betterproto.int32_field(1)


@dataclass
class SnoozeTableRequestWrapper(betterproto.Message):
    table_id: int = betterproto.int32_field(1)
    body: "SnoozeTableRequest" = betterproto.message_field(2)


@dataclass
class SnoozeTableRequest(betterproto.Message):
    minutes: int = betterproto.int32_field(1)
    include_descendants: bool = betterproto.bool_field(2)


@dataclass
class UnSnoozeTableResponse(betterproto.Message):
    metric_ids: List[int] = betterproto.int32_field(1)


@dataclass
class UnSnoozeTableRequestWrapper(betterproto.Message):
    table_id: int = betterproto.int32_field(1)
    body: "UnSnoozeTableRequest" = betterproto.message_field(2)


@dataclass
class UnSnoozeTableRequest(betterproto.Message):
    include_descendants: bool = betterproto.bool_field(1)


@dataclass
class MetricBackfill(betterproto.Message):
    id: int = betterproto.int32_field(1)
    metric_ids: List[int] = betterproto.int32_field(2)
    backfill_range: "TimeRange" = betterproto.message_field(3)
    backfill_runs: List["MetricBackfillRun"] = betterproto.message_field(4)
    overall_status: "MetricBackfillRunStatus" = betterproto.enum_field(7)


@dataclass
class MetricBackfillRun(betterproto.Message):
    id: int = betterproto.int32_field(1)
    metric_ids: List[int] = betterproto.int32_field(2)
    run_timestamp: int = betterproto.int32_field(3)
    run_status: "MetricBackfillRunStatus" = betterproto.enum_field(4)
    metric_run_ids: List[int] = betterproto.int32_field(5)


@dataclass
class TimeRange(betterproto.Message):
    start_timestamp: int = betterproto.int32_field(1)
    end_timestamp: int = betterproto.int32_field(2)


@dataclass
class MetricBackfillRequest(betterproto.Message):
    metric_ids: List[int] = betterproto.int32_field(1)
    backfill_range: "TimeRange" = betterproto.message_field(2)
    delete_history: bool = betterproto.bool_field(3)


@dataclass
class SearchMetricBackfillRequest(betterproto.Message):
    ids: List[int] = betterproto.int32_field(1)
    # If searching by table name, at least one warehouse ID must be present
    warehouse_ids: List[int] = betterproto.int32_field(2)
    table_ids: List[int] = betterproto.int32_field(3)
    table_name: str = betterproto.string_field(4)
    # Valid statuses are: METRIC_BACKFILL_RUN_STATUS_QUEUED,
    # METRIC_BACKFILL_RUN_STATUS_FAILED, METRIC_BACKFILL_RUN_STATUS_SUCCEEDED
    status: List["MetricBackfillRunStatus"] = betterproto.enum_field(5)


@dataclass
class MetricBackfillResponse(betterproto.Message):
    metric_backfills: List["MetricBackfill"] = betterproto.message_field(1)


@dataclass
class SinglePathParamBackfillRunRequest(betterproto.Message):
    run_id: int = betterproto.int32_field(1)


@dataclass
class GetDebugQueriesRequest(betterproto.Message):
    metric_id: int = betterproto.int32_field(1)


@dataclass
class GetDebugQueriesResponse(betterproto.Message):
    metric_query: str = betterproto.string_field(1)
    debug_query: str = betterproto.string_field(2)


@dataclass
class GetDebugPreviewRequest(betterproto.Message):
    metric_id: int = betterproto.int32_field(1)


@dataclass
class ColumnNamePair(betterproto.Message):
    source_column_name: str = betterproto.string_field(1)
    target_column_name: str = betterproto.string_field(2)


@dataclass
class ComparisonTableConfiguration(betterproto.Message):
    id: int = betterproto.int32_field(1)
    source_table_id: int = betterproto.int32_field(2)
    target_table_id: int = betterproto.int32_field(3)
    entity_info: "EntityInfo" = betterproto.message_field(4)
    name: str = betterproto.string_field(5)
    column_mappings: List["ComparisonColumnMapping"] = betterproto.message_field(6)
    named_schedule: "IdAndDisplayName" = betterproto.message_field(7)
    group_bys: List["ColumnNamePair"] = betterproto.message_field(8)
    source_filters: List[str] = betterproto.string_field(9)
    target_filters: List[str] = betterproto.string_field(10)
    tolerance: float = betterproto.double_field(11)
    target_schema: "IdAndDisplayName" = betterproto.message_field(12)
    target_table: "IdAndDisplayName" = betterproto.message_field(13)


@dataclass
class ComparisonMetricConfiguration(betterproto.Message):
    id: int = betterproto.int32_field(1)
    comparison_table_id: int = betterproto.int32_field(2)
    source_metric_configuration: "MetricConfiguration" = betterproto.message_field(3)
    target_metric_configuration: "MetricConfiguration" = betterproto.message_field(4)
    tolerance: float = betterproto.double_field(5)
    source_column_name: str = betterproto.string_field(6)
    target_column_name: str = betterproto.string_field(7)
    metric: "MetricType" = betterproto.message_field(8)


@dataclass
class ComparisonMetricGroup(betterproto.Message):
    dimensions: List["MetricGroupDimension"] = betterproto.message_field(1)
    source_value: float = betterproto.double_field(2)
    target_value: float = betterproto.double_field(3)
    difference: float = betterproto.double_field(4)
    status: "ComparisonMetricStatus" = betterproto.enum_field(5)


@dataclass
class ComparisonMetricInfo(betterproto.Message):
    comparison_metric_configuration: "ComparisonMetricConfiguration" = (
        betterproto.message_field(1)
    )
    source_metric_info: "MetricInfo" = betterproto.message_field(2)
    target_metric_info: "MetricInfo" = betterproto.message_field(3)
    status: "ComparisonMetricStatus" = betterproto.enum_field(4)
    difference: float = betterproto.double_field(5)
    group_count: int = betterproto.int32_field(6)
    critical_group_count: int = betterproto.int32_field(7)
    source_value: float = betterproto.double_field(8)
    target_value: float = betterproto.double_field(9)
    failed_group_count: int = betterproto.int32_field(10)
    exception_class: str = betterproto.string_field(11)
    exception_message: str = betterproto.string_field(12)
    source_failed: bool = betterproto.bool_field(13)
    target_failed: bool = betterproto.bool_field(14)


@dataclass
class ComparisonTableInfo(betterproto.Message):
    comparison_table_configuration: "ComparisonTableConfiguration" = (
        betterproto.message_field(1)
    )
    comparison_metric_infos: List["ComparisonMetricInfo"] = betterproto.message_field(2)
    schema_match: bool = betterproto.bool_field(3)
    last_run_at_epoch_seconds: int = betterproto.int64_field(4)
    metric_count: int = betterproto.int64_field(5)
    failed_metric_count: int = betterproto.int64_field(6)
    alerting_metric_count: int = betterproto.int64_field(7)
    source_row_count: float = betterproto.double_field(8)
    target_row_count: float = betterproto.double_field(9)
    next_run_epoch_seconds: int = betterproto.int64_field(10)
    is_favorite: bool = betterproto.bool_field(11)


@dataclass
class TableApplicableMetricTypes(betterproto.Message):
    id: int = betterproto.int32_field(1)
    applicable_metric_types: List["ColumnApplicableMetricTypes"] = (
        betterproto.message_field(2)
    )


@dataclass
class TableAllApplicableMetricTypes(betterproto.Message):
    table: "IdAndDisplayName" = betterproto.message_field(1)
    schema: "IdAndDisplayName" = betterproto.message_field(2)
    source: "IdAndDisplayName" = betterproto.message_field(3)
    applicable_metric_types: List["MetricType"] = betterproto.message_field(4)


@dataclass
class TableLevelApplicableMetricTypes(betterproto.Message):
    id: int = betterproto.int32_field(1)
    applicable_metric_types: List["MetricType"] = betterproto.message_field(2)
    table: "IdAndDisplayName" = betterproto.message_field(3)
    schema: "IdAndDisplayName" = betterproto.message_field(4)
    source: "IdAndDisplayName" = betterproto.message_field(5)


@dataclass
class ColumnApplicableMetricTypes(betterproto.Message):
    column: "IdAndDisplayName" = betterproto.message_field(1)
    applicable_metric_types: List["MetricType"] = betterproto.message_field(2)
    table: "IdAndDisplayName" = betterproto.message_field(3)
    schema: "IdAndDisplayName" = betterproto.message_field(4)
    source: "IdAndDisplayName" = betterproto.message_field(5)


@dataclass
class SchemaApplicableMetricTypes(betterproto.Message):
    schema: "IdAndDisplayName" = betterproto.message_field(1)
    source: "IdAndDisplayName" = betterproto.message_field(2)
    applicable_metric_types: List["MetricType"] = betterproto.message_field(3)


@dataclass
class SourceApplicableMetricTypes(betterproto.Message):
    source: "IdAndDisplayName" = betterproto.message_field(1)
    applicable_metric_types: List["MetricType"] = betterproto.message_field(2)


@dataclass
class ComparisonColumnMapping(betterproto.Message):
    source_column: "IdAndDisplayName" = betterproto.message_field(1)
    target_column: "IdAndDisplayName" = betterproto.message_field(2)
    metrics: List["MetricType"] = betterproto.message_field(3)
    user_defined: bool = betterproto.bool_field(4)
    is_part_of_key: bool = betterproto.bool_field(5)


@dataclass
class CreateComparisonTableRequest(betterproto.Message):
    comparison_table_configuration: "ComparisonTableConfiguration" = (
        betterproto.message_field(1)
    )


@dataclass
class CreateComparisonTableResponse(betterproto.Message):
    comparison_table_configuration: "ComparisonTableConfiguration" = (
        betterproto.message_field(1)
    )


@dataclass
class GetComparisonTableResponse(betterproto.Message):
    comparison_table_configuration: "ComparisonTableConfiguration" = (
        betterproto.message_field(1)
    )


@dataclass
class RunComparisonTableResponse(betterproto.Message):
    comparison_table_info: "ComparisonTableInfo" = betterproto.message_field(1)


@dataclass
class GetComparisonTableInfosRequest(betterproto.Message):
    comparison_table_ids: List[int] = betterproto.int32_field(1)
    exclude_comparison_metrics: bool = betterproto.bool_field(2)
    page_size: int = betterproto.int32_field(3)
    page_cursor: str = betterproto.string_field(4)
    sort_field: "ComparisonTableSortField" = betterproto.enum_field(5)
    sort_direction: "SortDirection" = betterproto.enum_field(6)
    search: str = betterproto.string_field(7)
    workspace_id: int = betterproto.int32_field(8)
    tag_ids: List[int] = betterproto.int32_field(9)
    dimension_ids: List[int] = betterproto.int32_field(10)
    delta_types: List["DeltaType"] = betterproto.enum_field(11)


@dataclass
class GetComparisonTableInfosResponse(betterproto.Message):
    comparison_table_infos: List["ComparisonTableInfo"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GetTableComparisonMetricGroupInfoRequest(betterproto.Message):
    comparison_metric_id: int = betterproto.int32_field(1)


@dataclass
class GetTableComparisonMetricGroupInfoResponse(betterproto.Message):
    group_state: List["ComparisonMetricGroup"] = betterproto.message_field(1)


@dataclass
class GetDeltaApplicableMetricTypesRequest(betterproto.Message):
    table_id: int = betterproto.int32_field(1)


@dataclass
class GetTableLevelApplicableMetricTypesRequest(betterproto.Message):
    table_id: int = betterproto.int32_field(1)


@dataclass
class GetDeltaApplicableMetricTypesResponse(betterproto.Message):
    metric_types: "TableApplicableMetricTypes" = betterproto.message_field(1)


@dataclass
class TableComparisonBatchEditRequest(betterproto.Message):
    table_comparison_ids: List[int] = betterproto.int32_field(1)
    named_schedule_id: int = betterproto.int32_field(2, group="schedule_change")
    remove_named_schedule: bool = betterproto.bool_field(3, group="schedule_change")
    dimension_id: int = betterproto.int32_field(4)


@dataclass
class TableComparisonBatchEditResponse(betterproto.Message):
    successful_comparison_ids: List[int] = betterproto.int32_field(1)
    failed_comparison_edits: List["FailedMetricEdit"] = betterproto.message_field(2)


@dataclass
class CreateMetricRunAnnotationRequest(betterproto.Message):
    metric_run_label: "MetricRunLabel" = betterproto.enum_field(1)


@dataclass
class CreateMetricRunAnnotationResponse(betterproto.Message):
    metric_run_annotation: "MetricRunAnnotation" = betterproto.message_field(1)


@dataclass
class AnnotateIssueGroupRequest(betterproto.Message):
    metric_id: int = betterproto.int32_field(1)
    metric_run_label: "MetricRunLabel" = betterproto.enum_field(2)
    group_dimensions: List["MetricGroupDimension"] = betterproto.message_field(3)


@dataclass
class MetricGroupDimensionBulk(betterproto.Message):
    group_dimensions: List["MetricGroupDimension"] = betterproto.message_field(1)


@dataclass
class AnnotateIssueGroupBulkRequest(betterproto.Message):
    metric_id: int = betterproto.int32_field(1)
    metric_run_label: "MetricRunLabel" = betterproto.enum_field(2)
    groups: List["MetricGroupDimensionBulk"] = betterproto.message_field(3)
    user_id: int = betterproto.int32_field(4)


@dataclass
class FailedGroupUpdate(betterproto.Message):
    group_dimensions: List["MetricGroupDimension"] = betterproto.message_field(1)
    reason: str = betterproto.string_field(2)


@dataclass
class AnnotateIssueGroupBulkResult(betterproto.Message):
    successful_groups: List["MetricGroupDimensionBulk"] = betterproto.message_field(1)
    failed_updates: List["FailedGroupUpdate"] = betterproto.message_field(2)


@dataclass
class AnnotateIssueGroupBulkResponse(betterproto.Message):
    workflow_id: "WorkflowV2Id" = betterproto.message_field(1)
    total_groups_queued: int = betterproto.int32_field(2)


@dataclass
class IssueMetricFeedback(betterproto.Message):
    id: int = betterproto.int64_field(1)
    issue_id: int = betterproto.int32_field(2)
    metric_id: int = betterproto.int32_field(3)
    feedback: "MetricRunLabel" = betterproto.enum_field(4)
    group_dimensions: List["MetricGroupDimension"] = betterproto.message_field(5)
    created_by: "IdAndDisplayName" = betterproto.message_field(6)
    created_at: int = betterproto.int64_field(7)


@dataclass
class GetIssueGroupFeedbackListResponse(betterproto.Message):
    feedback: List["IssueMetricFeedback"] = betterproto.message_field(1)


@dataclass
class SearchFilter(betterproto.Message):
    warehouse_id: int = betterproto.int32_field(1, group="filter")
    schema_name: str = betterproto.string_field(2, group="filter")
    table_id: int = betterproto.int32_field(3, group="filter")
    column_id: int = betterproto.int32_field(4, group="filter")
    schema_id: int = betterproto.int32_field(5, group="filter")
    issue_status: "IssueStatus" = betterproto.enum_field(6, group="filter")
    metric_id: int = betterproto.int32_field(7, group="filter")
    start_epoch_seconds: int = betterproto.int64_field(8, group="filter")
    end_epoch_seconds: int = betterproto.int64_field(9, group="filter")
    start_issue_closed_epoch_seconds: int = betterproto.int64_field(10, group="filter")
    end_issue_closed_epoch_seconds: int = betterproto.int64_field(11, group="filter")
    issue_priority: "IssuePriority" = betterproto.enum_field(12, group="filter")
    metric_status: "MetricStatus" = betterproto.enum_field(13, group="filter")
    collection_id: int = betterproto.int32_field(14, group="filter")
    metric_type: "MetricType" = betterproto.message_field(15, group="filter")
    metric_category: "MetricCategory" = betterproto.enum_field(16, group="filter")
    workspace_id: int = betterproto.int32_field(17, group="filter")
    owner_id: int = betterproto.int32_field(18, group="filter")
    issue_type: "IssueType" = betterproto.enum_field(19, group="filter")
    parent_issue_id: int = betterproto.int32_field(20, group="filter")
    is_root_cause: bool = betterproto.bool_field(21, group="filter")
    dimension_id: int = betterproto.int32_field(22, group="filter")
    catalog_entity: "CatalogEntityPathElement" = betterproto.message_field(
        23, group="filter"
    )
    monitor_type: "MonitorType" = betterproto.enum_field(24, group="filter")


@dataclass
class CountsQuery(betterproto.Message):
    fields: List["AggregateField"] = betterproto.enum_field(1)
    filters: List["SearchFilter"] = betterproto.message_field(2)
    group_by_entity_type: "GroupByEntityType" = betterproto.enum_field(3)


@dataclass
class GetCountsRequest(betterproto.Message):
    queries: List["CountsQuery"] = betterproto.message_field(1)
    exclude_zeros: bool = betterproto.bool_field(2)


@dataclass
class CountForField(betterproto.Message):
    field: "AggregateField" = betterproto.enum_field(1)
    count: int = betterproto.int64_field(2)


@dataclass
class CountsQueryResult(betterproto.Message):
    warehouse_id: int = betterproto.int32_field(1, group="entity_id")
    schema_name: str = betterproto.string_field(3, group="entity_id")
    table_id: int = betterproto.int32_field(4, group="entity_id")
    column_id: int = betterproto.int32_field(5, group="entity_id")
    schema_id: int = betterproto.int32_field(6, group="entity_id")
    sla_id: int = betterproto.int32_field(7, group="entity_id")
    metric_run_label: "MetricRunLabel" = betterproto.enum_field(8, group="entity_id")
    issue_priority: "IssuePriority" = betterproto.enum_field(9, group="entity_id")
    issue_status: "IssueStatus" = betterproto.enum_field(10, group="entity_id")
    metric_status: "MetricStatus" = betterproto.enum_field(11, group="entity_id")
    metric_type: "MetricType" = betterproto.message_field(12, group="entity_id")
    metric_category: "MetricCategory" = betterproto.enum_field(13, group="entity_id")
    owner_id: int = betterproto.int32_field(15, group="entity_id")
    issue_type: "IssueType" = betterproto.enum_field(16, group="entity_id")
    is_root_cause: bool = betterproto.bool_field(17, group="entity_id")
    dimension_id: int = betterproto.int32_field(18, group="entity_id")
    catalog_entity: "CatalogEntityPathElement" = betterproto.message_field(
        19, group="entity_id"
    )
    monitor_type: "MonitorType" = betterproto.enum_field(20, group="entity_id")
    counts_for_fields: List["CountForField"] = betterproto.message_field(2)
    entity: "IdAndDisplayName" = betterproto.message_field(14)


@dataclass
class GetCountsResponse(betterproto.Message):
    query_results: List["CountsQueryResult"] = betterproto.message_field(1)


@dataclass
class WhereClause(betterproto.Message):
    ids: List[int] = betterproto.int32_field(1)
    search: str = betterproto.string_field(2)
    search_all: bool = betterproto.bool_field(3)
    source_ids: List[int] = betterproto.int32_field(4)
    schema_ids: List[int] = betterproto.int32_field(5)
    table_ids: List[int] = betterproto.int32_field(6)
    column_ids: List[int] = betterproto.int32_field(7)
    statuses: List[str] = betterproto.string_field(8)
    metric_types: List["PredefinedMetricName"] = betterproto.enum_field(9)
    workspace_id: int = betterproto.int32_field(10)
    custom_rule_ids: List[int] = betterproto.int32_field(11)
    dimension_ids: List[int] = betterproto.int32_field(12)
    custom_rule_types: List["CustomRuleType"] = betterproto.enum_field(13)
    delta_types: List["DeltaType"] = betterproto.enum_field(14)
    template_ids: List[int] = betterproto.int32_field(15)
    monitor_types: List["MonitorType"] = betterproto.enum_field(16)
    collection_ids: List[int] = betterproto.int32_field(17)


@dataclass
class BulkIssueUpdateWhereClause(betterproto.Message):
    ids: List[int] = betterproto.int32_field(1)
    search: str = betterproto.string_field(2)
    search_all: bool = betterproto.bool_field(3)
    source_ids: List[int] = betterproto.int32_field(4)
    schema_ids: List[int] = betterproto.int32_field(5)
    table_ids: List[int] = betterproto.int32_field(6)
    column_ids: List[int] = betterproto.int32_field(7)
    statuses: List[str] = betterproto.string_field(8)
    metric_types: List["PredefinedMetricName"] = betterproto.enum_field(9)
    metric_ids: List[int] = betterproto.int32_field(10)
    collection_ids: List[int] = betterproto.int32_field(11)
    priority: List["IssuePriority"] = betterproto.enum_field(12)
    metric_status: List["MetricStatus"] = betterproto.enum_field(13)
    metric_type: List["MetricType"] = betterproto.message_field(14)
    min_opened_time: int = betterproto.int64_field(15)
    max_opened_time: int = betterproto.int64_field(16)
    workspace_id: int = betterproto.int32_field(17)
    assignee_ids: List[int] = betterproto.int32_field(18)
    issue_type: List["IssueType"] = betterproto.enum_field(19)
    parent_issue_ids: List[int] = betterproto.int32_field(20)
    is_root_cause: "ThreeLeggedBoolean" = betterproto.enum_field(21)
    dimension_ids: List[int] = betterproto.int32_field(22)
    monitor_types: List["MonitorType"] = betterproto.enum_field(23)


@dataclass
class BulkMetricOperation(betterproto.Message):
    where: "WhereClause" = betterproto.message_field(1)
    edit_request: "MetricConfiguration" = betterproto.message_field(2)
    mute_request: "MuteRequest" = betterproto.message_field(3)
    is_run: bool = betterproto.bool_field(4)
    is_delete: bool = betterproto.bool_field(5)
    add_to_collection: int = betterproto.int32_field(6)
    remove_from_collection: int = betterproto.int32_field(7)
    backfill_request: "MetricBackfillRequest" = betterproto.message_field(8)


@dataclass
class BulkIssueUpdate(betterproto.Message):
    where: "BulkIssueUpdateWhereClause" = betterproto.message_field(1)
    status_update: "IssueStatusUpdate" = betterproto.message_field(2)
    config_update: "IssueConfigUpdate" = betterproto.message_field(3)
    is_metric_run: bool = betterproto.bool_field(4)
    assignment_update: "IssueAssignmentUpdate" = betterproto.message_field(5)
    priority_update: "IssuePriorityChangeEvent" = betterproto.message_field(6)
    updated_by_id: int = betterproto.int32_field(7)


@dataclass
class QueuedIssueUpdate(betterproto.Message):
    issue_id: int = betterproto.int32_field(1)
    workflow_id: "WorkflowV2Id" = betterproto.message_field(2)


@dataclass
class QueueBulkIssueUpdateResponse(betterproto.Message):
    successfully_queued: List["QueuedIssueUpdate"] = betterproto.message_field(1)
    failed_to_queue: List["FailedUpdate"] = betterproto.message_field(2)


@dataclass
class BulkDeltaOperation(betterproto.Message):
    where: "WhereClause" = betterproto.message_field(1)
    is_run: bool = betterproto.bool_field(2)
    edit_request: "TableComparisonBatchEditRequest" = betterproto.message_field(3)
    is_delete: bool = betterproto.bool_field(4)


@dataclass
class MuteRequest(betterproto.Message):
    mute_until: int = betterproto.int32_field(1)


@dataclass
class BulkBackfillIsDestructiveRequest(betterproto.Message):
    where: "WhereClause" = betterproto.message_field(1)


@dataclass
class BulkBackfillIsDestructiveResponse(betterproto.Message):
    destructive_metrics: List["IdAndDisplayName"] = betterproto.message_field(1)


@dataclass
class FailedUpdate(betterproto.Message):
    id: int = betterproto.int32_field(1)
    reason: str = betterproto.string_field(2)


@dataclass
class BulkResponse(betterproto.Message):
    successful_ids: List[int] = betterproto.int32_field(1)
    failed_updates: List["FailedUpdate"] = betterproto.message_field(2)
    not_run_ids: List[int] = betterproto.int32_field(3)


@dataclass
class IssueStatusUpdate(betterproto.Message):
    id: int = betterproto.int32_field(1)
    updated_by: "User" = betterproto.message_field(2)
    new_status: "IssueStatus" = betterproto.enum_field(3)
    message: str = betterproto.string_field(4)
    closing_label: "MetricRunLabel" = betterproto.enum_field(5)
    metric_ids_to_adapt: List[int] = betterproto.int32_field(6)
    metric_ids_to_maintain: List[int] = betterproto.int32_field(7)
    normal_metric_ids: List[int] = betterproto.int32_field(8)
    anomalous_metric_ids: List[int] = betterproto.int32_field(9)


@dataclass
class MetricEvent(betterproto.Message):
    id: int = betterproto.int32_field(1)
    metric_runs: List["MetricRun"] = betterproto.message_field(2)
    notification_sent: bool = betterproto.bool_field(3)
    metric_run_status: "MetricRunStatus" = betterproto.enum_field(4)
    failure_reason: "MetricRunFailureReason" = betterproto.enum_field(5)
    description: str = betterproto.string_field(6)


@dataclass
class IssueEvent(betterproto.Message):
    timestamp: int = betterproto.int64_field(1)
    metric_event: "MetricEvent" = betterproto.message_field(2, group="event")
    issue_status_update: "IssueStatusUpdate" = betterproto.message_field(
        3, group="event"
    )
    issue_priority_change_event: "IssuePriorityChangeEvent" = betterproto.message_field(
        4, group="event"
    )
    issue_message_update: "IssueMessageUpdate" = betterproto.message_field(
        5, group="event"
    )
    issue_assignment_update: "IssueAssignmentUpdate" = betterproto.message_field(
        6, group="event"
    )
    issue_config_update: "IssueConfigUpdate" = betterproto.message_field(
        7, group="event"
    )
    issue_merge_update: "IssueMergeUpdate" = betterproto.message_field(8, group="event")
    issue_root_cause_update: "IssueRootCauseUpdate" = betterproto.message_field(
        9, group="event"
    )
    issue_ai_overview_update: "IssueAiOverviewUpdate" = betterproto.message_field(
        10, group="event"
    )


@dataclass
class Issue(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    metric_configuration: "MetricConfiguration" = betterproto.message_field(3)
    events: List["IssueEvent"] = betterproto.message_field(4)
    current_status: "IssueStatus" = betterproto.enum_field(5)
    ack_snooze_seconds: int = betterproto.int32_field(6)
    opened_time_seconds: int = betterproto.int64_field(7)
    closed_time_seconds: int = betterproto.int64_field(8)
    muted_until_timestamp: int = betterproto.int64_field(9)
    summary: str = betterproto.string_field(10)
    acked_time_seconds: int = betterproto.int64_field(11)
    time_to_ack_seconds: int = betterproto.int64_field(12)
    time_to_resolve_seconds: int = betterproto.int64_field(13)
    metric_metadata: "MetricMetadata" = betterproto.message_field(14)
    first_metric_run_status: "MetricRunStatus" = betterproto.enum_field(15)
    priority: "IssuePriority" = betterproto.enum_field(16)
    priority_score: int = betterproto.int32_field(17)
    earliest_alerting_point_time_seconds: int = betterproto.int64_field(18)
    alert_count: int = betterproto.int32_field(19)
    notification_channels: List["NotificationChannel"] = betterproto.message_field(20)
    current_closing_feedback: "MetricRunLabel" = betterproto.enum_field(21)
    assignee: "User" = betterproto.message_field(22)
    description: str = betterproto.string_field(23)
    issue_type: "IssueType" = betterproto.enum_field(24)
    parent_issue: "IdAndDisplayName" = betterproto.message_field(25)
    workspace_id: int = betterproto.int32_field(26)
    is_root_cause: bool = betterproto.bool_field(27)
    impacted_objects: int = betterproto.int32_field(28)
    alerting_metrics: List["IdAndDisplayName"] = betterproto.message_field(29)
    ai_overview: str = betterproto.string_field(30)
    alerting_data_description: str = betterproto.string_field(31)
    etl_analysis: str = betterproto.string_field(32)
    issue_resolution_steps: List["IssueResolutionStep"] = betterproto.message_field(33)
    previous_resolution_summary: str = betterproto.string_field(34)
    alerting_metrics_with_label: List["AlertingMetric"] = betterproto.message_field(35)
    dimension_id: int = betterproto.int32_field(36)


@dataclass
class AlertingMetric(betterproto.Message):
    metric: "IdAndDisplayName" = betterproto.message_field(1)
    label: "MetricRunLabel" = betterproto.enum_field(2)


@dataclass
class IssueWithRootCause(betterproto.Message):
    issue: "Issue" = betterproto.message_field(1)
    root_cause_analysis: "IssueRootCauseAnalysis" = betterproto.message_field(2)


@dataclass
class IssueShortSummary(betterproto.Message):
    id: "IdAndDisplayName" = betterproto.message_field(1)
    is_root_cause: bool = betterproto.bool_field(2)
    overview: str = betterproto.string_field(3)
    issue_resolution_steps: List["IssueResolutionStep"] = betterproto.message_field(4)


@dataclass
class Incident(betterproto.Message):
    parent_issue: "IssueShortSummary" = betterproto.message_field(1)
    child_issues: List["IssueShortSummary"] = betterproto.message_field(2)


@dataclass
class IssueAiOverview(betterproto.Message):
    issue_id: int = betterproto.int32_field(1)
    ai_overview: str = betterproto.string_field(2)


@dataclass
class MetricIssueHistoryResponse(betterproto.Message):
    metric_id: int = betterproto.int32_field(1)
    issue_history_list: List["IssueHistory"] = betterproto.message_field(2)


@dataclass
class IssueHistory(betterproto.Message):
    issue_id: int = betterproto.int32_field(1)
    issue_started_at: int = betterproto.int64_field(2)
    issue_closed_at: int = betterproto.int64_field(3)
    issue_name: str = betterproto.string_field(4)


@dataclass
class IssueConfigUpdate(betterproto.Message):
    mute_until_timestamp: int = betterproto.int64_field(1)
    summary: str = betterproto.string_field(2)
    description: str = betterproto.string_field(3)
    created_by: "User" = betterproto.message_field(4)
    id: int = betterproto.int32_field(5)


@dataclass
class IssueMessageUpdate(betterproto.Message):
    id: int = betterproto.int32_field(1)
    created_by: "User" = betterproto.message_field(2)
    message: str = betterproto.string_field(3)


@dataclass
class IssueAiOverviewUpdate(betterproto.Message):
    id: int = betterproto.int32_field(1)
    created_by: "User" = betterproto.message_field(2)
    overview: str = betterproto.string_field(3)
    type: "IssueAiUpdateType" = betterproto.enum_field(4)


@dataclass
class IssueResolutionStep(betterproto.Message):
    id: int = betterproto.int32_field(1)
    description: str = betterproto.string_field(2)
    comments: str = betterproto.string_field(3)
    created_by: "User" = betterproto.message_field(4)
    created_timestamp: int = betterproto.int64_field(5)
    updated_by: "User" = betterproto.message_field(6)
    updated_timestamp: int = betterproto.int64_field(7)
    status: "IssueResolutionStepStatus" = betterproto.enum_field(8)


@dataclass
class IssueResolutionSteps(betterproto.Message):
    issue: "IdAndDisplayName" = betterproto.message_field(1)
    steps: List["IssueResolutionStep"] = betterproto.message_field(2)


@dataclass
class IssuePreventionStep(betterproto.Message):
    id: int = betterproto.int32_field(1)
    description: str = betterproto.string_field(2)
    comments: str = betterproto.string_field(3)
    created_by: "User" = betterproto.message_field(4)
    created_timestamp: int = betterproto.int64_field(5)
    updated_by: "User" = betterproto.message_field(6)
    updated_timestamp: int = betterproto.int64_field(7)
    status: "IssuePreventionStepStatus" = betterproto.enum_field(8)


@dataclass
class IssuePreventionSteps(betterproto.Message):
    dataset_id: int = betterproto.int32_field(1)
    steps: List["IssuePreventionStep"] = betterproto.message_field(2)
    job_name: str = betterproto.string_field(3)
    sql: str = betterproto.string_field(4)
    latest_created_epoch_seconds: int = betterproto.int64_field(5)


@dataclass
class IssueAiGenerationRequest(betterproto.Message):
    issue_id: int = betterproto.int32_field(1)
    type: "IssueAiUpdateType" = betterproto.enum_field(2)


@dataclass
class IssueMergeUpdate(betterproto.Message):
    id: int = betterproto.int32_field(1)
    created_by: "User" = betterproto.message_field(2)
    type: "IssueMergeUpdateType" = betterproto.enum_field(3)
    issues: List["IdAndDisplayName"] = betterproto.message_field(4)


@dataclass
class IssueRootCauseUpdate(betterproto.Message):
    id: int = betterproto.int32_field(1)
    is_root_cause: bool = betterproto.bool_field(3)
    num_impacted_objects: int = betterproto.int32_field(5)


@dataclass
class IssueAssignmentUpdate(betterproto.Message):
    id: int = betterproto.int32_field(1)
    assignee: "User" = betterproto.message_field(2)
    created_by: "User" = betterproto.message_field(3)


@dataclass
class IssuePriorityChangeEvent(betterproto.Message):
    id: int = betterproto.int32_field(1)
    issue_priority: "IssuePriority" = betterproto.enum_field(2)
    metric_run_observed_value: float = betterproto.double_field(3)
    created_by: "User" = betterproto.message_field(4)


@dataclass
class UpdateIssueRequest(betterproto.Message):
    status_update: "IssueStatusUpdate" = betterproto.message_field(1)
    config_update: "IssueConfigUpdate" = betterproto.message_field(2)
    message_update: "IssueMessageUpdate" = betterproto.message_field(3)
    assignment_update: "IssueAssignmentUpdate" = betterproto.message_field(4)
    priority_update: "IssuePriorityChangeEvent" = betterproto.message_field(5)
    ai_overview_update: "IssueAiOverviewUpdate" = betterproto.message_field(6)


@dataclass
class UpdateIssueRequestWrapper(betterproto.Message):
    issue_id: int = betterproto.int32_field(1)
    body: "UpdateIssueRequest" = betterproto.message_field(2)


@dataclass
class UpdateIssueBatchRequestWrapper(betterproto.Message):
    issue_ids: List[int] = betterproto.int32_field(1)
    body: "UpdateIssueRequest" = betterproto.message_field(2)


@dataclass
class UpdateIssueBatchResponse(betterproto.Message):
    successful_issue_ids: List[int] = betterproto.int32_field(1)
    failed_issue_updates: List["FailedIssueUpdate"] = betterproto.message_field(2)


@dataclass
class FailedIssueUpdate(betterproto.Message):
    issue_id: int = betterproto.int32_field(1)
    reason: str = betterproto.string_field(2)


@dataclass
class UpdateIssueResponse(betterproto.Message):
    issue: "Issue" = betterproto.message_field(1)


@dataclass
class GetIssuesRequest(betterproto.Message):
    issue_ids: List[int] = betterproto.int32_field(1)
    current_status: List["IssueStatus"] = betterproto.enum_field(2)
    metric_ids: List[int] = betterproto.int32_field(3)
    company_issue_id: str = betterproto.string_field(4)
    page_size: int = betterproto.int32_field(5)
    page_cursor: str = betterproto.string_field(6)
    sort_field: "IssueSortField" = betterproto.enum_field(7)
    sort_direction: "SortDirection" = betterproto.enum_field(14)
    search: str = betterproto.string_field(15)
    warehouse_ids: List[int] = betterproto.int32_field(16)
    schema_ids: List[int] = betterproto.int32_field(17)
    schema_names: List[str] = betterproto.string_field(18)
    table_ids: List[int] = betterproto.int32_field(19)
    column_ids: List[int] = betterproto.int32_field(20)
    sla_ids: List[int] = betterproto.int32_field(21)
    related_issue_ids: List[int] = betterproto.int32_field(22)
    priority: List["IssuePriority"] = betterproto.enum_field(23)
    metric_status: List["MetricStatus"] = betterproto.enum_field(24)
    metric_type: List["MetricType"] = betterproto.message_field(25)
    min_opened_time: int = betterproto.int64_field(26)
    max_opened_time: int = betterproto.int64_field(27)
    sort_options: List["IssueSortOption"] = betterproto.message_field(28)
    workspace_id: int = betterproto.int32_field(29)
    assignee_ids: List[int] = betterproto.int32_field(30)
    parent_issue_ids: List[int] = betterproto.int32_field(31)
    issue_type: List["IssueType"] = betterproto.enum_field(32)
    is_root_cause: "ThreeLeggedBoolean" = betterproto.enum_field(33)
    dimension_ids: List[int] = betterproto.int32_field(34)
    include_companion_metrics: bool = betterproto.bool_field(35)
    downstream_report_ids: List[int] = betterproto.int32_field(36)
    monitor_types: List["MonitorType"] = betterproto.enum_field(37)


@dataclass
class IssueSortOption(betterproto.Message):
    sort_direction: "SortDirection" = betterproto.enum_field(1)
    sort_field: "IssueSortField" = betterproto.enum_field(2)


@dataclass
class GetIssuesResponse(betterproto.Message):
    issue: List["Issue"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GetIssueTableSummaryRequest(betterproto.Message):
    current_status: List["IssueStatus"] = betterproto.enum_field(1)
    page_size: int = betterproto.int32_field(2)
    page_cursor: str = betterproto.string_field(3)
    sort_field: "IssueSortField" = betterproto.enum_field(4)
    sort_direction: "SortDirection" = betterproto.enum_field(5)
    search: str = betterproto.string_field(6)
    table_ids: List[int] = betterproto.int32_field(7)


@dataclass
class GetIssueTableSummaryResponse(betterproto.Message):
    table_summary: List["IssueTableSummary"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class IssueTableSummary(betterproto.Message):
    schema_id: int = betterproto.int32_field(1)
    schema_name: str = betterproto.string_field(2)
    table_id: int = betterproto.int32_field(3)
    table_name: str = betterproto.string_field(4)
    new_issues_ids: List[int] = betterproto.int32_field(5)
    acknowledged_issues_ids: List[int] = betterproto.int32_field(6)
    closed_issues_ids: List[int] = betterproto.int32_field(7)
    last_issue_epoch_seconds: int = betterproto.int64_field(8)
    last_issue_closed_epoch_seconds: int = betterproto.int64_field(9)
    priority: "IssuePriority" = betterproto.enum_field(10)
    priority_score: int = betterproto.int32_field(11)
    has_autothreshold_metrics: bool = betterproto.bool_field(12)
    source_id: int = betterproto.int32_field(13)
    source_name: str = betterproto.string_field(14)
    monitoring_issues_ids: List[int] = betterproto.int32_field(15)


@dataclass
class IssueExternalTicketInfo(betterproto.Message):
    issue_id: int = betterproto.int32_field(1)
    external_ticket_id: str = betterproto.string_field(2)
    external_ticket_url: str = betterproto.string_field(3)
    external_ticket_provider: "ExternalTicketProvider" = betterproto.enum_field(4)


@dataclass
class ExternalTicketNotificationConfig(betterproto.Message):
    notification_config_id: int = betterproto.int32_field(1)
    external_ticket_provider: "ExternalTicketProvider" = betterproto.enum_field(2)
    external_ticket_webhook_url: str = betterproto.string_field(3)
    always_create_ticket: bool = betterproto.bool_field(4)
    monitor_types: List["ExternalTicketMonitorTypeConfig"] = betterproto.message_field(
        5
    )
    webhook_headers: List["WebhookHeader"] = betterproto.message_field(6)


@dataclass
class ExternalTicketMonitorTypeConfig(betterproto.Message):
    type: "MonitorType" = betterproto.enum_field(1)
    auto_create: "ThreeLeggedBoolean" = betterproto.enum_field(2)


@dataclass
class UpdateExternalTicketNotificationConfigRequest(betterproto.Message):
    external_ticket_notification_config: "ExternalTicketNotificationConfig" = (
        betterproto.message_field(1)
    )


@dataclass
class GetExternalTicketNotificationConfigResponse(betterproto.Message):
    external_ticket_notification_config: "ExternalTicketNotificationConfig" = (
        betterproto.message_field(1)
    )


@dataclass
class GetExternalTicketNotificationConfigsResponse(betterproto.Message):
    external_ticket_notification_configs: List["ExternalTicketNotificationConfig"] = (
        betterproto.message_field(1)
    )


@dataclass
class FailedMonitorNotificationConfig(betterproto.Message):
    notification_channels: List["NotificationChannel"] = betterproto.message_field(1)


@dataclass
class GetFailedMonitorNotificationConfigResponse(betterproto.Message):
    config: "FailedMonitorNotificationConfig" = betterproto.message_field(1)


@dataclass
class UpdateFailedMonitorNotificationConfigRequest(betterproto.Message):
    config: "FailedMonitorNotificationConfig" = betterproto.message_field(1)


@dataclass
class SinglePathParamIssueRequest(betterproto.Message):
    issue_id: int = betterproto.int32_field(1)


@dataclass
class SparklinePoint(betterproto.Message):
    timestamp: int = betterproto.int64_field(1)
    value: float = betterproto.double_field(2)


@dataclass
class Sparkline(betterproto.Message):
    sparkline_points: List["SparklinePoint"] = betterproto.message_field(1)


@dataclass
class GetSparklineResponse(betterproto.Message):
    sparkline: "Sparkline" = betterproto.message_field(1)


@dataclass
class PreviewRow(betterproto.Message):
    column_values: List[str] = betterproto.string_field(1)


@dataclass
class RowDiffRequest(betterproto.Message):
    target_column: str = betterproto.string_field(1)
    all_rows: "GetPreviewResponse" = betterproto.message_field(2)
    anomalous_rows: "GetPreviewResponse" = betterproto.message_field(3)


@dataclass
class EtlAnalysisRequest(betterproto.Message):
    issue_description: str = betterproto.string_field(1)
    alerting_data_description: str = betterproto.string_field(2)
    etl_job_name: str = betterproto.string_field(3)
    etl_sql: str = betterproto.string_field(4)


@dataclass
class GetPreviewResponse(betterproto.Message):
    preview_rows: List["PreviewRow"] = betterproto.message_field(1)
    header: "PreviewRow" = betterproto.message_field(2)
    affected_row_count: int = betterproto.int64_field(3)


@dataclass
class GetPreviewResponseCustomRule(betterproto.Message):
    is_valid: bool = betterproto.bool_field(1)
    is_preview_enabled: bool = betterproto.bool_field(2)
    validation_message: str = betterproto.string_field(3)
    would_have_alerted: bool = betterproto.bool_field(4)
    preview_response: "GetPreviewResponse" = betterproto.message_field(5)


@dataclass
class PaginationInfo(betterproto.Message):
    prev_cursor: str = betterproto.string_field(1)
    next_cursor: str = betterproto.string_field(2)
    num_records: int = betterproto.int32_field(3)
    first_sort_distinct_values: int = betterproto.int64_field(4)
    no_num_records: bool = betterproto.bool_field(5)


@dataclass
class ColumnSearchRequest(betterproto.Message):
    table_id: int = betterproto.int32_field(1)
    column_ids: List[int] = betterproto.int32_field(2)
    include_data_node_ids: bool = betterproto.bool_field(3)


@dataclass
class ColumnSearchResponse(betterproto.Message):
    warehouse: "Warehouse" = betterproto.message_field(1)
    schema: "Schema" = betterproto.message_field(2)
    table: "Table" = betterproto.message_field(3)
    columns: List["TableColumn"] = betterproto.message_field(4)


@dataclass
class ConfigValue(betterproto.Message):
    key: str = betterproto.string_field(1)
    string_value: str = betterproto.string_field(2, group="value")
    number_value: float = betterproto.double_field(4, group="value")
    boolean_value: bool = betterproto.bool_field(5, group="value")
    type: "ConfigValueType" = betterproto.enum_field(6)


@dataclass
class VirtualTableRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    sql: str = betterproto.string_field(2)
    warehouse_id: int = betterproto.int32_field(3)
    invoking_user: int = betterproto.int32_field(4)


@dataclass
class VirtualTableIdRequest(betterproto.Message):
    id: int = betterproto.int32_field(1)


@dataclass
class UpdateVirtualTableRequest(betterproto.Message):
    id: int = betterproto.int32_field(1)
    request: "VirtualTableRequest" = betterproto.message_field(2)


@dataclass
class UserEventExchangeMessage(betterproto.Message):
    reinitialize_realm: bool = betterproto.bool_field(1)
    email_to_lock: str = betterproto.string_field(2)
    email_to_unlock: str = betterproto.string_field(3)
    emitted_at: int = betterproto.int64_field(4)


@dataclass
class CacheEventExchangeMessage(betterproto.Message):
    cache_operation: "CacheOperation" = betterproto.enum_field(1)


@dataclass
class AggregateMetricMeasurement(betterproto.Message):
    number_of_points: int = betterproto.int64_field(1)
    number_of_critical_points: int = betterproto.int64_field(2)
    number_of_no_value_points: int = betterproto.int64_field(3)


@dataclass
class SinglePointMetricMeasurement(betterproto.Message):
    observed_value: float = betterproto.double_field(1)
    is_null: bool = betterproto.bool_field(2)


@dataclass
class MetricGroup(betterproto.Message):
    ran_at_epoch_seconds: int = betterproto.int64_field(1)
    group_dimensions: List["MetricGroupDimension"] = betterproto.message_field(2)
    status: "MetricRunStatus" = betterproto.enum_field(3)
    thresholds: List["ConstantThreshold"] = betterproto.message_field(4)
    metric_time_metric_group: "AggregateMetricMeasurement" = betterproto.message_field(
        5, group="group"
    )
    standard_metric_group: "SinglePointMetricMeasurement" = betterproto.message_field(
        6, group="group"
    )
    # used for internal representation of the metric group
    group_name: str = betterproto.string_field(7)


@dataclass
class MetricGroups(betterproto.Message):
    metric_group: List["MetricGroup"] = betterproto.message_field(1)


@dataclass
class GetMetricGroupsRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_field: "MetricGroupSortField" = betterproto.enum_field(3)
    sort_direction: "SortDirection" = betterproto.enum_field(4)
    search: str = betterproto.string_field(5)


@dataclass
class GetMetricGroupsResponse(betterproto.Message):
    metric_groups: List["MetricGroup"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class NamedSchedule(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    cron: str = betterproto.string_field(3)
    entity_info: "EntityInfo" = betterproto.message_field(4)


@dataclass
class GetNamedSchedulesRequest(betterproto.Message):
    ids: List[int] = betterproto.int32_field(1)
    page_size: int = betterproto.int32_field(2)
    page_cursor: str = betterproto.string_field(3)
    sort_field: "NamedScheduleSortField" = betterproto.enum_field(4)
    sort_direction: "SortDirection" = betterproto.enum_field(5)
    search: str = betterproto.string_field(6)


@dataclass
class GetNamedSchedulesResponse(betterproto.Message):
    named_schedules: List["NamedSchedule"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class CreateNamedScheduleRequest(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    cron: str = betterproto.string_field(3)
    workspace_id: int = betterproto.int32_field(4)


@dataclass
class GetNamedScheduleEntitiesResponse(betterproto.Message):
    table_comparisons: List["IdAndDisplayName"] = betterproto.message_field(1)
    metrics: List["IdAndDisplayName"] = betterproto.message_field(2)


@dataclass
class SinglePathParamNamedScheduleRequest(betterproto.Message):
    schedule_id: int = betterproto.int32_field(1)


@dataclass
class IdAndDisplayName(betterproto.Message):
    id: int = betterproto.int32_field(1)
    display_name: str = betterproto.string_field(2)


@dataclass
class SinglePathParamMetricTemplateIdRequest(betterproto.Message):
    # The ID of the metric template
    metric_template_id: int = betterproto.int32_field(1)


@dataclass
class MetricTemplateParametersFieldEntry(betterproto.Message):
    key: str = betterproto.string_field(1)
    value: "MetricTemplateParameterType" = betterproto.enum_field(2)


@dataclass
class MetricTemplate(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    template: str = betterproto.string_field(3)
    return_type: "FieldType" = betterproto.enum_field(4)
    # this should be a map, but https://github.com/stephenh/ts-proto/issues/382
    # was causing frontend problems
    parameters: List["MetricTemplateParametersFieldEntry"] = betterproto.message_field(
        5
    )
    source: "Warehouse" = betterproto.message_field(6)
    dimension: "IdAndDisplayName" = betterproto.message_field(7)
    entity_info: "EntityInfo" = betterproto.message_field(8)


@dataclass
class GetMetricTemplateResponse(betterproto.Message):
    metric_template: "MetricTemplate" = betterproto.message_field(1)


@dataclass
class CreateMetricTemplateRequest(betterproto.Message):
    metric_template: "MetricTemplate" = betterproto.message_field(1)


@dataclass
class CreateMetricTemplateResponse(betterproto.Message):
    metric_template: "MetricTemplate" = betterproto.message_field(1)


@dataclass
class GetMetricTemplateListRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_field: "MetricTemplateSortField" = betterproto.enum_field(3)
    sort_direction: "SortDirection" = betterproto.enum_field(4)
    search: str = betterproto.string_field(5)
    workspace_id: int = betterproto.int32_field(6)


@dataclass
class GetMetricTemplateListResponse(betterproto.Message):
    metric_templates: List["MetricTemplate"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GetColumnApplicableMetricTypesResponse(betterproto.Message):
    metric_types: "ColumnApplicableMetricTypes" = betterproto.message_field(1)


@dataclass
class DomainAuthMapping(betterproto.Message):
    id: int = betterproto.int32_field(1)
    domain: str = betterproto.string_field(2)
    connection_name: str = betterproto.string_field(3)
    id_provider: "IdProvider" = betterproto.enum_field(4)
    oidc_config: "OidcConfigResponse" = betterproto.message_field(5)
    scopes: List[str] = betterproto.string_field(6)


@dataclass
class OidcConfigRequest(betterproto.Message):
    identity_provider_url: str = betterproto.string_field(1)
    client_id: str = betterproto.string_field(2)
    client_secret: str = betterproto.string_field(3)


@dataclass
class OidcConfigResponse(betterproto.Message):
    identity_provider_url: str = betterproto.string_field(1)
    client_id: str = betterproto.string_field(2)


@dataclass
class CreateDomainMappingRequest(betterproto.Message):
    domain: str = betterproto.string_field(1)
    connection_name: str = betterproto.string_field(2)
    id_provider: "IdProvider" = betterproto.enum_field(3)
    oidc_config: "OidcConfigRequest" = betterproto.message_field(4)
    scopes: List[str] = betterproto.string_field(5)


@dataclass
class CreateDomainMappingResponse(betterproto.Message):
    domain_mapping: "DomainAuthMapping" = betterproto.message_field(1)


@dataclass
class UpdateDomainMappingRequestWrapper(betterproto.Message):
    id: int = betterproto.int32_field(1)
    domain_mapping: "CreateDomainMappingRequest" = betterproto.message_field(2)


@dataclass
class UpdateDomainMappingResponse(betterproto.Message):
    domain_mapping: "DomainAuthMapping" = betterproto.message_field(1)


@dataclass
class GetDomainMappingResponse(betterproto.Message):
    domain_mappings: List["DomainAuthMapping"] = betterproto.message_field(1)


@dataclass
class PreAuthResponse(betterproto.Message):
    domain_mappings: List["DomainAuthMapping"] = betterproto.message_field(1)


@dataclass
class GetUserListResponse(betterproto.Message):
    users: List["User"] = betterproto.message_field(1)


@dataclass
class TableMetricsCoverageResponse(betterproto.Message):
    coverage: float = betterproto.double_field(1)


@dataclass
class MetricValidationResult(betterproto.Message):
    issues: List[str] = betterproto.string_field(1)
    can_save: bool = betterproto.bool_field(2)
    warn_before_save: bool = betterproto.bool_field(3)
    critical_issues: List[str] = betterproto.string_field(4)


@dataclass
class SourceMetadataOverrides(betterproto.Message):
    access_history_table_name: str = betterproto.string_field(1)
    copy_history_table_name: str = betterproto.string_field(2)
    query_history_table_name: str = betterproto.string_field(3)
    tables_table_name: str = betterproto.string_field(4)
    dynamic_table_refresh_history_table_name: str = betterproto.string_field(5)


@dataclass
class Source(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    hostname: str = betterproto.string_field(3)
    port: int = betterproto.int32_field(4)
    database_name: str = betterproto.string_field(5)
    database_type: "WarehouseType" = betterproto.enum_field(6)
    domain: str = betterproto.string_field(7)
    username: str = betterproto.string_field(8)
    project_id: str = betterproto.string_field(9)
    service_account_email: str = betterproto.string_field(10)
    query_timeout_seconds: int = betterproto.int32_field(11)
    schema_change_info: "SchemaChangeInfo" = betterproto.message_field(12)
    alation_source_id: int = betterproto.int32_field(13)
    is_favorite: bool = betterproto.bool_field(14)
    atlan_connection_id: str = betterproto.string_field(15)
    temporal_agent_uuid: str = betterproto.string_field(16)
    target_bigquery_project_id: str = betterproto.string_field(17)
    bigquery_query_project_ids: str = betterproto.string_field(18)
    datadotworld_connection_id: str = betterproto.string_field(19)
    uses_agent: bool = betterproto.bool_field(20)
    agent_health_status: "AgentHealthStatus" = betterproto.enum_field(21)
    source_metadata_overrides: "SourceMetadataOverrides" = betterproto.message_field(22)
    max_pool_size: int = betterproto.int32_field(23)
    tags: List["Tag"] = betterproto.message_field(24)
    metric_run_native_temporal_parallelism: int = betterproto.int32_field(25)
    metric_batch_size_query: int = betterproto.int32_field(26)
    metric_batch_size_metadata: int = betterproto.int32_field(27)
    auth_type: "AuthType" = betterproto.enum_field(28)
    cross_source_agent_health_status: "AgentHealthStatus" = betterproto.enum_field(29)
    ignore_schemas_prefix: str = betterproto.string_field(30)
    indexing_schedule: "IdAndDisplayName" = betterproto.message_field(31)
    data_source_agent_version: str = betterproto.string_field(32)
    sensitive_data_agent_health_status: "AgentHealthStatus" = betterproto.enum_field(33)


@dataclass
class CreateSourceRequest(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    hostname: str = betterproto.string_field(3)
    port: int = betterproto.int32_field(4)
    database_name: str = betterproto.string_field(5)
    database_type: "WarehouseType" = betterproto.enum_field(6)
    domain: str = betterproto.string_field(7)
    username: str = betterproto.string_field(8)
    password: str = betterproto.string_field(9)
    # base64 encoded json for BigQuery access keys
    private_key_file: str = betterproto.string_field(10)
    query_timeout_seconds: int = betterproto.int32_field(11)
    skip_indexing: bool = betterproto.bool_field(12)
    alation_source_id: int = betterproto.int32_field(13)
    atlan_connection_id: str = betterproto.string_field(14)
    temporal_agent_secret: str = betterproto.string_field(15)
    target_bigquery_project_id: str = betterproto.string_field(16)
    bigquery_query_project_ids: str = betterproto.string_field(17)
    workspace_id: int = betterproto.int32_field(18)
    datadotworld_connection_id: str = betterproto.string_field(19)
    source_metadata_overrides: "SourceMetadataOverrides" = betterproto.message_field(20)
    max_pool_size: int = betterproto.int32_field(21)
    auth_type: "AuthType" = betterproto.enum_field(22)
    ignore_schemas_prefix: str = betterproto.string_field(23)
    indexing_schedule: "MetricSchedule" = betterproto.message_field(24)


@dataclass
class MetadataSchemaRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    schema_name: List[str] = betterproto.string_field(2)


@dataclass
class SourceValidationResponse(betterproto.Message):
    is_valid: bool = betterproto.bool_field(1)
    errors: List[str] = betterproto.string_field(2)


@dataclass
class SinglePathParamSourceIdRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)


@dataclass
class GetSourceResponse(betterproto.Message):
    source: "Source" = betterproto.message_field(1)


@dataclass
class CreateSourceResponse(betterproto.Message):
    source: "Source" = betterproto.message_field(1)
    schema_names: List[str] = betterproto.string_field(2)


@dataclass
class GetSourceListRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_field: "SourceSortField" = betterproto.enum_field(3)
    sort_direction: "SortDirection" = betterproto.enum_field(4)
    search: str = betterproto.string_field(5)
    workspace_id: int = betterproto.int32_field(6)


@dataclass
class GetSourceListResponse(betterproto.Message):
    sources: List["Source"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class SourcePermission(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    type: "SourcePermissionType" = betterproto.enum_field(2)
    is_successful: bool = betterproto.bool_field(3)
    last_run_at: int = betterproto.int64_field(4)
    exception_class: str = betterproto.string_field(5)
    exception_message: str = betterproto.string_field(6)


@dataclass
class GetSourcePermissionResponse(betterproto.Message):
    permissions: List["SourcePermission"] = betterproto.message_field(1)


@dataclass
class GetSchemaListRequest(betterproto.Message):
    source_ids: List[int] = betterproto.int32_field(1)
    page_size: int = betterproto.int32_field(2)
    page_cursor: str = betterproto.string_field(3)
    sort_field: "SchemaSortField" = betterproto.enum_field(4)
    sort_direction: "SortDirection" = betterproto.enum_field(5)
    search: str = betterproto.string_field(6)
    workspace_id: int = betterproto.int32_field(7)
    hidden: bool = betterproto.bool_field(8)
    tag_ids: List[int] = betterproto.int32_field(9)
    include_virtual: bool = betterproto.bool_field(10)


@dataclass
class GetSchemaListResponse(betterproto.Message):
    schemas: List["Schema"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GetTableListRequest(betterproto.Message):
    source_ids: List[int] = betterproto.int32_field(1)
    schema_ids: List[int] = betterproto.int32_field(2)
    table_ids: List[int] = betterproto.int32_field(3)
    page_size: int = betterproto.int32_field(4)
    page_cursor: str = betterproto.string_field(5)
    sort_field: "TableSortField" = betterproto.enum_field(6)
    sort_direction: "SortDirection" = betterproto.enum_field(7)
    search: str = betterproto.string_field(8)
    ignore_fields: bool = betterproto.bool_field(9)
    workspace_id: int = betterproto.int32_field(10)
    include_data_node_ids: bool = betterproto.bool_field(11)
    tag_ids: List[int] = betterproto.int32_field(12)
    source_connection_types: List["SourceConnectionType"] = betterproto.enum_field(13)


@dataclass
class GetTableListResponse(betterproto.Message):
    tables: List["Table"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GetColumnListRequest(betterproto.Message):
    source_ids: List[int] = betterproto.int32_field(1)
    schema_ids: List[int] = betterproto.int32_field(2)
    table_ids: List[int] = betterproto.int32_field(3)
    column_ids: List[int] = betterproto.int32_field(4)
    page_size: int = betterproto.int32_field(5)
    page_cursor: str = betterproto.string_field(6)
    sort_field: "ColumnSortField" = betterproto.enum_field(7)
    sort_direction: "SortDirection" = betterproto.enum_field(8)
    search: str = betterproto.string_field(9)
    workspace_id: int = betterproto.int32_field(10)
    exclude_data_node: bool = betterproto.bool_field(11)


@dataclass
class ColumnWithTable(betterproto.Message):
    column: "TableColumn" = betterproto.message_field(1)
    table: "Table" = betterproto.message_field(2)


@dataclass
class GetColumnListResponse(betterproto.Message):
    columns: List["ColumnWithTable"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GetAllVirtualTablesRequest(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)


@dataclass
class GetVirtualTableListRequest(betterproto.Message):
    source_ids: List[int] = betterproto.int32_field(1)
    schema_ids: List[int] = betterproto.int32_field(2)
    table_ids: List[int] = betterproto.int32_field(3)
    page_size: int = betterproto.int32_field(4)
    page_cursor: str = betterproto.string_field(5)
    sort_field: "VirtualTableSortField" = betterproto.enum_field(6)
    sort_direction: "SortDirection" = betterproto.enum_field(7)
    search: str = betterproto.string_field(8)
    ignore_fields: bool = betterproto.bool_field(9)
    workspace_id: int = betterproto.int32_field(10)


@dataclass
class GetVirtualTableListResponse(betterproto.Message):
    virtual_tables: List["VirtualTable"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GetConfigResponse(betterproto.Message):
    advanced_config: "ConfigValue" = betterproto.message_field(1)


@dataclass
class GetConfigListResponse(betterproto.Message):
    advanced_configs: List["ConfigValue"] = betterproto.message_field(1)


@dataclass
class UpdateConfigRequest(betterproto.Message):
    advanced_configs: List["ConfigValue"] = betterproto.message_field(1)


@dataclass
class RebuildSourceRequestWrapper(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    request: "RebuildSourceRequest" = betterproto.message_field(2)


@dataclass
class RebuildSourceRequest(betterproto.Message):
    priority: int = betterproto.int32_field(1)


@dataclass
class RebuildSchemaRequestWrapper(betterproto.Message):
    schema_id: int = betterproto.int32_field(1)
    request: "RebuildSchemaRequest" = betterproto.message_field(2)


@dataclass
class RebuildSchemaRequest(betterproto.Message):
    priority: int = betterproto.int32_field(1)


@dataclass
class RebuildIntegrationRequestWrapper(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)
    request: "RebuildIntegrationRequest" = betterproto.message_field(2)


@dataclass
class RebuildIntegrationRequest(betterproto.Message):
    priority: int = betterproto.int32_field(1)


@dataclass
class RebuildDbtProjectRequest(betterproto.Message):
    priority: int = betterproto.int32_field(1)
    force_synchronous: bool = betterproto.bool_field(2)


@dataclass
class RebuildDbtJobRequest(betterproto.Message):
    priority: int = betterproto.int32_field(1)
    force_synchronous: bool = betterproto.bool_field(2)


@dataclass
class QueueSingleTableResponse(betterproto.Message):
    workflow_v2_id: "WorkflowV2Id" = betterproto.message_field(1)
    status_url: str = betterproto.string_field(2)


@dataclass
class RebuildSingleTableRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    schema_name: str = betterproto.string_field(2)
    table_name: str = betterproto.string_field(3)


@dataclass
class WorkflowResponse(betterproto.Message):
    workflow_id: int = betterproto.int64_field(1)
    workflow_type: "WorkflowProcessingType" = betterproto.enum_field(2)


@dataclass
class WorkflowV2Id(betterproto.Message):
    workflow_id: str = betterproto.string_field(1)
    run_id: str = betterproto.string_field(2)


@dataclass
class WorkflowV2StatusResponse(betterproto.Message):
    workflow_v2_id: "WorkflowV2Id" = betterproto.message_field(2)
    status: "WorkflowProcessingStatus" = betterproto.enum_field(3)
    started_at: int = betterproto.int64_field(4)
    completed_at: int = betterproto.int64_field(5)
    error: str = betterproto.string_field(6)


@dataclass
class BigconfigWorkflowV2StatusResponse(betterproto.Message):
    status_response: "WorkflowV2StatusResponse" = betterproto.message_field(1)
    bigconfig_response: "MetricSuiteResponse" = betterproto.message_field(2)


@dataclass
class VirtualTableWorkflowV2StatusResponse(betterproto.Message):
    status_response: "WorkflowV2StatusResponse" = betterproto.message_field(1)
    virtual_table: "VirtualTable" = betterproto.message_field(2)


@dataclass
class WorkflowStatusResponse(betterproto.Message):
    workflow_id: int = betterproto.int64_field(1)
    total_ops: int = betterproto.int32_field(2)
    completed_ops: int = betterproto.int32_field(3)
    status: "WorkflowProcessingStatus" = betterproto.enum_field(4)
    workflow_type: "WorkflowProcessingType" = betterproto.enum_field(5)
    started_at: int = betterproto.int64_field(6)
    completed_at: int = betterproto.int64_field(7)


@dataclass
class BulkWorkflowV2StatusRequest(betterproto.Message):
    workflow_v2_ids: List["WorkflowV2Id"] = betterproto.message_field(1)


@dataclass
class FailedWorkflowV2Id(betterproto.Message):
    workflow_v2_id: "WorkflowV2Id" = betterproto.message_field(1)
    reason: str = betterproto.string_field(2)


@dataclass
class BulkWorkflowV2StatusResponse(betterproto.Message):
    statuses: List["WorkflowV2StatusResponse"] = betterproto.message_field(1)
    failures: List["FailedWorkflowV2Id"] = betterproto.message_field(2)


@dataclass
class BulkWorkflowV2CancelRequest(betterproto.Message):
    workflow_v2_ids: List["WorkflowV2Id"] = betterproto.message_field(1)


@dataclass
class BulkWorkflowV2CancelResponse(betterproto.Message):
    canceled: List["WorkflowV2Id"] = betterproto.message_field(1)
    failures: List["FailedWorkflowV2Id"] = betterproto.message_field(2)


@dataclass
class WorkflowV2TerminateRequest(betterproto.Message):
    workflow_v2_id: "WorkflowV2Id" = betterproto.message_field(1)
    reason: str = betterproto.string_field(2)


@dataclass
class BulkWorkflowV2TerminateRequest(betterproto.Message):
    workflow_v2_ids: List["WorkflowV2Id"] = betterproto.message_field(1)
    reason: str = betterproto.string_field(2)


@dataclass
class BulkWorkflowV2TerminateResponse(betterproto.Message):
    terminated: List["WorkflowV2Id"] = betterproto.message_field(1)
    failures: List["FailedWorkflowV2Id"] = betterproto.message_field(2)


@dataclass
class BigconfigWorkflowStatusResponse(betterproto.Message):
    workflow_status_response: "WorkflowStatusResponse" = betterproto.message_field(1)
    metric_suite_response: "MetricSuiteResponse" = betterproto.message_field(2)


@dataclass
class CatalogIndexRequest(betterproto.Message):
    id: int = betterproto.int32_field(1)
    workflow_info: "WorkflowInfo" = betterproto.message_field(2)
    priority: int = betterproto.int32_field(3)
    is_first_indexing: bool = betterproto.bool_field(4)
    indexed_at: int = betterproto.int64_field(5)
    warehouse_id: int = betterproto.int32_field(6)


@dataclass
class DeltaRunRequest(betterproto.Message):
    id: int = betterproto.int32_field(1)
    workflow_info: "WorkflowInfo" = betterproto.message_field(2)


@dataclass
class IntegrationIndexRequest(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)
    workflow_info: "WorkflowInfo" = betterproto.message_field(2)
    priority: int = betterproto.int32_field(3)


@dataclass
class DatasetIndexRequest(betterproto.Message):
    dataset_id: int = betterproto.int32_field(1)
    table: "Table" = betterproto.message_field(2)
    catalog_index_operation_type: "CatalogIndexOperationType" = betterproto.enum_field(
        3
    )
    workflow_process_id: int = betterproto.int64_field(4)
    is_first_indexing: bool = betterproto.bool_field(5)
    indexed_at: int = betterproto.int64_field(6)
    warehouse_id: int = betterproto.int32_field(7)
    short_circuit_dataset_ids: List[int] = betterproto.int32_field(8)


@dataclass
class TableauWorkbookIndexRequest(betterproto.Message):
    tableau_workbook_id: int = betterproto.int32_field(1)
    tableau_workbook: "TableauWorkbook" = betterproto.message_field(2)
    integration_partner: "IntegrationPartner" = betterproto.enum_field(3)
    catalog_index_operation_type: "CatalogIndexOperationType" = betterproto.enum_field(
        4
    )
    workflow_process_id: int = betterproto.int64_field(5)
    integration_id: int = betterproto.int32_field(7)


@dataclass
class DbtProjectIndexRequest(betterproto.Message):
    dbt_project_id: int = betterproto.int32_field(1)
    dbt_project: "UpsertDbtProject" = betterproto.message_field(2)
    integration_partner: "IntegrationPartner" = betterproto.enum_field(3)
    catalog_index_operation_type: "CatalogIndexOperationType" = betterproto.enum_field(
        4
    )
    workflow_process_id: int = betterproto.int64_field(5)
    integration_id: int = betterproto.int32_field(6)
    priority: int = betterproto.int32_field(7)


@dataclass
class DbtJobIndexRequest(betterproto.Message):
    dbt_job_id: int = betterproto.int32_field(1)
    dbt_job: "UpsertDbtJob" = betterproto.message_field(2)
    catalog_index_operation_type: "CatalogIndexOperationType" = betterproto.enum_field(
        3
    )
    workflow_process_id: int = betterproto.int64_field(4)
    integration_id: int = betterproto.int32_field(5)
    priority: int = betterproto.int32_field(6)


@dataclass
class DbtJobRunIndexRequest(betterproto.Message):
    dbt_job_run_id: int = betterproto.int64_field(1)
    dbt_job_run: "UpsertDbtJobRun" = betterproto.message_field(2)
    catalog_index_operation_type: "CatalogIndexOperationType" = betterproto.enum_field(
        3
    )
    workflow_process_id: int = betterproto.int64_field(4)


@dataclass
class LineageCriticalEntitiesExportRequest(betterproto.Message):
    filters: List[str] = betterproto.string_field(1)


@dataclass
class SinglePathParamSchemaIdRequest(betterproto.Message):
    schema_id: int = betterproto.int32_field(1)


@dataclass
class SinglePathParamWorkflowIdRequest(betterproto.Message):
    workflow_id: int = betterproto.int64_field(1)


@dataclass
class SchemaChange(betterproto.Message):
    id: int = betterproto.int64_field(1)
    source_id: int = betterproto.int32_field(2)
    source_name: str = betterproto.string_field(3)
    schema_id: int = betterproto.int32_field(4)
    schema_name: str = betterproto.string_field(5)
    table_id: int = betterproto.int32_field(6)
    table_name: str = betterproto.string_field(7)
    column_id: int = betterproto.int32_field(8)
    column_name: str = betterproto.string_field(9)
    change_type: "SchemaChangeOperation" = betterproto.enum_field(10)
    object_type: "CatalogEntityType" = betterproto.enum_field(11)
    new_value: str = betterproto.string_field(12)
    old_value: str = betterproto.string_field(13)
    is_first_indexing: bool = betterproto.bool_field(14)
    detected_at: int = betterproto.int64_field(15)
    fully_qualified_name: str = betterproto.string_field(16)
    schema_exists_in_catalog: bool = betterproto.bool_field(17)
    table_exists_in_catalog: bool = betterproto.bool_field(18)
    column_exists_in_catalog: bool = betterproto.bool_field(19)


@dataclass
class SchemaChangeInfo(betterproto.Message):
    last_schema_change_at: int = betterproto.int64_field(1)
    most_recent_schema_scan_at: int = betterproto.int64_field(2)
    initial_schema_scan_at: int = betterproto.int64_field(3)


@dataclass
class GetSchemaChangesRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_field: "SchemaChangeSortField" = betterproto.enum_field(3)
    sort_direction: "SortDirection" = betterproto.enum_field(4)
    search: str = betterproto.string_field(5)
    source_id: int = betterproto.int32_field(6)
    schema_id: int = betterproto.int32_field(7)
    table_id: int = betterproto.int32_field(8)
    column_id: int = betterproto.int32_field(9)
    workspace_id: int = betterproto.int32_field(10)


@dataclass
class GetSchemaChangesResponse(betterproto.Message):
    schema_changes: List["SchemaChange"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class CatalogAttribute(betterproto.Message):
    key: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)


@dataclass
class GetCatalogAttributeRequest(betterproto.Message):
    entity_type: "CatalogEntityType" = betterproto.enum_field(1)
    entity_id: int = betterproto.int32_field(2)


@dataclass
class SetCatalogAttributeRequest(betterproto.Message):
    entity_type: "CatalogEntityType" = betterproto.enum_field(1)
    entity_id: int = betterproto.int32_field(2)
    attributes: List["CatalogAttribute"] = betterproto.message_field(3)


@dataclass
class CatalogAttributeResponse(betterproto.Message):
    entity_type: "CatalogEntityType" = betterproto.enum_field(1)
    entity_id: int = betterproto.int32_field(2)
    attributes: List["CatalogAttribute"] = betterproto.message_field(3)


@dataclass
class SetObjectOwnerRequest(betterproto.Message):
    ownable_type: "OwnableType" = betterproto.enum_field(1)
    ownable_id: int = betterproto.int32_field(2)
    owner: int = betterproto.int32_field(3)


@dataclass
class ObjectOwnerResponse(betterproto.Message):
    ownable_type: "OwnableType" = betterproto.enum_field(1)
    ownable_id: int = betterproto.int32_field(2)
    owner: "IdAndDisplayName" = betterproto.message_field(3)
    inherited_owner: "IdAndDisplayName" = betterproto.message_field(4)


@dataclass
class MetricNamesResponse(betterproto.Message):
    metric_names: List["PredefinedMetricName"] = betterproto.enum_field(1)


@dataclass
class FavoriteItem(betterproto.Message):
    entity_id: int = betterproto.int32_field(1)
    entity_type: "TaggableEntityType" = betterproto.enum_field(2)
    entity_name: str = betterproto.string_field(3)


@dataclass
class GetFavoritesRequest(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)


@dataclass
class FavoriteListResponse(betterproto.Message):
    favorites: List["FavoriteItem"] = betterproto.message_field(1)


@dataclass
class FavoriteRequest(betterproto.Message):
    favorite: "FavoriteItem" = betterproto.message_field(1)


@dataclass
class BulkFavoriteRequest(betterproto.Message):
    favorites: List["FavoriteItem"] = betterproto.message_field(1)


@dataclass
class BulkFavoriteResponse(betterproto.Message):
    successes: List["FavoriteItem"] = betterproto.message_field(1)
    failures: List["FavoriteFailure"] = betterproto.message_field(2)


@dataclass
class FavoriteFailure(betterproto.Message):
    favorite: "FavoriteItem" = betterproto.message_field(1)
    reason: str = betterproto.string_field(2)


@dataclass
class PublicKeyMessage(betterproto.Message):
    public_key: str = betterproto.string_field(1)


@dataclass
class UpsertDeltaRequest(betterproto.Message):
    delta: "Delta" = betterproto.message_field(1)
    workspace_id: int = betterproto.int32_field(2)


@dataclass
class UpsertDeltaResponse(betterproto.Message):
    delta: "Delta" = betterproto.message_field(1)


@dataclass
class Delta(betterproto.Message):
    id: int = betterproto.int32_field(1)
    source_table: "IdAndDisplayName" = betterproto.message_field(2)
    entity_info: "EntityInfo" = betterproto.message_field(3)
    name: str = betterproto.string_field(4)
    last_run_at_epoch_seconds: int = betterproto.int64_field(5)
    named_schedule: "IdAndDisplayName" = betterproto.message_field(6)
    alerting_metric_count: int = betterproto.int64_field(7)
    total_metric_count: int = betterproto.int64_field(8)
    failed_metric_count: int = betterproto.int64_field(9)
    comparison_table_configurations: List["ComparisonTableConfiguration"] = (
        betterproto.message_field(10)
    )
    source_warehouse_type: "WarehouseType" = betterproto.enum_field(11)
    source_schema: "IdAndDisplayName" = betterproto.message_field(12)
    source_source: "IdAndDisplayName" = betterproto.message_field(13)
    notification_channels: List["NotificationChannel"] = betterproto.message_field(14)
    is_source_table_deleted: bool = betterproto.bool_field(15)
    delta_type: "DeltaType" = betterproto.enum_field(16)
    tags: List["Tag"] = betterproto.message_field(17)
    dimension: "IdAndDisplayName" = betterproto.message_field(18)


@dataclass
class DeltaIdRequest(betterproto.Message):
    delta_id: int = betterproto.int32_field(1)


@dataclass
class RunDeltaResponse(betterproto.Message):
    delta_info: "DeltaInfo" = betterproto.message_field(1)
    workflow_info: "WorkflowResponse" = betterproto.message_field(2)


@dataclass
class DeltaInfo(betterproto.Message):
    delta: "Delta" = betterproto.message_field(1)
    comparison_target_infos: List["DeltaTargetInfo"] = betterproto.message_field(2)
    next_run_epoch_seconds: int = betterproto.int64_field(3)
    is_favorite: bool = betterproto.bool_field(4)


@dataclass
class DeltaTargetInfo(betterproto.Message):
    comparison_column_infos: List["ComparisonColumnInfo"] = betterproto.message_field(1)
    comparison_metric_infos: List["ComparisonMetricInfo"] = betterproto.message_field(2)
    schema_match: bool = betterproto.bool_field(3)
    metric_count: int = betterproto.int64_field(4)
    failed_metric_count: int = betterproto.int64_field(5)
    alerting_metric_count: int = betterproto.int64_field(6)
    source_row_count: int = betterproto.int64_field(7)
    target_row_count: int = betterproto.int64_field(8)
    target_table: "IdAndDisplayName" = betterproto.message_field(9)
    target_warehouse_type: "WarehouseType" = betterproto.enum_field(10)
    target_schema: "IdAndDisplayName" = betterproto.message_field(11)
    target_source: "IdAndDisplayName" = betterproto.message_field(12)
    total_group_count: int = betterproto.int32_field(13)
    failed_group_count: int = betterproto.int32_field(14)
    alerting_group_count: int = betterproto.int32_field(15)
    is_target_table_deleted: bool = betterproto.bool_field(16)
    last_run_at_epoch_seconds: int = betterproto.int64_field(17)
    keys_in_all_count: int = betterproto.int64_field(18)
    keys_only_in_source_count: int = betterproto.int64_field(19)
    keys_only_in_target_count: int = betterproto.int64_field(20)


@dataclass
class ComparisonColumnInfo(betterproto.Message):
    source_column: "IdAndDisplayName" = betterproto.message_field(1)
    target_column: "IdAndDisplayName" = betterproto.message_field(2)
    metrics: List["MetricType"] = betterproto.message_field(3)
    user_defined: bool = betterproto.bool_field(4)
    total_metric_count: int = betterproto.int64_field(5)
    failed_metric_count: int = betterproto.int32_field(6)
    alerting_metric_count: int = betterproto.int64_field(7)
    total_group_count: int = betterproto.int32_field(8)
    failed_group_count: int = betterproto.int32_field(9)
    alerting_group_count: int = betterproto.int32_field(10)
    is_part_of_key: bool = betterproto.bool_field(11)


@dataclass
class GetDeltaInfosResponse(betterproto.Message):
    delta_infos: List["DeltaInfo"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GetDeltaResponse(betterproto.Message):
    delta_info: "DeltaInfo" = betterproto.message_field(1)


@dataclass
class Workspace(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    is_default: bool = betterproto.bool_field(3)
    sources: List["Source"] = betterproto.message_field(4)


@dataclass
class SinglePathParamWorkspaceIdRequest(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)


@dataclass
class SinglePathParamWarehouseIdRequest(betterproto.Message):
    warehouse_id: int = betterproto.int32_field(1)


@dataclass
class WorkspaceListResponse(betterproto.Message):
    workspaces: List["Workspace"] = betterproto.message_field(1)


@dataclass
class CreateOrUpdateWorkspaceRequest(betterproto.Message):
    name: str = betterproto.string_field(1)


@dataclass
class UpdateWorkspaceRequestWrapper(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)
    request: "CreateOrUpdateWorkspaceRequest" = betterproto.message_field(2)


@dataclass
class AgentApiKeyInfo(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    description: str = betterproto.string_field(3)
    created_at: int = betterproto.int64_field(4)
    last_used_at: int = betterproto.int64_field(5)
    last_used_ip: str = betterproto.string_field(6)
    type: "AgentApiKeyType" = betterproto.enum_field(7)


@dataclass
class CreateAgentApiKeyRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    type: "AgentApiKeyType" = betterproto.enum_field(3)


@dataclass
class CreateAgentApiKeyResponse(betterproto.Message):
    info: "AgentApiKeyInfo" = betterproto.message_field(1)
    api_key: str = betterproto.string_field(2)


@dataclass
class ListAgentApiKeyResponse(betterproto.Message):
    keys: List["AgentApiKeyInfo"] = betterproto.message_field(1)


@dataclass
class PersonalApiKeyInfo(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    description: str = betterproto.string_field(3)
    created_at: int = betterproto.int64_field(4)
    last_used_at: int = betterproto.int64_field(5)
    last_used_ip: str = betterproto.string_field(6)


@dataclass
class CreatePersonalApiKeyRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)


@dataclass
class CreatePersonalApiKeyResponse(betterproto.Message):
    info: "PersonalApiKeyInfo" = betterproto.message_field(1)
    api_key: str = betterproto.string_field(2)


@dataclass
class ListPersonalApiKeyResponse(betterproto.Message):
    keys: List["PersonalApiKeyInfo"] = betterproto.message_field(1)


@dataclass
class SinglePathParamApiKeyIdRequest(betterproto.Message):
    api_key_id: int = betterproto.int32_field(1)


@dataclass
class SinglePathParamRoleIdRequest(betterproto.Message):
    role_id: int = betterproto.int32_field(1)


@dataclass
class RevisionInfo(betterproto.Message):
    type: "RevisionType" = betterproto.enum_field(1)
    epoch_seconds: int = betterproto.int64_field(2)
    revised_by: "User" = betterproto.message_field(3)


@dataclass
class WorkspaceRevision(betterproto.Message):
    revision_info: "RevisionInfo" = betterproto.message_field(1)
    workspace: "Workspace" = betterproto.message_field(2)


@dataclass
class GetWorkspaceRevisionsResponse(betterproto.Message):
    revisions: List["WorkspaceRevision"] = betterproto.message_field(1)


@dataclass
class GetWorkspaceAccessorsResponse(betterproto.Message):
    groups: List["GroupWorkspaceAccessor"] = betterproto.message_field(1)
    users: List["UserWorkspaceAccessor"] = betterproto.message_field(2)


@dataclass
class GroupWorkspaceAccessor(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    user_count: int = betterproto.int32_field(3)
    roles: List["RoleV2"] = betterproto.message_field(4)


@dataclass
class UserWorkspaceAccessor(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    email: str = betterproto.string_field(3)
    group_ids: List[int] = betterproto.int32_field(4)
    highest_role_name: str = betterproto.string_field(5)
    highest_role_type: "RoleType" = betterproto.enum_field(6)


@dataclass
class GetRoleAccessorsResponse(betterproto.Message):
    groups: List["GroupRoleAccessor"] = betterproto.message_field(1)
    users: List["UserRoleAccessor"] = betterproto.message_field(2)


@dataclass
class GroupRoleAccessor(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    user_count: int = betterproto.int32_field(3)
    workspaces: List["IdAndDisplayName"] = betterproto.message_field(4)


@dataclass
class UserRoleAccessor(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    email: str = betterproto.string_field(3)
    group_ids: List[int] = betterproto.int32_field(4)
    workspaces: List["IdAndDisplayName"] = betterproto.message_field(5)


@dataclass
class UserRevision(betterproto.Message):
    revision_info: "RevisionInfo" = betterproto.message_field(1)
    user: "User" = betterproto.message_field(2)


@dataclass
class GetUserRevisionsResponse(betterproto.Message):
    revisions: List["UserRevision"] = betterproto.message_field(1)


@dataclass
class CalculateDashboardDataPointsRequest(betterproto.Message):
    source_id: List[int] = betterproto.int32_field(1)
    timestamp: int = betterproto.int64_field(2)


@dataclass
class DashboardDataPointsRequest(betterproto.Message):
    company_id: int = betterproto.int32_field(1)
    workspace_ids: List[int] = betterproto.int32_field(2)
    source_ids: List[int] = betterproto.int32_field(3)
    starting_timestamp: int = betterproto.int64_field(4)
    ending_timestamp: int = betterproto.int64_field(5)
    data_point_types: List["DashboardDataPointType"] = betterproto.enum_field(6)
    aggregation_type: "DashboardDateAggregationType" = betterproto.enum_field(7)


@dataclass
class DashboardDataPointsResponse(betterproto.Message):
    company_id: int = betterproto.int32_field(1)
    workspace_ids: List[int] = betterproto.int32_field(2)
    source_ids: List[int] = betterproto.int32_field(3)
    starting_timestamp: int = betterproto.int64_field(4)
    ending_timestamp: int = betterproto.int64_field(5)
    data_point_types: List["DashboardDataPointType"] = betterproto.enum_field(6)
    data_point_series: List["DashboardDataPointSeries"] = betterproto.message_field(7)


@dataclass
class DashboardRefreshInfoRequest(betterproto.Message):
    company_id: int = betterproto.int32_field(1)
    workspace_ids: List[int] = betterproto.int32_field(2)
    source_ids: List[int] = betterproto.int32_field(3)
    starting_timestamp: int = betterproto.int64_field(4)
    ending_timestamp: int = betterproto.int64_field(5)


@dataclass
class DashboardRefreshInfoResponse(betterproto.Message):
    last_updated_at: int = betterproto.int64_field(1)
    next_updated_at: int = betterproto.int64_field(2)


@dataclass
class DashboardDataPointSeries(betterproto.Message):
    company_id: int = betterproto.int32_field(1)
    workspace_ids: List[int] = betterproto.int32_field(2)
    source_ids: List[int] = betterproto.int32_field(3)
    key: str = betterproto.string_field(4)
    starting_timestamp: int = betterproto.int64_field(5)
    ending_timestamp: int = betterproto.int64_field(6)
    data_point_type: "DashboardDataPointType" = betterproto.enum_field(7)
    data_points: List["DashboardDataPoint"] = betterproto.message_field(8)
    key_info: str = betterproto.string_field(9)


@dataclass
class DashboardDataPoint(betterproto.Message):
    company_id: int = betterproto.int32_field(1)
    workspace_ids: List[int] = betterproto.int32_field(2)
    source_ids: List[int] = betterproto.int32_field(3)
    key: str = betterproto.string_field(4)
    data_timestamp: int = betterproto.int64_field(5)
    data_point_type: "DashboardDataPointType" = betterproto.enum_field(6)
    value: float = betterproto.double_field(7)
    collected_timestamp: int = betterproto.int64_field(8)


@dataclass
class Group(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    users: List["IdAndDisplayName"] = betterproto.message_field(3)
    idp_groups: List[str] = betterproto.string_field(5)
    memberships: List["UserGroupMembership"] = betterproto.message_field(6)
    grants: List["Grant"] = betterproto.message_field(7)


@dataclass
class UserGroupMembership(betterproto.Message):
    user: "User" = betterproto.message_field(1)
    membership_paths: List["GroupMembershipVia"] = betterproto.enum_field(2)


@dataclass
class GroupListResponse(betterproto.Message):
    groups: List["Group"] = betterproto.message_field(1)


@dataclass
class GetAllIdpGroupsResponse(betterproto.Message):
    idp_groups: List[str] = betterproto.string_field(1)


@dataclass
class CreateOrUpdateGroupRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    idp_groups: List[str] = betterproto.string_field(2)


@dataclass
class SinglePathParamGroupIdRequest(betterproto.Message):
    group_id: int = betterproto.int32_field(1)


@dataclass
class UpdateGroupRequestWrapper(betterproto.Message):
    group_id: int = betterproto.int32_field(1)
    request: "CreateOrUpdateGroupRequest" = betterproto.message_field(2)


@dataclass
class BulkChangeGroupUsersRequest(betterproto.Message):
    user_ids: List[int] = betterproto.int32_field(1)
    group_ids: List[int] = betterproto.int32_field(2)
    operation: "GroupUserOperation" = betterproto.enum_field(3)


@dataclass
class GroupUserPair(betterproto.Message):
    user_id: int = betterproto.int32_field(1)
    group_id: int = betterproto.int32_field(2)


@dataclass
class FailedGroupUserUpdate(betterproto.Message):
    user_id: int = betterproto.int32_field(1)
    group_id: int = betterproto.int32_field(2)
    reason: str = betterproto.string_field(3)


@dataclass
class BulkChangeGroupUsersResponse(betterproto.Message):
    successful_ids: List["GroupUserPair"] = betterproto.message_field(1)
    failed_updates: List["FailedGroupUserUpdate"] = betterproto.message_field(2)


@dataclass
class RoleV2(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(3)
    role_type: "RoleType" = betterproto.enum_field(4)
    role_permissions: List["RolePermission"] = betterproto.message_field(5)
    description: str = betterproto.string_field(6)


@dataclass
class RolePermission(betterproto.Message):
    domains: List["PermissionDomain"] = betterproto.enum_field(1)
    actions: List["PermissionAction"] = betterproto.enum_field(2)


@dataclass
class CreateOrUpdateRoleRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    base_role: "RoleType" = betterproto.enum_field(3)
    role_permissions: List["RolePermission"] = betterproto.message_field(4)


@dataclass
class UpdateRoleRequestWrapper(betterproto.Message):
    id: int = betterproto.int32_field(1)
    request: "CreateOrUpdateRoleRequest" = betterproto.message_field(2)


@dataclass
class RoleV2ListResponse(betterproto.Message):
    roles: List["RoleV2"] = betterproto.message_field(1)


@dataclass
class RoleV2Revision(betterproto.Message):
    revision_info: "RevisionInfo" = betterproto.message_field(1)
    role: "RoleV2" = betterproto.message_field(2)


@dataclass
class GetRoleV2RevisionsResponse(betterproto.Message):
    revisions: List["RoleV2Revision"] = betterproto.message_field(1)


@dataclass
class Grant(betterproto.Message):
    id: int = betterproto.int32_field(1)
    role: "RoleV2" = betterproto.message_field(2)
    group: "IdAndDisplayName" = betterproto.message_field(3)
    workspace: "IdAndDisplayName" = betterproto.message_field(4)


@dataclass
class BulkChangeGroupGrantsRequest(betterproto.Message):
    operation: "RoleOperation" = betterproto.enum_field(3)
    requests: List["Grant"] = betterproto.message_field(4)


@dataclass
class FailedGroupRoleUpdate(betterproto.Message):
    request: "Grant" = betterproto.message_field(1)
    reason: str = betterproto.string_field(2)


@dataclass
class BulkChangeGroupGrantsResponse(betterproto.Message):
    successful_requests: List["Grant"] = betterproto.message_field(1)
    failed_updates: List["FailedGroupRoleUpdate"] = betterproto.message_field(2)


@dataclass
class BulkDeleteUsersRequest(betterproto.Message):
    user_ids: List[int] = betterproto.int32_field(1)


@dataclass
class SetBigQueryRegionRequestWrapper(betterproto.Message):
    schema_id: int = betterproto.int32_field(1)
    body: "SetBigQueryRegionRequest" = betterproto.message_field(2)


@dataclass
class SetBigQueryRegionRequest(betterproto.Message):
    region: str = betterproto.string_field(1)


@dataclass
class GetBigQueryRegionResponse(betterproto.Message):
    region: str = betterproto.string_field(1)
    manually_set: bool = betterproto.bool_field(2)


@dataclass
class SinglePathParamDbtJobRunIdRequest(betterproto.Message):
    dbt_job_run_id: int = betterproto.int32_field(1)


@dataclass
class DbtJobRun(betterproto.Message):
    id: int = betterproto.int64_field(1)
    status: "DbtJobRunStatus" = betterproto.enum_field(2)
    dbt_job_run_ext_id: int = betterproto.int64_field(3)
    started_at: int = betterproto.int64_field(4)
    completed_at: int = betterproto.int64_field(5)
    git_sha: str = betterproto.string_field(6)
    url: str = betterproto.string_field(7)
    job_id: int = betterproto.int32_field(8)


@dataclass
class UpsertDbtJobRun(betterproto.Message):
    id: int = betterproto.int64_field(1)
    job_id: int = betterproto.int32_field(2)
    status: "DbtJobRunStatus" = betterproto.enum_field(3)
    dbt_job_run_ext_id: int = betterproto.int64_field(4)
    started_at: int = betterproto.int64_field(5)
    completed_at: int = betterproto.int64_field(6)
    git_sha: str = betterproto.string_field(7)


@dataclass
class SinglePathParamDbtJobIdRequest(betterproto.Message):
    dbt_job_id: int = betterproto.int32_field(1)


@dataclass
class DbtJob(betterproto.Message):
    id: int = betterproto.int32_field(1)
    project_id: int = betterproto.int32_field(2)
    name: str = betterproto.string_field(3)
    dbt_job_ext_id: int = betterproto.int32_field(4)
    is_favorite: bool = betterproto.bool_field(5)
    most_recent_job_runs: List["DbtJobRun"] = betterproto.message_field(6)
    url: str = betterproto.string_field(7)
    tags: List["Tag"] = betterproto.message_field(8)


@dataclass
class UpsertDbtJob(betterproto.Message):
    id: int = betterproto.int32_field(1)
    project_id: int = betterproto.int32_field(2)
    name: str = betterproto.string_field(3)
    dbt_job_id: int = betterproto.int32_field(4)


@dataclass
class GetDbtJobResponse(betterproto.Message):
    dbt_job: "DbtJob" = betterproto.message_field(1)


@dataclass
class GetDbtJobsRequest(betterproto.Message):
    project_id: int = betterproto.int32_field(1)


@dataclass
class GetDbtJobsResponse(betterproto.Message):
    dbt_jobs: List["DbtJob"] = betterproto.message_field(1)


@dataclass
class SchemaDbtJobsRequest(betterproto.Message):
    schema_id: int = betterproto.int32_field(1)


@dataclass
class TableDbtJobsRequest(betterproto.Message):
    table_id: int = betterproto.int32_field(1)


@dataclass
class SingleDbtJobRunIdRequest(betterproto.Message):
    job_run_id: int = betterproto.int32_field(1)


@dataclass
class DbtJobRunResponse(betterproto.Message):
    dbt_job_run: "DbtJobRun" = betterproto.message_field(1)


@dataclass
class IssueDbtInfoRequest(betterproto.Message):
    issue_id: int = betterproto.int32_field(1)


@dataclass
class IssueDbtInfoResponse(betterproto.Message):
    issue_id: int = betterproto.int32_field(1)
    preceding_dbt_job_runs: List["DbtJobRun"] = betterproto.message_field(2)


@dataclass
class MergeIssuesRequest(betterproto.Message):
    where: "BulkIssueUpdateWhereClause" = betterproto.message_field(1)
    existing_incident: int = betterproto.int32_field(2)
    incident_name: str = betterproto.string_field(3)
    assignee: int = betterproto.int32_field(4)
    status: "IssueStatus" = betterproto.enum_field(5)
    allow_incidents: bool = betterproto.bool_field(6)


@dataclass
class MergeIssuesResponse(betterproto.Message):
    incident: "Issue" = betterproto.message_field(1)
    response: "BulkResponse" = betterproto.message_field(2)


@dataclass
class UnmergeIssuesRequest(betterproto.Message):
    where: "BulkIssueUpdateWhereClause" = betterproto.message_field(1)
    assignee: int = betterproto.int32_field(2)
    status: "IssueStatus" = betterproto.enum_field(3)


@dataclass
class UnmergeIssuesResponse(betterproto.Message):
    response: "BulkResponse" = betterproto.message_field(1)


@dataclass
class ApplicableColumnsTablesRequest(betterproto.Message):
    table_id: int = betterproto.int32_field(1)
    schema_id: int = betterproto.int32_field(2)
    source_id: int = betterproto.int32_field(3)
    metrics: List["MetricType"] = betterproto.message_field(4)
    column_id: int = betterproto.int32_field(5)
    is_default_metrics: bool = betterproto.bool_field(6)
    node_id: int = betterproto.int32_field(7)


@dataclass
class ApplicableColumnsTablesResponse(betterproto.Message):
    valid_columns: List["ColumnApplicableMetricTypes"] = betterproto.message_field(1)
    tables: List["TableLevelApplicableMetricTypes"] = betterproto.message_field(2)
    recommended_columns: List["ColumnApplicableMetricTypes"] = (
        betterproto.message_field(3)
    )


@dataclass
class MetricDeploysRequest(betterproto.Message):
    bulk_metric_deploys: List["BulkMetricDeploy"] = betterproto.message_field(1)
    bulk_metric_configuration: "BulkMetricConfiguration" = betterproto.message_field(2)
    company_id: int = betterproto.int32_field(3)
    rct_fields: "SetDateColumnRequest" = betterproto.message_field(4)
    invoking_user: int = betterproto.int32_field(5)


@dataclass
class BulkMetricDeploy(betterproto.Message):
    table_id: int = betterproto.int32_field(1)
    parameters: List["MetricParameter"] = betterproto.message_field(2)
    metric: "MetricType" = betterproto.message_field(3)
    is_table_metric: bool = betterproto.bool_field(4)
    name: str = betterproto.string_field(5)
    description: str = betterproto.string_field(6)
    is_profiling_suggestion: bool = betterproto.bool_field(7)


@dataclass
class BulkMetricConfiguration(betterproto.Message):
    schedule_frequency: "TimeInterval" = betterproto.message_field(1)
    filters: List[str] = betterproto.string_field(2)
    group_bys: List[str] = betterproto.string_field(3)
    thresholds: List["Threshold"] = betterproto.message_field(4)
    notification_channels: List["NotificationChannel"] = betterproto.message_field(5)
    lookback: "TimeInterval" = betterproto.message_field(6)
    lookback_type: "LookbackType" = betterproto.enum_field(7)
    metric_creation_state: "MetricCreationState" = betterproto.enum_field(8)
    grain_seconds: int = betterproto.int32_field(9)
    muted_until_epoch_seconds: int = betterproto.int64_field(10)
    metric_group_overrides: List["MetricGroupOverride"] = betterproto.message_field(11)
    metric_schedule: "MetricSchedule" = betterproto.message_field(12)
    run_backfill: bool = betterproto.bool_field(13)
    collection_ids: List[int] = betterproto.int32_field(14)
    freshness_thresholds: List["Threshold"] = betterproto.message_field(15)
    volume_thresholds: List["Threshold"] = betterproto.message_field(16)
    owner_id: int = betterproto.int32_field(17)
    is_lookback_using_current_time: bool = betterproto.bool_field(18)
    dimension_id: int = betterproto.int32_field(19)


@dataclass
class MetricDeployMetricRequest(betterproto.Message):
    configuration: "MetricConfigurationWithSLAs" = betterproto.message_field(1)
    workflow_info: "WorkflowInfo" = betterproto.message_field(2)
    run_backfill: bool = betterproto.bool_field(3)
    run_all_metrics: bool = betterproto.bool_field(4)
    user_id: int = betterproto.int32_field(5)
    attempts: int = betterproto.int32_field(6)


@dataclass
class Empty(betterproto.Message):
    pass


@dataclass
class SetMetricSchedulingMechanismRequest(betterproto.Message):
    # To be removed in PLAT-1706
    company_id: int = betterproto.int32_field(1)
    scheduling_mechanism: "SchedulingMechanism" = betterproto.enum_field(2)


@dataclass
class WriteAgentQueryResultRequest(betterproto.Message):
    agent_uuid: str = betterproto.string_field(1)
    query_result: bytes = betterproto.bytes_field(2)
    company_uuid: str = betterproto.string_field(3)
    encryption_metadata: "EncryptionMetadata" = betterproto.message_field(4)


@dataclass
class WriteAgentQueryResultV2Request(betterproto.Message):
    query_result: bytes = betterproto.bytes_field(1)
    encryption_metadata: "EncryptionMetadata" = betterproto.message_field(2)


@dataclass
class McpGatewayAccessLogRequest(betterproto.Message):
    data_access_log: bytes = betterproto.bytes_field(1)
    encryption_metadata: "EncryptionMetadata" = betterproto.message_field(2)


@dataclass
class McpGatewayAccessLogResponse(betterproto.Message):
    key: str = betterproto.string_field(1)


@dataclass
class EncryptionMetadata(betterproto.Message):
    encryption_key: bytes = betterproto.bytes_field(1)
    signature: str = betterproto.string_field(2)
    encryption_version: str = betterproto.string_field(3)


@dataclass
class WriteAgentQueryResultResponse(betterproto.Message):
    key: str = betterproto.string_field(1)


@dataclass
class AgentHealthInfo(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    agent_health_status: "AgentHealthStatus" = betterproto.enum_field(2)
    last_heartbeat_latency_millis: int = betterproto.int64_field(3)
    last_heartbeat_sent_at: int = betterproto.int64_field(4)
    last_heartbeat_received_at: int = betterproto.int64_field(5)
    cross_source_agent_health_status: "AgentHealthStatus" = betterproto.enum_field(6)
    sensitive_data_agent_health_status: "AgentHealthStatus" = betterproto.enum_field(7)


@dataclass
class AgentHealthResponse(betterproto.Message):
    sources: List["AgentHealthInfo"] = betterproto.message_field(1)
    failures: List["FailedUpdate"] = betterproto.message_field(2)


@dataclass
class LineageSearchRequest(betterproto.Message):
    search: str = betterproto.string_field(1)
    limit: int = betterproto.int32_field(2)


@dataclass
class CatalogPath(betterproto.Message):
    source_name: str = betterproto.string_field(1)
    schema_name: str = betterproto.string_field(2)
    table_name: str = betterproto.string_field(3)
    column_name: str = betterproto.string_field(4)
    path_parts: List[str] = betterproto.string_field(5)


@dataclass
class LineageSearchResponse(betterproto.Message):
    results: List["LineageNodeV2"] = betterproto.message_field(1)


@dataclass
class MetricRevision(betterproto.Message):
    revision_info: "RevisionInfo" = betterproto.message_field(1)
    metric: "MetricConfiguration" = betterproto.message_field(2)
    collection_ids: List[int] = betterproto.int32_field(3)


@dataclass
class GetMetricRevisionsResponse(betterproto.Message):
    revisions: List["MetricRevision"] = betterproto.message_field(1)


@dataclass
class CustomRuleRevision(betterproto.Message):
    revision_info: "RevisionInfo" = betterproto.message_field(1)
    custom_rule: "CustomRule" = betterproto.message_field(2)


@dataclass
class GetCustomRuleRevisionsResponse(betterproto.Message):
    revisions: List["CustomRuleRevision"] = betterproto.message_field(1)


@dataclass
class CreateCustomRuleRequest(betterproto.Message):
    custom_rule: "CustomRule" = betterproto.message_field(1)


@dataclass
class CustomRule(betterproto.Message):
    name: str = betterproto.string_field(1)
    sql: str = betterproto.string_field(2)
    warehouse_id: int = betterproto.int32_field(3)
    threshold_type: "CustomRulesThresholdType" = betterproto.enum_field(4)
    upper_threshold: float = betterproto.double_field(5)
    lower_threshold: float = betterproto.double_field(6)
    collection_ids: List[int] = betterproto.int32_field(7)
    owner: "User" = betterproto.message_field(8)
    metric_schedule: "MetricSchedule" = betterproto.message_field(9)
    tags: List["Tag"] = betterproto.message_field(10)
    custom_rule_type: "CustomRuleType" = betterproto.enum_field(11)
    description: str = betterproto.string_field(12)
    join: "Join" = betterproto.message_field(13)
    join_type: "JoinType" = betterproto.enum_field(14)
    left_alias: str = betterproto.string_field(15)
    right_alias: str = betterproto.string_field(16)
    left_select_columns: List["IdAndDisplayName"] = betterproto.message_field(17)
    right_select_columns: List["IdAndDisplayName"] = betterproto.message_field(18)
    dimension: "IdAndDisplayName" = betterproto.message_field(19)
    profiling_suggestion_for_column: "IdAndDisplayName" = betterproto.message_field(20)
    profiling_suggestion_for_correlated_columns: "ColumnCorrelation" = (
        betterproto.message_field(21)
    )
    metric_observed_column_response: List["MetricObservedColumnResponse"] = (
        betterproto.message_field(22)
    )


@dataclass
class ColumnCorrelation(betterproto.Message):
    dataset_id: int = betterproto.int32_field(1)
    column_correlation_string: str = betterproto.string_field(2)


@dataclass
class CustomRuleInfo(betterproto.Message):
    id: int = betterproto.int32_field(1)
    custom_rule: "CustomRule" = betterproto.message_field(2)
    created_by: "User" = betterproto.message_field(3)
    created_at_epoch_seconds: int = betterproto.int64_field(4)
    updated_by: "User" = betterproto.message_field(5)
    updated_at_epoch_seconds: int = betterproto.int64_field(6)
    is_favorite: bool = betterproto.bool_field(7)
    latest_runs: List["MetricRun"] = betterproto.message_field(8)
    collections: List["IdAndDisplayName"] = betterproto.message_field(9)
    warehouse: "IdAndDisplayName" = betterproto.message_field(10)
    metric_id: int = betterproto.int32_field(11)


@dataclass
class UpdateCustomRuleRequest(betterproto.Message):
    id: int = betterproto.int32_field(1)
    custom_rule: "CustomRule" = betterproto.message_field(2)


@dataclass
class CustomRuleBulkRequest(betterproto.Message):
    where: "WhereClause" = betterproto.message_field(1)
    updates: List["UpdateCustomRuleRequest"] = betterproto.message_field(2)
    is_delete: bool = betterproto.bool_field(3)
    is_run: bool = betterproto.bool_field(4)
    add_to_collection: int = betterproto.int32_field(5)
    dimension_id: int = betterproto.int32_field(6)


@dataclass
class CustomRuleSortOption(betterproto.Message):
    sort_direction: "SortDirection" = betterproto.enum_field(1)
    sort_field: "CustomRuleSortField" = betterproto.enum_field(2)


@dataclass
class GetCustomRuleListRequest(betterproto.Message):
    search: str = betterproto.string_field(1)
    sort_option: List["CustomRuleSortOption"] = betterproto.message_field(2)
    page_size: int = betterproto.int32_field(3)
    page_cursor: str = betterproto.string_field(4)
    source_id: int = betterproto.int32_field(5)
    schema_id: int = betterproto.int32_field(6)
    table_id: int = betterproto.int32_field(7)
    column_id: int = betterproto.int32_field(8)
    collection_id: int = betterproto.int32_field(9)
    join_id: int = betterproto.int32_field(10)
    rule_types: List["CustomRuleType"] = betterproto.enum_field(11)
    dimension_ids: List[int] = betterproto.int32_field(12)
    workspace_id: int = betterproto.int32_field(13)
    tag_ids: List[int] = betterproto.int32_field(14)


@dataclass
class GetCustomRuleListResponse(betterproto.Message):
    custom_rules: List["CustomRuleInfo"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class SinglePathParamCustomRuleIdRequest(betterproto.Message):
    custom_rule_id: int = betterproto.int32_field(1)


@dataclass
class SinglePathParamJoinIdRequest(betterproto.Message):
    join_id: int = betterproto.int32_field(1)


@dataclass
class GetMetricObservedColumnBulkRequest(betterproto.Message):
    metric_ids: List[int] = betterproto.int32_field(1)
    column_ids: List[int] = betterproto.int32_field(2)
    table_ids: List[int] = betterproto.int32_field(3)
    schema_ids: List[int] = betterproto.int32_field(4)
    is_for_custom_rule: bool = betterproto.bool_field(5)
    remove_duplicate_metrics: bool = betterproto.bool_field(6)
    source_ids: List[int] = betterproto.int32_field(7)
    tag_ids: List[int] = betterproto.int32_field(8)


@dataclass
class MetricObservedColumnRequest(betterproto.Message):
    column_id: int = betterproto.int32_field(1)
    metric_id: int = betterproto.int32_field(2)
    comments: str = betterproto.string_field(3)


@dataclass
class DeleteMetricObservedColumnRequest(betterproto.Message):
    column_id: int = betterproto.int32_field(1)
    metric_id: int = betterproto.int32_field(2)


@dataclass
class MetricObservedColumnResponse(betterproto.Message):
    column: "ColumnWithTable" = betterproto.message_field(1)
    metric: "MetricInfo" = betterproto.message_field(2)
    comments: str = betterproto.string_field(3)
    entity_info: "EntityInfo" = betterproto.message_field(4)
    custom_rule: "CustomRuleInfo" = betterproto.message_field(5)


@dataclass
class MetricObservedColumnListResponse(betterproto.Message):
    metric_observed_columns: List["MetricObservedColumnResponse"] = (
        betterproto.message_field(1)
    )
    suggested_columns: List["ColumnWithTable"] = betterproto.message_field(2)


@dataclass
class JoinRuleObservedColumnDebugResponse(betterproto.Message):
    left_sql: str = betterproto.string_field(1)
    right_sql: str = betterproto.string_field(2)
    left_fields: List[str] = betterproto.string_field(3)
    right_fields: List[str] = betterproto.string_field(4)
    left_field_ids: List[int] = betterproto.int32_field(5)
    right_field_ids: List[int] = betterproto.int32_field(6)
    join_field_ids: List[int] = betterproto.int32_field(7)
    suggested_field_ids: List[int] = betterproto.int32_field(8)


@dataclass
class JoinColumnPairing(betterproto.Message):
    id: int = betterproto.int32_field(1)
    left_column: "TableColumn" = betterproto.message_field(2)
    right_column: "TableColumn" = betterproto.message_field(3)
    entity_info: "EntityInfo" = betterproto.message_field(4)


@dataclass
class RowCreationTimeFilter(betterproto.Message):
    rct_column: "IdAndDisplayName" = betterproto.message_field(1)
    lookback: "TimeInterval" = betterproto.message_field(2)


@dataclass
class JoinTableFilter(betterproto.Message):
    where_clause: str = betterproto.string_field(1, group="filter_option")
    rct_filter: "RowCreationTimeFilter" = betterproto.message_field(
        2, group="filter_option"
    )


@dataclass
class Join(betterproto.Message):
    id: int = betterproto.int32_field(1)
    left_table: "Table" = betterproto.message_field(2)
    right_table: "Table" = betterproto.message_field(3)
    key_columns: List["JoinColumnPairing"] = betterproto.message_field(4)
    entity_info: "EntityInfo" = betterproto.message_field(5)
    left_filter: "JoinTableFilter" = betterproto.message_field(6)
    right_filter: "JoinTableFilter" = betterproto.message_field(7)


@dataclass
class JoinColumnIdPairing(betterproto.Message):
    left_column_id: int = betterproto.int32_field(1)
    right_column_id: int = betterproto.int32_field(2)


@dataclass
class CreateOrUpdateJoinRequest(betterproto.Message):
    left_table_id: int = betterproto.int32_field(1)
    right_table_id: int = betterproto.int32_field(2)
    key_columns: List["JoinColumnIdPairing"] = betterproto.message_field(4)
    left_filter: "JoinTableFilter" = betterproto.message_field(5)
    right_filter: "JoinTableFilter" = betterproto.message_field(6)


@dataclass
class CreateOrUpdateJoinRequestWrapper(betterproto.Message):
    join_id: int = betterproto.int32_field(1)
    request: "CreateOrUpdateJoinRequest" = betterproto.message_field(2)


@dataclass
class CreateOrUpdateJoinResponse(betterproto.Message):
    join: "Join" = betterproto.message_field(1)


@dataclass
class JoinSortOption(betterproto.Message):
    sort_direction: "SortDirection" = betterproto.enum_field(1)
    sort_field: "JoinSortField" = betterproto.enum_field(2)


@dataclass
class GetJoinsRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    schema_id: int = betterproto.int32_field(2)
    table_id: int = betterproto.int32_field(3)
    column_id: int = betterproto.int32_field(4)
    search: str = betterproto.string_field(5)
    sort_option: List["JoinSortOption"] = betterproto.message_field(6)
    page_size: int = betterproto.int32_field(7)
    page_cursor: str = betterproto.string_field(8)


@dataclass
class GetJoinsResponse(betterproto.Message):
    joins: List["Join"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class SetRequiredPartitionColumnRequest(betterproto.Message):
    column_id: int = betterproto.int32_field(1)


@dataclass
class SetRequiredPartitionColumnResponse(betterproto.Message):
    dataset_id: int = betterproto.int32_field(1)
    required_partition_column_id: int = betterproto.int32_field(2)


@dataclass
class SetRequiredPartitionColumnRequestWrapper(betterproto.Message):
    table_id: int = betterproto.int32_field(1)
    request: "SetRequiredPartitionColumnRequest" = betterproto.message_field(2)


@dataclass
class SearchRequest(betterproto.Message):
    search: str = betterproto.string_field(1)
    types: List["SearchType"] = betterproto.message_field(2)
    limit: int = betterproto.int32_field(3)


@dataclass
class SearchResponse(betterproto.Message):
    results: List["SearchResult"] = betterproto.message_field(1)


@dataclass
class SearchResult(betterproto.Message):
    schema_node: "Schema" = betterproto.message_field(1, group="result")
    table_node: "Table" = betterproto.message_field(2, group="result")
    column_node: "ColumnWithTable" = betterproto.message_field(3, group="result")
    lineage_node: "LineageNodeV2" = betterproto.message_field(4, group="result")
    issue: "Issue" = betterproto.message_field(5, group="result")
    collection: "Collection" = betterproto.message_field(6, group="result")
    delta: "DeltaInfo" = betterproto.message_field(7, group="result")


@dataclass
class SearchType(betterproto.Message):
    system_search_type: "SystemSearchType" = betterproto.enum_field(1, group="type")
    data_node_type: "DataNodeType" = betterproto.enum_field(2, group="type")


@dataclass
class AvailableSearchTypesResponse(betterproto.Message):
    available_types: List["SearchType"] = betterproto.message_field(1)


@dataclass
class GetObjectOwnerRequest(betterproto.Message):
    """Request messages"""

    ownable_type: str = betterproto.string_field(1)
    ownable_id: int = betterproto.int32_field(2)


@dataclass
class DeleteObjectOwnerRequest(betterproto.Message):
    ownable_type: str = betterproto.string_field(1)
    ownable_id: int = betterproto.int32_field(2)


@dataclass
class Tag(betterproto.Message):
    """Tags"""

    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    # color_hex includes a # prefix (e.g. #181818 is correct, 181818 is
    # incorrect)
    color_hex: str = betterproto.string_field(3)
    workspace_id: int = betterproto.int32_field(4)
    created_at: int = betterproto.int64_field(5)
    updated_at: int = betterproto.int64_field(6)


@dataclass
class CreateOrUpdateTagRequest(betterproto.Message):
    tag: "Tag" = betterproto.message_field(1)


@dataclass
class CreateOrUpdateTagResponse(betterproto.Message):
    tag: "Tag" = betterproto.message_field(1)


@dataclass
class DeleteTagResponse(betterproto.Message):
    tag: "Tag" = betterproto.message_field(1)


@dataclass
class TagItem(betterproto.Message):
    entity_id: int = betterproto.int32_field(1)
    entity_type: "TaggableEntityType" = betterproto.enum_field(2)
    entity_name: str = betterproto.string_field(3)
    tag: str = betterproto.string_field(4)
    workspace_tag: "Tag" = betterproto.message_field(5)
    catalog_path: "CatalogPath" = betterproto.message_field(6)
    node_type: "NodeType" = betterproto.message_field(7)


@dataclass
class TagRequest(betterproto.Message):
    tag: "TagItem" = betterproto.message_field(1)
    create_tag_if_does_not_exist: bool = betterproto.bool_field(2)


@dataclass
class TagResponse(betterproto.Message):
    tag: "TagItem" = betterproto.message_field(1)


@dataclass
class UntagRequest(betterproto.Message):
    tag: "TagItem" = betterproto.message_field(1)


@dataclass
class UntagResponse(betterproto.Message):
    tag: "TagItem" = betterproto.message_field(1)


@dataclass
class GetTagItemRequest(betterproto.Message):
    tag_name: str = betterproto.string_field(1)
    workspace_id: int = betterproto.int32_field(2)


@dataclass
class GetTagItemResponse(betterproto.Message):
    tags: List["TagItem"] = betterproto.message_field(1)


@dataclass
class GetAllTagsRequest(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)
    page_size: int = betterproto.int32_field(2)
    page_cursor: str = betterproto.string_field(3)
    search: str = betterproto.string_field(4)
    sort_field: "TagSortField" = betterproto.enum_field(5)
    sort_direction: "SortDirection" = betterproto.enum_field(6)
    get_tagged_item_counts: bool = betterproto.bool_field(7)


@dataclass
class GetAllTagsResponse(betterproto.Message):
    tags: List["Tag"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)
    tagged_item_counts: Dict[int, int] = betterproto.map_field(
        3, betterproto.TYPE_INT32, betterproto.TYPE_INT32
    )


@dataclass
class TagList(betterproto.Message):
    entity_id: int = betterproto.int32_field(1)
    entity_type: "TaggableEntityType" = betterproto.enum_field(2)
    tags: List[str] = betterproto.string_field(4)


@dataclass
class GetTagRequest(betterproto.Message):
    entity_type: "TaggableEntityType" = betterproto.enum_field(1)
    entity_id: int = betterproto.int32_field(2)


@dataclass
class BulkTagRequest(betterproto.Message):
    tags: List["TagItem"] = betterproto.message_field(1)


@dataclass
class BulkTagResponse(betterproto.Message):
    successes: List["TagItem"] = betterproto.message_field(1)
    failures: List["TagFailure"] = betterproto.message_field(2)


@dataclass
class TagFailure(betterproto.Message):
    tag: "TagItem" = betterproto.message_field(1)
    reason: str = betterproto.string_field(2)


@dataclass
class TableProfile(betterproto.Message):
    """Data profiles"""

    table_id: int = betterproto.int32_field(1)
    sample_selection: "SampleSelection" = betterproto.message_field(2)
    requested_columns: List["IdAndDisplayName"] = betterproto.message_field(3)
    where_clause: str = betterproto.string_field(4)
    run_at: int = betterproto.int64_field(5)
    full_row_count: int = betterproto.int64_field(6)
    sample_row_count: int = betterproto.int32_field(7)
    full_column_count: int = betterproto.int32_field(8)
    column_profiles: List["ColumnProfile"] = betterproto.message_field(9)
    status: "TableProfileStatus" = betterproto.enum_field(10)
    exception_class: str = betterproto.string_field(11)
    exception_message: str = betterproto.string_field(12)
    execution_duration_seconds: int = betterproto.int32_field(13)
    table_level_suggested_monitors: List["SuggestedMonitor"] = (
        betterproto.message_field(14)
    )
    hit_oom_prevention_hard_cap: bool = betterproto.bool_field(15)
    hit_oom_prevention_soft_cap: bool = betterproto.bool_field(16)


@dataclass
class ColumnProfile(betterproto.Message):
    column_id: int = betterproto.int32_field(1)
    column_name: str = betterproto.string_field(2)
    type: str = betterproto.string_field(3)
    existing_metric_count: int = betterproto.int32_field(4)
    metric_profiles: List["MetricProfile"] = betterproto.message_field(5)
    patterns: List["ObservedPattern"] = betterproto.message_field(6)
    extended_type: str = betterproto.string_field(7)
    suggested_monitors: List["SuggestedMonitor"] = betterproto.message_field(8)


@dataclass
class MetricProfile(betterproto.Message):
    stats_name: "PredefinedMetricName" = betterproto.enum_field(1)
    observed_value: float = betterproto.double_field(2)


@dataclass
class ObservedPattern(betterproto.Message):
    stats_name: "PredefinedMetricName" = betterproto.enum_field(1)
    percent_match: float = betterproto.double_field(2)


@dataclass
class SuggestedMonitor(betterproto.Message):
    metric: "MetricConfiguration" = betterproto.message_field(1, group="monitor")
    sql_rule: "CustomRule" = betterproto.message_field(2, group="monitor")


@dataclass
class QueueTableProfileRequest(betterproto.Message):
    table_id: int = betterproto.int32_field(1)
    sample_selection: "SampleSelection" = betterproto.message_field(2)
    requested_columns: List["IdAndDisplayName"] = betterproto.message_field(3)
    where_clause: str = betterproto.string_field(4)
    user_id: int = betterproto.int32_field(5)


@dataclass
class SampleSelection(betterproto.Message):
    row_limit: int = betterproto.int32_field(1)
    sample_method: "SampleMethod" = betterproto.enum_field(2)


@dataclass
class GetTableProfileResponse(betterproto.Message):
    successful_profile: "TableProfile" = betterproto.message_field(1)
    failed_profile: "TableProfile" = betterproto.message_field(2)


@dataclass
class InstanceTypeWithCounts(betterproto.Message):
    instance_type: "DimensionInstanceType" = betterproto.enum_field(1)
    name: str = betterproto.string_field(2)
    is_override: bool = betterproto.bool_field(3)
    count: int = betterproto.int64_field(4)


@dataclass
class SinglePathParamDimensionIdRequest(betterproto.Message):
    dimension_id: int = betterproto.int32_field(1)


@dataclass
class UpsertDimensionRequestWrapper(betterproto.Message):
    dimension_id: int = betterproto.int32_field(1)
    request: "UpsertDimensionRequest" = betterproto.message_field(2)


@dataclass
class Dimension(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    top_level_category: "TopLevelCategory" = betterproto.enum_field(3)
    entity_info: "EntityInfo" = betterproto.message_field(4)
    instance_types_with_counts: List["InstanceTypeWithCounts"] = (
        betterproto.message_field(5)
    )
    description: str = betterproto.string_field(6)


@dataclass
class UpsertDimensionRequest(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    top_level_category: "TopLevelCategory" = betterproto.enum_field(3)
    description: str = betterproto.string_field(4)


@dataclass
class GetDimensionsListResponse(betterproto.Message):
    dimensions: List["Dimension"] = betterproto.message_field(1)


@dataclass
class StatDimension(betterproto.Message):
    id: int = betterproto.int32_field(1)
    stat_name: str = betterproto.string_field(2)
    dimension: "Dimension" = betterproto.message_field(3)
    comments: str = betterproto.string_field(4)
    entity_info: "EntityInfo" = betterproto.message_field(5)


@dataclass
class UpsertStatDimensionRequest(betterproto.Message):
    dimension_id: int = betterproto.int32_field(1)
    stat_name: str = betterproto.string_field(2)


@dataclass
class BulkMoveDimensionRequest(betterproto.Message):
    requests: List["MoveDimensionRequest"] = betterproto.message_field(1)


@dataclass
class MoveDimensionRequest(betterproto.Message):
    source_dimension_id: int = betterproto.int32_field(1)
    instance_type: "DimensionInstanceType" = betterproto.enum_field(2)
    name: str = betterproto.string_field(3)
    is_override: bool = betterproto.bool_field(4)
    target_dimension_id: int = betterproto.int32_field(5)


@dataclass
class AgentPasswordResponse(betterproto.Message):
    encrypted_password: str = betterproto.string_field(1)


@dataclass
class DimensionRevision(betterproto.Message):
    revision_info: "RevisionInfo" = betterproto.message_field(1)
    dimension: "Dimension" = betterproto.message_field(2)


@dataclass
class GetDimensionRevisionsResponse(betterproto.Message):
    revisions: List["DimensionRevision"] = betterproto.message_field(1)


@dataclass
class WorkspaceWithCountsRequest(betterproto.Message):
    dimension_id: int = betterproto.int32_field(1)
    instance_type: "DimensionInstanceType" = betterproto.enum_field(2)
    name: str = betterproto.string_field(3)


@dataclass
class WorkspaceWithCounts(betterproto.Message):
    workspace: "IdAndDisplayName" = betterproto.message_field(1)
    count: int = betterproto.int64_field(2)


@dataclass
class WorkspaceWithCountsResponse(betterproto.Message):
    counts_for_workspace: List["WorkspaceWithCounts"] = betterproto.message_field(1)


@dataclass
class TableColumns(betterproto.Message):
    table_name: str = betterproto.string_field(1)
    schema: str = betterproto.string_field(2)
    columns: List[str] = betterproto.string_field(3)


@dataclass
class SqlDataAccessLog(betterproto.Message):
    table_columns: List["TableColumns"] = betterproto.message_field(1)
    statement_type: "SqlStatementType" = betterproto.enum_field(2)
    success: bool = betterproto.bool_field(3)
    error_message: str = betterproto.string_field(4)
    timestamp: int = betterproto.int64_field(5)
    gateway_version: str = betterproto.string_field(6)
    agent_identifier: str = betterproto.string_field(7)
    mcp_server_name: str = betterproto.string_field(8)
    mcp_server_tool_name: str = betterproto.string_field(9)


@dataclass
class SqlParserRequest(betterproto.Message):
    warehouse_type: str = betterproto.string_field(1)
    sql_query: str = betterproto.string_field(2)
    include_non_select_columns: bool = betterproto.bool_field(3)


@dataclass
class SqlParserResponse(betterproto.Message):
    metacenter_json: str = betterproto.string_field(1)
    tables: List[str] = betterproto.string_field(2)
    columns: List[str] = betterproto.string_field(3)


@dataclass
class CreateOrUpdateScanJobRequest(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    description: str = betterproto.string_field(3)
    tables: List["TableToScan"] = betterproto.message_field(7)
    classifier_ids: List[int] = betterproto.int64_field(8)
    scan_type: "ScanType" = betterproto.enum_field(9)
    notification_channels: List["NotificationChannel"] = betterproto.message_field(10)
    incremental_scan_start_at: int = betterproto.int64_field(13)
    fraction_of_rows_to_sample: float = betterproto.double_field(14)
    minimum_sample_size_rows: int = betterproto.int32_field(15)
    schedule: "ScanSchedule" = betterproto.message_field(16)


@dataclass
class TableToScan(betterproto.Message):
    table_id: int = betterproto.int32_field(1)
    rct_column_id: int = betterproto.int32_field(2)
    partition_column_id: int = betterproto.int32_field(3)
    rct_watermark_epoch_seconds: int = betterproto.int64_field(4)
    schema_id: int = betterproto.int32_field(5)
    source_id: int = betterproto.int32_field(6)


@dataclass
class ScanJob(betterproto.Message):
    id: int = betterproto.int64_field(1)
    workspace_id: int = betterproto.int32_field(2)
    name: str = betterproto.string_field(3)
    description: str = betterproto.string_field(4)
    tables: List["TableToScan"] = betterproto.message_field(8)
    classifiers: List["IdAndDisplayName"] = betterproto.message_field(9)
    entity_info: "EntityInfo" = betterproto.message_field(10)
    latest_completed_scan_run: "ScanRun" = betterproto.message_field(11)
    in_progress_scan_run: "ScanRun" = betterproto.message_field(12)
    scan_type: "ScanType" = betterproto.enum_field(13)
    notification_channels: List["NotificationChannel"] = betterproto.message_field(14)
    incremental_scan_start_at: int = betterproto.int64_field(17)
    fraction_of_rows_to_sample: float = betterproto.double_field(18)
    minimum_sample_size_rows: int = betterproto.int32_field(19)
    status: "ScanJobStatus" = betterproto.enum_field(20)
    distinct_warehouses: List["Warehouse"] = betterproto.message_field(21)
    next_run_at: int = betterproto.int64_field(22)
    schedule: "ScanSchedule" = betterproto.message_field(23)


@dataclass
class GetScanJobListRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_options: List["ScanJobSortOption"] = betterproto.message_field(3)
    search: str = betterproto.string_field(4)
    workspace_id: int = betterproto.int32_field(5)
    warehouse_ids: List[int] = betterproto.int32_field(6)
    scan_types: List["ScanType"] = betterproto.enum_field(7)
    schedule_ids: List[int] = betterproto.int32_field(8)
    statuses: List["ScanJobStatus"] = betterproto.enum_field(9)
    include_warehouse_ids: bool = betterproto.bool_field(10)
    include_schema_ids: bool = betterproto.bool_field(11)
    include_table_ids: bool = betterproto.bool_field(12)
    include_classifiers: bool = betterproto.bool_field(13)
    include_notification_channels: bool = betterproto.bool_field(14)
    include_tables_to_rct_columns: bool = betterproto.bool_field(15)
    include_tables_to_partition_columns: bool = betterproto.bool_field(16)


@dataclass
class ScanJobSortOption(betterproto.Message):
    sort_direction: "SortDirection" = betterproto.enum_field(1)
    sort_field: "ScanJobSortField" = betterproto.enum_field(2)


@dataclass
class GetScanJobListResponse(betterproto.Message):
    scan_jobs: List["ScanJob"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class TerminateScanJobRequest(betterproto.Message):
    reason: str = betterproto.string_field(1)


@dataclass
class ScanRun(betterproto.Message):
    id: int = betterproto.int64_field(1)
    workspace_id: int = betterproto.int32_field(2)
    scan_job: "IdAndDisplayName" = betterproto.message_field(3)
    status: "ScanJobStatus" = betterproto.enum_field(4)
    error_message: str = betterproto.string_field(5)
    started_at: int = betterproto.int64_field(6)
    completed_at: int = betterproto.int64_field(7)
    rows_scanned: int = betterproto.int64_field(8)
    rows_matched: int = betterproto.int64_field(9)
    display_name: str = betterproto.string_field(10)
    scan_type: "ScanType" = betterproto.enum_field(11)
    schedule: "IdAndDisplayName" = betterproto.message_field(12)


@dataclass
class GetScanRunListRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_options: List["ScanRunSortOption"] = betterproto.message_field(3)
    search: str = betterproto.string_field(4)
    workspace_id: int = betterproto.int32_field(5)
    warehouse_ids: List[int] = betterproto.int32_field(6)
    scan_job_ids: List[int] = betterproto.int64_field(7)
    scan_types: List["ScanType"] = betterproto.enum_field(8)
    schedule_ids: List[int] = betterproto.int32_field(9)
    statuses: List["ScanJobStatus"] = betterproto.enum_field(10)


@dataclass
class ScanRunSortOption(betterproto.Message):
    sort_direction: "SortDirection" = betterproto.enum_field(1)
    sort_field: "ScanRunSortField" = betterproto.enum_field(2)


@dataclass
class GetScanRunListResponse(betterproto.Message):
    scan_runs: List["ScanRun"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GetScanFindingsRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_options: List["ScanFindingSortOption"] = betterproto.message_field(3)
    search: str = betterproto.string_field(4)
    workspace_id: int = betterproto.int32_field(5)
    scan_job_ids: List[int] = betterproto.int64_field(6)
    scan_run_ids: List[int] = betterproto.int64_field(7)
    source_ids: List[int] = betterproto.int32_field(8)
    schema_ids: List[int] = betterproto.int32_field(9)
    table_ids: List[int] = betterproto.int32_field(10)
    column_ids: List[int] = betterproto.int32_field(11)
    positive_or_negative_findings: "ThreeLeggedBoolean" = betterproto.enum_field(12)
    classifier_ids: List[int] = betterproto.int64_field(13)
    data_class_ids: List[int] = betterproto.int64_field(14)
    sensitivities: List["DataSensitivity"] = betterproto.enum_field(15)
    include_chunk_info: bool = betterproto.bool_field(16)


@dataclass
class ScanFindingSortOption(betterproto.Message):
    sort_direction: "SortDirection" = betterproto.enum_field(1)
    sort_field: "ScanFindingSortField" = betterproto.enum_field(2)


@dataclass
class GetScanFindingsResponse(betterproto.Message):
    findings: List["ScanFinding"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class ScanFinding(betterproto.Message):
    scan_job: "IdAndDisplayName" = betterproto.message_field(1)
    source: "IdAndDisplayName" = betterproto.message_field(2)
    schema: "IdAndDisplayName" = betterproto.message_field(3)
    table: "IdAndDisplayName" = betterproto.message_field(4)
    column: "IdAndDisplayName" = betterproto.message_field(5)
    classifier: "IdAndDisplayName" = betterproto.message_field(6)
    data_class: "DataClass" = betterproto.message_field(7)
    is_positive: bool = betterproto.bool_field(8)
    rows_scanned: int = betterproto.int64_field(9)
    rows_matched: int = betterproto.int64_field(10)
    is_column_deleted: bool = betterproto.bool_field(11)
    scan_run_id: int = betterproto.int64_field(12)
    earliest_scan_run_id: int = betterproto.int64_field(13)
    latest_scan_run_id: int = betterproto.int64_field(14)
    scan_type: "ScanType" = betterproto.enum_field(15)
    earliest_scan_table_finished_at: int = betterproto.int64_field(16)
    latest_scan_table_finished_at: int = betterproto.int64_field(17)
    chunk_infos: List["ScanFindingChunkInfo"] = betterproto.message_field(18)
    is_marked_for_reset_scan: bool = betterproto.bool_field(19)
    was_reset_scan: bool = betterproto.bool_field(20)


@dataclass
class ScanFindingChunkInfo(betterproto.Message):
    chunk_id: int = betterproto.int32_field(1)
    rows_scanned: int = betterproto.int64_field(2)
    rows_matched: int = betterproto.int64_field(3)
    agent_version: str = betterproto.string_field(4)
    query: str = betterproto.string_field(5)
    query_executed_at: int = betterproto.int64_field(6)


@dataclass
class BulkResetScanRequest(betterproto.Message):
    scan_job_id: int = betterproto.int64_field(1)
    requests: List["ResetScanRequest"] = betterproto.message_field(2)
    action: "ResetScanAction" = betterproto.enum_field(3)


@dataclass
class ResetScanRequest(betterproto.Message):
    column_id: int = betterproto.int32_field(1)


@dataclass
class BulkResetScanResponse(betterproto.Message):
    successes: List["ResetScanRequest"] = betterproto.message_field(1)
    failures: List["ResetScanFailure"] = betterproto.message_field(2)


@dataclass
class ResetScanFailure(betterproto.Message):
    request: "ResetScanRequest" = betterproto.message_field(1)
    reason: str = betterproto.string_field(2)


@dataclass
class CreateOrUpdateDataClassRequest(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    sensitivity: "DataSensitivity" = betterproto.enum_field(3)
    color_hex: str = betterproto.string_field(4)


@dataclass
class DataClass(betterproto.Message):
    id: int = betterproto.int64_field(1)
    workspace_id: int = betterproto.int32_field(2)
    name: str = betterproto.string_field(3)
    sensitivity: "DataSensitivity" = betterproto.enum_field(4)
    color_hex: str = betterproto.string_field(5)
    entity_info: "EntityInfo" = betterproto.message_field(6)
    created_by: "User" = betterproto.message_field(7)
    provided_by_bigeye: bool = betterproto.bool_field(8)
    can_reset_to_default: bool = betterproto.bool_field(9)
    number_of_classifiers: int = betterproto.int32_field(10)


@dataclass
class GetDataClassListRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_options: List["DataClassSortOption"] = betterproto.message_field(3)
    search: str = betterproto.string_field(4)
    workspace_id: int = betterproto.int32_field(5)
    sensitivities: List["DataSensitivity"] = betterproto.enum_field(6)
    creator_ids: List[int] = betterproto.int32_field(8)


@dataclass
class DataClassSortOption(betterproto.Message):
    sort_direction: "SortDirection" = betterproto.enum_field(1)
    sort_field: "DataClassSortField" = betterproto.enum_field(2)


@dataclass
class GetDataClassListResponse(betterproto.Message):
    data_classes: List["DataClass"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class CreateOrUpdateClassifierRequest(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    description: str = betterproto.string_field(3)
    detector: "Detector" = betterproto.message_field(4)
    data_class_id: int = betterproto.int64_field(5)


@dataclass
class Detector(betterproto.Message):
    compound_detector: "CompoundDetector" = betterproto.message_field(
        1, group="detector"
    )
    simple_detector: "SimpleDetector" = betterproto.message_field(2, group="detector")


@dataclass
class CompoundDetector(betterproto.Message):
    combinator: "DetectorCombinator" = betterproto.enum_field(1)
    detectors: List["Detector"] = betterproto.message_field(2)


@dataclass
class SimpleDetector(betterproto.Message):
    regex_detector: "RegexDetector" = betterproto.message_field(1, group="detector")
    machine_learning_detector: "MachineLearningDetector" = betterproto.message_field(
        2, group="detector"
    )


@dataclass
class MachineLearningDetector(betterproto.Message):
    detector: "Detector" = betterproto.enum_field(1)
    target: "DetectorTarget" = betterproto.enum_field(2)
    threshold: float = betterproto.double_field(3)
    display_name: str = betterproto.string_field(4)


@dataclass
class RegexDetector(betterproto.Message):
    regex: str = betterproto.string_field(1)
    target: "DetectorTarget" = betterproto.enum_field(2)


@dataclass
class Classifier(betterproto.Message):
    id: int = betterproto.int64_field(1)
    workspace_id: int = betterproto.int32_field(2)
    name: str = betterproto.string_field(3)
    description: str = betterproto.string_field(4)
    detector: "Detector" = betterproto.message_field(5)
    data_class: "DataClass" = betterproto.message_field(6)
    entity_info: "EntityInfo" = betterproto.message_field(7)
    created_by: "User" = betterproto.message_field(8)
    provided_by_bigeye: bool = betterproto.bool_field(9)
    can_reset_to_default: bool = betterproto.bool_field(10)
    number_of_scan_jobs: int = betterproto.int32_field(11)


@dataclass
class GetClassifierListRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    page_cursor: str = betterproto.string_field(2)
    sort_options: List["ClassifierSortOption"] = betterproto.message_field(3)
    search: str = betterproto.string_field(4)
    workspace_id: int = betterproto.int32_field(5)
    sensitivities: List["DataSensitivity"] = betterproto.enum_field(6)
    detector_types: List["SimpleDetector"] = betterproto.message_field(8)
    data_class_ids: List[int] = betterproto.int64_field(9)
    include_detector: bool = betterproto.bool_field(10)
    creator_ids: List[int] = betterproto.int32_field(11)


@dataclass
class ClassifierSortOption(betterproto.Message):
    sort_direction: "SortDirection" = betterproto.enum_field(1)
    sort_field: "ClassifierSortField" = betterproto.enum_field(2)


@dataclass
class GetClassifierListResponse(betterproto.Message):
    classifiers: List["Classifier"] = betterproto.message_field(1)
    pagination_info: "PaginationInfo" = betterproto.message_field(2)


@dataclass
class GetMachineLearningDetectorListRequest(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)


@dataclass
class GetMachineLearningDetectorListResponse(betterproto.Message):
    detectors: List["MachineLearningDetector"] = betterproto.message_field(1)


@dataclass
class TestDetectorRequest(betterproto.Message):
    workspace_id: int = betterproto.int32_field(1)
    detector: "SimpleDetector" = betterproto.message_field(2)
    value: str = betterproto.string_field(3)


@dataclass
class TestDetectorResponse(betterproto.Message):
    positive: bool = betterproto.bool_field(1)


@dataclass
class SensitiveDataUsageStats(betterproto.Message):
    total_bytes_capacity: int = betterproto.int64_field(1)
    total_bytes_used: int = betterproto.int64_field(2)


@dataclass
class PurchaseUsageRequest(betterproto.Message):
    usage_capacity: int = betterproto.int64_field(1)
    expire_at: int = betterproto.int64_field(2)


@dataclass
class PurchasedUsageResponse(betterproto.Message):
    id: int = betterproto.int64_field(1)
    usage_capacity: int = betterproto.int64_field(3)
    bytes_used: int = betterproto.int64_field(4)
    expire_at: int = betterproto.int64_field(5)
    created_at: int = betterproto.int64_field(6)


@dataclass
class UpdatePurchasedUsageRequest(betterproto.Message):
    usage_capacity: int = betterproto.int64_field(1)
    expire_at: int = betterproto.int64_field(2)


@dataclass
class BypassBillingQuotaRequest(betterproto.Message):
    bypass_billing_quota: bool = betterproto.bool_field(1)


@dataclass
class ExternalMonitorRunRequest(betterproto.Message):
    run_at_epoch_seconds: int = betterproto.int64_field(1)
    observed_value: float = betterproto.double_field(2)


@dataclass
class ReecryptEntityRequest(betterproto.Message):
    class_name: str = betterproto.string_field(1)
    id: int = betterproto.int32_field(2)


@dataclass
class MetricRunHistoryProviderRequest(betterproto.Message):
    metric_identifier: "MetricIdentifier" = betterproto.message_field(1)


@dataclass
class MetricConfigurationProviderRequest(betterproto.Message):
    metric_id: int = betterproto.int32_field(1)


@dataclass
class AutoThresholdRequestV2(betterproto.Message):
    monocle_model_request: "MonocleModelRequest" = betterproto.message_field(1)
    prediction_epoch_seconds: List[int] = betterproto.int32_field(2)
    force_online: bool = betterproto.bool_field(3)


@dataclass
class AutoThresholdResponse(betterproto.Message):
    auto_thresholds: List["AutoThreshold"] = betterproto.message_field(1)
    preamble_url_offline_training: str = betterproto.string_field(3)
    preamble_url_calculate_autothresholds: str = betterproto.string_field(4)


@dataclass
class TrainingPreamble(betterproto.Message):
    metric_run_history: "MetricRunHistory" = betterproto.message_field(1)
    metric_configuration: "MetricConfiguration" = betterproto.message_field(2)
    version_info: "VersionInfo" = betterproto.message_field(3)
    call_site: str = betterproto.string_field(4)
    backfill_enabled: bool = betterproto.bool_field(5)
    optimal_history_enabled: bool = betterproto.bool_field(6)
    allow_ets_for_freshness: bool = betterproto.bool_field(7)
    remove_extreme_values: bool = betterproto.bool_field(8)
    freshness_simple_seasonal: bool = betterproto.bool_field(9)
    simple_processing: bool = betterproto.bool_field(10)


@dataclass
class CalculateAutoThresholdV2Preamble(betterproto.Message):
    request: "AutoThresholdRequestV2" = betterproto.message_field(1)
    current_time: float = betterproto.double_field(2)
    model_url: str = betterproto.string_field(3)
    metric_configuration: "MetricConfiguration" = betterproto.message_field(4)
    retraining_period_hours: float = betterproto.double_field(5)
    metric_run_history: "MetricRunHistory" = betterproto.message_field(6)
    training_preamble: "TrainingPreamble" = betterproto.message_field(7)
    offline_training_enabled: bool = betterproto.bool_field(8)
    version_info: "VersionInfo" = betterproto.message_field(9)
    use_simple_thresholds: bool = betterproto.bool_field(10)
    inline_training: bool = betterproto.bool_field(11)


@dataclass
class MonocleModelRequest(betterproto.Message):
    metric_run_history_provider_request: "MetricRunHistoryProviderRequest" = (
        betterproto.message_field(1)
    )
    metric_configuration_provider_request: "MetricConfigurationProviderRequest" = (
        betterproto.message_field(2)
    )


@dataclass
class TrainingRequest(betterproto.Message):
    monocle_model_request: "MonocleModelRequest" = betterproto.message_field(1)
    retries: int = betterproto.int32_field(2)


@dataclass
class InvalidationRequest(betterproto.Message):
    monocle_model_request: "MonocleModelRequest" = betterproto.message_field(1)


@dataclass
class BulkInvalidationRequest(betterproto.Message):
    requests: List["InvalidationRequest"] = betterproto.message_field(1)


@dataclass
class MetricRunWorkflowContext(betterproto.Message):
    metrics: "MetricPartition" = betterproto.message_field(1)
    collection_queue: str = betterproto.string_field(2)


@dataclass
class MetricPartition(betterproto.Message):
    metric_ids: List[int] = betterproto.int32_field(1)
    collection_queue: str = betterproto.string_field(2)


@dataclass
class MetricPartitions(betterproto.Message):
    partitions: List["MetricPartition"] = betterproto.message_field(1)


@dataclass
class JdbcInfo(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    source_name: str = betterproto.string_field(2)
    source_type: str = betterproto.string_field(3)


@dataclass
class SqlQueryContext(betterproto.Message):
    sql: List[str] = betterproto.string_field(1)
    jdbc_info: "JdbcInfo" = betterproto.message_field(2)
    receiver: str = betterproto.string_field(3)
    is_outbound: bool = betterproto.bool_field(4)
    workspace_id: int = betterproto.int32_field(5)
    agent_uuid: str = betterproto.string_field(6)
    catalog: str = betterproto.string_field(7)


@dataclass
class SqlQueryResponse(betterproto.Message):
    results: List["QueryResult"] = betterproto.message_field(1)
    size: int = betterproto.int64_field(2)
    version: str = betterproto.string_field(3)
    database_name: str = betterproto.string_field(4)
    timeout_seconds: int = betterproto.int32_field(5)
    query_project_ids: List[str] = betterproto.string_field(6)
    bigquery_project_id: str = betterproto.string_field(7)
    agent_uuid: str = betterproto.string_field(8)
    response_key: str = betterproto.string_field(9)
    company_uuid: str = betterproto.string_field(10)
    encryption_metadata: "EncryptionMetadata" = betterproto.message_field(11)
    compressed: bool = betterproto.bool_field(12)
    byte_encoded: bool = betterproto.bool_field(13)


@dataclass
class QueryResult(betterproto.Message):
    error: "QueryError" = betterproto.message_field(1)
    col_names: List[str] = betterproto.string_field(2)
    col_types: List[str] = betterproto.string_field(3)
    row_data: List["RowData"] = betterproto.message_field(4)
    conn_time_ms: int = betterproto.int32_field(5)
    exec_time_ms: int = betterproto.int32_field(6)
    col_type_ids: List[int] = betterproto.int32_field(7)
    col_sizes: List[int] = betterproto.int64_field(8)
    col_precisions: List[int] = betterproto.int32_field(9)
    col_scales: List[int] = betterproto.int32_field(10)


@dataclass
class QueryError(betterproto.Message):
    class_: str = betterproto.string_field(1)
    message: str = betterproto.string_field(2)
    type: "QueryErrorType" = betterproto.enum_field(3)


@dataclass
class WorkflowError(betterproto.Message):
    class_: str = betterproto.string_field(1)
    message: str = betterproto.string_field(2)


@dataclass
class RowData(betterproto.Message):
    cells: List["StringValue"] = betterproto.message_field(1)


@dataclass
class MetricRunPostProcessResult(betterproto.Message):
    results: List["MetricRunSummary"] = betterproto.message_field(1)


@dataclass
class MetricRunSummary(betterproto.Message):
    metric_id: int = betterproto.int32_field(1)
    metric_run_id: int = betterproto.int64_field(2)
    status: int = betterproto.int32_field(3)


@dataclass
class StringValue(betterproto.Message):
    value: str = betterproto.string_field(1)
    is_null: bool = betterproto.bool_field(2)


@dataclass
class SqlCollectionContext(betterproto.Message):
    collection_queue: str = betterproto.string_field(1)
    context: "SqlQueryContext" = betterproto.message_field(2)


@dataclass
class RowLevelDeltaContext(betterproto.Message):
    collection_queue: str = betterproto.string_field(1)
    delta: "Delta" = betterproto.message_field(2)
    source_jdbc_info: "JdbcInfo" = betterproto.message_field(3)
    target_jdbc_info: "JdbcInfo" = betterproto.message_field(4)
    workspace_id: int = betterproto.int32_field(5)
    agent_uuid: str = betterproto.string_field(6)
    is_outbound: bool = betterproto.bool_field(7)


@dataclass
class RowLevelDeltaResponse(betterproto.Message):
    delta_id: int = betterproto.int32_field(1)
    target_info: "DeltaTargetInfo" = betterproto.message_field(2)
    error: str = betterproto.string_field(3)


@dataclass
class SqlMetadataContext(betterproto.Message):
    collection_queue: str = betterproto.string_field(1)
    metadata_operation: "MetadataOperation" = betterproto.enum_field(2)
    jdbc_info: "JdbcInfo" = betterproto.message_field(3)
    table_name: str = betterproto.string_field(5)
    company_id: str = betterproto.string_field(6)
    is_outbound: bool = betterproto.bool_field(7)
    schema_name: str = betterproto.string_field(8)
    workspace_id: int = betterproto.int32_field(9)
    agent_uuid: str = betterproto.string_field(10)


@dataclass
class TriggerBatchMetricRunResponse(betterproto.Message):
    successful_requests: List["BatchRunMetricsRequest"] = betterproto.message_field(1)
    failed_requests: List["FailedBatchMetricRun"] = betterproto.message_field(2)


@dataclass
class FailedBatchMetricRun(betterproto.Message):
    request: "BatchRunMetricsRequest" = betterproto.message_field(1)
    status_code: int = betterproto.int32_field(2)


@dataclass
class AgentSource(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    heartbeat_queue_name: str = betterproto.string_field(2)


@dataclass
class AgentHeartbeatRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    sent_at_epoch_millis: int = betterproto.int64_field(2)
    receiver: str = betterproto.string_field(3)
    is_outbound: bool = betterproto.bool_field(4)


@dataclass
class AgentHeartbeatResponse(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    request_sent_at_epoch_millis: int = betterproto.int64_field(2)
    response_sent_at_epoch_millis: int = betterproto.int64_field(3)
    version: str = betterproto.string_field(4)


@dataclass
class AgentHeartbeatV2Source(betterproto.Message):
    name: str = betterproto.string_field(1)
    allowed_workspaces: List[int] = betterproto.int32_field(2)
    max_concurrent_activities: int = betterproto.int32_field(3)
    max_concurrent_interactive_activities: int = betterproto.int32_field(4)
    max_concurrent_activity_task_pollers: int = betterproto.int32_field(5)
    max_concurrent_interactive_activity_task_pollers: int = betterproto.int32_field(6)


@dataclass
class AgentHeartbeatV2Payload(betterproto.Message):
    company_uuid: str = betterproto.string_field(1)
    sources: List["AgentHeartbeatV2Source"] = betterproto.message_field(2)
    sent_at_epoch_millis: int = betterproto.int64_field(3)
    version: str = betterproto.string_field(4)
    agent_type: "AgentType" = betterproto.enum_field(5)
    encryption_enabled: bool = betterproto.bool_field(6)
    signature: str = betterproto.string_field(7)
    in_progress_activity_details: Dict[str, "InProgressActivityDetails"] = (
        betterproto.map_field(8, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE)
    )
    worker_id: str = betterproto.string_field(9)


@dataclass
class InProgressActivityDetails(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    task_queue: str = betterproto.string_field(2)


@dataclass
class GatherLineageForMetaCenterMetadataRequest(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)
    repository_offset: int = betterproto.int32_field(2)
    metadata_offset: int = betterproto.int32_field(3)


@dataclass
class GatherMetaCenterRepositoriesRequest(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)
    repository_uid: str = betterproto.string_field(2)


@dataclass
class GatherMetaCenterMetadataFromRepositoryRequest(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)
    repository_offset: int = betterproto.int32_field(2)


@dataclass
class GatherLineageForSourceRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)


@dataclass
class GatherLineageForSchemaRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    schema_start: int = betterproto.int32_field(2)
    schema_end: int = betterproto.int32_field(3)


@dataclass
class GatherLineageForTableRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    schema_offset: int = betterproto.int32_field(2)
    table_start: int = betterproto.int32_field(3)
    table_end: int = betterproto.int32_field(4)


@dataclass
class GetSchemaIdsForSourceRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)


@dataclass
class GetSchemaIdsForSourceResponse(betterproto.Message):
    schema_count: int = betterproto.int32_field(1)


@dataclass
class GetTableIdsForSchemaRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    schema_offset: int = betterproto.int32_field(2)


@dataclass
class GetTableIdsForSchemaResponse(betterproto.Message):
    table_count: int = betterproto.int32_field(1)


@dataclass
class ComputeLineageForSchemaRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    schema_offset: int = betterproto.int32_field(2)


@dataclass
class ComputeLineageForTableRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)
    schema_offset: int = betterproto.int32_field(2)
    table_offset: int = betterproto.int32_field(3)


@dataclass
class ComputeLineageForSourceFromQueryRequest(betterproto.Message):
    source_id: int = betterproto.int32_field(1)


@dataclass
class MetaCenterIntegration(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)


@dataclass
class MetaCenterLineageGatherRequest(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)
    min_parallelism: int = betterproto.int32_field(2)
    max_batch_size: int = betterproto.int32_field(3)
    repository_uid: str = betterproto.string_field(4)
    use_v2_algorithm: bool = betterproto.bool_field(5)


@dataclass
class PopularityScoreRequest(betterproto.Message):
    warehouse_id: int = betterproto.int32_field(1)


@dataclass
class PrePopularityScoreCalculationResponse(betterproto.Message):
    requires_calculation: bool = betterproto.bool_field(1)
    existing_score_detail_ids: List[int] = betterproto.int32_field(2)
    current_score_detail_ids: List[int] = betterproto.int32_field(3)


@dataclass
class UpdatePopularityScoreDetailsRequest(betterproto.Message):
    warehouse_id: int = betterproto.int32_field(1)
    existing_score_detail_ids: List[int] = betterproto.int32_field(2)
    current_score_detail_ids: List[int] = betterproto.int32_field(3)


@dataclass
class UpdatePopularityScoreDetailsResponse(betterproto.Message):
    total_queries: int = betterproto.int32_field(1)
    max_query_count: int = betterproto.int32_field(2)
    dataset_update_batch_request_s3_keys: List[str] = betterproto.string_field(3)


@dataclass
class UpdateDatasetPopularityRequest(betterproto.Message):
    dataset_id: int = betterproto.int32_field(1)
    popularity_score_details_id: int = betterproto.int32_field(2)


@dataclass
class UpdateSchemaPopularityRequest(betterproto.Message):
    schema_id: int = betterproto.int32_field(1)
    current_query_counts: int = betterproto.int32_field(2)
    total_query_counts: int = betterproto.int32_field(3)
    current_period_start_seconds: int = betterproto.int32_field(4)
    current_period_end_seconds: int = betterproto.int32_field(5)


@dataclass
class UpdateSchemaPopularityBatchRequest(betterproto.Message):
    updates: List["UpdateSchemaPopularityRequest"] = betterproto.message_field(1)
    total_queries: int = betterproto.int32_field(2)
    max_query_count_among_schemas: int = betterproto.int32_field(3)


@dataclass
class UpdateDatasetPopularityResponse(betterproto.Message):
    schema_query_counts: List["SchemaQueryCount"] = betterproto.message_field(1)


@dataclass
class SchemaQueryCount(betterproto.Message):
    schema_id: int = betterproto.int32_field(1)
    current_query_count: int = betterproto.int32_field(2)
    total_query_count: int = betterproto.int32_field(3)


@dataclass
class UpdateDatasetPopularityBatchRequest(betterproto.Message):
    dataset_update_requests: List["UpdateDatasetPopularityRequest"] = (
        betterproto.message_field(3)
    )


@dataclass
class MetaCenterRepositoryRange(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)
    repository_start: int = betterproto.int32_field(2)
    repository_end: int = betterproto.int32_field(3)
    use_v2_algorithm: bool = betterproto.bool_field(5)


@dataclass
class MetaCenterSingleRepository(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)
    repository_offset: int = betterproto.int32_field(2)
    repository_uid: str = betterproto.string_field(3)


@dataclass
class MetaCenterMetadataCopyRequest(betterproto.Message):
    integration_id: int = betterproto.int32_field(1)
    repository_uid: str = betterproto.string_field(2)


@dataclass
class MetaCenterParallelLineagePrepRequest(betterproto.Message):
    repository: "MetaCenterSingleRepository" = betterproto.message_field(1)
    parallelism: int = betterproto.int32_field(2)


@dataclass
class MetaCenterParallelLineageFetchRequest(betterproto.Message):
    repository: "MetaCenterSingleRepository" = betterproto.message_field(1)
    s3_key_for_metadata_results_to_process: str = betterproto.string_field(2)
    all_s3_keys_for_metadata_results: List[str] = betterproto.string_field(3)


@dataclass
class MetaCenterParallelLineageReconcileRequest(betterproto.Message):
    repository: "MetaCenterSingleRepository" = betterproto.message_field(1)
    s3_keys_for_lineage_results: List[str] = betterproto.string_field(2)


@dataclass
class MetaCenterParallelLineageCleanupRequest(betterproto.Message):
    s3_keys_to_delete: List[str] = betterproto.string_field(1)


@dataclass
class RefreshWarehouseScorecardsRequest(betterproto.Message):
    warehouse_id: int = betterproto.int32_field(1)


@dataclass
class RefreshSchemaScorecardsRequest(betterproto.Message):
    warehouse_id: int = betterproto.int32_field(1)
    schema_id: int = betterproto.int32_field(2)


@dataclass
class RefreshTableScorecardsRequest(betterproto.Message):
    warehouse_id: int = betterproto.int32_field(1)
    schema_id: int = betterproto.int32_field(2)
    table_id: int = betterproto.int32_field(3)


@dataclass
class DeleteScheduleWorkflowRequest(betterproto.Message):
    schedule_id: str = betterproto.string_field(1)


@dataclass
class RunMetricsRequest(betterproto.Message):
    metrics: "BatchRunMetricsRequest" = betterproto.message_field(1)
    user_id: int = betterproto.int32_field(2)


@dataclass
class SchemaVisRequest(betterproto.Message):
    entity_type: "CatalogEntityType" = betterproto.enum_field(1)
    entity_id: int = betterproto.int32_field(2)
    operation: "VisibilityOperation" = betterproto.enum_field(3)
    user_id: int = betterproto.int32_field(4)


@dataclass
class GenerateTableProfileRequest(betterproto.Message):
    queue_request: "QueueTableProfileRequest" = betterproto.message_field(1)
    full_row_count_query: str = betterproto.string_field(2)
    full_row_count_result_set_column_name: str = betterproto.string_field(3)
    full_column_count: int = betterproto.int32_field(4)
    sample_query: str = betterproto.string_field(5)
    columns_to_profile: List["ColumnToProfile"] = betterproto.message_field(6)
    is_agent: bool = betterproto.bool_field(7)
    is_outbound: bool = betterproto.bool_field(8)
    agent_queue_name: str = betterproto.string_field(9)
    jdbc_info: "JdbcInfo" = betterproto.message_field(10)
    workspace_id: int = betterproto.int32_field(11)
    minimum_sample_size: int = betterproto.int32_field(12)
    warehouse_type: str = betterproto.string_field(13)
    outliers_z_score_threshold: float = betterproto.double_field(14)
    normal_regex_string_too_long: int = betterproto.int32_field(15)
    simple_regex_string_too_long: int = betterproto.int32_field(16)
    threshold_top_pattern_pct_match: float = betterproto.double_field(17)
    workflow_timeout_seconds: int = betterproto.int64_field(18)
    oom_prevention_hard_cap_row_count: int = betterproto.int32_field(19)
    oom_prevention_soft_cap_pct_memory: float = betterproto.double_field(20)
    sample_query_limit: int = betterproto.int32_field(21)
    from_clause_has_table_sample: bool = betterproto.bool_field(22)
    where_clause_has_hash_mod: bool = betterproto.bool_field(23)
    num_sample_rows_to_return: int = betterproto.int32_field(24)


@dataclass
class ColumnToProfile(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    result_set_column_name: str = betterproto.string_field(3)
    stats_to_profile: List["StatToProfile"] = betterproto.message_field(4)
    potential_patterns: List["StatToProfile"] = betterproto.message_field(5)
    should_compute_min_max_avg_extra_fields: bool = betterproto.bool_field(6)


@dataclass
class StatToProfile(betterproto.Message):
    name: "PredefinedMetricName" = betterproto.enum_field(1)
    parameters: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass
class GenerateTableProfileResponse(betterproto.Message):
    """
    These are parallel to the [Table|Column|Metric]Profile and ObservedPattern
    types to allow extra internal-only fields. Originally created for
    GenerateColumnProfileResponse for mean, standard_deviation, num_outliers,
    and observed_regex.
    """

    table_profile: "TableProfile" = betterproto.message_field(1)
    column_profiles: List["GenerateColumnProfileResponse"] = betterproto.message_field(
        2
    )
    sample_rows: "GetPreviewResponse" = betterproto.message_field(3)
    hit_oom_prevention_hard_cap: bool = betterproto.bool_field(4)
    hit_oom_prevention_soft_cap: bool = betterproto.bool_field(5)


@dataclass
class GenerateColumnProfileResponse(betterproto.Message):
    column_profile: "ColumnProfile" = betterproto.message_field(1)
    metric_profiles: List["GenerateMetricProfileResponse"] = betterproto.message_field(
        2
    )
    patterns: List["GenerateObservedPatternResponse"] = betterproto.message_field(3)
    mean: float = betterproto.double_field(4)
    standard_deviation: float = betterproto.double_field(5)
    num_outliers: int = betterproto.int32_field(6)
    observed_regex: "ObservedRegex" = betterproto.message_field(7)


@dataclass
class ObservedRegex(betterproto.Message):
    regex: str = betterproto.string_field(1)
    percent_match: float = betterproto.double_field(2)


@dataclass
class GenerateMetricProfileResponse(betterproto.Message):
    metric_profile: "MetricProfile" = betterproto.message_field(1)


@dataclass
class GenerateObservedPatternResponse(betterproto.Message):
    observed_pattern: "ObservedPattern" = betterproto.message_field(1)


@dataclass
class RunJoinRuleRequest(betterproto.Message):
    # Represents a single request from Datawatch to the agent, to run a batch of
    # join rules in one activity. Initially the join rules will not be batched,
    # so join_conditions will be a singleton-list for now.
    fetch_left: "JoinRuleFetchSql" = betterproto.message_field(1)
    fetch_right: "JoinRuleFetchSql" = betterproto.message_field(2)
    key_columns: List["JoinColumnNamePairing"] = betterproto.message_field(3)
    join_conditions: List["JoinRuleJoinCondition"] = betterproto.message_field(4)
    user_id: int = betterproto.int32_field(5)
    is_outbound: bool = betterproto.bool_field(6)
    collection_queue: str = betterproto.string_field(7)
    workspace_id: int = betterproto.int32_field(8)
    left_select_columns: List[str] = betterproto.string_field(9)
    right_select_columns: List[str] = betterproto.string_field(10)


@dataclass
class JoinRuleFetchSql(betterproto.Message):
    source: "JdbcInfo" = betterproto.message_field(1)
    sql: str = betterproto.string_field(2)
    alias: str = betterproto.string_field(3)


@dataclass
class JoinColumnNamePairing(betterproto.Message):
    left_column_name: str = betterproto.string_field(1)
    right_column_name: str = betterproto.string_field(2)


@dataclass
class JoinRuleJoinCondition(betterproto.Message):
    rule_id: int = betterproto.int32_field(1)
    join_type: "JoinType" = betterproto.enum_field(2)
    where_clause: str = betterproto.string_field(3)


@dataclass
class RunJoinRuleResponse(betterproto.Message):
    query_error: "QueryError" = betterproto.message_field(1)
    results: List["RunSingleJoinRuleResult"] = betterproto.message_field(2)


@dataclass
class RunSingleJoinRuleResult(betterproto.Message):
    rule_id: int = betterproto.int32_field(1)
    rows_scanned: int = betterproto.int64_field(2)
    rows_matched: int = betterproto.int64_field(3)


@dataclass
class DebugPreviewJoinRuleRequest(betterproto.Message):
    run_request: "RunJoinRuleRequest" = betterproto.message_field(1)
    row_count_limit: int = betterproto.int32_field(2)
    should_retrieve_affected_row_count: bool = betterproto.bool_field(3)
    agent_uuid: str = betterproto.string_field(4)


@dataclass
class DebugPreviewJoinRuleResponse(betterproto.Message):
    query_error: "QueryError" = betterproto.message_field(1)
    response: "GetPreviewResponse" = betterproto.message_field(2)
    large_payload_metadata: "AgentLargePayloadMetadata" = betterproto.message_field(3)


@dataclass
class AgentLargePayloadMetadata(betterproto.Message):
    agent_uuid: str = betterproto.string_field(1)
    response_key: str = betterproto.string_field(2)
    company_uuid: str = betterproto.string_field(3)
    encryption_metadata: "EncryptionMetadata" = betterproto.message_field(4)
    compressed: bool = betterproto.bool_field(5)
    byte_encoded: bool = betterproto.bool_field(6)


@dataclass
class ScanJobRequest(betterproto.Message):
    # Scan jobs can run for many days. It's important to have consistent behavior
    # using the configuration values from the start of the scan job.
    scan_job_id: int = betterproto.int64_field(1)
    invoking_user: int = betterproto.int32_field(2)


@dataclass
class ScanJobResponse(betterproto.Message):
    scan_run_id: int = betterproto.int64_field(1)
    successful_table_ids: List[int] = betterproto.int32_field(2)
    failed_tables: List["FailedUpdate"] = betterproto.message_field(3)
    bytes_scanned: int = betterproto.int64_field(4)
    invoking_user: int = betterproto.int32_field(5)


@dataclass
class CreateScanRunResponse(betterproto.Message):
    scan_run_id: int = betterproto.int64_field(1)
    tables_to_scan: List["ScanTableRequest"] = betterproto.message_field(2)
    parallelism_for_tables: int = betterproto.int32_field(3)
    error: str = betterproto.string_field(4)


@dataclass
class ScanTableRequest(betterproto.Message):
    scan_run_id: int = betterproto.int64_field(1)
    warehouse: "IdAndDisplayName" = betterproto.message_field(2)
    schema: "IdAndDisplayName" = betterproto.message_field(3)
    table: "ScanTableRequestTableDetails" = betterproto.message_field(4)
    columns: List["ScanTableRequestColumnDetails"] = betterproto.message_field(5)
    classifiers: List["Classifier"] = betterproto.message_field(6)
    invoking_user: int = betterproto.int32_field(7)
    scan_run_table_id: int = betterproto.int64_field(8)
    scan_type: "ScanType" = betterproto.enum_field(9)
    incremental_scan_start_at: int = betterproto.int64_field(10)


@dataclass
class ScanTableRequestTableDetails(betterproto.Message):
    id: int = betterproto.int32_field(1)
    display_name: str = betterproto.string_field(2)
    rct_column_id: int = betterproto.int32_field(3)
    watermark_epoch_seconds: int = betterproto.int64_field(4)


@dataclass
class ScanTableRequestColumnDetails(betterproto.Message):
    id: int = betterproto.int32_field(1)
    display_name: str = betterproto.string_field(2)
    needs_full_scan: bool = betterproto.bool_field(3)


@dataclass
class ScanTableResponse(betterproto.Message):
    table: "ScanTableRequestTableDetails" = betterproto.message_field(1)
    success: bool = betterproto.bool_field(2)
    error_message: str = betterproto.string_field(3)
    bytes_scanned: int = betterproto.int64_field(4)


@dataclass
class SplitResponse(betterproto.Message):
    chunks: List["ScanChunkRequest"] = betterproto.message_field(1)
    new_watermark_epoch_seconds: int = betterproto.int64_field(2)


@dataclass
class ScanChunkRequest(betterproto.Message):
    scan_run_id: int = betterproto.int64_field(1)
    is_outbound: bool = betterproto.bool_field(2)
    agent_queue_name: str = betterproto.string_field(3)
    workspace_id: int = betterproto.int32_field(4)
    source: "JdbcInfo" = betterproto.message_field(5)
    chunk_id: int = betterproto.int32_field(6)
    classifiers: List["Classifier"] = betterproto.message_field(7)
    query: str = betterproto.string_field(8)
    columns: List["IdAndDisplayName"] = betterproto.message_field(9)
    scan_run_chunk_id: int = betterproto.int64_field(10)


@dataclass
class ScanChunkResponse(betterproto.Message):
    chunk_id: int = betterproto.int32_field(1)
    success: bool = betterproto.bool_field(2)
    error: "QueryError" = betterproto.message_field(3)
    rows_scanned: int = betterproto.int64_field(4)
    findings: List["Finding"] = betterproto.message_field(5)
    bytes_scanned: int = betterproto.int64_field(6)
    agent_version: str = betterproto.string_field(7)
    query_executed_at: int = betterproto.int64_field(8)


@dataclass
class Finding(betterproto.Message):
    column_id: int = betterproto.int32_field(1)
    classifier_id: int = betterproto.int64_field(2)
    rows_matched: int = betterproto.int64_field(3)
    scan_chunk_snapshot_finding_id: int = betterproto.int64_field(4)


@dataclass
class PersistTableFindingsRequest(betterproto.Message):
    table_request: "ScanTableRequest" = betterproto.message_field(1)
    chunk_responses: List["ScanChunkResponse"] = betterproto.message_field(2)
    new_watermark_epoch_seconds: int = betterproto.int64_field(3)
    invoking_user: int = betterproto.int32_field(4)


@dataclass
class RetryScanJobRequest(betterproto.Message):
    scan_run_id: int = betterproto.int64_field(1)
    invoking_user: int = betterproto.int32_field(2)


@dataclass
class RetryScanTableRequest(betterproto.Message):
    scan_run_table_id: int = betterproto.int64_field(1)


@dataclass
class RetryChunksInfo(betterproto.Message):
    failed_chunks: List["ScanChunkRequest"] = betterproto.message_field(1)
    parallelism_for_chunks: int = betterproto.int32_field(2)
    has_chunks: bool = betterproto.bool_field(3)


@dataclass
class RetryTablesInfo(betterproto.Message):
    failed_tables: List["ScanTableRequest"] = betterproto.message_field(1)
    parallelism_for_tables: int = betterproto.int32_field(2)
    has_tables: bool = betterproto.bool_field(3)


@dataclass
class TentativeTableSplitStrategy(betterproto.Message):
    strategy: "TableSplitStrategy" = betterproto.enum_field(1)
    column: "IdAndDisplayName" = betterproto.message_field(2)
    secondary_hash_mod_column: "IdAndDisplayName" = betterproto.message_field(3)
    query_for_agent: "SqlCollectionContext" = betterproto.message_field(4)


@dataclass
class AgentTestDetectorRequest(betterproto.Message):
    detector: "SimpleDetector" = betterproto.message_field(1)
    value: str = betterproto.string_field(2)
    agent_queue_name: str = betterproto.string_field(3)
    is_outbound: bool = betterproto.bool_field(4)


@dataclass
class ScanJobBatchInfoRequest(betterproto.Message):
    batch_job: "RunScanJobBatchJob" = betterproto.message_field(1)
    workflow_trigger_epoch_seconds: int = betterproto.int64_field(2)


@dataclass
class ScanJobSearchAttributesRequest(betterproto.Message):
    id: int = betterproto.int64_field(1)


@dataclass
class ScanJobBatchInfo(betterproto.Message):
    int_list: "IntList" = betterproto.message_field(1, group="ids")
    s3_list: "S3List" = betterproto.message_field(2, group="ids")
    parallelism: int = betterproto.int32_field(3)


@dataclass
class IntList(betterproto.Message):
    items: List[int] = betterproto.int64_field(1)


@dataclass
class S3List(betterproto.Message):
    path: str = betterproto.string_field(1)
    length: int = betterproto.int32_field(2)


@dataclass
class SearchAttributesDefinition(betterproto.Message):
    company_id: int = betterproto.int64_field(1)
    workspace_id: int = betterproto.int64_field(2)
    warehouse_id: int = betterproto.int64_field(3)


class MetricServiceStub(betterproto.ServiceStub):
    """Metrics"""

    async def search_metric_configuration(
        self,
        *,
        ids: List[int] = [],
        warehouse_ids: List[int] = [],
        table_ids: List[int] = [],
        table_name: str = "",
        status: str = "",
        muted: bool = False,
    ) -> BatchGetMetricResponse:
        """Search metric configuration"""

        request = SearchMetricConfigurationRequest()
        request.ids = ids
        request.warehouse_ids = warehouse_ids
        request.table_ids = table_ids
        request.table_name = table_name
        request.status = status
        request.muted = muted

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/SearchMetricConfiguration",
            request,
            BatchGetMetricResponse,
        )

    async def batch_edit_metrics(
        self,
        *,
        metric_ids: List[int] = [],
        metric_configuration: Optional["MetricConfiguration"] = None,
    ) -> BatchMetricConfigResponse:
        """Batch edit metrics"""

        request = BatchMetricConfigRequest()
        request.metric_ids = metric_ids
        if metric_configuration is not None:
            request.metric_configuration = metric_configuration

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/BatchEditMetrics",
            request,
            BatchMetricConfigResponse,
        )

    async def get_metric_info(self, *, metric_id: int = 0) -> MetricInfo:
        """Get single metric information"""

        request = SinglePathParamMetricIdRequest()
        request.metric_id = metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetMetricInfo",
            request,
            MetricInfo,
        )

    async def get_metric_info_batch(
        self,
        *,
        metric_ids: List[int] = [],
        warehouse_ids: List[int] = [],
        table_ids: List[int] = [],
        table_name: str = "",
        status: str = "",
        metric_creation_states: List["MetricCreationState"] = [],
        muted: "ThreeLeggedBoolean" = 0,
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "MetricSortField" = 0,
        schema_name: str = "",
        column_ids: List[int] = [],
        search: str = "",
        sort_direction: "SortDirection" = 0,
        schema_id: int = 0,
        metric_types: List["PredefinedMetricName"] = [],
        include_latest_metric_runs: bool = False,
        workspace_id: int = 0,
        tag_ids: List[int] = [],
        dimension_ids: List[int] = [],
        template_ids: List[int] = [],
        monitor_types: List["MonitorType"] = [],
    ) -> MetricInfoList:
        """Get metric information"""

        request = GetMetricInfoListRequest()
        request.metric_ids = metric_ids
        request.warehouse_ids = warehouse_ids
        request.table_ids = table_ids
        request.table_name = table_name
        request.status = status
        request.metric_creation_states = metric_creation_states
        request.muted = muted
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.schema_name = schema_name
        request.column_ids = column_ids
        request.search = search
        request.sort_direction = sort_direction
        request.schema_id = schema_id
        request.metric_types = metric_types
        request.include_latest_metric_runs = include_latest_metric_runs
        request.workspace_id = workspace_id
        request.tag_ids = tag_ids
        request.dimension_ids = dimension_ids
        request.template_ids = template_ids
        request.monitor_types = monitor_types

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetMetricInfoBatch",
            request,
            MetricInfoList,
        )

    async def get_metric_info_batch_post(
        self,
        *,
        metric_ids: List[int] = [],
        warehouse_ids: List[int] = [],
        table_ids: List[int] = [],
        table_name: str = "",
        status: str = "",
        metric_creation_states: List["MetricCreationState"] = [],
        muted: "ThreeLeggedBoolean" = 0,
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "MetricSortField" = 0,
        schema_name: str = "",
        column_ids: List[int] = [],
        search: str = "",
        sort_direction: "SortDirection" = 0,
        schema_id: int = 0,
        metric_types: List["PredefinedMetricName"] = [],
        include_latest_metric_runs: bool = False,
        workspace_id: int = 0,
        tag_ids: List[int] = [],
        dimension_ids: List[int] = [],
        template_ids: List[int] = [],
        monitor_types: List["MonitorType"] = [],
    ) -> MetricInfoList:
        """Get batch metric information"""

        request = GetMetricInfoListRequest()
        request.metric_ids = metric_ids
        request.warehouse_ids = warehouse_ids
        request.table_ids = table_ids
        request.table_name = table_name
        request.status = status
        request.metric_creation_states = metric_creation_states
        request.muted = muted
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.schema_name = schema_name
        request.column_ids = column_ids
        request.search = search
        request.sort_direction = sort_direction
        request.schema_id = schema_id
        request.metric_types = metric_types
        request.include_latest_metric_runs = include_latest_metric_runs
        request.workspace_id = workspace_id
        request.tag_ids = tag_ids
        request.dimension_ids = dimension_ids
        request.template_ids = template_ids
        request.monitor_types = monitor_types

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetMetricInfoBatchPost",
            request,
            MetricInfoList,
        )

    async def get_metrics_count(
        self,
        *,
        metric_ids: List[int] = [],
        warehouse_ids: List[int] = [],
        table_ids: List[int] = [],
        table_name: str = "",
        status: str = "",
        metric_creation_states: List["MetricCreationState"] = [],
        muted: "ThreeLeggedBoolean" = 0,
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "MetricSortField" = 0,
        schema_name: str = "",
        column_ids: List[int] = [],
        search: str = "",
        sort_direction: "SortDirection" = 0,
        schema_id: int = 0,
        metric_types: List["PredefinedMetricName"] = [],
        include_latest_metric_runs: bool = False,
        workspace_id: int = 0,
        tag_ids: List[int] = [],
        dimension_ids: List[int] = [],
        template_ids: List[int] = [],
        monitor_types: List["MonitorType"] = [],
    ) -> GetMetricsCountResponse:
        """Get count of metrics"""

        request = GetMetricInfoListRequest()
        request.metric_ids = metric_ids
        request.warehouse_ids = warehouse_ids
        request.table_ids = table_ids
        request.table_name = table_name
        request.status = status
        request.metric_creation_states = metric_creation_states
        request.muted = muted
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.schema_name = schema_name
        request.column_ids = column_ids
        request.search = search
        request.sort_direction = sort_direction
        request.schema_id = schema_id
        request.metric_types = metric_types
        request.include_latest_metric_runs = include_latest_metric_runs
        request.workspace_id = workspace_id
        request.tag_ids = tag_ids
        request.dimension_ids = dimension_ids
        request.template_ids = template_ids
        request.monitor_types = monitor_types

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetMetricsCount",
            request,
            GetMetricsCountResponse,
        )

    async def create_metric(
        self,
        *,
        id: int = 0,
        schedule_frequency: Optional["TimeInterval"] = None,
        filters: List[str] = [],
        group_bys: List[str] = [],
        thresholds: List["Threshold"] = [],
        notification_channels: List["NotificationChannel"] = [],
        warehouse_id: int = 0,
        dataset_id: int = 0,
        metric_type: Optional["MetricType"] = None,
        parameters: List["MetricParameter"] = [],
        lookback: Optional["TimeInterval"] = None,
        lookback_type: "LookbackType" = 0,
        metric_creation_state: "MetricCreationState" = 0,
        grain_seconds: int = 0,
        muted_until_epoch_seconds: int = 0,
        name: str = "",
        description: str = "",
        is_table_metric: bool = False,
        metric_group_overrides: List["MetricGroupOverride"] = [],
        metric_schedule: Optional["MetricSchedule"] = None,
        rct_override: str = "",
        is_lookback_using_current_time: bool = False,
        bigconfig_namespace: str = "",
        dimension: Optional["IdAndDisplayName"] = None,
        profiling_suggestion_for_column: Optional["IdAndDisplayName"] = None,
        metric_observed_column_response: List["MetricObservedColumnResponse"] = [],
        monitor_type: "MonitorType" = 0,
    ) -> MetricConfiguration:
        """Create or update metric"""

        request = MetricConfiguration()
        request.id = id
        if schedule_frequency is not None:
            request.schedule_frequency = schedule_frequency
        request.filters = filters
        request.group_bys = group_bys
        if thresholds is not None:
            request.thresholds = thresholds
        if notification_channels is not None:
            request.notification_channels = notification_channels
        request.warehouse_id = warehouse_id
        request.dataset_id = dataset_id
        if metric_type is not None:
            request.metric_type = metric_type
        if parameters is not None:
            request.parameters = parameters
        if lookback is not None:
            request.lookback = lookback
        request.lookback_type = lookback_type
        request.metric_creation_state = metric_creation_state
        request.grain_seconds = grain_seconds
        request.muted_until_epoch_seconds = muted_until_epoch_seconds
        request.name = name
        request.description = description
        request.is_table_metric = is_table_metric
        if metric_group_overrides is not None:
            request.metric_group_overrides = metric_group_overrides
        if metric_schedule is not None:
            request.metric_schedule = metric_schedule
        request.rct_override = rct_override
        request.is_lookback_using_current_time = is_lookback_using_current_time
        request.bigconfig_namespace = bigconfig_namespace
        if dimension is not None:
            request.dimension = dimension
        if profiling_suggestion_for_column is not None:
            request.profiling_suggestion_for_column = profiling_suggestion_for_column
        if metric_observed_column_response is not None:
            request.metric_observed_column_response = metric_observed_column_response
        request.monitor_type = monitor_type

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/CreateMetric",
            request,
            MetricConfiguration,
        )

    async def delete_metric(self, *, metric_id: int = 0) -> Empty:
        """Delete metric"""

        request = SinglePathParamMetricIdRequest()
        request.metric_id = metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/DeleteMetric",
            request,
            Empty,
        )

    async def get_metric_configuration(
        self, *, metric_id: int = 0
    ) -> MetricConfiguration:
        """Get metric configuration"""

        request = SinglePathParamMetricIdRequest()
        request.metric_id = metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetMetricConfiguration",
            request,
            MetricConfiguration,
        )

    async def get_metric_runs(
        self,
        *,
        metric_identifier: Optional["MetricIdentifier"] = None,
        days_of_history: int = 0,
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "MetricRunSortField" = 0,
        sort_direction: "SortDirection" = 0,
        issue_id: int = 0,
        start_epoch_seconds: int = 0,
        end_epoch_seconds: int = 0,
    ) -> GetMetricRunsResponse:
        """Get metric runs"""

        request = GetMetricRunsRequest()
        if metric_identifier is not None:
            request.metric_identifier = metric_identifier
        request.days_of_history = days_of_history
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.issue_id = issue_id
        request.start_epoch_seconds = start_epoch_seconds
        request.end_epoch_seconds = end_epoch_seconds

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetMetricRuns",
            request,
            GetMetricRunsResponse,
        )

    async def run_metric(self, *, metric_id: int = 0) -> MetricInfo:
        """Run metric"""

        request = SinglePathParamMetricIdRequest()
        request.metric_id = metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/RunMetric",
            request,
            MetricInfo,
        )

    async def run_metric_batch(
        self,
        *,
        metric_ids: List[int] = [],
        should_write_to_metric_run_start: bool = False,
        where: Optional["WhereClause"] = None,
    ) -> BatchRunMetricsResponse:
        """Batch run metrics"""

        request = BatchRunMetricsRequest()
        request.metric_ids = metric_ids
        request.should_write_to_metric_run_start = should_write_to_metric_run_start
        if where is not None:
            request.where = where

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/RunMetricBatch",
            request,
            BatchRunMetricsResponse,
        )

    async def run_metric_batch_queue(
        self,
        *,
        metric_ids: List[int] = [],
        should_write_to_metric_run_start: bool = False,
        where: Optional["WhereClause"] = None,
    ) -> WorkflowResponse:
        """
        Queue batch run metrics. This is useful for batches that take a long
        time to run. Returns a WorkflowResponse, which contains a workflow_id.
        The status of the batch can be checked by using the
        /api/v1/workflows/{workflow_id}/status endpoint.
        """

        request = BatchRunMetricsRequest()
        request.metric_ids = metric_ids
        request.should_write_to_metric_run_start = should_write_to_metric_run_start
        if where is not None:
            request.where = where

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/RunMetricBatchQueue",
            request,
            WorkflowResponse,
        )

    async def backfill_metric(
        self,
        *,
        metric_ids: List[int] = [],
        backfill_range: Optional["TimeRange"] = None,
        delete_history: bool = False,
    ) -> MetricBackfillResponse:
        """Backfill metric"""

        request = MetricBackfillRequest()
        request.metric_ids = metric_ids
        if backfill_range is not None:
            request.backfill_range = backfill_range
        request.delete_history = delete_history

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/BackfillMetric",
            request,
            MetricBackfillResponse,
        )

    async def search_metric_backfill(
        self,
        *,
        ids: List[int] = [],
        warehouse_ids: List[int] = [],
        table_ids: List[int] = [],
        table_name: str = "",
        status: List["MetricBackfillRunStatus"] = [],
    ) -> MetricBackfillResponse:
        """Get backfill status"""

        request = SearchMetricBackfillRequest()
        request.ids = ids
        request.warehouse_ids = warehouse_ids
        request.table_ids = table_ids
        request.table_name = table_name
        request.status = status

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/SearchMetricBackfill",
            request,
            MetricBackfillResponse,
        )

    async def get_debug_queries(self, *, metric_id: int = 0) -> GetDebugQueriesResponse:
        """Get queries for debug page"""

        request = GetDebugQueriesRequest()
        request.metric_id = metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetDebugQueries",
            request,
            GetDebugQueriesResponse,
        )

    async def get_debug_preview(self, *, metric_id: int = 0) -> GetPreviewResponse:
        """Get sample debug rows for debug page"""

        request = GetDebugPreviewRequest()
        request.metric_id = metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetDebugPreview",
            request,
            GetPreviewResponse,
        )

    async def validate_metric(
        self,
        *,
        id: int = 0,
        schedule_frequency: Optional["TimeInterval"] = None,
        filters: List[str] = [],
        group_bys: List[str] = [],
        thresholds: List["Threshold"] = [],
        notification_channels: List["NotificationChannel"] = [],
        warehouse_id: int = 0,
        dataset_id: int = 0,
        metric_type: Optional["MetricType"] = None,
        parameters: List["MetricParameter"] = [],
        lookback: Optional["TimeInterval"] = None,
        lookback_type: "LookbackType" = 0,
        metric_creation_state: "MetricCreationState" = 0,
        grain_seconds: int = 0,
        muted_until_epoch_seconds: int = 0,
        name: str = "",
        description: str = "",
        is_table_metric: bool = False,
        metric_group_overrides: List["MetricGroupOverride"] = [],
        metric_schedule: Optional["MetricSchedule"] = None,
        rct_override: str = "",
        is_lookback_using_current_time: bool = False,
        bigconfig_namespace: str = "",
        dimension: Optional["IdAndDisplayName"] = None,
        profiling_suggestion_for_column: Optional["IdAndDisplayName"] = None,
        metric_observed_column_response: List["MetricObservedColumnResponse"] = [],
        monitor_type: "MonitorType" = 0,
    ) -> MetricValidationResult:
        """Validate a metric configuration"""

        request = MetricConfiguration()
        request.id = id
        if schedule_frequency is not None:
            request.schedule_frequency = schedule_frequency
        request.filters = filters
        request.group_bys = group_bys
        if thresholds is not None:
            request.thresholds = thresholds
        if notification_channels is not None:
            request.notification_channels = notification_channels
        request.warehouse_id = warehouse_id
        request.dataset_id = dataset_id
        if metric_type is not None:
            request.metric_type = metric_type
        if parameters is not None:
            request.parameters = parameters
        if lookback is not None:
            request.lookback = lookback
        request.lookback_type = lookback_type
        request.metric_creation_state = metric_creation_state
        request.grain_seconds = grain_seconds
        request.muted_until_epoch_seconds = muted_until_epoch_seconds
        request.name = name
        request.description = description
        request.is_table_metric = is_table_metric
        if metric_group_overrides is not None:
            request.metric_group_overrides = metric_group_overrides
        if metric_schedule is not None:
            request.metric_schedule = metric_schedule
        request.rct_override = rct_override
        request.is_lookback_using_current_time = is_lookback_using_current_time
        request.bigconfig_namespace = bigconfig_namespace
        if dimension is not None:
            request.dimension = dimension
        if profiling_suggestion_for_column is not None:
            request.profiling_suggestion_for_column = profiling_suggestion_for_column
        if metric_observed_column_response is not None:
            request.metric_observed_column_response = metric_observed_column_response
        request.monitor_type = monitor_type

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/ValidateMetric",
            request,
            MetricValidationResult,
        )

    async def bulk_update_metrics(
        self,
        *,
        where: Optional["WhereClause"] = None,
        edit_request: Optional["MetricConfiguration"] = None,
        mute_request: Optional["MuteRequest"] = None,
        is_run: bool = False,
        is_delete: bool = False,
        add_to_collection: int = 0,
        remove_from_collection: int = 0,
        backfill_request: Optional["MetricBackfillRequest"] = None,
    ) -> BulkResponse:
        """Performs bulk metric updates"""

        request = BulkMetricOperation()
        if where is not None:
            request.where = where
        if edit_request is not None:
            request.edit_request = edit_request
        if mute_request is not None:
            request.mute_request = mute_request
        request.is_run = is_run
        request.is_delete = is_delete
        request.add_to_collection = add_to_collection
        request.remove_from_collection = remove_from_collection
        if backfill_request is not None:
            request.backfill_request = backfill_request

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/BulkUpdateMetrics",
            request,
            BulkResponse,
        )

    async def bulk_updates_deltas(
        self,
        *,
        where: Optional["WhereClause"] = None,
        is_run: bool = False,
        edit_request: Optional["TableComparisonBatchEditRequest"] = None,
        is_delete: bool = False,
    ) -> BulkResponse:
        """Performs bulk Delta updates"""

        request = BulkDeltaOperation()
        if where is not None:
            request.where = where
        request.is_run = is_run
        if edit_request is not None:
            request.edit_request = edit_request
        request.is_delete = is_delete

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/BulkUpdatesDeltas",
            request,
            BulkResponse,
        )

    async def get_table_level_metric_names(self) -> MetricNamesResponse:
        """Gets the list of all table-level metric names"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetTableLevelMetricNames",
            request,
            MetricNamesResponse,
        )

    async def get_metadata_metric_names(self) -> MetricNamesResponse:
        """Gets the list of all metadata metric names"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetMetadataMetricNames",
            request,
            MetricNamesResponse,
        )

    async def get_revisions(self, *, metric_id: int = 0) -> GetMetricRevisionsResponse:
        """Get metric revisions / history / timeline"""

        request = SinglePathParamMetricIdRequest()
        request.metric_id = metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetRevisions",
            request,
            GetMetricRevisionsResponse,
        )

    async def get_scorecard(
        self, *, days_of_history: int = 0, where: Optional["WhereClause"] = None
    ) -> GetMetricScorecardResponse:
        """Get metric scorecard"""

        request = GetMetricScorecardRequest()
        request.days_of_history = days_of_history
        if where is not None:
            request.where = where

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricService/GetScorecard",
            request,
            GetMetricScorecardResponse,
        )


class CollectionServiceStub(betterproto.ServiceStub):
    """Collections"""

    async def create_collection(
        self,
        *,
        collection_name: str = "",
        description: str = "",
        metric_ids: List[int] = [],
        notification_channels: List["NotificationChannel"] = [],
        muted_until_timestamp: int = 0,
        workspace_id: int = 0,
    ) -> CreateCollectionResponse:
        """Create collection"""

        request = EditCollectionRequest()
        request.collection_name = collection_name
        request.description = description
        request.metric_ids = metric_ids
        if notification_channels is not None:
            request.notification_channels = notification_channels
        request.muted_until_timestamp = muted_until_timestamp
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CollectionService/CreateCollection",
            request,
            CreateCollectionResponse,
        )

    async def edit_collection(
        self, *, collection_id: int = 0, body: Optional["EditCollectionRequest"] = None
    ) -> EditCollectionResponse:
        """Edit collection"""

        request = EditCollectionWrapper()
        request.collection_id = collection_id
        if body is not None:
            request.body = body

        return await self._unary_unary(
            "/com.bigeye.models.generated.CollectionService/EditCollection",
            request,
            EditCollectionResponse,
        )

    async def get_collections(self, *, workspace_id: int = 0) -> GetCollectionsResponse:
        """Get all collections"""

        request = GetCollectionsRequest()
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CollectionService/GetCollections",
            request,
            GetCollectionsResponse,
        )

    async def get_collection(self, *, collection_id: int = 0) -> GetCollectionsResponse:
        """Get specific collection"""

        request = SinglePathParamCollectionIdRequest()
        request.collection_id = collection_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CollectionService/GetCollection",
            request,
            GetCollectionsResponse,
        )

    async def delete_collection(self, *, collection_id: int = 0) -> Empty:
        """Delete collection"""

        request = SinglePathParamCollectionIdRequest()
        request.collection_id = collection_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CollectionService/DeleteCollection",
            request,
            Empty,
        )

    async def get_collection_info(
        self, *, collection_id: int = 0
    ) -> GetCollectionInfoResponse:
        """Get collection information"""

        request = SinglePathParamCollectionIdRequest()
        request.collection_id = collection_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CollectionService/GetCollectionInfo",
            request,
            GetCollectionInfoResponse,
        )

    async def get_collection_infos(
        self, *, workspace_id: int = 0
    ) -> GetAllCollectionInfosResponse:
        """Get all collection information"""

        request = GetAllCollectionInfosRequest()
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CollectionService/GetCollectionInfos",
            request,
            GetAllCollectionInfosResponse,
        )


class CollectionV2ServiceStub(betterproto.ServiceStub):
    """Collections V2"""

    async def get_collection_info_v2(
        self, *, collection_id: int = 0
    ) -> GetCollectionInfoResponse:
        """Get collection information"""

        request = SinglePathParamCollectionIdRequest()
        request.collection_id = collection_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CollectionV2Service/GetCollectionInfoV2",
            request,
            GetCollectionInfoResponse,
        )

    async def get_collection_infos_v2(
        self, *, workspace_id: int = 0
    ) -> GetAllCollectionInfosResponse:
        """Get all collection information"""

        request = GetAllCollectionInfosRequest()
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CollectionV2Service/GetCollectionInfosV2",
            request,
            GetAllCollectionInfosResponse,
        )

    async def fetch_collection_infos_v2(
        self,
        *,
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "CollectionInfoV2SortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        workspace_id: int = 0,
    ) -> GetPaginatedCollectionInfosResponse:
        """Fetch paginated collection information"""

        request = GetPaginatedCollectionInfosV2Request()
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CollectionV2Service/FetchCollectionInfosV2",
            request,
            GetPaginatedCollectionInfosResponse,
        )


class TableServiceStub(betterproto.ServiceStub):
    """Tables"""

    async def get_profile_for_table(
        self, *, table_id: int = 0
    ) -> ColumnMetricProfileList:
        """Profile a table"""

        request = SinglePathParamTableIdRequest()
        request.table_id = table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/GetProfileForTable",
            request,
            ColumnMetricProfileList,
        )

    async def get_profile_for_column(
        self, *, table_id: int = 0, column_id: int = 0
    ) -> ColumnMetricProfileList:
        """Profile a column"""

        request = TableAndColumnIdRequest()
        request.table_id = table_id
        request.column_id = column_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/GetProfileForColumn",
            request,
            ColumnMetricProfileList,
        )

    async def search_tables(
        self,
        *,
        warehouse_id: List[int] = [],
        schema: List[str] = [],
        table_name: List[str] = [],
        ids: List[int] = [],
        schema_id: List[int] = [],
        include_favorites: bool = False,
        ignore_fields: bool = False,
        workspace_id: int = 0,
        include_data_node_ids: bool = False,
    ) -> TableList:
        """Search tables"""

        request = TableSearchRequest()
        request.warehouse_id = warehouse_id
        request.schema = schema
        request.table_name = table_name
        request.ids = ids
        request.schema_id = schema_id
        request.include_favorites = include_favorites
        request.ignore_fields = ignore_fields
        request.workspace_id = workspace_id
        request.include_data_node_ids = include_data_node_ids

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/SearchTables",
            request,
            TableList,
        )

    async def snooze_table(
        self, *, table_id: int = 0, body: Optional["SnoozeTableRequest"] = None
    ) -> SnoozeTableResponse:
        """Snooze table"""

        request = SnoozeTableRequestWrapper()
        request.table_id = table_id
        if body is not None:
            request.body = body

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/SnoozeTable",
            request,
            SnoozeTableResponse,
        )

    async def fake_api1(
        self, *, minutes: int = 0, include_descendants: bool = False
    ) -> SnoozeTableResponse:
        """
        need to use the non-wrapper requests and responses to make them
        generate
        """

        request = SnoozeTableRequest()
        request.minutes = minutes
        request.include_descendants = include_descendants

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/FakeApi1",
            request,
            SnoozeTableResponse,
        )

    async def unsnooze_table(
        self, *, table_id: int = 0, body: Optional["UnSnoozeTableRequest"] = None
    ) -> UnSnoozeTableResponse:
        """Unsnooze table"""

        request = UnSnoozeTableRequestWrapper()
        request.table_id = table_id
        if body is not None:
            request.body = body

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/UnsnoozeTable",
            request,
            UnSnoozeTableResponse,
        )

    async def fake_api2(
        self, *, include_descendants: bool = False
    ) -> UnSnoozeTableResponse:
        """
        need to use the non-wrapper requests and responses to make them
        generate
        """

        request = UnSnoozeTableRequest()
        request.include_descendants = include_descendants

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/FakeApi2",
            request,
            UnSnoozeTableResponse,
        )

    async def get_delta_applicable_metric_types(
        self, *, table_id: int = 0
    ) -> GetDeltaApplicableMetricTypesResponse:
        """Get list of metrics applicable for deltas"""

        request = GetDeltaApplicableMetricTypesRequest()
        request.table_id = table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/GetDeltaApplicableMetricTypes",
            request,
            GetDeltaApplicableMetricTypesResponse,
        )

    async def table_level_applicable_metric_types(
        self, *, table_id: int = 0
    ) -> GetDeltaApplicableMetricTypesResponse:
        """
        Get list of metrics applicable to an entire table, filtered for only
        the ones that are valid for that table's warehouse
        """

        request = GetTableLevelApplicableMetricTypesRequest()
        request.table_id = table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/TableLevelApplicableMetricTypes",
            request,
            GetDeltaApplicableMetricTypesResponse,
        )

    async def get_table_workflow(self, *, table_id: int = 0) -> WorkflowResponse:
        """Get workflow for table"""

        request = SinglePathParamTableIdRequest()
        request.table_id = table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/GetTableWorkflow",
            request,
            WorkflowResponse,
        )

    async def get_table_workflow_status(
        self, *, table_id: int = 0
    ) -> WorkflowStatusResponse:
        """Get the current status for a workflow for a table"""

        request = SinglePathParamTableIdRequest()
        request.table_id = table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/GetTableWorkflowStatus",
            request,
            WorkflowStatusResponse,
        )

    async def get_tables(
        self,
        *,
        source_ids: List[int] = [],
        schema_ids: List[int] = [],
        table_ids: List[int] = [],
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "TableSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        ignore_fields: bool = False,
        workspace_id: int = 0,
        include_data_node_ids: bool = False,
        tag_ids: List[int] = [],
        source_connection_types: List["SourceConnectionType"] = [],
    ) -> GetTableListResponse:
        """Get tables"""

        request = GetTableListRequest()
        request.source_ids = source_ids
        request.schema_ids = schema_ids
        request.table_ids = table_ids
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.ignore_fields = ignore_fields
        request.workspace_id = workspace_id
        request.include_data_node_ids = include_data_node_ids
        request.tag_ids = tag_ids
        request.source_connection_types = source_connection_types

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/GetTables",
            request,
            GetTableListResponse,
        )

    async def get_table_info_with_columns(
        self, *, table_id: int = 0
    ) -> TableInfoWithColumns:
        """Get the date column information for a table"""

        request = SinglePathParamTableIdRequest()
        request.table_id = table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/GetTableInfoWithColumns",
            request,
            TableInfoWithColumns,
        )

    async def set_date_columns(
        self, *, column_ids: List[int] = [], table_ids_with_none_rct: List[int] = []
    ) -> TableInfoWithColumnsResponse:
        """Set the date columns for a list of tables"""

        request = SetDateColumnRequest()
        request.column_ids = column_ids
        request.table_ids_with_none_rct = table_ids_with_none_rct

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/SetDateColumns",
            request,
            TableInfoWithColumnsResponse,
        )

    async def get_dbt_jobs_for_table(self, *, table_id: int = 0) -> GetDbtJobsResponse:
        """Get dbt jobs for table"""

        request = SinglePathParamTableIdRequest()
        request.table_id = table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/GetDbtJobsForTable",
            request,
            GetDbtJobsResponse,
        )

    async def set_required_partition_column(
        self,
        *,
        table_id: int = 0,
        request: Optional["SetRequiredPartitionColumnRequest"] = None,
    ) -> SetRequiredPartitionColumnResponse:
        request = SetRequiredPartitionColumnRequestWrapper()
        request.table_id = table_id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/SetRequiredPartitionColumn",
            request,
            SetRequiredPartitionColumnResponse,
        )

    async def fake_set_required_partition_column(
        self, *, column_id: int = 0
    ) -> SetRequiredPartitionColumnResponse:
        """fake api is required for the wrapper container"""

        request = SetRequiredPartitionColumnRequest()
        request.column_id = column_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/FakeSetRequiredPartitionColumn",
            request,
            SetRequiredPartitionColumnResponse,
        )

    async def unset_required_partition_column(self, *, table_id: int = 0) -> Empty:
        request = SinglePathParamTableIdRequest()
        request.table_id = table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.TableService/UnsetRequiredPartitionColumn",
            request,
            Empty,
        )


class QueryServiceStub(betterproto.ServiceStub):
    async def get_counts_batch_post(
        self, *, queries: List["CountsQuery"] = [], exclude_zeros: bool = False
    ) -> GetCountsResponse:
        request = GetCountsRequest()
        if queries is not None:
            request.queries = queries
        request.exclude_zeros = exclude_zeros

        return await self._unary_unary(
            "/com.bigeye.models.generated.QueryService/GetCountsBatchPost",
            request,
            GetCountsResponse,
        )


class SearchServiceStub(betterproto.ServiceStub):
    async def search(
        self, *, search: str = "", types: List["SearchType"] = [], limit: int = 0
    ) -> SearchResponse:
        """Search for entities"""

        request = SearchRequest()
        request.search = search
        if types is not None:
            request.types = types
        request.limit = limit

        return await self._unary_unary(
            "/com.bigeye.models.generated.SearchService/Search",
            request,
            SearchResponse,
        )


class SchemaServiceStub(betterproto.ServiceStub):
    """Get list of schemas"""

    async def search_schemas(
        self,
        *,
        warehouse_id: List[int] = [],
        schema_name: List[str] = [],
        schema_id: List[int] = [],
        workspace_id: int = 0,
    ) -> SchemaList:
        """Search schemas"""

        request = SchemaSearchRequest()
        request.warehouse_id = warehouse_id
        request.schema_name = schema_name
        request.schema_id = schema_id
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SchemaService/SearchSchemas",
            request,
            SchemaList,
        )

    async def get_schema_workflow(self, *, schema_id: int = 0) -> WorkflowResponse:
        """Get workflow for schema"""

        request = SinglePathParamSchemaIdRequest()
        request.schema_id = schema_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SchemaService/GetSchemaWorkflow",
            request,
            WorkflowResponse,
        )

    async def get_schema_workflow_status(
        self, *, schema_id: int = 0
    ) -> WorkflowStatusResponse:
        """Get the current status for a workflow for a schema"""

        request = SinglePathParamSchemaIdRequest()
        request.schema_id = schema_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SchemaService/GetSchemaWorkflowStatus",
            request,
            WorkflowStatusResponse,
        )

    async def get_schemas(
        self,
        *,
        source_ids: List[int] = [],
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "SchemaSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        workspace_id: int = 0,
        hidden: bool = False,
        tag_ids: List[int] = [],
        include_virtual: bool = False,
    ) -> GetSchemaListResponse:
        """Get schemas"""

        request = GetSchemaListRequest()
        request.source_ids = source_ids
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.workspace_id = workspace_id
        request.hidden = hidden
        request.tag_ids = tag_ids
        request.include_virtual = include_virtual

        return await self._unary_unary(
            "/com.bigeye.models.generated.SchemaService/GetSchemas",
            request,
            GetSchemaListResponse,
        )

    async def set_big_query_region(
        self, *, schema_id: int = 0, body: Optional["SetBigQueryRegionRequest"] = None
    ) -> Empty:
        """
        Set the region for a BigQuery schema (called dataset in BigQuery)
        """

        request = SetBigQueryRegionRequestWrapper()
        request.schema_id = schema_id
        if body is not None:
            request.body = body

        return await self._unary_unary(
            "/com.bigeye.models.generated.SchemaService/SetBigQueryRegion",
            request,
            Empty,
        )

    async def fake_api1(
        self, *, schema_id: int = 0, body: Optional["SetBigQueryRegionRequest"] = None
    ) -> Empty:
        request = SetBigQueryRegionRequestWrapper()
        request.schema_id = schema_id
        if body is not None:
            request.body = body

        return await self._unary_unary(
            "/com.bigeye.models.generated.SchemaService/FakeApi1",
            request,
            Empty,
        )

    async def get_big_query_region(
        self, *, schema_id: int = 0
    ) -> GetBigQueryRegionResponse:
        """
        Get the region for a BigQuery schema (called dataset in BigQuery)
        """

        request = SinglePathParamSchemaIdRequest()
        request.schema_id = schema_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SchemaService/GetBigQueryRegion",
            request,
            GetBigQueryRegionResponse,
        )

    async def delete_big_query_region_override(self, *, schema_id: int = 0) -> Empty:
        """
        Remove the manual override of a region for a BigQuery schema (called
        dataset in BigQuery)
        """

        request = SinglePathParamSchemaIdRequest()
        request.schema_id = schema_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SchemaService/DeleteBigQueryRegionOverride",
            request,
            Empty,
        )

    async def get_dbt_jobs_for_schema(
        self, *, schema_id: int = 0
    ) -> GetDbtJobsResponse:
        """Get dbt jobs for schema"""

        request = SinglePathParamSchemaIdRequest()
        request.schema_id = schema_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SchemaService/GetDbtJobsForSchema",
            request,
            GetDbtJobsResponse,
        )


class ColumnServiceStub(betterproto.ServiceStub):
    """Columns"""

    async def get_specified_columns(
        self,
        *,
        table_id: int = 0,
        column_ids: List[int] = [],
        include_data_node_ids: bool = False,
    ) -> ColumnSearchResponse:
        """Get specified columns"""

        request = ColumnSearchRequest()
        request.table_id = table_id
        request.column_ids = column_ids
        request.include_data_node_ids = include_data_node_ids

        return await self._unary_unary(
            "/com.bigeye.models.generated.ColumnService/GetSpecifiedColumns",
            request,
            ColumnSearchResponse,
        )

    async def get_column_applicable_metric_types(
        self, *, column_id: int = 0
    ) -> GetColumnApplicableMetricTypesResponse:
        """Get applicable metric types for column"""

        request = SinglePathParamColumnIdRequest()
        request.column_id = column_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.ColumnService/GetColumnApplicableMetricTypes",
            request,
            GetColumnApplicableMetricTypesResponse,
        )

    async def get_columns(
        self,
        *,
        source_ids: List[int] = [],
        schema_ids: List[int] = [],
        table_ids: List[int] = [],
        column_ids: List[int] = [],
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "ColumnSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        workspace_id: int = 0,
        exclude_data_node: bool = False,
    ) -> GetColumnListResponse:
        """Get columns"""

        request = GetColumnListRequest()
        request.source_ids = source_ids
        request.schema_ids = schema_ids
        request.table_ids = table_ids
        request.column_ids = column_ids
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.workspace_id = workspace_id
        request.exclude_data_node = exclude_data_node

        return await self._unary_unary(
            "/com.bigeye.models.generated.ColumnService/GetColumns",
            request,
            GetColumnListResponse,
        )


class MetricTemplateServiceStub(betterproto.ServiceStub):
    """Metric Templates"""

    async def get_metric_templates(
        self,
        *,
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "MetricTemplateSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        workspace_id: int = 0,
    ) -> GetMetricTemplateListResponse:
        """Get all metric templates"""

        request = GetMetricTemplateListRequest()
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricTemplateService/GetMetricTemplates",
            request,
            GetMetricTemplateListResponse,
        )

    async def get_metric_template(
        self, *, metric_template_id: int = 0
    ) -> GetMetricTemplateResponse:
        """Get single metric template"""

        request = SinglePathParamMetricTemplateIdRequest()
        request.metric_template_id = metric_template_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricTemplateService/GetMetricTemplate",
            request,
            GetMetricTemplateResponse,
        )

    async def create_metric_template(
        self, *, metric_template: Optional["MetricTemplate"] = None
    ) -> CreateMetricTemplateResponse:
        """Create or update a metric template"""

        request = CreateMetricTemplateRequest()
        if metric_template is not None:
            request.metric_template = metric_template

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricTemplateService/CreateMetricTemplate",
            request,
            CreateMetricTemplateResponse,
        )

    async def delete_metric_template(self, *, metric_template_id: int = 0) -> Empty:
        """Delete a metric template"""

        request = SinglePathParamMetricTemplateIdRequest()
        request.metric_template_id = metric_template_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricTemplateService/DeleteMetricTemplate",
            request,
            Empty,
        )


class NamedScheduleServiceStub(betterproto.ServiceStub):
    """Named Schedules"""

    async def create_named_schedule(
        self, *, id: int = 0, name: str = "", cron: str = "", workspace_id: int = 0
    ) -> NamedSchedule:
        """Create a named schedule"""

        request = CreateNamedScheduleRequest()
        request.id = id
        request.name = name
        request.cron = cron
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.NamedScheduleService/CreateNamedSchedule",
            request,
            NamedSchedule,
        )

    async def delete_named_schedule(self, *, schedule_id: int = 0) -> Empty:
        """Deleted a named schedule"""

        request = SinglePathParamNamedScheduleRequest()
        request.schedule_id = schedule_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.NamedScheduleService/DeleteNamedSchedule",
            request,
            Empty,
        )

    async def get_named_schedule(
        self,
        *,
        ids: List[int] = [],
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "NamedScheduleSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
    ) -> GetNamedSchedulesResponse:
        """Get named schedules"""

        request = GetNamedSchedulesRequest()
        request.ids = ids
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search

        return await self._unary_unary(
            "/com.bigeye.models.generated.NamedScheduleService/GetNamedSchedule",
            request,
            GetNamedSchedulesResponse,
        )

    async def get_named_schedule_entities(
        self, *, schedule_id: int = 0
    ) -> GetNamedScheduleEntitiesResponse:
        """Get all entities using a given named schedule"""

        request = SinglePathParamNamedScheduleRequest()
        request.schedule_id = schedule_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.NamedScheduleService/GetNamedScheduleEntities",
            request,
            GetNamedScheduleEntitiesResponse,
        )


class DeltasServiceStub(betterproto.ServiceStub):
    """Deltas"""

    async def create_comparison_table(
        self,
        *,
        comparison_table_configuration: Optional["ComparisonTableConfiguration"] = None,
    ) -> CreateComparisonTableResponse:
        """Create a delta"""

        request = CreateComparisonTableRequest()
        if comparison_table_configuration is not None:
            request.comparison_table_configuration = comparison_table_configuration

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltasService/CreateComparisonTable",
            request,
            CreateComparisonTableResponse,
        )

    async def get_comparison_table(
        self, *, comparison_table_id: int = 0
    ) -> GetComparisonTableResponse:
        """Retrieve a delta configuration"""

        request = SinglePathParamComparisonTableIdRequest()
        request.comparison_table_id = comparison_table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltasService/GetComparisonTable",
            request,
            GetComparisonTableResponse,
        )

    async def delete_comparison_table(self, *, comparison_table_id: int = 0) -> Empty:
        """Delete a delta"""

        request = SinglePathParamComparisonTableIdRequest()
        request.comparison_table_id = comparison_table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltasService/DeleteComparisonTable",
            request,
            Empty,
        )

    async def run_comparison_table(
        self, *, comparison_table_id: int = 0
    ) -> RunComparisonTableResponse:
        """Run a delta"""

        request = SinglePathParamComparisonTableIdRequest()
        request.comparison_table_id = comparison_table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltasService/RunComparisonTable",
            request,
            RunComparisonTableResponse,
        )

    async def get_comparison_table_infos(
        self,
        *,
        comparison_table_ids: List[int] = [],
        exclude_comparison_metrics: bool = False,
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "ComparisonTableSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        workspace_id: int = 0,
        tag_ids: List[int] = [],
        dimension_ids: List[int] = [],
        delta_types: List["DeltaType"] = [],
    ) -> GetComparisonTableInfosResponse:
        """Get information about deltas"""

        request = GetComparisonTableInfosRequest()
        request.comparison_table_ids = comparison_table_ids
        request.exclude_comparison_metrics = exclude_comparison_metrics
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.workspace_id = workspace_id
        request.tag_ids = tag_ids
        request.dimension_ids = dimension_ids
        request.delta_types = delta_types

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltasService/GetComparisonTableInfos",
            request,
            GetComparisonTableInfosResponse,
        )

    async def get_table_comparison_metric_group_info(
        self, *, comparison_metric_id: int = 0
    ) -> GetTableComparisonMetricGroupInfoResponse:
        """Get info about the groups of a particular metric in a delta"""

        request = GetTableComparisonMetricGroupInfoRequest()
        request.comparison_metric_id = comparison_metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltasService/GetTableComparisonMetricGroupInfo",
            request,
            GetTableComparisonMetricGroupInfoResponse,
        )

    async def get_delta_applicable_metric_types(
        self, *, table_id: int = 0
    ) -> GetDeltaApplicableMetricTypesResponse:
        """Get list of metrics applicable for deltas"""

        request = GetDeltaApplicableMetricTypesRequest()
        request.table_id = table_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltasService/GetDeltaApplicableMetricTypes",
            request,
            GetDeltaApplicableMetricTypesResponse,
        )


class IssueServiceStub(betterproto.ServiceStub):
    """Issues"""

    async def get_issues(
        self,
        *,
        issue_ids: List[int] = [],
        current_status: List["IssueStatus"] = [],
        metric_ids: List[int] = [],
        company_issue_id: str = "",
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "IssueSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        warehouse_ids: List[int] = [],
        schema_ids: List[int] = [],
        schema_names: List[str] = [],
        table_ids: List[int] = [],
        column_ids: List[int] = [],
        sla_ids: List[int] = [],
        related_issue_ids: List[int] = [],
        priority: List["IssuePriority"] = [],
        metric_status: List["MetricStatus"] = [],
        metric_type: List["MetricType"] = [],
        min_opened_time: int = 0,
        max_opened_time: int = 0,
        sort_options: List["IssueSortOption"] = [],
        workspace_id: int = 0,
        assignee_ids: List[int] = [],
        parent_issue_ids: List[int] = [],
        issue_type: List["IssueType"] = [],
        is_root_cause: "ThreeLeggedBoolean" = 0,
        dimension_ids: List[int] = [],
        include_companion_metrics: bool = False,
        downstream_report_ids: List[int] = [],
        monitor_types: List["MonitorType"] = [],
    ) -> GetIssuesResponse:
        """Get issues"""

        request = GetIssuesRequest()
        request.issue_ids = issue_ids
        request.current_status = current_status
        request.metric_ids = metric_ids
        request.company_issue_id = company_issue_id
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.warehouse_ids = warehouse_ids
        request.schema_ids = schema_ids
        request.schema_names = schema_names
        request.table_ids = table_ids
        request.column_ids = column_ids
        request.sla_ids = sla_ids
        request.related_issue_ids = related_issue_ids
        request.priority = priority
        request.metric_status = metric_status
        if metric_type is not None:
            request.metric_type = metric_type
        request.min_opened_time = min_opened_time
        request.max_opened_time = max_opened_time
        if sort_options is not None:
            request.sort_options = sort_options
        request.workspace_id = workspace_id
        request.assignee_ids = assignee_ids
        request.parent_issue_ids = parent_issue_ids
        request.issue_type = issue_type
        request.is_root_cause = is_root_cause
        request.dimension_ids = dimension_ids
        request.include_companion_metrics = include_companion_metrics
        request.downstream_report_ids = downstream_report_ids
        request.monitor_types = monitor_types

        return await self._unary_unary(
            "/com.bigeye.models.generated.IssueService/GetIssues",
            request,
            GetIssuesResponse,
        )

    async def get_issue(self, *, issue_id: int = 0) -> GetIssuesResponse:
        """Get issue"""

        request = SinglePathParamIssueRequest()
        request.issue_id = issue_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.IssueService/GetIssue",
            request,
            GetIssuesResponse,
        )

    async def update_issue(
        self, *, issue_id: int = 0, body: Optional["UpdateIssueRequest"] = None
    ) -> UpdateIssueResponse:
        """Update issue"""

        request = UpdateIssueRequestWrapper()
        request.issue_id = issue_id
        if body is not None:
            request.body = body

        return await self._unary_unary(
            "/com.bigeye.models.generated.IssueService/UpdateIssue",
            request,
            UpdateIssueResponse,
        )

    async def batch_update_issues(
        self, *, issue_ids: List[int] = [], body: Optional["UpdateIssueRequest"] = None
    ) -> UpdateIssueBatchResponse:
        """Batch update issues"""

        request = UpdateIssueBatchRequestWrapper()
        request.issue_ids = issue_ids
        if body is not None:
            request.body = body

        return await self._unary_unary(
            "/com.bigeye.models.generated.IssueService/BatchUpdateIssues",
            request,
            UpdateIssueBatchResponse,
        )

    async def fake_api1(
        self,
        *,
        status_update: Optional["IssueStatusUpdate"] = None,
        config_update: Optional["IssueConfigUpdate"] = None,
        message_update: Optional["IssueMessageUpdate"] = None,
        assignment_update: Optional["IssueAssignmentUpdate"] = None,
        priority_update: Optional["IssuePriorityChangeEvent"] = None,
        ai_overview_update: Optional["IssueAiOverviewUpdate"] = None,
    ) -> UpdateIssueResponse:
        """
        need to use the non-wrapper requests and responses to make them
        generate
        """

        request = UpdateIssueRequest()
        if status_update is not None:
            request.status_update = status_update
        if config_update is not None:
            request.config_update = config_update
        if message_update is not None:
            request.message_update = message_update
        if assignment_update is not None:
            request.assignment_update = assignment_update
        if priority_update is not None:
            request.priority_update = priority_update
        if ai_overview_update is not None:
            request.ai_overview_update = ai_overview_update

        return await self._unary_unary(
            "/com.bigeye.models.generated.IssueService/FakeApi1",
            request,
            UpdateIssueResponse,
        )

    async def get_table_issues(
        self,
        *,
        current_status: List["IssueStatus"] = [],
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "IssueSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        table_ids: List[int] = [],
    ) -> GetIssueTableSummaryResponse:
        """Get issues summary by table"""

        request = GetIssueTableSummaryRequest()
        request.current_status = current_status
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.table_ids = table_ids

        return await self._unary_unary(
            "/com.bigeye.models.generated.IssueService/GetTableIssues",
            request,
            GetIssueTableSummaryResponse,
        )

    async def bulk_update_issues(
        self,
        *,
        where: Optional["BulkIssueUpdateWhereClause"] = None,
        status_update: Optional["IssueStatusUpdate"] = None,
        config_update: Optional["IssueConfigUpdate"] = None,
        is_metric_run: bool = False,
        assignment_update: Optional["IssueAssignmentUpdate"] = None,
        priority_update: Optional["IssuePriorityChangeEvent"] = None,
        updated_by_id: int = 0,
    ) -> BulkResponse:
        """Performs bulk issues updates"""

        request = BulkIssueUpdate()
        if where is not None:
            request.where = where
        if status_update is not None:
            request.status_update = status_update
        if config_update is not None:
            request.config_update = config_update
        request.is_metric_run = is_metric_run
        if assignment_update is not None:
            request.assignment_update = assignment_update
        if priority_update is not None:
            request.priority_update = priority_update
        request.updated_by_id = updated_by_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.IssueService/BulkUpdateIssues",
            request,
            BulkResponse,
        )


class SourceServiceStub(betterproto.ServiceStub):
    """Sources"""

    async def get_sources(
        self,
        *,
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "SourceSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        workspace_id: int = 0,
    ) -> GetSourceListResponse:
        """Get sources"""

        request = GetSourceListRequest()
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SourceService/GetSources",
            request,
            GetSourceListResponse,
        )

    async def get_source(self, *, source_id: int = 0) -> GetSourceResponse:
        """Get single source"""

        request = SinglePathParamSourceIdRequest()
        request.source_id = source_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SourceService/GetSource",
            request,
            GetSourceResponse,
        )

    async def validate_source(
        self,
        *,
        id: int = 0,
        name: str = "",
        hostname: str = "",
        port: int = 0,
        database_name: str = "",
        database_type: "WarehouseType" = 0,
        domain: str = "",
        username: str = "",
        password: str = "",
        private_key_file: str = "",
        query_timeout_seconds: int = 0,
        skip_indexing: bool = False,
        alation_source_id: int = 0,
        atlan_connection_id: str = "",
        temporal_agent_secret: str = "",
        target_bigquery_project_id: str = "",
        bigquery_query_project_ids: str = "",
        workspace_id: int = 0,
        datadotworld_connection_id: str = "",
        source_metadata_overrides: Optional["SourceMetadataOverrides"] = None,
        max_pool_size: int = 0,
        auth_type: "AuthType" = 0,
        ignore_schemas_prefix: str = "",
        indexing_schedule: Optional["MetricSchedule"] = None,
    ) -> SourceValidationResponse:
        """Validate source"""

        request = CreateSourceRequest()
        request.id = id
        request.name = name
        request.hostname = hostname
        request.port = port
        request.database_name = database_name
        request.database_type = database_type
        request.domain = domain
        request.username = username
        request.password = password
        request.private_key_file = private_key_file
        request.query_timeout_seconds = query_timeout_seconds
        request.skip_indexing = skip_indexing
        request.alation_source_id = alation_source_id
        request.atlan_connection_id = atlan_connection_id
        request.temporal_agent_secret = temporal_agent_secret
        request.target_bigquery_project_id = target_bigquery_project_id
        request.bigquery_query_project_ids = bigquery_query_project_ids
        request.workspace_id = workspace_id
        request.datadotworld_connection_id = datadotworld_connection_id
        if source_metadata_overrides is not None:
            request.source_metadata_overrides = source_metadata_overrides
        request.max_pool_size = max_pool_size
        request.auth_type = auth_type
        request.ignore_schemas_prefix = ignore_schemas_prefix
        if indexing_schedule is not None:
            request.indexing_schedule = indexing_schedule

        return await self._unary_unary(
            "/com.bigeye.models.generated.SourceService/ValidateSource",
            request,
            SourceValidationResponse,
        )

    async def create_or_update_source(
        self,
        *,
        id: int = 0,
        name: str = "",
        hostname: str = "",
        port: int = 0,
        database_name: str = "",
        database_type: "WarehouseType" = 0,
        domain: str = "",
        username: str = "",
        password: str = "",
        private_key_file: str = "",
        query_timeout_seconds: int = 0,
        skip_indexing: bool = False,
        alation_source_id: int = 0,
        atlan_connection_id: str = "",
        temporal_agent_secret: str = "",
        target_bigquery_project_id: str = "",
        bigquery_query_project_ids: str = "",
        workspace_id: int = 0,
        datadotworld_connection_id: str = "",
        source_metadata_overrides: Optional["SourceMetadataOverrides"] = None,
        max_pool_size: int = 0,
        auth_type: "AuthType" = 0,
        ignore_schemas_prefix: str = "",
        indexing_schedule: Optional["MetricSchedule"] = None,
    ) -> CreateSourceResponse:
        """Create or update source"""

        request = CreateSourceRequest()
        request.id = id
        request.name = name
        request.hostname = hostname
        request.port = port
        request.database_name = database_name
        request.database_type = database_type
        request.domain = domain
        request.username = username
        request.password = password
        request.private_key_file = private_key_file
        request.query_timeout_seconds = query_timeout_seconds
        request.skip_indexing = skip_indexing
        request.alation_source_id = alation_source_id
        request.atlan_connection_id = atlan_connection_id
        request.temporal_agent_secret = temporal_agent_secret
        request.target_bigquery_project_id = target_bigquery_project_id
        request.bigquery_query_project_ids = bigquery_query_project_ids
        request.workspace_id = workspace_id
        request.datadotworld_connection_id = datadotworld_connection_id
        if source_metadata_overrides is not None:
            request.source_metadata_overrides = source_metadata_overrides
        request.max_pool_size = max_pool_size
        request.auth_type = auth_type
        request.ignore_schemas_prefix = ignore_schemas_prefix
        if indexing_schedule is not None:
            request.indexing_schedule = indexing_schedule

        return await self._unary_unary(
            "/com.bigeye.models.generated.SourceService/CreateOrUpdateSource",
            request,
            CreateSourceResponse,
        )

    async def delete_source(self, *, source_id: int = 0) -> Empty:
        """Delete source"""

        request = SinglePathParamSourceIdRequest()
        request.source_id = source_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SourceService/DeleteSource",
            request,
            Empty,
        )

    async def get_source_workflow(self, *, source_id: int = 0) -> WorkflowResponse:
        """Get workflow for source"""

        request = SinglePathParamSourceIdRequest()
        request.source_id = source_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SourceService/GetSourceWorkflow",
            request,
            WorkflowResponse,
        )

    async def get_source_workflow_status(
        self, *, source_id: int = 0
    ) -> WorkflowStatusResponse:
        """Get the current status for a workflow for a source"""

        request = SinglePathParamSourceIdRequest()
        request.source_id = source_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SourceService/GetSourceWorkflowStatus",
            request,
            WorkflowStatusResponse,
        )

    async def set_metadata_schemas(
        self, *, source_id: int = 0, schema_name: List[str] = []
    ) -> Empty:
        """Set the schemas that automatically get metadata metrics"""

        request = MetadataSchemaRequest()
        request.source_id = source_id
        request.schema_name = schema_name

        return await self._unary_unary(
            "/com.bigeye.models.generated.SourceService/SetMetadataSchemas",
            request,
            Empty,
        )


class ConfigServiceStub(betterproto.ServiceStub):
    """Configs"""

    async def get_configs(self) -> GetConfigListResponse:
        """Get configs"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.ConfigService/GetConfigs",
            request,
            GetConfigListResponse,
        )

    async def update_configs(
        self, *, advanced_configs: List["ConfigValue"] = []
    ) -> GetConfigListResponse:
        """Update configs"""

        request = UpdateConfigRequest()
        if advanced_configs is not None:
            request.advanced_configs = advanced_configs

        return await self._unary_unary(
            "/com.bigeye.models.generated.ConfigService/UpdateConfigs",
            request,
            GetConfigListResponse,
        )


class CatalogRebuildsServiceStub(betterproto.ServiceStub):
    """Update catalog"""

    async def update_source(
        self, *, source_id: int = 0, request: Optional["RebuildSourceRequest"] = None
    ) -> WorkflowResponse:
        request = RebuildSourceRequestWrapper()
        request.source_id = source_id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.CatalogRebuildsService/UpdateSource",
            request,
            WorkflowResponse,
        )

    async def update_table(
        self, *, source_id: int = 0, schema_name: str = "", table_name: str = ""
    ) -> QueueSingleTableResponse:
        request = RebuildSingleTableRequest()
        request.source_id = source_id
        request.schema_name = schema_name
        request.table_name = table_name

        return await self._unary_unary(
            "/com.bigeye.models.generated.CatalogRebuildsService/UpdateTable",
            request,
            QueueSingleTableResponse,
        )

    async def fake_api1(self, *, priority: int = 0) -> WorkflowResponse:
        """
        need to use the non-wrapper requests and responses to make them
        generate
        """

        request = RebuildSourceRequest()
        request.priority = priority

        return await self._unary_unary(
            "/com.bigeye.models.generated.CatalogRebuildsService/FakeApi1",
            request,
            WorkflowResponse,
        )

    async def update_schema(
        self, *, schema_id: int = 0, request: Optional["RebuildSchemaRequest"] = None
    ) -> WorkflowResponse:
        request = RebuildSchemaRequestWrapper()
        request.schema_id = schema_id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.CatalogRebuildsService/UpdateSchema",
            request,
            WorkflowResponse,
        )

    async def fake_api2(self, *, priority: int = 0) -> WorkflowResponse:
        """
        need to use the non-wrapper requests and responses to make them
        generate
        """

        request = RebuildSchemaRequest()
        request.priority = priority

        return await self._unary_unary(
            "/com.bigeye.models.generated.CatalogRebuildsService/FakeApi2",
            request,
            WorkflowResponse,
        )


class WorkflowServiceStub(betterproto.ServiceStub):
    """Workflow"""

    async def get_workflow_status(
        self, *, workflow_id: int = 0
    ) -> WorkflowStatusResponse:
        """Get the current status for a workflow"""

        request = SinglePathParamWorkflowIdRequest()
        request.workflow_id = workflow_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.WorkflowService/GetWorkflowStatus",
            request,
            WorkflowStatusResponse,
        )


class VirtualTableServiceStub(betterproto.ServiceStub):
    """Virtual Tables"""

    async def create_virtual_table(
        self,
        *,
        name: str = "",
        sql: str = "",
        warehouse_id: int = 0,
        invoking_user: int = 0,
    ) -> VirtualTable:
        """Create a Virtual Table"""

        request = VirtualTableRequest()
        request.name = name
        request.sql = sql
        request.warehouse_id = warehouse_id
        request.invoking_user = invoking_user

        return await self._unary_unary(
            "/com.bigeye.models.generated.VirtualTableService/CreateVirtualTable",
            request,
            VirtualTable,
        )

    async def queue_create_virtual_table(
        self,
        *,
        name: str = "",
        sql: str = "",
        warehouse_id: int = 0,
        invoking_user: int = 0,
    ) -> VirtualTableWorkflowV2StatusResponse:
        """Queue creation of a Virtual Table"""

        request = VirtualTableRequest()
        request.name = name
        request.sql = sql
        request.warehouse_id = warehouse_id
        request.invoking_user = invoking_user

        return await self._unary_unary(
            "/com.bigeye.models.generated.VirtualTableService/QueueCreateVirtualTable",
            request,
            VirtualTableWorkflowV2StatusResponse,
        )

    async def get_virtual_table_create_status(
        self, *, workflow_id: str = "", run_id: str = ""
    ) -> VirtualTableWorkflowV2StatusResponse:
        """Get status of Virtual Table Creation workflow"""

        request = WorkflowV2Id()
        request.workflow_id = workflow_id
        request.run_id = run_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.VirtualTableService/GetVirtualTableCreateStatus",
            request,
            VirtualTableWorkflowV2StatusResponse,
        )

    async def update_virtual_table(
        self, *, id: int = 0, request: Optional["VirtualTableRequest"] = None
    ) -> VirtualTable:
        """Update a Virtual Table"""

        request = UpdateVirtualTableRequest()
        request.id = id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.VirtualTableService/UpdateVirtualTable",
            request,
            VirtualTable,
        )

    async def get_all_virtual_tables(
        self, *, workspace_id: int = 0
    ) -> VirtualTableList:
        """Get all Virtual Tables"""

        request = GetAllVirtualTablesRequest()
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.VirtualTableService/GetAllVirtualTables",
            request,
            VirtualTableList,
        )

    async def get_virtual_tables(
        self,
        *,
        source_ids: List[int] = [],
        schema_ids: List[int] = [],
        table_ids: List[int] = [],
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "VirtualTableSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        ignore_fields: bool = False,
        workspace_id: int = 0,
    ) -> GetVirtualTableListResponse:
        """Get Virtual Tables"""

        request = GetVirtualTableListRequest()
        request.source_ids = source_ids
        request.schema_ids = schema_ids
        request.table_ids = table_ids
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.ignore_fields = ignore_fields
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.VirtualTableService/GetVirtualTables",
            request,
            GetVirtualTableListResponse,
        )

    async def get_virtual_table(self, *, id: int = 0) -> VirtualTable:
        """Get a Virtual Table"""

        request = VirtualTableIdRequest()
        request.id = id

        return await self._unary_unary(
            "/com.bigeye.models.generated.VirtualTableService/GetVirtualTable",
            request,
            VirtualTable,
        )

    async def delete_virtual_table(self, *, id: int = 0) -> Empty:
        """Delete Virtual Table"""

        request = VirtualTableIdRequest()
        request.id = id

        return await self._unary_unary(
            "/com.bigeye.models.generated.VirtualTableService/DeleteVirtualTable",
            request,
            Empty,
        )


class LineageServiceStub(betterproto.ServiceStub):
    async def create_data_node(
        self,
        *,
        node_type: "DataNodeType" = 0,
        node_entity_id: int = 0,
        node_name: str = "",
        node_container_name: str = "",
        workspace_id: int = 0,
        rebuild_graph: bool = False,
        node_container_entity_id: int = 0,
    ) -> DataNode:
        request = CreateDataNodeRequest()
        request.node_type = node_type
        request.node_entity_id = node_entity_id
        request.node_name = node_name
        request.node_container_name = node_container_name
        request.workspace_id = workspace_id
        request.rebuild_graph = rebuild_graph
        request.node_container_entity_id = node_container_entity_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/CreateDataNode",
            request,
            DataNode,
        )

    async def get_data_node(self, *, data_node_id: int = 0) -> DataNode:
        request = SinglePathParamDataNodeIdRequest()
        request.data_node_id = data_node_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/GetDataNode",
            request,
            DataNode,
        )

    async def delete_data_node(self, *, data_node_id: int = 0) -> Empty:
        request = SinglePathParamDataNodeIdRequest()
        request.data_node_id = data_node_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/DeleteDataNode",
            request,
            Empty,
        )

    async def get_lineage_relationships_for_node(
        self, *, data_node_id: int = 0
    ) -> GetLineageRelationshipsForNodeResponse:
        request = SinglePathParamDataNodeIdRequest()
        request.data_node_id = data_node_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/GetLineageRelationshipsForNode",
            request,
            GetLineageRelationshipsForNodeResponse,
        )

    async def delete_lineage_relationships_for_node(
        self, *, data_node_id: int = 0
    ) -> DeleteLineageRelationshipsForNodeResponse:
        request = SinglePathParamDataNodeIdRequest()
        request.data_node_id = data_node_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/DeleteLineageRelationshipsForNode",
            request,
            DeleteLineageRelationshipsForNodeResponse,
        )

    async def create_lineage_relationship(
        self, *, upstream_data_node_id: int = 0, downstream_data_node_id: int = 0
    ) -> LineageRelationship:
        request = CreateLineageRelationshipRequest()
        request.upstream_data_node_id = upstream_data_node_id
        request.downstream_data_node_id = downstream_data_node_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/CreateLineageRelationship",
            request,
            LineageRelationship,
        )

    async def get_lineage_relationship(
        self, *, lineage_relationship_id: int = 0
    ) -> LineageRelationship:
        request = SinglePathParamLineageRelationshipIdRequest()
        request.lineage_relationship_id = lineage_relationship_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/GetLineageRelationship",
            request,
            LineageRelationship,
        )

    async def delete_lineage_relationship(
        self, *, lineage_relationship_id: int = 0
    ) -> Empty:
        request = SinglePathParamLineageRelationshipIdRequest()
        request.lineage_relationship_id = lineage_relationship_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/DeleteLineageRelationship",
            request,
            Empty,
        )

    async def queue_lineage_for_source(self, *, source_id: int = 0) -> WorkflowResponse:
        request = SinglePathParamSourceIdRequest()
        request.source_id = source_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/QueueLineageForSource",
            request,
            WorkflowResponse,
        )

    async def queue_lineage_for_integration(
        self, *, integration_id: int = 0
    ) -> WorkflowResponse:
        request = SinglePathParamIntegrationIdRequest()
        request.integration_id = integration_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/QueueLineageForIntegration",
            request,
            WorkflowResponse,
        )

    async def get_downstream_data_nodes(
        self,
        *,
        data_node_id: int = 0,
        request: Optional["GetDownstreamDataNodesRequest"] = None,
    ) -> GetDownstreamDataNodesResponse:
        request = GetDownstreamDataNodesRequestWrapper()
        request.data_node_id = data_node_id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/GetDownstreamDataNodes",
            request,
            GetDownstreamDataNodesResponse,
        )

    async def fake_api1(
        self,
        *,
        applicable_filters: List[str] = [],
        node_id_filters: List[int] = [],
        node_type_filters: List["DataNodeType"] = [],
    ) -> GetDownstreamDataNodesResponse:
        """
        need to use the non-wrapper requests and responses to make them
        generate
        """

        request = GetDownstreamDataNodesRequest()
        request.applicable_filters = applicable_filters
        request.node_id_filters = node_id_filters
        request.node_type_filters = node_type_filters

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageService/FakeApi1",
            request,
            GetDownstreamDataNodesResponse,
        )


class LineageV2ServiceStub(betterproto.ServiceStub):
    """Lineage V2 Service"""

    async def create_custom_lineage_node(
        self,
        *,
        node_type: "DataNodeType" = 0,
        node_entity_id: int = 0,
        node_name: str = "",
        workspace_id: int = 0,
        node_container_name: str = "",
        rebuild_graph: bool = False,
        icon_url: str = "",
        node_container_entity_id: int = 0,
        custom_repository_id: int = 0,
        custom_node_type_id: int = 0,
        external_id: str = "",
    ) -> LineageNodeV2:
        """Create custom lineage node"""

        request = CreateLineageNodeV2Request()
        request.node_type = node_type
        request.node_entity_id = node_entity_id
        request.node_name = node_name
        request.workspace_id = workspace_id
        request.node_container_name = node_container_name
        request.rebuild_graph = rebuild_graph
        request.icon_url = icon_url
        request.node_container_entity_id = node_container_entity_id
        request.custom_repository_id = custom_repository_id
        request.custom_node_type_id = custom_node_type_id
        request.external_id = external_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageV2Service/CreateCustomLineageNode",
            request,
            LineageNodeV2,
        )

    async def bulk_create_custom_lineage_nodes(
        self, *, nodes: List["CreateLineageNodeV2Request"] = []
    ) -> BulkResponse:
        """Bulk create custom lineage nodes"""

        request = CreateLineageNodeV2BulkRequest()
        if nodes is not None:
            request.nodes = nodes

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageV2Service/BulkCreateCustomLineageNodes",
            request,
            BulkResponse,
        )

    async def get_lineage_node(self, *, data_node_id: int = 0) -> LineageNodeV2:
        """Get lineage node by id"""

        request = SinglePathParamDataNodeIdRequest()
        request.data_node_id = data_node_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageV2Service/GetLineageNode",
            request,
            LineageNodeV2,
        )

    async def delete_lineage_node(self, *, data_node_id: int = 0) -> Empty:
        """Delete custom lineage node"""

        request = SinglePathParamDataNodeIdRequest()
        request.data_node_id = data_node_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageV2Service/DeleteLineageNode",
            request,
            Empty,
        )

    async def create_lineage_edge(
        self,
        *,
        upstream_data_node_id: int = 0,
        downstream_data_node_id: int = 0,
        relationship_type: "RelationshipType" = 0,
        rebuild_graph: bool = False,
    ) -> LineageEdgeV2:
        """Create custom lineage edge between two nodes"""

        request = CreateLineageEdgeV2Request()
        request.upstream_data_node_id = upstream_data_node_id
        request.downstream_data_node_id = downstream_data_node_id
        request.relationship_type = relationship_type
        request.rebuild_graph = rebuild_graph

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageV2Service/CreateLineageEdge",
            request,
            LineageEdgeV2,
        )

    async def bulk_create_lineage_edge(
        self, *, edges: List["CreateLineageEdgeV2Request"] = []
    ) -> BulkResponse:
        """Bulk create custom lineage edges"""

        request = CreateLineageEdgeV2BulkRequest()
        if edges is not None:
            request.edges = edges

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageV2Service/BulkCreateLineageEdge",
            request,
            BulkResponse,
        )

    async def get_lineage_edge(self, *, edge_id: int = 0) -> LineageEdgeV2:
        """Get edge"""

        request = SinglePathParamEdgeIdRequest()
        request.edge_id = edge_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageV2Service/GetLineageEdge",
            request,
            LineageEdgeV2,
        )

    async def delete_lineage_edge(self, *, edge_id: int = 0) -> Empty:
        """Delete custom lineage edge"""

        request = SinglePathParamEdgeIdRequest()
        request.edge_id = edge_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageV2Service/DeleteLineageEdge",
            request,
            Empty,
        )

    async def get_lineage_graph_for_node(
        self,
        *,
        data_node_id: int = 0,
        depth: int = 0,
        direction: "LineageDirection" = 0,
    ) -> TableLineageV2Response:
        """Get lineage graph from a data node"""

        request = LineageV2GraphRequest()
        request.data_node_id = data_node_id
        request.depth = depth
        request.direction = direction

        return await self._unary_unary(
            "/com.bigeye.models.generated.LineageV2Service/GetLineageGraphForNode",
            request,
            TableLineageV2Response,
        )


class IntegrationServiceStub(betterproto.ServiceStub):
    async def get_integrations(self) -> IntegrationsResponse:
        """Get integrations"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.IntegrationService/GetIntegrations",
            request,
            IntegrationsResponse,
        )

    async def create_integration(
        self,
        *,
        name: str = "",
        integration_partner: "IntegrationPartner" = 0,
        api_base_uri: str = "",
        api_port: int = 0,
        web_base_uri: str = "",
        web_port: int = 0,
        namespace: str = "",
        credentials_public: str = "",
        credentials_private: str = "",
        timeout: int = 0,
        workspace_id: int = 0,
    ) -> Integration:
        """Create integration"""

        request = CreateOrUpdateIntegrationRequest()
        request.name = name
        request.integration_partner = integration_partner
        request.api_base_uri = api_base_uri
        request.api_port = api_port
        request.web_base_uri = web_base_uri
        request.web_port = web_port
        request.namespace = namespace
        request.credentials_public = credentials_public
        request.credentials_private = credentials_private
        request.timeout = timeout
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.IntegrationService/CreateIntegration",
            request,
            Integration,
        )

    async def get_integration(self, *, integration_id: int = 0) -> Integration:
        """Get single integration"""

        request = SinglePathParamIntegrationIdRequest()
        request.integration_id = integration_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.IntegrationService/GetIntegration",
            request,
            Integration,
        )

    async def update_integration(
        self,
        *,
        integration_id: int = 0,
        request: Optional["CreateOrUpdateIntegrationRequest"] = None,
    ) -> Integration:
        """Update integration"""

        request = UpdateIntegrationRequestWrapper()
        request.integration_id = integration_id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.IntegrationService/UpdateIntegration",
            request,
            Integration,
        )

    async def delete_integration(self, *, integration_id: int = 0) -> Empty:
        """Delete integration"""

        request = SinglePathParamIntegrationIdRequest()
        request.integration_id = integration_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.IntegrationService/DeleteIntegration",
            request,
            Empty,
        )

    async def get_entities_for_integration(
        self, *, integration_id: int = 0
    ) -> GetIntegrationEntitiesResponse:
        """Get entities for integration"""

        request = SinglePathParamIntegrationIdRequest()
        request.integration_id = integration_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.IntegrationService/GetEntitiesForIntegration",
            request,
            GetIntegrationEntitiesResponse,
        )

    async def get_tableau_workbook(
        self, *, tableau_workbook_id: int = 0
    ) -> TableauWorkbook:
        """Get single Tableau workbook"""

        request = SinglePathParamTableauWorkbookIdRequest()
        request.tableau_workbook_id = tableau_workbook_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.IntegrationService/GetTableauWorkbook",
            request,
            TableauWorkbook,
        )

    async def get_dbt_project(self, *, dbt_project_id: int = 0) -> DbtProject:
        """Get single dbt project"""

        request = SinglePathParamDbtProjectIdRequest()
        request.dbt_project_id = dbt_project_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.IntegrationService/GetDbtProject",
            request,
            DbtProject,
        )

    async def get_dbt_jobs_for_project(
        self, *, dbt_project_id: int = 0
    ) -> GetDbtJobsResponse:
        """Get dbt jobs for project"""

        request = SinglePathParamDbtProjectIdRequest()
        request.dbt_project_id = dbt_project_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.IntegrationService/GetDbtJobsForProject",
            request,
            GetDbtJobsResponse,
        )

    async def get_dbt_job(self, *, dbt_job_id: int = 0) -> GetDbtJobResponse:
        """Get single dbt job"""

        request = SinglePathParamDbtJobIdRequest()
        request.dbt_job_id = dbt_job_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.IntegrationService/GetDbtJob",
            request,
            GetDbtJobResponse,
        )

    async def get_dbt_job_run_response(
        self, *, dbt_job_run_id: int = 0
    ) -> DbtJobRunResponse:
        """Get single dbt job run"""

        request = SinglePathParamDbtJobRunIdRequest()
        request.dbt_job_run_id = dbt_job_run_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.IntegrationService/GetDbtJobRunResponse",
            request,
            DbtJobRunResponse,
        )


class FavoriteServiceStub(betterproto.ServiceStub):
    async def get_favorites(self, *, workspace_id: int = 0) -> FavoriteListResponse:
        request = GetFavoritesRequest()
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.FavoriteService/GetFavorites",
            request,
            FavoriteListResponse,
        )

    async def favorite(self, *, favorite: Optional["FavoriteItem"] = None) -> Empty:
        request = FavoriteRequest()
        if favorite is not None:
            request.favorite = favorite

        return await self._unary_unary(
            "/com.bigeye.models.generated.FavoriteService/Favorite",
            request,
            Empty,
        )

    async def bulk_favorite(
        self, *, favorites: List["FavoriteItem"] = []
    ) -> BulkFavoriteResponse:
        request = BulkFavoriteRequest()
        if favorites is not None:
            request.favorites = favorites

        return await self._unary_unary(
            "/com.bigeye.models.generated.FavoriteService/BulkFavorite",
            request,
            BulkFavoriteResponse,
        )

    async def unfavorite(self, *, favorite: Optional["FavoriteItem"] = None) -> Empty:
        request = FavoriteRequest()
        if favorite is not None:
            request.favorite = favorite

        return await self._unary_unary(
            "/com.bigeye.models.generated.FavoriteService/Unfavorite",
            request,
            Empty,
        )

    async def bulk_unfavorite(
        self, *, favorites: List["FavoriteItem"] = []
    ) -> BulkFavoriteResponse:
        request = BulkFavoriteRequest()
        if favorites is not None:
            request.favorites = favorites

        return await self._unary_unary(
            "/com.bigeye.models.generated.FavoriteService/BulkUnfavorite",
            request,
            BulkFavoriteResponse,
        )


class TagServiceStub(betterproto.ServiceStub):
    async def get_tags(
        self, *, entity_type: "TaggableEntityType" = 0, entity_id: int = 0
    ) -> TagList:
        request = GetTagRequest()
        request.entity_type = entity_type
        request.entity_id = entity_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.TagService/GetTags",
            request,
            TagList,
        )

    async def tag(
        self,
        *,
        tag: Optional["TagItem"] = None,
        create_tag_if_does_not_exist: bool = False,
    ) -> Empty:
        request = TagRequest()
        if tag is not None:
            request.tag = tag
        request.create_tag_if_does_not_exist = create_tag_if_does_not_exist

        return await self._unary_unary(
            "/com.bigeye.models.generated.TagService/Tag",
            request,
            Empty,
        )

    async def bulk_tag(self, *, tags: List["TagItem"] = []) -> BulkTagResponse:
        request = BulkTagRequest()
        if tags is not None:
            request.tags = tags

        return await self._unary_unary(
            "/com.bigeye.models.generated.TagService/BulkTag",
            request,
            BulkTagResponse,
        )

    async def untag(
        self,
        *,
        tag: Optional["TagItem"] = None,
        create_tag_if_does_not_exist: bool = False,
    ) -> Empty:
        request = TagRequest()
        if tag is not None:
            request.tag = tag
        request.create_tag_if_does_not_exist = create_tag_if_does_not_exist

        return await self._unary_unary(
            "/com.bigeye.models.generated.TagService/Untag",
            request,
            Empty,
        )

    async def bulk_untag(self, *, tags: List["TagItem"] = []) -> BulkTagResponse:
        request = BulkTagRequest()
        if tags is not None:
            request.tags = tags

        return await self._unary_unary(
            "/com.bigeye.models.generated.TagService/BulkUntag",
            request,
            BulkTagResponse,
        )


class SchemaChangeServiceStub(betterproto.ServiceStub):
    async def get_schema_changes(
        self,
        *,
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "SchemaChangeSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        source_id: int = 0,
        schema_id: int = 0,
        table_id: int = 0,
        column_id: int = 0,
        workspace_id: int = 0,
    ) -> GetSchemaChangesResponse:
        request = GetSchemaChangesRequest()
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.source_id = source_id
        request.schema_id = schema_id
        request.table_id = table_id
        request.column_id = column_id
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.SchemaChangeService/GetSchemaChanges",
            request,
            GetSchemaChangesResponse,
        )


class DeltaServiceStub(betterproto.ServiceStub):
    async def get_delta(self, *, delta_id: int = 0) -> Delta:
        request = DeltaIdRequest()
        request.delta_id = delta_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltaService/GetDelta",
            request,
            Delta,
        )

    async def run_delta(self, *, delta_id: int = 0) -> RunDeltaResponse:
        request = DeltaIdRequest()
        request.delta_id = delta_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltaService/RunDelta",
            request,
            RunDeltaResponse,
        )

    async def create_delta(
        self, *, delta: Optional["Delta"] = None, workspace_id: int = 0
    ) -> UpsertDeltaResponse:
        request = UpsertDeltaRequest()
        if delta is not None:
            request.delta = delta
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltaService/CreateDelta",
            request,
            UpsertDeltaResponse,
        )

    async def bulk_operation_deltas(
        self,
        *,
        where: Optional["WhereClause"] = None,
        is_run: bool = False,
        edit_request: Optional["TableComparisonBatchEditRequest"] = None,
        is_delete: bool = False,
    ) -> BulkResponse:
        request = BulkDeltaOperation()
        if where is not None:
            request.where = where
        request.is_run = is_run
        if edit_request is not None:
            request.edit_request = edit_request
        request.is_delete = is_delete

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltaService/BulkOperationDeltas",
            request,
            BulkResponse,
        )

    async def edit_delta(
        self, *, delta: Optional["Delta"] = None, workspace_id: int = 0
    ) -> UpsertDeltaResponse:
        request = UpsertDeltaRequest()
        if delta is not None:
            request.delta = delta
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltaService/EditDelta",
            request,
            UpsertDeltaResponse,
        )

    async def delete_delta(self, *, delta_id: int = 0) -> Empty:
        request = DeltaIdRequest()
        request.delta_id = delta_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltaService/DeleteDelta",
            request,
            Empty,
        )

    async def fetch_deltas(
        self,
        *,
        comparison_table_ids: List[int] = [],
        exclude_comparison_metrics: bool = False,
        page_size: int = 0,
        page_cursor: str = "",
        sort_field: "ComparisonTableSortField" = 0,
        sort_direction: "SortDirection" = 0,
        search: str = "",
        workspace_id: int = 0,
        tag_ids: List[int] = [],
        dimension_ids: List[int] = [],
        delta_types: List["DeltaType"] = [],
    ) -> GetDeltaInfosResponse:
        request = GetComparisonTableInfosRequest()
        request.comparison_table_ids = comparison_table_ids
        request.exclude_comparison_metrics = exclude_comparison_metrics
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.sort_field = sort_field
        request.sort_direction = sort_direction
        request.search = search
        request.workspace_id = workspace_id
        request.tag_ids = tag_ids
        request.dimension_ids = dimension_ids
        request.delta_types = delta_types

        return await self._unary_unary(
            "/com.bigeye.models.generated.DeltaService/FetchDeltas",
            request,
            GetDeltaInfosResponse,
        )


class ApiKeyServiceStub(betterproto.ServiceStub):
    """API Keys"""

    async def get_all_personal_api_keys(self) -> ListPersonalApiKeyResponse:
        """Get all Personal API Keys"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.ApiKeyService/GetAllPersonalApiKeys",
            request,
            ListPersonalApiKeyResponse,
        )

    async def create_personal_api_key(
        self, *, name: str = "", description: str = ""
    ) -> CreatePersonalApiKeyResponse:
        """Create a Personal API Key"""

        request = CreatePersonalApiKeyRequest()
        request.name = name
        request.description = description

        return await self._unary_unary(
            "/com.bigeye.models.generated.ApiKeyService/CreatePersonalApiKey",
            request,
            CreatePersonalApiKeyResponse,
        )

    async def delete_personal_api_key(self, *, api_key_id: int = 0) -> Empty:
        """Delete a Personal API Key"""

        request = SinglePathParamApiKeyIdRequest()
        request.api_key_id = api_key_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.ApiKeyService/DeletePersonalApiKey",
            request,
            Empty,
        )

    async def verify_personal_api_key(self) -> Empty:
        """Verify a Personal API Key"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.ApiKeyService/VerifyPersonalApiKey",
            request,
            Empty,
        )

    async def get_all_agent_api_keys(self) -> ListAgentApiKeyResponse:
        """Get all Agent API Keys"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.ApiKeyService/GetAllAgentApiKeys",
            request,
            ListAgentApiKeyResponse,
        )

    async def create_agent_api_key(
        self, *, name: str = "", description: str = "", type: "AgentApiKeyType" = 0
    ) -> CreateAgentApiKeyResponse:
        """Create an Agent API Key"""

        request = CreateAgentApiKeyRequest()
        request.name = name
        request.description = description
        request.type = type

        return await self._unary_unary(
            "/com.bigeye.models.generated.ApiKeyService/CreateAgentApiKey",
            request,
            CreateAgentApiKeyResponse,
        )

    async def delete_agent_api_key(self, *, api_key_id: int = 0) -> Empty:
        """Delete an Agent API Key"""

        request = SinglePathParamApiKeyIdRequest()
        request.api_key_id = api_key_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.ApiKeyService/DeleteAgentApiKey",
            request,
            Empty,
        )

    async def verify_agent_api_key(self) -> Empty:
        """Verify an Agent API Key"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.ApiKeyService/VerifyAgentApiKey",
            request,
            Empty,
        )


class AgentServiceStub(betterproto.ServiceStub):
    async def get_bigeye_public_key(self) -> PublicKeyMessage:
        """
        Get the public key the user's company Agent should use when sending
        messages to Bigeye
        """

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.AgentService/GetBigeyePublicKey",
            request,
            PublicKeyMessage,
        )

    async def get_company_public_key(self) -> PublicKeyMessage:
        """
        Get the public key Bigeye currently has for the user's company Agent
        """

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.AgentService/GetCompanyPublicKey",
            request,
            PublicKeyMessage,
        )

    async def set_company_public_key(self, *, public_key: str = "") -> PublicKeyMessage:
        """
        Set the public key Bigeye will use to encrypt messages to the user's
        company Agent
        """

        request = PublicKeyMessage()
        request.public_key = public_key

        return await self._unary_unary(
            "/com.bigeye.models.generated.AgentService/SetCompanyPublicKey",
            request,
            PublicKeyMessage,
        )

    async def validate_agent_for_source(
        self, *, source_id: int = 0
    ) -> SourceValidationResponse:
        """Validate that the agent is working for a given source"""

        request = SinglePathParamSourceIdRequest()
        request.source_id = source_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.AgentService/ValidateAgentForSource",
            request,
            SourceValidationResponse,
        )

    async def retrieve_agent_health(self) -> AgentHealthResponse:
        """Retrieve the latest health status of all agent sources"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.AgentService/RetrieveAgentHealth",
            request,
            AgentHealthResponse,
        )

    async def ping_agents(self) -> AgentHealthResponse:
        """Synchronously ping all agent sources for their health status"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.AgentService/PingAgents",
            request,
            AgentHealthResponse,
        )


class WorkspaceServiceStub(betterproto.ServiceStub):
    """Workspaces"""

    async def create_workspace(self, *, name: str = "") -> Workspace:
        """Create a workspace"""

        request = CreateOrUpdateWorkspaceRequest()
        request.name = name

        return await self._unary_unary(
            "/com.bigeye.models.generated.WorkspaceService/CreateWorkspace",
            request,
            Workspace,
        )

    async def get_all_workspaces(self) -> WorkspaceListResponse:
        """Get all workspaces"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.WorkspaceService/GetAllWorkspaces",
            request,
            WorkspaceListResponse,
        )

    async def get_workspace(self, *, workspace_id: int = 0) -> Workspace:
        """Get a workspace"""

        request = SinglePathParamWorkspaceIdRequest()
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.WorkspaceService/GetWorkspace",
            request,
            Workspace,
        )

    async def update_workspace(
        self,
        *,
        workspace_id: int = 0,
        request: Optional["CreateOrUpdateWorkspaceRequest"] = None,
    ) -> Workspace:
        """Update a workspace"""

        request = UpdateWorkspaceRequestWrapper()
        request.workspace_id = workspace_id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.WorkspaceService/UpdateWorkspace",
            request,
            Workspace,
        )

    async def delete_workspace(self, *, workspace_id: int = 0) -> Empty:
        """Delete a workspace"""

        request = SinglePathParamWorkspaceIdRequest()
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.WorkspaceService/DeleteWorkspace",
            request,
            Empty,
        )

    async def get_workspace_accessors(
        self, *, workspace_id: int = 0
    ) -> GetWorkspaceAccessorsResponse:
        """List the groups and users who can access a workspace"""

        request = SinglePathParamWorkspaceIdRequest()
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.WorkspaceService/GetWorkspaceAccessors",
            request,
            GetWorkspaceAccessorsResponse,
        )

    async def set_default_workspace(self, *, workspace_id: int = 0) -> Workspace:
        """Set the default workspace"""

        request = SinglePathParamWorkspaceIdRequest()
        request.workspace_id = workspace_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.WorkspaceService/SetDefaultWorkspace",
            request,
            Workspace,
        )


class RoleServiceStub(betterproto.ServiceStub):
    """Roles"""

    async def get_all_roles(self) -> RoleV2ListResponse:
        """Get all roles"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.RoleService/GetAllRoles",
            request,
            RoleV2ListResponse,
        )

    async def get_role(self, *, role_id: int = 0) -> RoleV2:
        """Get a role"""

        request = SinglePathParamRoleIdRequest()
        request.role_id = role_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.RoleService/GetRole",
            request,
            RoleV2,
        )

    async def create_role(
        self,
        *,
        name: str = "",
        description: str = "",
        base_role: "RoleType" = 0,
        role_permissions: List["RolePermission"] = [],
    ) -> RoleV2:
        """Create a role"""

        request = CreateOrUpdateRoleRequest()
        request.name = name
        request.description = description
        request.base_role = base_role
        if role_permissions is not None:
            request.role_permissions = role_permissions

        return await self._unary_unary(
            "/com.bigeye.models.generated.RoleService/CreateRole",
            request,
            RoleV2,
        )

    async def update_role(
        self, *, id: int = 0, request: Optional["CreateOrUpdateRoleRequest"] = None
    ) -> RoleV2:
        """Update a role"""

        request = UpdateRoleRequestWrapper()
        request.id = id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.RoleService/UpdateRole",
            request,
            RoleV2,
        )

    async def delete_role(self, *, role_id: int = 0) -> Empty:
        """Delete a role"""

        request = SinglePathParamRoleIdRequest()
        request.role_id = role_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.RoleService/DeleteRole",
            request,
            Empty,
        )

    async def get_role_accessors(self, *, role_id: int = 0) -> GetRoleAccessorsResponse:
        """List the groups and users who have been granted a role"""

        request = SinglePathParamRoleIdRequest()
        request.role_id = role_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.RoleService/GetRoleAccessors",
            request,
            GetRoleAccessorsResponse,
        )


class CustomRuleServiceStub(betterproto.ServiceStub):
    """Custom Rules"""

    async def create_custom_rule(
        self, *, custom_rule: Optional["CustomRule"] = None
    ) -> CustomRuleInfo:
        """Create a custom rule"""

        request = CreateCustomRuleRequest()
        if custom_rule is not None:
            request.custom_rule = custom_rule

        return await self._unary_unary(
            "/com.bigeye.models.generated.CustomRuleService/CreateCustomRule",
            request,
            CustomRuleInfo,
        )

    async def update_custom_rule(
        self, *, id: int = 0, custom_rule: Optional["CustomRule"] = None
    ) -> CustomRuleInfo:
        """Update a custom rule"""

        request = UpdateCustomRuleRequest()
        request.id = id
        if custom_rule is not None:
            request.custom_rule = custom_rule

        return await self._unary_unary(
            "/com.bigeye.models.generated.CustomRuleService/UpdateCustomRule",
            request,
            CustomRuleInfo,
        )

    async def get_custom_rule(self, *, custom_rule_id: int = 0) -> CustomRuleInfo:
        """Get a custom rule"""

        request = SinglePathParamCustomRuleIdRequest()
        request.custom_rule_id = custom_rule_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CustomRuleService/GetCustomRule",
            request,
            CustomRuleInfo,
        )

    async def run_custom_rule(self, *, custom_rule_id: int = 0) -> CustomRuleInfo:
        """Run a custom rule"""

        request = SinglePathParamCustomRuleIdRequest()
        request.custom_rule_id = custom_rule_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CustomRuleService/RunCustomRule",
            request,
            CustomRuleInfo,
        )

    async def delete_custom_rule(self, *, custom_rule_id: int = 0) -> Empty:
        """Delete a custom rule"""

        request = SinglePathParamCustomRuleIdRequest()
        request.custom_rule_id = custom_rule_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CustomRuleService/DeleteCustomRule",
            request,
            Empty,
        )

    async def get_custom_rules_for_collection(
        self, *, collection_id: int = 0
    ) -> GetCustomRuleListResponse:
        """Get all custom rules for a collection"""

        request = SinglePathParamCollectionIdRequest()
        request.collection_id = collection_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CustomRuleService/GetCustomRulesForCollection",
            request,
            GetCustomRuleListResponse,
        )

    async def get_custom_rules_for_warehouse(
        self, *, warehouse_id: int = 0
    ) -> GetCustomRuleListResponse:
        """Get all custom rules for a warehouse"""

        request = SinglePathParamWarehouseIdRequest()
        request.warehouse_id = warehouse_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CustomRuleService/GetCustomRulesForWarehouse",
            request,
            GetCustomRuleListResponse,
        )

    async def get_custom_rules(
        self,
        *,
        search: str = "",
        sort_option: List["CustomRuleSortOption"] = [],
        page_size: int = 0,
        page_cursor: str = "",
        source_id: int = 0,
        schema_id: int = 0,
        table_id: int = 0,
        column_id: int = 0,
        collection_id: int = 0,
        join_id: int = 0,
        rule_types: List["CustomRuleType"] = [],
        dimension_ids: List[int] = [],
        workspace_id: int = 0,
        tag_ids: List[int] = [],
    ) -> GetCustomRuleListResponse:
        """Get custom rules"""

        request = GetCustomRuleListRequest()
        request.search = search
        if sort_option is not None:
            request.sort_option = sort_option
        request.page_size = page_size
        request.page_cursor = page_cursor
        request.source_id = source_id
        request.schema_id = schema_id
        request.table_id = table_id
        request.column_id = column_id
        request.collection_id = collection_id
        request.join_id = join_id
        request.rule_types = rule_types
        request.dimension_ids = dimension_ids
        request.workspace_id = workspace_id
        request.tag_ids = tag_ids

        return await self._unary_unary(
            "/com.bigeye.models.generated.CustomRuleService/GetCustomRules",
            request,
            GetCustomRuleListResponse,
        )

    async def get_custom_rule_revisions(
        self, *, custom_rule_id: int = 0
    ) -> GetCustomRuleRevisionsResponse:
        """Get custom rule revisions"""

        request = SinglePathParamCustomRuleIdRequest()
        request.custom_rule_id = custom_rule_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.CustomRuleService/GetCustomRuleRevisions",
            request,
            GetCustomRuleRevisionsResponse,
        )


class GroupServiceStub(betterproto.ServiceStub):
    """Groups"""

    async def create_group(
        self, *, name: str = "", idp_groups: List[str] = []
    ) -> Group:
        """Create a group"""

        request = CreateOrUpdateGroupRequest()
        request.name = name
        request.idp_groups = idp_groups

        return await self._unary_unary(
            "/com.bigeye.models.generated.GroupService/CreateGroup",
            request,
            Group,
        )

    async def get_all_groups(self) -> GroupListResponse:
        """Get all groups"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.GroupService/GetAllGroups",
            request,
            GroupListResponse,
        )

    async def get_group(self, *, group_id: int = 0) -> Group:
        """Get a group"""

        request = SinglePathParamGroupIdRequest()
        request.group_id = group_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.GroupService/GetGroup",
            request,
            Group,
        )

    async def update_group(
        self,
        *,
        group_id: int = 0,
        request: Optional["CreateOrUpdateGroupRequest"] = None,
    ) -> Group:
        """Update a group"""

        request = UpdateGroupRequestWrapper()
        request.group_id = group_id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.GroupService/UpdateGroup",
            request,
            Group,
        )

    async def delete_group(self, *, group_id: int = 0) -> Empty:
        """Delete a group"""

        request = SinglePathParamGroupIdRequest()
        request.group_id = group_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.GroupService/DeleteGroup",
            request,
            Empty,
        )

    async def bulk_change_group_grants(
        self, *, operation: "RoleOperation" = 0, requests: List["Grant"] = []
    ) -> BulkChangeGroupGrantsResponse:
        """Change a group's access to workspaces"""

        request = BulkChangeGroupGrantsRequest()
        request.operation = operation
        if requests is not None:
            request.requests = requests

        return await self._unary_unary(
            "/com.bigeye.models.generated.GroupService/BulkChangeGroupGrants",
            request,
            BulkChangeGroupGrantsResponse,
        )

    async def bulk_change_group_users(
        self,
        *,
        user_ids: List[int] = [],
        group_ids: List[int] = [],
        operation: "GroupUserOperation" = 0,
    ) -> BulkChangeGroupUsersResponse:
        """Add or remove users to a group"""

        request = BulkChangeGroupUsersRequest()
        request.user_ids = user_ids
        request.group_ids = group_ids
        request.operation = operation

        return await self._unary_unary(
            "/com.bigeye.models.generated.GroupService/BulkChangeGroupUsers",
            request,
            BulkChangeGroupUsersResponse,
        )


class UserServiceStub(betterproto.ServiceStub):
    """Users"""

    async def get_all_users(self) -> GetUserListResponse:
        """Get all users"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.UserService/GetAllUsers",
            request,
            GetUserListResponse,
        )

    async def get_user(self, *, user_id: int = 0) -> User:
        """Get a user"""

        request = SinglePathParamUserIdRequest()
        request.user_id = user_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.UserService/GetUser",
            request,
            User,
        )

    async def invite_new_user(
        self, *, name: str = "", email: str = "", group_ids: List[int] = []
    ) -> User:
        """Invite a new user"""

        request = UserInviteRequest()
        request.name = name
        request.email = email
        request.group_ids = group_ids

        return await self._unary_unary(
            "/com.bigeye.models.generated.UserService/InviteNewUser",
            request,
            User,
        )

    async def bulk_delete_users(self, *, user_ids: List[int] = []) -> BulkResponse:
        """Delete users"""

        request = BulkDeleteUsersRequest()
        request.user_ids = user_ids

        return await self._unary_unary(
            "/com.bigeye.models.generated.UserService/BulkDeleteUsers",
            request,
            BulkResponse,
        )

    async def update_user(
        self, *, user_id: int = 0, request: Optional["UpdateUserRequest"] = None
    ) -> UpdateUserResponse:
        """Update user name and/or groups"""

        request = UpdateUserRequestWrapper()
        request.user_id = user_id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.UserService/UpdateUser",
            request,
            UpdateUserResponse,
        )

    async def fake_update_user(
        self, *, name: str = "", group_ids: List[int] = []
    ) -> Empty:
        """fake api is required for the wrapper container"""

        request = UpdateUserRequest()
        request.name = name
        request.group_ids = group_ids

        return await self._unary_unary(
            "/com.bigeye.models.generated.UserService/FakeUpdateUser",
            request,
            Empty,
        )


class WorkflowV2ServiceStub(betterproto.ServiceStub):
    async def get_workflow_v2_status(
        self, *, workflow_id: str = "", run_id: str = ""
    ) -> WorkflowV2StatusResponse:
        """Get status for V2 workflow and run"""

        request = WorkflowV2Id()
        request.workflow_id = workflow_id
        request.run_id = run_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.WorkflowV2Service/GetWorkflowV2Status",
            request,
            WorkflowV2StatusResponse,
        )

    async def get_workflow_v2_status_without_run(
        self, *, workflow_id: str = "", run_id: str = ""
    ) -> WorkflowV2StatusResponse:
        """Get status for V2 workflow without run"""

        request = WorkflowV2Id()
        request.workflow_id = workflow_id
        request.run_id = run_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.WorkflowV2Service/GetWorkflowV2StatusWithoutRun",
            request,
            WorkflowV2StatusResponse,
        )


class DashboardServiceStub(betterproto.ServiceStub):
    async def get_dashboard_data_series(
        self,
        *,
        company_id: int = 0,
        workspace_ids: List[int] = [],
        source_ids: List[int] = [],
        starting_timestamp: int = 0,
        ending_timestamp: int = 0,
        data_point_types: List["DashboardDataPointType"] = [],
        aggregation_type: "DashboardDateAggregationType" = 0,
    ) -> DashboardDataPointsResponse:
        """Get dashboard data series for requested types"""

        request = DashboardDataPointsRequest()
        request.company_id = company_id
        request.workspace_ids = workspace_ids
        request.source_ids = source_ids
        request.starting_timestamp = starting_timestamp
        request.ending_timestamp = ending_timestamp
        request.data_point_types = data_point_types
        request.aggregation_type = aggregation_type

        return await self._unary_unary(
            "/com.bigeye.models.generated.DashboardService/GetDashboardDataSeries",
            request,
            DashboardDataPointsResponse,
        )

    async def get_dashboard_data_refresh_info(
        self,
        *,
        company_id: int = 0,
        workspace_ids: List[int] = [],
        source_ids: List[int] = [],
        starting_timestamp: int = 0,
        ending_timestamp: int = 0,
    ) -> DashboardRefreshInfoResponse:
        """Gets last updated date for dashboard data series"""

        request = DashboardRefreshInfoRequest()
        request.company_id = company_id
        request.workspace_ids = workspace_ids
        request.source_ids = source_ids
        request.starting_timestamp = starting_timestamp
        request.ending_timestamp = ending_timestamp

        return await self._unary_unary(
            "/com.bigeye.models.generated.DashboardService/GetDashboardDataRefreshInfo",
            request,
            DashboardRefreshInfoResponse,
        )


class CompanyServiceStub(betterproto.ServiceStub):
    """Companies"""

    async def update_company(
        self, *, company_id: int = 0, request: Optional["UpdateCompanyRequest"] = None
    ) -> Company:
        """Update a company"""

        request = UpdateCompanyRequestWrapper()
        request.company_id = company_id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.CompanyService/UpdateCompany",
            request,
            Company,
        )

    async def fake_update_company(self, *, name: str = "") -> Empty:
        """fake api is required for the wrapper container"""

        request = UpdateCompanyRequest()
        request.name = name

        return await self._unary_unary(
            "/com.bigeye.models.generated.CompanyService/FakeUpdateCompany",
            request,
            Empty,
        )


class ObjectOwnerServiceStub(betterproto.ServiceStub):
    async def get_object_owner(
        self, *, ownable_type: str = "", ownable_id: int = 0
    ) -> ObjectOwnerResponse:
        """Get object owner"""

        request = GetObjectOwnerRequest()
        request.ownable_type = ownable_type
        request.ownable_id = ownable_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.ObjectOwnerService/GetObjectOwner",
            request,
            ObjectOwnerResponse,
        )

    async def set_object_owner(
        self, *, ownable_type: "OwnableType" = 0, ownable_id: int = 0, owner: int = 0
    ) -> ObjectOwnerResponse:
        """Set object owner"""

        request = SetObjectOwnerRequest()
        request.ownable_type = ownable_type
        request.ownable_id = ownable_id
        request.owner = owner

        return await self._unary_unary(
            "/com.bigeye.models.generated.ObjectOwnerService/SetObjectOwner",
            request,
            ObjectOwnerResponse,
        )

    async def delete_object_owner(
        self, *, ownable_type: str = "", ownable_id: int = 0
    ) -> ObjectOwnerResponse:
        """Delete object owner"""

        request = DeleteObjectOwnerRequest()
        request.ownable_type = ownable_type
        request.ownable_id = ownable_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.ObjectOwnerService/DeleteObjectOwner",
            request,
            ObjectOwnerResponse,
        )


class JoinServiceStub(betterproto.ServiceStub):
    async def create_join(
        self,
        *,
        left_table_id: int = 0,
        right_table_id: int = 0,
        key_columns: List["JoinColumnIdPairing"] = [],
        left_filter: Optional["JoinTableFilter"] = None,
        right_filter: Optional["JoinTableFilter"] = None,
    ) -> CreateOrUpdateJoinResponse:
        """Create join"""

        request = CreateOrUpdateJoinRequest()
        request.left_table_id = left_table_id
        request.right_table_id = right_table_id
        if key_columns is not None:
            request.key_columns = key_columns
        if left_filter is not None:
            request.left_filter = left_filter
        if right_filter is not None:
            request.right_filter = right_filter

        return await self._unary_unary(
            "/com.bigeye.models.generated.JoinService/CreateJoin",
            request,
            CreateOrUpdateJoinResponse,
        )

    async def get_join(self, *, join_id: int = 0) -> Join:
        """Get join"""

        request = SinglePathParamJoinIdRequest()
        request.join_id = join_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.JoinService/GetJoin",
            request,
            Join,
        )

    async def get_joins(
        self,
        *,
        source_id: int = 0,
        schema_id: int = 0,
        table_id: int = 0,
        column_id: int = 0,
        search: str = "",
        sort_option: List["JoinSortOption"] = [],
        page_size: int = 0,
        page_cursor: str = "",
    ) -> GetJoinsResponse:
        """Get joins"""

        request = GetJoinsRequest()
        request.source_id = source_id
        request.schema_id = schema_id
        request.table_id = table_id
        request.column_id = column_id
        request.search = search
        if sort_option is not None:
            request.sort_option = sort_option
        request.page_size = page_size
        request.page_cursor = page_cursor

        return await self._unary_unary(
            "/com.bigeye.models.generated.JoinService/GetJoins",
            request,
            GetJoinsResponse,
        )

    async def update_join(
        self, *, join_id: int = 0, request: Optional["CreateOrUpdateJoinRequest"] = None
    ) -> CreateOrUpdateJoinResponse:
        """Update join"""

        request = CreateOrUpdateJoinRequestWrapper()
        request.join_id = join_id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.JoinService/UpdateJoin",
            request,
            CreateOrUpdateJoinResponse,
        )

    async def delete_join(self, *, join_id: int = 0) -> Empty:
        """Delete join"""

        request = SinglePathParamJoinIdRequest()
        request.join_id = join_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.JoinService/DeleteJoin",
            request,
            Empty,
        )


class DimensionServiceStub(betterproto.ServiceStub):
    async def create_dimension(
        self,
        *,
        id: int = 0,
        name: str = "",
        top_level_category: "TopLevelCategory" = 0,
        description: str = "",
    ) -> Dimension:
        """Create dimension"""

        request = UpsertDimensionRequest()
        request.id = id
        request.name = name
        request.top_level_category = top_level_category
        request.description = description

        return await self._unary_unary(
            "/com.bigeye.models.generated.DimensionService/CreateDimension",
            request,
            Dimension,
        )

    async def delete_dimension(self, *, dimension_id: int = 0) -> Empty:
        """Delete dimension"""

        request = SinglePathParamDimensionIdRequest()
        request.dimension_id = dimension_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DimensionService/DeleteDimension",
            request,
            Empty,
        )

    async def update_dimension(
        self,
        *,
        dimension_id: int = 0,
        request: Optional["UpsertDimensionRequest"] = None,
    ) -> Dimension:
        """Update dimension"""

        request = UpsertDimensionRequestWrapper()
        request.dimension_id = dimension_id
        if request is not None:
            request.request = request

        return await self._unary_unary(
            "/com.bigeye.models.generated.DimensionService/UpdateDimension",
            request,
            Dimension,
        )

    async def get_dimension(self, *, dimension_id: int = 0) -> Dimension:
        """Get dimension"""

        request = SinglePathParamDimensionIdRequest()
        request.dimension_id = dimension_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.DimensionService/GetDimension",
            request,
            Dimension,
        )

    async def get_dimensions(self) -> GetDimensionsListResponse:
        """Get all dimensions"""

        request = Empty()

        return await self._unary_unary(
            "/com.bigeye.models.generated.DimensionService/GetDimensions",
            request,
            GetDimensionsListResponse,
        )

    async def set_stat_dimension(
        self, *, dimension_id: int = 0, stat_name: str = ""
    ) -> StatDimension:
        """Assign statistic (e.g., "AVERAGE") to dimension"""

        request = UpsertStatDimensionRequest()
        request.dimension_id = dimension_id
        request.stat_name = stat_name

        return await self._unary_unary(
            "/com.bigeye.models.generated.DimensionService/SetStatDimension",
            request,
            StatDimension,
        )

    async def bulk_update_dimensions(
        self, *, requests: List["MoveDimensionRequest"] = []
    ) -> GetDimensionsListResponse:
        """Bulk update dimensions"""

        request = BulkMoveDimensionRequest()
        if requests is not None:
            request.requests = requests

        return await self._unary_unary(
            "/com.bigeye.models.generated.DimensionService/BulkUpdateDimensions",
            request,
            GetDimensionsListResponse,
        )


class MetricObservedColumnServiceStub(betterproto.ServiceStub):
    """Metric Observed Columns"""

    async def create_metric_observed_column(
        self, *, column_id: int = 0, metric_id: int = 0, comments: str = ""
    ) -> MetricObservedColumnResponse:
        """
        Create a metric observed column relationship This endpoint creates a
        relationship between a metric and a column that the metric observes
        """

        request = MetricObservedColumnRequest()
        request.column_id = column_id
        request.metric_id = metric_id
        request.comments = comments

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricObservedColumnService/CreateMetricObservedColumn",
            request,
            MetricObservedColumnResponse,
        )

    async def delete_metric_observed_column(
        self, *, column_id: int = 0, metric_id: int = 0
    ) -> MetricObservedColumnResponse:
        """
        Delete a metric observed column relationship This endpoint removes the
        relationship between a metric and a column
        """

        request = DeleteMetricObservedColumnRequest()
        request.column_id = column_id
        request.metric_id = metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricObservedColumnService/DeleteMetricObservedColumn",
            request,
            MetricObservedColumnResponse,
        )

    async def get_metric_observed_columns_for_metric(
        self, *, metric_id: int = 0
    ) -> MetricObservedColumnListResponse:
        """
        Get metric observed columns for a specific metric Returns all columns
        that are observed by the specified metric, along with suggested columns
        """

        request = SinglePathParamMetricIdRequest()
        request.metric_id = metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricObservedColumnService/GetMetricObservedColumnsForMetric",
            request,
            MetricObservedColumnListResponse,
        )

    async def backfill_metric_observed_columns(self, *, metric_id: int = 0) -> Empty:
        """
        Backfill metric observed columns for a specific metric This endpoint
        automatically sets default observed columns for a metric based on its
        configuration
        """

        request = SinglePathParamMetricIdRequest()
        request.metric_id = metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricObservedColumnService/BackfillMetricObservedColumns",
            request,
            Empty,
        )

    async def get_metric_observed_columns_for_column(
        self, *, column_id: int = 0
    ) -> MetricObservedColumnListResponse:
        """
        Get metric observed columns for a specific column Returns all metrics
        that observe the specified column
        """

        request = SinglePathParamColumnIdRequest()
        request.column_id = column_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricObservedColumnService/GetMetricObservedColumnsForColumn",
            request,
            MetricObservedColumnListResponse,
        )

    async def get_metric_observed_columns_bulk(
        self,
        *,
        metric_ids: List[int] = [],
        column_ids: List[int] = [],
        table_ids: List[int] = [],
        schema_ids: List[int] = [],
        is_for_custom_rule: bool = False,
        remove_duplicate_metrics: bool = False,
        source_ids: List[int] = [],
        tag_ids: List[int] = [],
    ) -> MetricObservedColumnListResponse:
        """
        Get metric observed columns in bulk This endpoint allows fetching
        multiple metric observed column relationships based on various filters
        such as metric IDs, column IDs, table IDs, schema IDs, source IDs, and
        tag IDs
        """

        request = GetMetricObservedColumnBulkRequest()
        request.metric_ids = metric_ids
        request.column_ids = column_ids
        request.table_ids = table_ids
        request.schema_ids = schema_ids
        request.is_for_custom_rule = is_for_custom_rule
        request.remove_duplicate_metrics = remove_duplicate_metrics
        request.source_ids = source_ids
        request.tag_ids = tag_ids

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricObservedColumnService/GetMetricObservedColumnsBulk",
            request,
            MetricObservedColumnListResponse,
        )

    async def get_suggested_columns_for_metric(
        self, *, metric_id: int = 0
    ) -> GetColumnListResponse:
        """
        Get suggested columns for a metric Returns columns that are suggested
        to be observed by the specified metric based on its configuration
        """

        request = SinglePathParamMetricIdRequest()
        request.metric_id = metric_id

        return await self._unary_unary(
            "/com.bigeye.models.generated.MetricObservedColumnService/GetSuggestedColumnsForMetric",
            request,
            GetColumnListResponse,
        )
