## fastquadtree 2.0 Proposal

This document describes the breaking changes planned for fastquadtree v2.0. The goals are:

* A simpler, more predictable Python API
* Zero overhead for users who do not need object association
* First-class NumPy workflows without runtime type branching
* Safer, more explicit semantics around precision limits and serialization

---

## Target Audiences

* **New Python developers**: intuitive classes, predictable return types
* **Performance-focused users**: fastest possible hot paths, minimal memory overhead
* **Scientific users**: consistent NumPy I/O shapes and dtypes, clean data handling

---

## Overview of v2.0 Direction

v2.0 will:

* Split object association into dedicated "Objects" classes
* Remove mode-dependent return types (`track_objects`, `as_items`)
* Provide explicit NumPy APIs via `_np` methods (no runtime type detection)
* Simplify serialization and make object serialization explicit and opt-in

---

# Breaking Changes

## 1) Split Object Association into Separate Classes

### Current API

```python
qt = QuadTree(bounds, capacity, track_objects=True)   # or False
rqt = RectQuadTree(bounds, capacity, track_objects=True)  # or False
```

### New API

```python
# High performance spatial index (no object association)
qt = QuadTree(bounds, capacity)
rqt = RectQuadTree(bounds, capacity)

# Spatial index with Python object association
qt_obj = QuadTreeObjects(bounds, capacity)
rqt_obj = RectQuadTreeObjects(bounds, capacity)
```

### Naming rationale

| Class                 | Purpose                                   | Mental model                    |
| --------------------- | ----------------------------------------- | ------------------------------- |
| `QuadTree`            | Fast index for points                     | "store points with IDs"         |
| `QuadTreeObjects`     | Points with associated Python objects     | "points plus attached payloads" |
| `RectQuadTree`        | Fast index for rectangles                 | "store boxes with IDs"          |
| `RectQuadTreeObjects` | Rectangles with associated Python objects | "boxes plus attached payloads"  |

### Why this change

* Eliminates runtime branching and confusing toggles (`track_objects`, `as_items`)
* Keeps the fastest class as the default (`QuadTree`, `RectQuadTree`)
* Clear separation of capabilities and better typing

---

## 2) Predictable Query Return Types (No `as_items`)

### `QuadTree` (no objects)

```python
results = qt.query(rect)  # list[tuple[int, float, float]]

for id_, x, y in results:
    ...
```

### `QuadTreeObjects` (objects)

```python
results = qt_obj.query(rect)  # list[PointItem]

for item in results:
    print(item.id_, item.x, item.y, item.obj)

ids = qt_obj.query_ids(rect)  # list[int] fast path
```

### Impact

* Remove `as_items` everywhere
* If you previously used `as_items=True`, migrate to `QuadTreeObjects`
* If you previously used the default tuple output, stay on `QuadTree`

---

## 3) Explicit NumPy Methods (`_np`) Only

### Current behavior (v1)

* `insert_many` accepts list or ndarray and branches at runtime

### New behavior (v2)

```python
qt.insert_many([(x1, y1), (x2, y2)])  # Python sequences only
qt.insert_many_np(xy_array)           # NumPy only

qt.query(rect)                        # Python list output
ids, coords = qt.query_np(rect)        # NumPy output

ids, coords = qt.nearest_neighbors_np(point, k)
```

### Rules

* Passing a NumPy array into a non-`_np` method raises `TypeError`
* `_np` methods require NumPy installed (raise `ImportError` if missing)

### NumPy output guarantees

* `ids` is `np.uint64` with shape `(N,)`
* `coords` is `np.float32`, `np.float64`, `np.int32`, or `np.int64` matching `dtype`, shape `(N, 2)` for points and `(N, 4)` for rects

---

## 4) Improved Insertion API

### Single insertion with optional custom ID (non-Objects classes)

```python
id_ = qt.insert((x, y))           # auto-assigned ID
id_ = qt.insert((x, y), id_=42)   # custom ID
```

This allows users to correlate quadtree entries with external data structures (e.g., indices into a list or dataset) without the overhead of object association.

**Warning:** Mixing auto-assigned and custom IDs is dangerous. The quadtree does not track which IDs have been used. If you provide a custom ID that collides with an auto-assigned ID (or vice versa), both entries will exist in the tree with the same ID, leading to undefined behavior on deletion and update. Users who provide custom IDs are responsible for ensuring uniqueness.

### Bulk insertion with `InsertResult`

```python
result = qt.insert_many([(x1, y1), (x2, y2)])

result.count
result.start_id
result.end_id
```

IDs are contiguous in the inserted range: `[start_id, ..., end_id]`.

Bulk insertion does not support custom IDs. Use single `insert()` calls if you need custom IDs.

**Note:** For performance, `insert_many()` and `insert_many_np()` always append new items and do not reuse IDs from the free-list created by deletions. Use single `insert()` calls to fill holes in the ID space.

### Objects variants support payloads

```python
qt_obj.insert((x, y), obj=my_data)
qt_obj.insert_many(coords, objs=[obj1, obj2, ...])
```

`QuadTreeObjects` does **not** support custom IDs because it uses dense ID allocation internally for efficient object lookup.

### InsertResult

```python
@dataclass
class InsertResult:
    count: int
    start_id: int
    end_id: int

    @property
    def ids(self):
        return range(self.start_id, self.end_id + 1)
```

---

## 5) Deletion Semantics (and duplicates)

### Non-Objects classes require coordinates

```python
qt.delete(id_, x, y)
rqt.delete(id_, min_x, min_y, max_x, max_y)
```

### Objects classes can delete by id alone

```python
qt_obj.delete(id_)
rqt_obj.delete(id_)
```

### Location-based deletion for Objects variants

```python
qt_obj.delete_at(x, y)
```

**Duplicate points:** If multiple items exist at `(x, y)`, `delete_at(x, y)` deletes the lowest `id_` among matches. This is deterministic and documented.

### Object deletion semantics (identity, not equality)

```python
qt_obj.delete_by_object(obj)  # uses identity (is), deletes ALL matches
qt_obj.delete_one_by_object(obj)  # deletes one match (lowest id_)
```

Identity-based deletion avoids surprising behavior with `__eq__`, mutability, or duplicates.

**Duplicate object handling:** The same Python object can be inserted multiple times at different locations. The implementation tracks all IDs associated with each object:
- `delete_by_object(obj)` deletes **all items** with that object (by identity) and returns the count
- `delete_one_by_object(obj)` deletes **exactly one item** (deterministically: the one with the lowest ID)
- `by_obj()` internal lookups return the item with the **lowest ID** (deterministic)
- `attach()` correctly updates the reverse mapping when replacing objects

---

## 6) Remove `count_items()`, keep `len()` only

```python
n = len(qt)
```

---

## 7) Serialization: bytes-only, dtype encoded, objects opt-in and guarded

### New API

```python
data = qt.to_bytes()
qt2 = QuadTree.from_bytes(data)
```

### Objects trees

Object serialization is explicit and off by default.

```python
data = qt_obj.to_bytes(include_objects=False)      # default
data2 = qt_obj.to_bytes(include_objects=True)      # opt-in

qt_obj2 = QuadTreeObjects.from_bytes(data2, allow_objects=True)
```

### Safety notes

* Loading objects from bytes uses pickle-like semantics and is unsafe for untrusted data.
* `allow_objects` defaults to `False` to prevent accidental unsafe loads.

### Impact

* Remove `to_dict()`
* Remove `dtype=` from `from_bytes()`
* v2 serialization is not backward compatible with v1

---

# New Features (Non-breaking additions)

## `__contains__`

```python
if (10.0, 20.0) in qt:
    ...
```

Semantics with duplicates: membership is `True` if any item exists at that coordinate.

## Iteration

```python
for id_, x, y in qt:
    ...

for item in qt_obj:
    ...
```

## Moving items: efficient where possible

### Points

* `QuadTreeObjects.update(id_, new_x, new_y)` works efficiently (it knows old coords)
* `QuadTree.update(...)` must include old coords to avoid hidden scans

```python
qt.update(id_, old_x, old_y, new_x, new_y)
qt_obj.update(id_, new_x, new_y)
```

### Rectangles

```python
rqt.update(id_, old_min_x, old_min_y, old_max_x, old_max_y, new_min_x, new_min_y, new_max_x, new_max_y)
rqt_obj.update(id_, new_min_x, new_min_y, new_max_x, new_max_y)
```

This keeps performance promises intact for the non-Objects classes.

## `update_by_object` helper (Objects classes only)

Objects classes provide a convenience method to update an item by finding it via its associated object (by identity):

```python
qt_obj.update_by_object(obj, new_x, new_y)
rqt_obj.update_by_object(obj, new_min_x, new_min_y, new_max_x, new_max_y)
```

If multiple items have the same object, updates the one with the lowest ID.

Returns `True` if the item was found and updated, `False` otherwise.

---

# Migration Guide

## Step 1: Choose your class

| Old usage      | `track_objects` | New class             |
| -------------- | --------------- | --------------------- |
| `QuadTree`     | False           | `QuadTree`            |
| `QuadTree`     | True            | `QuadTreeObjects`     |
| `RectQuadTree` | False           | `RectQuadTree`        |
| `RectQuadTree` | True            | `RectQuadTreeObjects` |

## Step 2: Imports

```python
from fastquadtree import (
    QuadTree,
    QuadTreeObjects,
    RectQuadTree,
    RectQuadTreeObjects,
)
```

## Step 3: Queries

| Before                           | After                |
| -------------------------------- | -------------------- |
| `qt.query(rect, as_items=True)`  | `qt_obj.query(rect)` |
| `qt.query(rect, as_items=False)` | `qt.query(rect)`     |

## Step 4: NumPy calls

| Before                     | After                         |
| -------------------------- | ----------------------------- |
| `qt.insert_many(np_array)` | `qt.insert_many_np(np_array)` |

## Step 5: Insert results

| Before                                              | After                                          |
| --------------------------------------------------- | ---------------------------------------------- |
| `count = qt.insert_many(points)`                    | `r = qt.insert_many(points); count = r.count`  |
| `n, start = qt.insert_many(pts, get_start_id=True)` | `r = qt.insert_many(pts); r.count, r.start_id` |

## Step 6: Deletion

| Before                     | After                          |
| -------------------------- | ------------------------------ |
| `qt.delete(id_, (x, y))`    | `qt.delete(id_, x, y)`         |
| `qt.delete_by_object(obj)` | `qt_obj.delete_by_object(obj)` |

## Step 7: Update/move

* If you used object tracking, switch to `QuadTreeObjects.update(id_, new_x, new_y)`
* If you did not, use `QuadTree.update(id_, old_x, old_y, new_x, new_y)`

---

# Appendix: v2.0 API Reference (Proposed)

## QuadTree (points, no objects)

```python
class QuadTree:
    def __init__(self, bounds, capacity, max_depth=None, dtype="f32"): ...

    # Insertion
    def insert(self, point: tuple[float, float], id_: int | None = None) -> int: ...
    def insert_many(self, points) -> InsertResult: ...
    def insert_many_np(self, points) -> InsertResult: ...

    # Queries
    def query(self, rect) -> list[tuple[int, float, float]]: ...
    def query_np(self, rect): ...  # (ids: ndarray[uint64], coords: ndarray[dtype] shape (N,2))
    def nearest_neighbor(self, point) -> tuple[int, float, float] | None: ...
    def nearest_neighbor_np(self, point) -> tuple[int, "ndarray"] | None: ...  # (id: uint64, coords: ndarray shape (2,))
    def nearest_neighbors(self, point, k: int) -> list[tuple[int, float, float]]: ...
    def nearest_neighbors_np(self, point, k: int): ...  # (ids: ndarray[uint64], coords: ndarray[dtype] shape (k,2))

    # Deletion
    def delete(self, id_: int, x: float, y: float) -> bool: ...
    def clear(self) -> None: ...

    # Mutation
    def update(self, id_: int, old_x: float, old_y: float, new_x: float, new_y: float) -> bool: ...

    # Utilities
    def __len__(self) -> int: ...
    def __contains__(self, point: tuple[float, float]) -> bool: ...
    def __iter__(self): ...
    def get_all_node_boundaries(self) -> list[tuple]: ...
    def get_inner_max_depth(self) -> int: ...

    # Serialization
    def to_bytes(self) -> bytes: ...
    @classmethod
    def from_bytes(cls, data: bytes) -> "QuadTree": ...
```

## QuadTreeObjects (points with Python objects)

```python
class QuadTreeObjects:
    def __init__(self, bounds, capacity, max_depth=None, dtype="f32"): ...

    # Insertion (no custom IDs - uses dense allocation)
    def insert(self, point: tuple[float, float], obj=None) -> int: ...
    def insert_many(self, points, objs=None) -> InsertResult: ...
    def insert_many_np(self, points, objs=None) -> InsertResult: ...

    # Queries
    def query(self, rect) -> list["PointItem"]: ...
    def query_ids(self, rect) -> list[int]: ...
    def query_np(self, rect): ...  # ids, coords (coords shape (N,2), dtype matches tree)
    def nearest_neighbor(self, point) -> "PointItem" | None: ...
    def nearest_neighbors(self, point, k: int) -> list["PointItem"]: ...

    # Deletion
    def delete(self, id_: int) -> bool: ...
    def delete_at(self, x: float, y: float) -> bool: ...  # deletes lowest-id_ match
    def delete_by_object(self, obj) -> int: ...            # deletes all, returns count
    def delete_one_by_object(self, obj) -> bool: ...             # deletes one, lowest id_
    def clear(self) -> None: ...

    # Object management
    def get(self, id_: int): ...
    def attach(self, id_: int, obj) -> None: ...
    def get_all_objects(self) -> list: ...
    def get_all_items(self) -> list["PointItem"]: ...

    # Mutation
    def update(self, id_: int, new_x: float, new_y: float) -> bool: ...
    def update_by_object(self, obj, new_x: float, new_y: float) -> bool: ...

    # Utilities
    def __len__(self) -> int: ...
    def __contains__(self, point: tuple[float, float]) -> bool: ...
    def __iter__(self): ...

    # Serialization
    def to_bytes(self, include_objects: bool = False) -> bytes: ...
    @classmethod
    def from_bytes(cls, data: bytes, allow_objects: bool = False) -> "QuadTreeObjects": ...
```

## RectQuadTree (rectangles, no objects)

```python
class RectQuadTree:
    def __init__(self, bounds, capacity, max_depth=None, dtype="f32"): ...

    # Insertion
    def insert(self, rect: tuple[float, float, float, float], id_: int | None = None) -> int: ...
    def insert_many(self, rects) -> InsertResult: ...
    def insert_many_np(self, rects) -> InsertResult: ...

    # Queries
    def query(self, rect) -> list[tuple[int, float, float, float, float]]: ...
    def query_np(self, rect): ...  # (ids: ndarray[uint64], coords: ndarray[dtype] shape (N,4))
    def nearest_neighbor(self, point) -> tuple[int, float, float, float, float] | None: ...
    def nearest_neighbor_np(self, point) -> tuple[int, "ndarray"] | None: ...  # (id: uint64, coords: ndarray shape (4,))
    def nearest_neighbors(self, point, k: int) -> list[tuple[int, float, float, float, float]]: ...
    def nearest_neighbors_np(self, point, k: int): ...  # (ids: ndarray[uint64], coords: ndarray[dtype] shape (k,4))

    # Deletion
    def delete(self, id_: int, min_x: float, min_y: float, max_x: float, max_y: float) -> bool: ...
    def clear(self) -> None: ...

    # Mutation
    def update(self, id_: int, old_min_x: float, old_min_y: float, old_max_x: float, old_max_y: float,
               new_min_x: float, new_min_y: float, new_max_x: float, new_max_y: float) -> bool: ...

    # Utilities
    def __len__(self) -> int: ...
    def __contains__(self, rect: tuple[float, float, float, float]) -> bool: ...
    def __iter__(self): ...
    def get_all_node_boundaries(self) -> list[tuple]: ...
    def get_inner_max_depth(self) -> int: ...

    # Serialization
    def to_bytes(self) -> bytes: ...
    @classmethod
    def from_bytes(cls, data: bytes) -> "RectQuadTree": ...
```

## RectQuadTreeObjects (rectangles with Python objects)

```python
class RectQuadTreeObjects:
    def __init__(self, bounds, capacity, max_depth=None, dtype="f32"): ...

    # Insertion (no custom IDs - uses dense allocation)
    def insert(self, rect: tuple[float, float, float, float], obj=None) -> int: ...
    def insert_many(self, rects, objs=None) -> InsertResult: ...
    def insert_many_np(self, rects, objs=None) -> InsertResult: ...

    # Queries
    def query(self, rect) -> list["RectItem"]: ...
    def query_ids(self, rect) -> list[int]: ...
    def query_np(self, rect): ...  # ids, coords (coords shape (N,4), dtype matches tree)
    def nearest_neighbor(self, point) -> "RectItem" | None: ...
    def nearest_neighbors(self, point, k: int) -> list["RectItem"]: ...

    # Deletion
    def delete(self, id_: int) -> bool: ...
    def delete_at(self, min_x: float, min_y: float, max_x: float, max_y: float) -> bool: ...
    def delete_by_object(self, obj) -> int: ...
    def delete_one_by_object(self, obj) -> bool: ...
    def clear(self) -> None: ...

    # Object management
    def get(self, id_: int): ...
    def attach(self, id_: int, obj) -> None: ...
    def get_all_objects(self) -> list: ...
    def get_all_items(self) -> list["RectItem"]: ...

    # Mutation
    def update(self, id_: int, new_min_x: float, new_min_y: float, new_max_x: float, new_max_y: float) -> bool: ...
    def update_by_object(self, obj, new_min_x: float, new_min_y: float, new_max_x: float, new_max_y: float) -> bool: ...

    # Utilities
    def __len__(self) -> int: ...
    def __contains__(self, rect: tuple[float, float, float, float]) -> bool: ...
    def __iter__(self): ...

    # Serialization
    def to_bytes(self, include_objects: bool = False) -> bytes: ...
    @classmethod
    def from_bytes(cls, data: bytes, allow_objects: bool = False) -> "RectQuadTreeObjects": ...
```

## Data Classes

```python
@dataclass
class InsertResult:
    count: int
    start_id: int
    end_id: int

    @property
    def ids(self) -> range:
        return range(self.start_id, self.end_id + 1)
```

---

# Implementation Details

## ObjStore: Efficient Object Tracking

The `ObjStore` class (used internally by `QuadTreeObjects` and `RectQuadTreeObjects`) maintains a bidirectional mapping between IDs and Python objects:

**Storage:**
- `_arr[id]` → Item or None (dense array)
- `_objs[id]` → Python object or None (parallel array)
- `_obj_to_ids` → `dict[int, set[int]]` reverse map from `id(obj)` to all associated IDs
- `_free` → LIFO free-list of reusable IDs

**Key behaviors:**
1. **Multiple insertions of the same object are tracked**: When the same Python object is inserted multiple times at different locations, all IDs are stored in a set
2. **Deterministic lookup**: `by_obj(obj)` returns the item with the lowest ID (using `min(ids)`)
3. **Efficient deletion**: `delete_by_object()` retrieves all IDs via `by_obj_all()` and deletes each one
4. **Safe object replacement**: `attach(id, new_obj)` correctly removes the old object's ID from the reverse map, preventing corruption

**Performance characteristics:**
- `add()`: O(1) average (set insertion)
- `by_obj()`: O(k) where k = number of duplicates (typically small; `min()` on small sets is fast)
- `by_obj_all()`: O(k log k) for sorting
- `pop_id()`: O(1) average (set removal)
- Memory overhead: ~8 bytes per duplicate object insertion (set entry)

This design ensures correct semantics for duplicate objects while maintaining excellent performance for the common case (no duplicates).