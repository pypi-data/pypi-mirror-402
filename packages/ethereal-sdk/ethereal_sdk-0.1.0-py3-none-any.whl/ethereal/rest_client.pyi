# This file is auto-generated by scripts/generate_sync_client.py
# Type stub for the synchronous REST client.

from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple, Type, Union
from pydantic import BaseModel
from decimal import Decimal
from ethereal.models.config import RESTConfig
from ethereal.chain_client import ChainClient
from uuid import UUID
from ethereal.models.rest import (
    AccountSignerQuotaDto,
    BalanceHistoryDto,
    CancelOrderDto,
    CancelOrderResultDto,
    DryRunOrderCreatedDto,
    FundingDto,
    InitiateWithdrawDto,
    LinkSignerDto,
    MarketLiquidityDto,
    MarketPriceDto,
    OrderDto,
    OrderFillDto,
    PositionDto,
    PositionFundingHistoryDto,
    PositionLiquidationDto,
    ProductDto,
    ProjectedFundingDto,
    ReferralCodeUsageDto,
    ReferralDto,
    RefreshLinkedSignerDto,
    RevokeLinkedSignerDto,
    RpcConfigDto,
    SignerDto,
    SubaccountBalanceDto,
    SubaccountDto,
    SubaccountVolumeHistoryDto,
    SubmitOrderCreatedDto,
    SubmitOrderDto,
    TokenDto,
    TotalSubaccountVolumeDto,
    TradeDto,
    TransferDto,
    UnrealizedPnlHistoryDto,
    WithdrawDto,
)

class RESTClient:
    def __init__(self, config: Union[Dict[str, Any], RESTConfig] = ...) -> None: ...
    def close(self) -> None: ...
    def __enter__(self) -> RESTClient: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
    def cancel_all_orders(
        self, subaccount_id: UUID, product_ids: Optional[List[UUID]] = None, **kwargs
    ) -> List[CancelOrderResultDto]: ...
    def cancel_order(
        self, order_to_cancel: CancelOrderDto, **kwargs
    ) -> List[CancelOrderResultDto]: ...
    def cancel_orders(
        self,
        order_ids: List[UUID],
        sender: Optional[str] = None,
        subaccount: Optional[str] = None,
        client_order_ids: List[str] = [],
        sign: bool = True,
        submit: bool = True,
        **kwargs,
    ) -> Union[List[CancelOrderResultDto], CancelOrderDto]: ...
    def create_order(
        self,
        order_type: str,
        quantity: float,
        side: int,
        price: Optional[float] = None,
        ticker: Optional[str] = None,
        product_id: Optional[UUID] = None,
        client_order_id: Optional[str] = None,
        sender: Optional[str] = None,
        subaccount: Optional[str] = None,
        time_in_force: Optional[str] = None,
        post_only: Optional[bool] = None,
        reduce_only: Optional[bool] = False,
        close: Optional[bool] = None,
        stop_price: Optional[float] = None,
        stop_type: Optional[int] = None,
        expires_at: Optional[int] = None,
        group_id: Optional[str] = None,
        group_contingency_type: Optional[int] = None,
        sign: bool = True,
        dry_run: bool = False,
        submit: bool = True,
    ) -> Union[SubmitOrderCreatedDto, DryRunOrderCreatedDto, SubmitOrderDto]: ...
    def delete(
        self,
        url_path: Any,
        params: Union[dict, None] = None,
        data: Union[dict, None] = None,
        base_url_override: Union[str, None] = None,
        **kwargs,
    ) -> Dict[str, Any]: ...
    def dry_run_order(
        self, order: SubmitOrderDto, **kwargs
    ) -> DryRunOrderCreatedDto: ...
    def get(
        self,
        url_path: Any,
        params: Union[dict, None] = None,
        base_url_override: Union[str, None] = None,
        **kwargs,
    ) -> Dict[str, Any]: ...
    def get_maintenance_margin(
        self,
        subaccount_id: UUID,
        positions: Optional[List[PositionDto] | List[Dict[str, Any]]] = None,
        products: Optional[List[ProductDto] | List[Dict[str, Any]]] = None,
        product_ids: Optional[List[UUID]] = None,
    ) -> Decimal: ...
    def get_market_liquidity(self, **kwargs) -> MarketLiquidityDto: ...
    def get_order(self, id: UUID, **kwargs) -> OrderDto: ...
    def get_position(self, id: UUID, **kwargs) -> PositionDto: ...
    def get_projected_funding(self, **kwargs) -> ProjectedFundingDto: ...
    def get_referral_summary(self, **kwargs) -> ReferralCodeUsageDto: ...
    def get_rpc_config(self, **kwargs) -> RpcConfigDto: ...
    def get_signer(self, id: UUID, **kwargs) -> SignerDto: ...
    def get_signer_quota(self, **kwargs) -> AccountSignerQuotaDto: ...
    def get_subaccount(self, id: UUID, **kwargs) -> SubaccountDto: ...
    def get_subaccount_balance_history(self, **kwargs) -> List[BalanceHistoryDto]: ...
    def get_subaccount_balances(self, **kwargs) -> List[SubaccountBalanceDto]: ...
    def get_subaccount_funding_history(
        self, **kwargs
    ) -> List[PositionFundingHistoryDto]: ...
    def get_subaccount_total_volume(self, **kwargs) -> TotalSubaccountVolumeDto: ...
    def get_subaccount_unrealized_pnl_history(
        self, **kwargs
    ) -> List[UnrealizedPnlHistoryDto]: ...
    def get_subaccount_volume_history(
        self, **kwargs
    ) -> List[SubaccountVolumeHistoryDto]: ...
    def get_token(self, id: UUID, **kwargs) -> TokenDto: ...
    def get_tokens(self) -> List[TokenDto]: ...
    def get_validated(
        self,
        url_path: Any,
        request_model: Type[BaseModel],
        response_model: Type[BaseModel],
        base_url_override: Union[str, None] = None,
        **kwargs,
    ) -> BaseModel: ...
    def link_linked_signer(self, dto: LinkSignerDto, **kwargs) -> SignerDto: ...
    def link_signer(
        self,
        signer: str,
        subaccount_id: UUID,
        subaccount: Optional[str] = None,
        sender: Optional[str] = None,
        signer_private_key: Optional[str] = None,
        nonce: Optional[str] = None,
        signed_at: Optional[int] = None,
        sign_sender: bool = True,
        sign_signer: bool = True,
        submit: bool = True,
        **kwargs,
    ) -> Union[SignerDto, LinkSignerDto]: ...
    def list_fills(self, **kwargs) -> List[OrderFillDto]: ...
    def list_funding(self, **kwargs) -> List[FundingDto]: ...
    def list_market_prices(self, **kwargs) -> List[MarketPriceDto]: ...
    def list_orders(self, **kwargs) -> List[OrderDto]: ...
    def list_position_liquidations(self, **kwargs) -> List[PositionLiquidationDto]: ...
    def list_positions(self, **kwargs) -> List[PositionDto]: ...
    def list_products(self, **kwargs) -> List[ProductDto]: ...
    def list_projected_funding(self, **kwargs) -> List[ProjectedFundingDto]: ...
    def list_referrals(self, **kwargs) -> List[ReferralDto]: ...
    def list_signers(self, **kwargs) -> List[SignerDto]: ...
    def list_subaccounts(self, **kwargs) -> List[SubaccountDto]: ...
    def list_token_transfers(self, **kwargs) -> List[TransferDto]: ...
    def list_token_withdraws(self, **kwargs) -> List[WithdrawDto]: ...
    def list_tokens(self, **kwargs) -> List[TokenDto]: ...
    def list_trades(self, **kwargs) -> List[TradeDto]: ...
    def post(
        self,
        url_path: Any,
        params: Union[dict, None] = None,
        data: Union[dict, None] = None,
        base_url_override: Union[str, None] = None,
        **kwargs,
    ) -> Dict[str, Any]: ...
    def prepare_and_send_request(
        self,
        http_method: Any,
        url_path: Any,
        params: Union[dict, None] = None,
        data: Union[dict, None] = None,
        base_url_override: Union[str, None] = None,
    ) -> Any: ...
    def prepare_cancel_order(
        self,
        sender: str,
        subaccount: str,
        order_ids: List[UUID] = [],
        client_order_ids: List[str] = [],
        include_signature: bool = False,
        **kwargs,
    ) -> CancelOrderDto: ...
    def prepare_linked_signer(
        self,
        sender: str,
        signer: str,
        subaccount: str,
        subaccount_id: UUID,
        signer_signature: str = "",
        include_signature: bool = False,
        **kwargs,
    ) -> LinkSignerDto: ...
    def prepare_order(
        self,
        sender: str,
        price: Union[str, float, Decimal, None] = None,
        quantity: Union[str, float, Decimal, None] = None,
        side: Union[int, None] = None,
        subaccount: Union[str, None] = None,
        onchain_id: Union[float, None] = None,
        order_type: Union[str, None] = None,
        client_order_id: Union[str, None] = None,
        time_in_force: Union[str, None] = None,
        post_only: Union[bool, None] = False,
        reduce_only: Union[bool, None] = False,
        close: Union[bool, None] = None,
        stop_price: Union[str, float, Decimal, None] = None,
        stop_type: Union[int, None] = None,
        group_id: Union[str, None] = None,
        group_contingency_type: Union[int, None] = None,
        expires_at: Union[int, None] = None,
        include_signature: bool = False,
        **kwargs,
    ) -> SubmitOrderDto: ...
    def prepare_refresh_linked_signer(
        self,
        sender: str,
        signer: str,
        subaccount: str,
        subaccount_id: UUID,
        include_signature: bool = False,
        **kwargs,
    ) -> RefreshLinkedSignerDto: ...
    def prepare_revoke_linked_signer(
        self,
        sender: str,
        signer: str,
        subaccount: str,
        subaccount_id: UUID,
        include_signature: bool = False,
        **kwargs,
    ) -> RevokeLinkedSignerDto: ...
    def prepare_withdraw_token(
        self,
        subaccount: str,
        token: str,
        amount: int,
        account: str,
        destination_address: str,
        destination_endpoint: int,
        include_signature: bool = False,
        nonce: Union[str, None] = None,
        signed_at: Union[int, None] = None,
    ) -> InitiateWithdrawDto: ...
    def products(self, refresh: bool = False) -> List[ProductDto]: ...
    def products_by_id(self, refresh: bool = False) -> Dict[UUID, ProductDto]: ...
    def products_by_ticker(self, refresh: bool = False) -> Dict[str, ProductDto]: ...
    def put(
        self,
        url_path: Any,
        params: Union[dict, None] = None,
        data: Union[dict, None] = None,
        base_url_override: Union[str, None] = None,
        **kwargs,
    ) -> Dict[str, Any]: ...
    def refresh_linked_signer(
        self, dto: RefreshLinkedSignerDto, **kwargs
    ) -> SignerDto: ...
    def refresh_signer(
        self,
        signer: str,
        subaccount_id: UUID,
        subaccount: Optional[str] = None,
        sender: Optional[str] = None,
        sign: bool = True,
        submit: bool = True,
        **kwargs,
    ) -> Union[SignerDto, RefreshLinkedSignerDto]: ...
    def replace_order(
        self,
        order: Optional[OrderDto] = None,
        order_id: Optional[UUID] = None,
        quantity: Optional[float] = None,
        price: Optional[float] = None,
        time_in_force: Optional[str] = None,
        post_only: Optional[bool] = None,
        reduce_only: Optional[bool] = False,
    ) -> Tuple[SubmitOrderCreatedDto, bool]: ...
    def revoke_linked_signer(
        self, dto: RevokeLinkedSignerDto, **kwargs
    ) -> SignerDto: ...
    def revoke_signer(
        self,
        signer: str,
        subaccount_id: UUID,
        subaccount: Optional[str] = None,
        sender: Optional[str] = None,
        sign: bool = True,
        submit: bool = True,
        **kwargs,
    ) -> Union[SignerDto, RevokeLinkedSignerDto]: ...
    def send_request(
        self,
        http_method: Any,
        url_path: Any,
        params: Any,
        headers: Any,
        data: Any = None,
        base_url_override: Union[str, None] = None,
    ) -> Any: ...
    def sign_cancel_order(
        self, order_to_cancel: CancelOrderDto, private_key: Union[str, None] = None
    ) -> CancelOrderDto: ...
    def sign_linked_signer(
        self,
        link_to_sign: LinkSignerDto,
        signer_private_key: Union[str, None] = None,
        private_key: Union[str, None] = None,
    ) -> LinkSignerDto: ...
    def sign_order(
        self, order: SubmitOrderDto, private_key: Union[str, None] = None
    ) -> SubmitOrderDto: ...
    def sign_refresh_linked_signer(
        self,
        refresh_to_sign: RefreshLinkedSignerDto,
        private_key: Union[str, None] = None,
    ) -> RefreshLinkedSignerDto: ...
    def sign_revoke_linked_signer(
        self,
        revoke_to_sign: RevokeLinkedSignerDto,
        private_key: Union[str, None] = None,
    ) -> RevokeLinkedSignerDto: ...
    def sign_withdraw_token(
        self, withdraw_dto: InitiateWithdrawDto, private_key: Union[str, None] = None
    ) -> InitiateWithdrawDto: ...
    def subaccounts(self, refresh: bool = False) -> List[SubaccountDto]: ...
    def submit_order(
        self, order: SubmitOrderDto, **kwargs
    ) -> SubmitOrderCreatedDto: ...
    def submit_withdraw_token(
        self, dto: InitiateWithdrawDto, token_id: UUID, **kwargs
    ) -> WithdrawDto: ...
    def tokens(self, refresh: bool = False) -> List[TokenDto]: ...
    def withdraw_token(
        self,
        dto: Optional[InitiateWithdrawDto] = None,
        token_id: Optional[UUID] = None,
        amount: Optional[int] = None,
        destination_address: Optional[str] = None,
        destination_endpoint: Optional[int] = None,
        subaccount: Optional[str] = None,
        account: Optional[str] = None,
        nonce: Optional[str] = None,
        signed_at: Optional[int] = None,
        sign: bool = True,
        submit: bool = True,
        **kwargs,
    ) -> Union[WithdrawDto, InitiateWithdrawDto]: ...
    def _get_pages(
        self,
        endpoint: str,
        request_model: Type[BaseModel],
        response_model: Type[BaseModel],
        paginate: bool = False,
        **kwargs,
    ) -> Any: ...

    # Exposed internals
    @property
    def chain(self) -> Optional[ChainClient]: ...
    @property
    def logger(self) -> Any: ...
    @property
    def provider(self) -> Any: ...
    @property
    def private_key(self) -> Optional[str]: ...
    @property
    def _models(self) -> Any: ...
