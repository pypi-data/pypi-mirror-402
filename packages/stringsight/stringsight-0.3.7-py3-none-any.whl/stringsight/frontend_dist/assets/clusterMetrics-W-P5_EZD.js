function k(s,r,c){console.log("ðŸ”¢ Computing cluster metrics from raw data:",{conversations:s.length,properties:r.length,clusters:c.length});const n=new Map;s.forEach(e=>{const g=`${e.question_id}|${e.model}`;n.set(g,e)});const a=new Map;r.forEach(e=>{a.set(e.id,e)});const l=new Set(s.map(e=>e.question_id)).size,i=Array.from(new Set(s.map(e=>e.model))),C=$(s,i),y=new Map;return r.forEach(e=>{y.set(e.model,(y.get(e.model)||0)+1)}),c.map(e=>{const g=new Set(e.property_ids),p=r.filter(t=>g.has(t.id));console.log(`ðŸ”¢ Cluster "${e.label}": ${p.length} properties`);const m=[];p.forEach(t=>{const o=`${t.question_id}|${t.model}`,u=n.get(o);u&&u.score&&m.push({property:t,conversation:u})});const f=new Map;m.forEach(({conversation:t})=>{const o=t.model;f.has(o)||f.set(o,[]),f.get(o).push(t)});const _={},b={},M={};f.forEach((t,o)=>{const u=p.filter(d=>d.model===o).length,B=y.get(o)||1;_[o]=u/B;const h=w(t);b[o]=h;const S=C.get(o)||{},E={};Object.keys(h).forEach(d=>{const v=h[d],I=S[d]||0;E[d]=v-I}),M[o]=E});const q=new Set(p.map(t=>t.question_id)).size;return{cluster_id:e.id,cluster_label:e.label,total_unique_conversations:q,proportion_overall:q/l,proportion_by_model:_,quality_by_model:b,quality_delta_by_model:M}})}function $(s,r){const c=new Map;return r.forEach(n=>{const a=s.filter(i=>i.model===n&&i.score),l=w(a);c.set(n,l)}),console.log("ðŸ”¢ Computed baseline:",Object.fromEntries(c)),c}function w(s){if(s.length===0)return{};const r=new Set;s.forEach(n=>{n.score&&Object.keys(n.score).forEach(a=>r.add(a))});const c={};return r.forEach(n=>{const a=s.map(l=>l.score?.[n]).filter(l=>l!==void 0&&typeof l=="number");a.length>0&&(c[n]=a.reduce((l,i)=>l+i,0)/a.length)}),c}export{k as computeClusterMetrics};
