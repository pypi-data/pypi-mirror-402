"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from glean.api_client import errors, models, utils
from glean.api_client._hooks import HookContext
from glean.api_client.types import OptionalNullable, UNSET
from glean.api_client.utils import get_security_from_env
from glean.api_client.utils.unmarshal_json_response import unmarshal_json_response
from typing import List, Mapping, Optional, Union


class ClientChat(BaseSDK):
    def create(
        self,
        *,
        messages: Union[List[models.ChatMessage], List[models.ChatMessageTypedDict]],
        timezone_offset: Optional[int] = None,
        session_info: Optional[
            Union[models.SessionInfo, models.SessionInfoTypedDict]
        ] = None,
        save_chat: Optional[bool] = None,
        chat_id: Optional[str] = None,
        agent_config: Optional[
            Union[models.AgentConfig, models.AgentConfigTypedDict]
        ] = None,
        inclusions: Optional[
            Union[models.ChatRestrictionFilters, models.ChatRestrictionFiltersTypedDict]
        ] = None,
        exclusions: Optional[
            Union[models.ChatRestrictionFilters, models.ChatRestrictionFiltersTypedDict]
        ] = None,
        timeout_millis: Optional[int] = None,
        application_id: Optional[str] = None,
        agent_id: Optional[str] = None,
        stream: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ChatResponse:
        r"""Chat

        Have a conversation with Glean AI.

        :param messages: A list of chat messages, from most recent to least recent. At least one message must specify a USER author.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param session_info:
        :param save_chat: Save the current interaction as a Chat for the user to access and potentially continue later.
        :param chat_id: The id of the Chat that context should be retrieved from and messages added to. An empty id starts a new Chat, and the Chat is saved if saveChat is true.
        :param agent_config: Describes the agent that executes the request.
        :param inclusions:
        :param exclusions:
        :param timeout_millis: Timeout in milliseconds for the request. A `408` error will be returned if handling the request takes longer.
        :param application_id: The ID of the application this request originates from, used to determine the configuration of underlying chat processes. This should correspond to the ID set during admin setup. If not specified, the default chat experience will be used.
        :param agent_id: The ID of the Agent that should process this chat request. Only Agents with trigger set to 'User chat message' are invokable through this API. If not specified, the default chat experience will be used.
        :param stream: If set, response lines will be streamed one-by-one as they become available. Each will be a ChatResponse, formatted as JSON, and separated by a new line. If false, the entire response will be returned at once. Note that if this is set and the model being used does not support streaming, the model's response will not be streamed, but other messages from the endpoint still will be.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ChatRequestRequest(
            timezone_offset=timezone_offset,
            chat_request=models.ChatRequest(
                messages=utils.get_pydantic_model(messages, List[models.ChatMessage]),
                session_info=utils.get_pydantic_model(
                    session_info, Optional[models.SessionInfo]
                ),
                save_chat=save_chat,
                chat_id=chat_id,
                agent_config=utils.get_pydantic_model(
                    agent_config, Optional[models.AgentConfig]
                ),
                inclusions=utils.get_pydantic_model(
                    inclusions, Optional[models.ChatRestrictionFilters]
                ),
                exclusions=utils.get_pydantic_model(
                    exclusions, Optional[models.ChatRestrictionFilters]
                ),
                timeout_millis=timeout_millis,
                application_id=application_id,
                agent_id=agent_id,
                stream=stream,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/chat",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.chat_request, False, False, "json", models.ChatRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="chat",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "408", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ChatResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "408", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def create_async(
        self,
        *,
        messages: Union[List[models.ChatMessage], List[models.ChatMessageTypedDict]],
        timezone_offset: Optional[int] = None,
        session_info: Optional[
            Union[models.SessionInfo, models.SessionInfoTypedDict]
        ] = None,
        save_chat: Optional[bool] = None,
        chat_id: Optional[str] = None,
        agent_config: Optional[
            Union[models.AgentConfig, models.AgentConfigTypedDict]
        ] = None,
        inclusions: Optional[
            Union[models.ChatRestrictionFilters, models.ChatRestrictionFiltersTypedDict]
        ] = None,
        exclusions: Optional[
            Union[models.ChatRestrictionFilters, models.ChatRestrictionFiltersTypedDict]
        ] = None,
        timeout_millis: Optional[int] = None,
        application_id: Optional[str] = None,
        agent_id: Optional[str] = None,
        stream: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ChatResponse:
        r"""Chat

        Have a conversation with Glean AI.

        :param messages: A list of chat messages, from most recent to least recent. At least one message must specify a USER author.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param session_info:
        :param save_chat: Save the current interaction as a Chat for the user to access and potentially continue later.
        :param chat_id: The id of the Chat that context should be retrieved from and messages added to. An empty id starts a new Chat, and the Chat is saved if saveChat is true.
        :param agent_config: Describes the agent that executes the request.
        :param inclusions:
        :param exclusions:
        :param timeout_millis: Timeout in milliseconds for the request. A `408` error will be returned if handling the request takes longer.
        :param application_id: The ID of the application this request originates from, used to determine the configuration of underlying chat processes. This should correspond to the ID set during admin setup. If not specified, the default chat experience will be used.
        :param agent_id: The ID of the Agent that should process this chat request. Only Agents with trigger set to 'User chat message' are invokable through this API. If not specified, the default chat experience will be used.
        :param stream: If set, response lines will be streamed one-by-one as they become available. Each will be a ChatResponse, formatted as JSON, and separated by a new line. If false, the entire response will be returned at once. Note that if this is set and the model being used does not support streaming, the model's response will not be streamed, but other messages from the endpoint still will be.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ChatRequestRequest(
            timezone_offset=timezone_offset,
            chat_request=models.ChatRequest(
                messages=utils.get_pydantic_model(messages, List[models.ChatMessage]),
                session_info=utils.get_pydantic_model(
                    session_info, Optional[models.SessionInfo]
                ),
                save_chat=save_chat,
                chat_id=chat_id,
                agent_config=utils.get_pydantic_model(
                    agent_config, Optional[models.AgentConfig]
                ),
                inclusions=utils.get_pydantic_model(
                    inclusions, Optional[models.ChatRestrictionFilters]
                ),
                exclusions=utils.get_pydantic_model(
                    exclusions, Optional[models.ChatRestrictionFilters]
                ),
                timeout_millis=timeout_millis,
                application_id=application_id,
                agent_id=agent_id,
                stream=stream,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/chat",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.chat_request, False, False, "json", models.ChatRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="chat",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "408", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ChatResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "408", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def delete_all(
        self,
        *,
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Deletes all saved Chats owned by a user

        Deletes all saved Chats a user has had and all their contained conversational content.

        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteallchatsRequest(
            timezone_offset=timezone_offset,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/deleteallchats",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteallchats",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def delete_all_async(
        self,
        *,
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Deletes all saved Chats owned by a user

        Deletes all saved Chats a user has had and all their contained conversational content.

        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteallchatsRequest(
            timezone_offset=timezone_offset,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/deleteallchats",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteallchats",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        ids: List[str],
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Deletes saved Chats

        Deletes saved Chats and all their contained conversational content.

        :param ids: A non-empty list of ids of the Chats to be deleted.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeletechatsRequestRequest(
            timezone_offset=timezone_offset,
            delete_chats_request=models.DeleteChatsRequest(
                ids=ids,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/deletechats",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.delete_chats_request,
                False,
                False,
                "json",
                models.DeleteChatsRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletechats",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "403", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def delete_async(
        self,
        *,
        ids: List[str],
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Deletes saved Chats

        Deletes saved Chats and all their contained conversational content.

        :param ids: A non-empty list of ids of the Chats to be deleted.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeletechatsRequestRequest(
            timezone_offset=timezone_offset,
            delete_chats_request=models.DeleteChatsRequest(
                ids=ids,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/deletechats",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.delete_chats_request,
                False,
                False,
                "json",
                models.DeleteChatsRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletechats",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "403", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def retrieve(
        self,
        *,
        id: str,
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetChatResponse:
        r"""Retrieves a Chat

        Retrieves the chat history between Glean Assistant and the user for a given Chat.

        :param id: The id of the Chat to be retrieved.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetchatRequestRequest(
            timezone_offset=timezone_offset,
            get_chat_request=models.GetChatRequest(
                id=id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/getchat",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.get_chat_request, False, False, "json", models.GetChatRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getchat",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetChatResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def retrieve_async(
        self,
        *,
        id: str,
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetChatResponse:
        r"""Retrieves a Chat

        Retrieves the chat history between Glean Assistant and the user for a given Chat.

        :param id: The id of the Chat to be retrieved.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetchatRequestRequest(
            timezone_offset=timezone_offset,
            get_chat_request=models.GetChatRequest(
                id=id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/getchat",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.get_chat_request, False, False, "json", models.GetChatRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getchat",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetChatResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def list(
        self,
        *,
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListChatsResponse:
        r"""Retrieves all saved Chats

        Retrieves all the saved Chats between Glean Assistant and the user. The returned Chats contain only metadata and no conversational content.

        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListchatsRequest(
            timezone_offset=timezone_offset,
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/listchats",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listchats",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListChatsResponse, http_res)
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def list_async(
        self,
        *,
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListChatsResponse:
        r"""Retrieves all saved Chats

        Retrieves all the saved Chats between Glean Assistant and the user. The returned Chats contain only metadata and no conversational content.

        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListchatsRequest(
            timezone_offset=timezone_offset,
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/listchats",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="listchats",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListChatsResponse, http_res)
        if utils.match_response(http_res, ["401", "403", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def retrieve_application(
        self,
        *,
        id: str,
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetChatApplicationResponse:
        r"""Gets the metadata for a custom Chat application

        Gets the Chat application details for the specified application ID.

        :param id: The id of the Chat application to be retrieved.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetchatapplicationRequestRequest(
            timezone_offset=timezone_offset,
            get_chat_application_request=models.GetChatApplicationRequest(
                id=id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/getchatapplication",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.get_chat_application_request,
                False,
                False,
                "json",
                models.GetChatApplicationRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getchatapplication",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetChatApplicationResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def retrieve_application_async(
        self,
        *,
        id: str,
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetChatApplicationResponse:
        r"""Gets the metadata for a custom Chat application

        Gets the Chat application details for the specified application ID.

        :param id: The id of the Chat application to be retrieved.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetchatapplicationRequestRequest(
            timezone_offset=timezone_offset,
            get_chat_application_request=models.GetChatApplicationRequest(
                id=id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/getchatapplication",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.get_chat_application_request,
                False,
                False,
                "json",
                models.GetChatApplicationRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getchatapplication",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetChatApplicationResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def upload_files(
        self,
        *,
        files: Union[List[models.File], List[models.FileTypedDict]],
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UploadChatFilesResponse:
        r"""Upload files for Chat.

        Upload files for Chat.

        :param files: Raw files to be uploaded for chat in binary format.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UploadchatfilesRequestRequest(
            timezone_offset=timezone_offset,
            upload_chat_files_request=models.UploadChatFilesRequest(
                files=utils.get_pydantic_model(files, List[models.File]),
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/uploadchatfiles",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.upload_chat_files_request,
                False,
                False,
                "multipart",
                models.UploadChatFilesRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="uploadchatfiles",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UploadChatFilesResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def upload_files_async(
        self,
        *,
        files: Union[List[models.File], List[models.FileTypedDict]],
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UploadChatFilesResponse:
        r"""Upload files for Chat.

        Upload files for Chat.

        :param files: Raw files to be uploaded for chat in binary format.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UploadchatfilesRequestRequest(
            timezone_offset=timezone_offset,
            upload_chat_files_request=models.UploadChatFilesRequest(
                files=utils.get_pydantic_model(files, List[models.File]),
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/uploadchatfiles",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.upload_chat_files_request,
                False,
                False,
                "multipart",
                models.UploadChatFilesRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="uploadchatfiles",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.UploadChatFilesResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def retrieve_files(
        self,
        *,
        file_ids: List[str],
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetChatFilesResponse:
        r"""Get files uploaded by a user for Chat.

        Get files uploaded by a user for Chat.

        :param file_ids: IDs of files to fetch.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetchatfilesRequestRequest(
            timezone_offset=timezone_offset,
            get_chat_files_request=models.GetChatFilesRequest(
                file_ids=file_ids,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/getchatfiles",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.get_chat_files_request,
                False,
                False,
                "json",
                models.GetChatFilesRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getchatfiles",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetChatFilesResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def retrieve_files_async(
        self,
        *,
        file_ids: List[str],
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetChatFilesResponse:
        r"""Get files uploaded by a user for Chat.

        Get files uploaded by a user for Chat.

        :param file_ids: IDs of files to fetch.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetchatfilesRequestRequest(
            timezone_offset=timezone_offset,
            get_chat_files_request=models.GetChatFilesRequest(
                file_ids=file_ids,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/getchatfiles",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.get_chat_files_request,
                False,
                False,
                "json",
                models.GetChatFilesRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getchatfiles",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.GetChatFilesResponse, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def delete_files(
        self,
        *,
        file_ids: List[str],
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete files uploaded by a user for chat.

        Delete files uploaded by a user for Chat.

        :param file_ids: IDs of files to delete.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeletechatfilesRequestRequest(
            timezone_offset=timezone_offset,
            delete_chat_files_request=models.DeleteChatFilesRequest(
                file_ids=file_ids,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/deletechatfiles",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.delete_chat_files_request,
                False,
                False,
                "json",
                models.DeleteChatFilesRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletechatfiles",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "403", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def delete_files_async(
        self,
        *,
        file_ids: List[str],
        timezone_offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete files uploaded by a user for chat.

        Delete files uploaded by a user for Chat.

        :param file_ids: IDs of files to delete.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeletechatfilesRequestRequest(
            timezone_offset=timezone_offset,
            delete_chat_files_request=models.DeleteChatFilesRequest(
                file_ids=file_ids,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/deletechatfiles",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.delete_chat_files_request,
                False,
                False,
                "json",
                models.DeleteChatFilesRequest,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deletechatfiles",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, ["400", "401", "403", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    def create_stream(
        self,
        *,
        messages: Union[List[models.ChatMessage], List[models.ChatMessageTypedDict]],
        timezone_offset: Optional[int] = None,
        session_info: Optional[
            Union[models.SessionInfo, models.SessionInfoTypedDict]
        ] = None,
        save_chat: Optional[bool] = None,
        chat_id: Optional[str] = None,
        agent_config: Optional[
            Union[models.AgentConfig, models.AgentConfigTypedDict]
        ] = None,
        inclusions: Optional[
            Union[models.ChatRestrictionFilters, models.ChatRestrictionFiltersTypedDict]
        ] = None,
        exclusions: Optional[
            Union[models.ChatRestrictionFilters, models.ChatRestrictionFiltersTypedDict]
        ] = None,
        timeout_millis: Optional[int] = None,
        application_id: Optional[str] = None,
        agent_id: Optional[str] = None,
        stream: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""Chat

        Have a conversation with Glean AI.

        :param messages: A list of chat messages, from most recent to least recent. At least one message must specify a USER author.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param session_info:
        :param save_chat: Save the current interaction as a Chat for the user to access and potentially continue later.
        :param chat_id: The id of the Chat that context should be retrieved from and messages added to. An empty id starts a new Chat, and the Chat is saved if saveChat is true.
        :param agent_config: Describes the agent that executes the request.
        :param inclusions:
        :param exclusions:
        :param timeout_millis: Timeout in milliseconds for the request. A `408` error will be returned if handling the request takes longer.
        :param application_id: The ID of the application this request originates from, used to determine the configuration of underlying chat processes. This should correspond to the ID set during admin setup. If not specified, the default chat experience will be used.
        :param agent_id: The ID of the Agent that should process this chat request. Only Agents with trigger set to 'User chat message' are invokable through this API. If not specified, the default chat experience will be used.
        :param stream: If set, response lines will be streamed one-by-one as they become available. Each will be a ChatResponse, formatted as JSON, and separated by a new line. If false, the entire response will be returned at once. Note that if this is set and the model being used does not support streaming, the model's response will not be streamed, but other messages from the endpoint still will be.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ChatStreamRequest(
            timezone_offset=timezone_offset,
            chat_request=models.ChatRequest(
                messages=utils.get_pydantic_model(messages, List[models.ChatMessage]),
                session_info=utils.get_pydantic_model(
                    session_info, Optional[models.SessionInfo]
                ),
                save_chat=save_chat,
                chat_id=chat_id,
                agent_config=utils.get_pydantic_model(
                    agent_config, Optional[models.AgentConfig]
                ),
                inclusions=utils.get_pydantic_model(
                    inclusions, Optional[models.ChatRestrictionFilters]
                ),
                exclusions=utils.get_pydantic_model(
                    exclusions, Optional[models.ChatRestrictionFilters]
                ),
                timeout_millis=timeout_millis,
                application_id=application_id,
                agent_id=agent_id,
                stream=stream,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/rest/api/v1/chat#stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/plain",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.chat_request, False, False, "json", models.ChatRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="chatStream",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "408", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "text/plain"):
            return http_res.text
        if utils.match_response(http_res, ["400", "401", "408", "429", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)

    async def create_stream_async(
        self,
        *,
        messages: Union[List[models.ChatMessage], List[models.ChatMessageTypedDict]],
        timezone_offset: Optional[int] = None,
        session_info: Optional[
            Union[models.SessionInfo, models.SessionInfoTypedDict]
        ] = None,
        save_chat: Optional[bool] = None,
        chat_id: Optional[str] = None,
        agent_config: Optional[
            Union[models.AgentConfig, models.AgentConfigTypedDict]
        ] = None,
        inclusions: Optional[
            Union[models.ChatRestrictionFilters, models.ChatRestrictionFiltersTypedDict]
        ] = None,
        exclusions: Optional[
            Union[models.ChatRestrictionFilters, models.ChatRestrictionFiltersTypedDict]
        ] = None,
        timeout_millis: Optional[int] = None,
        application_id: Optional[str] = None,
        agent_id: Optional[str] = None,
        stream: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""Chat

        Have a conversation with Glean AI.

        :param messages: A list of chat messages, from most recent to least recent. At least one message must specify a USER author.
        :param timezone_offset: The offset of the client's timezone in minutes from UTC. e.g. PDT is -420 because it's 7 hours behind UTC.
        :param session_info:
        :param save_chat: Save the current interaction as a Chat for the user to access and potentially continue later.
        :param chat_id: The id of the Chat that context should be retrieved from and messages added to. An empty id starts a new Chat, and the Chat is saved if saveChat is true.
        :param agent_config: Describes the agent that executes the request.
        :param inclusions:
        :param exclusions:
        :param timeout_millis: Timeout in milliseconds for the request. A `408` error will be returned if handling the request takes longer.
        :param application_id: The ID of the application this request originates from, used to determine the configuration of underlying chat processes. This should correspond to the ID set during admin setup. If not specified, the default chat experience will be used.
        :param agent_id: The ID of the Agent that should process this chat request. Only Agents with trigger set to 'User chat message' are invokable through this API. If not specified, the default chat experience will be used.
        :param stream: If set, response lines will be streamed one-by-one as they become available. Each will be a ChatResponse, formatted as JSON, and separated by a new line. If false, the entire response will be returned at once. Note that if this is set and the model being used does not support streaming, the model's response will not be streamed, but other messages from the endpoint still will be.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ChatStreamRequest(
            timezone_offset=timezone_offset,
            chat_request=models.ChatRequest(
                messages=utils.get_pydantic_model(messages, List[models.ChatMessage]),
                session_info=utils.get_pydantic_model(
                    session_info, Optional[models.SessionInfo]
                ),
                save_chat=save_chat,
                chat_id=chat_id,
                agent_config=utils.get_pydantic_model(
                    agent_config, Optional[models.AgentConfig]
                ),
                inclusions=utils.get_pydantic_model(
                    inclusions, Optional[models.ChatRestrictionFilters]
                ),
                exclusions=utils.get_pydantic_model(
                    exclusions, Optional[models.ChatRestrictionFilters]
                ),
                timeout_millis=timeout_millis,
                application_id=application_id,
                agent_id=agent_id,
                stream=stream,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/rest/api/v1/chat#stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/plain",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.chat_request, False, False, "json", models.ChatRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="chatStream",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "408", "429", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "text/plain"):
            return http_res.text
        if utils.match_response(http_res, ["400", "401", "408", "429", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.GleanError("API error occurred", http_res, http_res_text)

        raise errors.GleanError("Unexpected response received", http_res)
