"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .digestsection import DigestSection, DigestSectionTypedDict
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class DigestTypedDict(TypedDict):
    podcast_file_id: NotRequired[str]
    r"""Identifier for the podcast file generated from this digest content."""
    podcast_duration: NotRequired[float]
    r"""Duration of the podcast file in seconds."""
    digest_date: NotRequired[str]
    r"""The date this digest covers, in YYYY-MM-DD format. Represents the specific day for which the digest content and updates were compiled. This can be empty if the digest is not yet available."""
    sections: NotRequired[List[DigestSectionTypedDict]]
    r"""Array of digest sections from which the podcast was created."""


class Digest(BaseModel):
    podcast_file_id: Annotated[Optional[str], pydantic.Field(alias="podcastFileId")] = (
        None
    )
    r"""Identifier for the podcast file generated from this digest content."""

    podcast_duration: Annotated[
        Optional[float], pydantic.Field(alias="podcastDuration")
    ] = None
    r"""Duration of the podcast file in seconds."""

    digest_date: Annotated[Optional[str], pydantic.Field(alias="digestDate")] = None
    r"""The date this digest covers, in YYYY-MM-DD format. Represents the specific day for which the digest content and updates were compiled. This can be empty if the digest is not yet available."""

    sections: Optional[List[DigestSection]] = None
    r"""Array of digest sections from which the podcast was created."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["podcastFileId", "podcastDuration", "digestDate", "sections"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
