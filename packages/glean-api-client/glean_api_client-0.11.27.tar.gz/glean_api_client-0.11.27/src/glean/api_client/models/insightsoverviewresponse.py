"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .currentactiveusers import CurrentActiveUsers, CurrentActiveUsersTypedDict
from .insightschatsummary import InsightsChatSummary, InsightsChatSummaryTypedDict
from .insightssearchsummary import InsightsSearchSummary, InsightsSearchSummaryTypedDict
from .labeledcountinfo import LabeledCountInfo, LabeledCountInfoTypedDict
from .peruserinsight import PerUserInsight, PerUserInsightTypedDict
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class InsightsOverviewResponseTypedDict(TypedDict):
    monthly_active_users: NotRequired[int]
    r"""Number of current Monthly Active Users, in the specified departments."""
    weekly_active_users: NotRequired[int]
    r"""Number of current Weekly Active Users, in the specified departments."""
    departments: NotRequired[List[str]]
    r"""Department name(s)."""
    employee_count: NotRequired[int]
    r"""Number of current employees in the specified departments, according to the Org Chart."""
    total_signups: NotRequired[int]
    r"""Number of current signed up employees in the specified departments, according to the Org Chart."""
    search_summary: NotRequired[InsightsSearchSummaryTypedDict]
    chat_summary: NotRequired[InsightsChatSummaryTypedDict]
    extension_summary: NotRequired[CurrentActiveUsersTypedDict]
    ugc_summary: NotRequired[CurrentActiveUsersTypedDict]
    last_updated_ts: NotRequired[int]
    r"""Unix timestamp of the last update for the insights data in the response."""
    search_session_satisfaction: NotRequired[float]
    r"""Search session satisfaction rate, over the specified time period in the specified departments."""
    monthly_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    weekly_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    daily_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    search_monthly_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    search_weekly_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    search_daily_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    assistant_monthly_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    assistant_weekly_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    assistant_daily_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    agents_monthly_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    agents_weekly_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    agents_daily_active_user_timeseries: NotRequired[LabeledCountInfoTypedDict]
    searches_timeseries: NotRequired[LabeledCountInfoTypedDict]
    assistant_interactions_timeseries: NotRequired[LabeledCountInfoTypedDict]
    agent_runs_timeseries: NotRequired[LabeledCountInfoTypedDict]
    search_datasource_counts: NotRequired[Dict[str, int]]
    r"""Counts of search result clicks, by datasource, over the specified time period in the specified departments."""
    chat_datasource_counts: NotRequired[Dict[str, int]]
    r"""Counts of cited documents in chat, by datasource, over the specified time period in the specified departments."""
    per_user_insights: NotRequired[List[PerUserInsightTypedDict]]
    r"""Per-user insights, over the specified time period in the specified departments. All current users in the organization who have signed into Glean at least once are included."""


class InsightsOverviewResponse(BaseModel):
    monthly_active_users: Annotated[
        Optional[int], pydantic.Field(alias="monthlyActiveUsers")
    ] = None
    r"""Number of current Monthly Active Users, in the specified departments."""

    weekly_active_users: Annotated[
        Optional[int], pydantic.Field(alias="weeklyActiveUsers")
    ] = None
    r"""Number of current Weekly Active Users, in the specified departments."""

    departments: Optional[List[str]] = None
    r"""Department name(s)."""

    employee_count: Annotated[Optional[int], pydantic.Field(alias="employeeCount")] = (
        None
    )
    r"""Number of current employees in the specified departments, according to the Org Chart."""

    total_signups: Annotated[Optional[int], pydantic.Field(alias="totalSignups")] = None
    r"""Number of current signed up employees in the specified departments, according to the Org Chart."""

    search_summary: Annotated[
        Optional[InsightsSearchSummary], pydantic.Field(alias="searchSummary")
    ] = None

    chat_summary: Annotated[
        Optional[InsightsChatSummary], pydantic.Field(alias="chatSummary")
    ] = None

    extension_summary: Annotated[
        Optional[CurrentActiveUsers], pydantic.Field(alias="extensionSummary")
    ] = None

    ugc_summary: Annotated[
        Optional[CurrentActiveUsers], pydantic.Field(alias="ugcSummary")
    ] = None

    last_updated_ts: Annotated[Optional[int], pydantic.Field(alias="lastUpdatedTs")] = (
        None
    )
    r"""Unix timestamp of the last update for the insights data in the response."""

    search_session_satisfaction: Annotated[
        Optional[float], pydantic.Field(alias="searchSessionSatisfaction")
    ] = None
    r"""Search session satisfaction rate, over the specified time period in the specified departments."""

    monthly_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo], pydantic.Field(alias="monthlyActiveUserTimeseries")
    ] = None

    weekly_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo], pydantic.Field(alias="weeklyActiveUserTimeseries")
    ] = None

    daily_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo], pydantic.Field(alias="dailyActiveUserTimeseries")
    ] = None

    search_monthly_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo],
        pydantic.Field(alias="searchMonthlyActiveUserTimeseries"),
    ] = None

    search_weekly_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo],
        pydantic.Field(alias="searchWeeklyActiveUserTimeseries"),
    ] = None

    search_daily_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo],
        pydantic.Field(alias="searchDailyActiveUserTimeseries"),
    ] = None

    assistant_monthly_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo],
        pydantic.Field(alias="assistantMonthlyActiveUserTimeseries"),
    ] = None

    assistant_weekly_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo],
        pydantic.Field(alias="assistantWeeklyActiveUserTimeseries"),
    ] = None

    assistant_daily_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo],
        pydantic.Field(alias="assistantDailyActiveUserTimeseries"),
    ] = None

    agents_monthly_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo],
        pydantic.Field(alias="agentsMonthlyActiveUserTimeseries"),
    ] = None

    agents_weekly_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo],
        pydantic.Field(alias="agentsWeeklyActiveUserTimeseries"),
    ] = None

    agents_daily_active_user_timeseries: Annotated[
        Optional[LabeledCountInfo],
        pydantic.Field(alias="agentsDailyActiveUserTimeseries"),
    ] = None

    searches_timeseries: Annotated[
        Optional[LabeledCountInfo], pydantic.Field(alias="searchesTimeseries")
    ] = None

    assistant_interactions_timeseries: Annotated[
        Optional[LabeledCountInfo],
        pydantic.Field(alias="assistantInteractionsTimeseries"),
    ] = None

    agent_runs_timeseries: Annotated[
        Optional[LabeledCountInfo], pydantic.Field(alias="agentRunsTimeseries")
    ] = None

    search_datasource_counts: Annotated[
        Optional[Dict[str, int]], pydantic.Field(alias="searchDatasourceCounts")
    ] = None
    r"""Counts of search result clicks, by datasource, over the specified time period in the specified departments."""

    chat_datasource_counts: Annotated[
        Optional[Dict[str, int]], pydantic.Field(alias="chatDatasourceCounts")
    ] = None
    r"""Counts of cited documents in chat, by datasource, over the specified time period in the specified departments."""

    per_user_insights: Annotated[
        Optional[List[PerUserInsight]], pydantic.Field(alias="perUserInsights")
    ] = None
    r"""Per-user insights, over the specified time period in the specified departments. All current users in the organization who have signed into Glean at least once are included."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "monthlyActiveUsers",
                "weeklyActiveUsers",
                "departments",
                "employeeCount",
                "totalSignups",
                "searchSummary",
                "chatSummary",
                "extensionSummary",
                "ugcSummary",
                "lastUpdatedTs",
                "searchSessionSatisfaction",
                "monthlyActiveUserTimeseries",
                "weeklyActiveUserTimeseries",
                "dailyActiveUserTimeseries",
                "searchMonthlyActiveUserTimeseries",
                "searchWeeklyActiveUserTimeseries",
                "searchDailyActiveUserTimeseries",
                "assistantMonthlyActiveUserTimeseries",
                "assistantWeeklyActiveUserTimeseries",
                "assistantDailyActiveUserTimeseries",
                "agentsMonthlyActiveUserTimeseries",
                "agentsWeeklyActiveUserTimeseries",
                "agentsDailyActiveUserTimeseries",
                "searchesTimeseries",
                "assistantInteractionsTimeseries",
                "agentRunsTimeseries",
                "searchDatasourceCounts",
                "chatDatasourceCounts",
                "perUserInsights",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
