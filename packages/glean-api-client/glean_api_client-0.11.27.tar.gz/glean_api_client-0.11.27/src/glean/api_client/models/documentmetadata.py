"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .countinfo import CountInfo, CountInfoTypedDict
from .customdatavalue import CustomDataValue, CustomDataValueTypedDict
from .documentvisibility import DocumentVisibility
from .indexstatus import IndexStatus, IndexStatusTypedDict
from .objectpermissions import ObjectPermissions, ObjectPermissionsTypedDict
from .thumbnail import Thumbnail, ThumbnailTypedDict
from .viewerinfo import ViewerInfo, ViewerInfoTypedDict
from datetime import datetime
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import Dict, List, Optional, TYPE_CHECKING
from typing_extensions import Annotated, NotRequired, TypedDict

if TYPE_CHECKING:
    from .collection import Collection, CollectionTypedDict
    from .document import Document, DocumentTypedDict
    from .documentinteractions import (
        DocumentInteractions,
        DocumentInteractionsTypedDict,
    )
    from .person import Person, PersonTypedDict
    from .pindocument import PinDocument, PinDocumentTypedDict
    from .shortcut import Shortcut, ShortcutTypedDict
    from .verification import Verification, VerificationTypedDict


class DocumentMetadataTypedDict(TypedDict):
    datasource: NotRequired[str]
    datasource_instance: NotRequired[str]
    r"""The datasource instance from which the document was extracted."""
    object_type: NotRequired[str]
    r"""The type of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue type such as Bug or Feature Request)."""
    container: NotRequired[str]
    r"""The name of the container (higher level parent, not direct parent) of the result. Interpretation is specific to each datasource (e.g. Channels for Slack, Project for Jira). cf. parentId"""
    container_id: NotRequired[str]
    r"""The Glean Document ID of the container. Uniquely identifies the container."""
    super_container_id: NotRequired[str]
    r"""The Glean Document ID of the super container. Super container represents a broader abstraction that contains many containers. For example, whereas container might refer to a folder, super container would refer to a drive."""
    parent_id: NotRequired[str]
    r"""The id of the direct parent of the result. Interpretation is specific to each datasource (e.g. parent issue for Jira). cf. container"""
    mime_type: NotRequired[str]
    document_id: NotRequired[str]
    r"""The index-wide unique identifier."""
    logging_id: NotRequired[str]
    r"""A unique identifier used to represent the document in any logging or feedback requests in place of documentId."""
    document_id_hash: NotRequired[str]
    r"""Hash of the Glean Document ID."""
    create_time: NotRequired[datetime]
    update_time: NotRequired[datetime]
    author: NotRequired["PersonTypedDict"]
    owner: NotRequired["PersonTypedDict"]
    mentioned_people: NotRequired[List["PersonTypedDict"]]
    r"""A list of people mentioned in the document."""
    visibility: NotRequired[DocumentVisibility]
    r"""The level of visibility of the document as understood by our system."""
    components: NotRequired[List[str]]
    r"""A list of components this result is associated with. Interpretation is specific to each datasource. (e.g. for Jira issues, these are [components](https://confluence.atlassian.com/jirasoftwarecloud/organizing-work-with-components-764478279.html).)"""
    status: NotRequired[str]
    r"""The status or disposition of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue status such as Done, In Progress or Will Not Fix)."""
    status_category: NotRequired[str]
    r"""The status category of the result. Meant to be more general than status. Interpretation is specific to each datasource."""
    pins: NotRequired[List["PinDocumentTypedDict"]]
    r"""A list of stars associated with this result.  \"Pin\" is an older name."""
    priority: NotRequired[str]
    r"""The document priority. Interpretation is datasource specific."""
    assigned_to: NotRequired["PersonTypedDict"]
    updated_by: NotRequired["PersonTypedDict"]
    labels: NotRequired[List[str]]
    r"""A list of tags for the document. Interpretation is datasource specific."""
    collections: NotRequired[List["CollectionTypedDict"]]
    r"""A list of collections that the document belongs to."""
    datasource_id: NotRequired[str]
    r"""The user-visible datasource specific id (e.g. Salesforce case number for example, GitHub PR number)."""
    interactions: NotRequired["DocumentInteractionsTypedDict"]
    verification: NotRequired["VerificationTypedDict"]
    viewer_info: NotRequired[ViewerInfoTypedDict]
    permissions: NotRequired[ObjectPermissionsTypedDict]
    visit_count: NotRequired[CountInfoTypedDict]
    shortcuts: NotRequired[List["ShortcutTypedDict"]]
    r"""A list of shortcuts of which destination URL is for the document."""
    path: NotRequired[str]
    r"""For file datasources like onedrive/github etc this has the path to the file"""
    custom_data: NotRequired[Dict[str, CustomDataValueTypedDict]]
    r"""Custom fields specific to individual datasources"""
    document_category: NotRequired[str]
    r"""The document's document_category(.proto)."""
    contact_person: NotRequired["PersonTypedDict"]
    thumbnail: NotRequired[ThumbnailTypedDict]
    index_status: NotRequired[IndexStatusTypedDict]
    ancestors: NotRequired[List["DocumentTypedDict"]]
    r"""A list of documents that are ancestors of this document in the hierarchy of the document's datasource, for example parent folders or containers. Ancestors can be of different types and some may not be indexed. Higher level ancestors appear earlier in the list."""


class DocumentMetadata(BaseModel):
    datasource: Optional[str] = None

    datasource_instance: Annotated[
        Optional[str], pydantic.Field(alias="datasourceInstance")
    ] = None
    r"""The datasource instance from which the document was extracted."""

    object_type: Annotated[Optional[str], pydantic.Field(alias="objectType")] = None
    r"""The type of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue type such as Bug or Feature Request)."""

    container: Optional[str] = None
    r"""The name of the container (higher level parent, not direct parent) of the result. Interpretation is specific to each datasource (e.g. Channels for Slack, Project for Jira). cf. parentId"""

    container_id: Annotated[Optional[str], pydantic.Field(alias="containerId")] = None
    r"""The Glean Document ID of the container. Uniquely identifies the container."""

    super_container_id: Annotated[
        Optional[str], pydantic.Field(alias="superContainerId")
    ] = None
    r"""The Glean Document ID of the super container. Super container represents a broader abstraction that contains many containers. For example, whereas container might refer to a folder, super container would refer to a drive."""

    parent_id: Annotated[Optional[str], pydantic.Field(alias="parentId")] = None
    r"""The id of the direct parent of the result. Interpretation is specific to each datasource (e.g. parent issue for Jira). cf. container"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None

    document_id: Annotated[Optional[str], pydantic.Field(alias="documentId")] = None
    r"""The index-wide unique identifier."""

    logging_id: Annotated[Optional[str], pydantic.Field(alias="loggingId")] = None
    r"""A unique identifier used to represent the document in any logging or feedback requests in place of documentId."""

    document_id_hash: Annotated[
        Optional[str], pydantic.Field(alias="documentIdHash")
    ] = None
    r"""Hash of the Glean Document ID."""

    create_time: Annotated[Optional[datetime], pydantic.Field(alias="createTime")] = (
        None
    )

    update_time: Annotated[Optional[datetime], pydantic.Field(alias="updateTime")] = (
        None
    )

    author: Optional["Person"] = None

    owner: Optional["Person"] = None

    mentioned_people: Annotated[
        Optional[List["Person"]], pydantic.Field(alias="mentionedPeople")
    ] = None
    r"""A list of people mentioned in the document."""

    visibility: Optional[DocumentVisibility] = None
    r"""The level of visibility of the document as understood by our system."""

    components: Optional[List[str]] = None
    r"""A list of components this result is associated with. Interpretation is specific to each datasource. (e.g. for Jira issues, these are [components](https://confluence.atlassian.com/jirasoftwarecloud/organizing-work-with-components-764478279.html).)"""

    status: Optional[str] = None
    r"""The status or disposition of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue status such as Done, In Progress or Will Not Fix)."""

    status_category: Annotated[
        Optional[str], pydantic.Field(alias="statusCategory")
    ] = None
    r"""The status category of the result. Meant to be more general than status. Interpretation is specific to each datasource."""

    pins: Optional[List["PinDocument"]] = None
    r"""A list of stars associated with this result.  \"Pin\" is an older name."""

    priority: Optional[str] = None
    r"""The document priority. Interpretation is datasource specific."""

    assigned_to: Annotated[Optional["Person"], pydantic.Field(alias="assignedTo")] = (
        None
    )

    updated_by: Annotated[Optional["Person"], pydantic.Field(alias="updatedBy")] = None

    labels: Optional[List[str]] = None
    r"""A list of tags for the document. Interpretation is datasource specific."""

    collections: Optional[List["Collection"]] = None
    r"""A list of collections that the document belongs to."""

    datasource_id: Annotated[Optional[str], pydantic.Field(alias="datasourceId")] = None
    r"""The user-visible datasource specific id (e.g. Salesforce case number for example, GitHub PR number)."""

    interactions: Optional["DocumentInteractions"] = None

    verification: Optional["Verification"] = None

    viewer_info: Annotated[Optional[ViewerInfo], pydantic.Field(alias="viewerInfo")] = (
        None
    )

    permissions: Optional[ObjectPermissions] = None

    visit_count: Annotated[Optional[CountInfo], pydantic.Field(alias="visitCount")] = (
        None
    )

    shortcuts: Optional[List["Shortcut"]] = None
    r"""A list of shortcuts of which destination URL is for the document."""

    path: Optional[str] = None
    r"""For file datasources like onedrive/github etc this has the path to the file"""

    custom_data: Annotated[
        Optional[Dict[str, CustomDataValue]], pydantic.Field(alias="customData")
    ] = None
    r"""Custom fields specific to individual datasources"""

    document_category: Annotated[
        Optional[str], pydantic.Field(alias="documentCategory")
    ] = None
    r"""The document's document_category(.proto)."""

    contact_person: Annotated[
        Optional["Person"], pydantic.Field(alias="contactPerson")
    ] = None

    thumbnail: Optional[Thumbnail] = None

    index_status: Annotated[
        Optional[IndexStatus], pydantic.Field(alias="indexStatus")
    ] = None

    ancestors: Optional[List["Document"]] = None
    r"""A list of documents that are ancestors of this document in the hierarchy of the document's datasource, for example parent folders or containers. Ancestors can be of different types and some may not be indexed. Higher level ancestors appear earlier in the list."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "datasource",
                "datasourceInstance",
                "objectType",
                "container",
                "containerId",
                "superContainerId",
                "parentId",
                "mimeType",
                "documentId",
                "loggingId",
                "documentIdHash",
                "createTime",
                "updateTime",
                "author",
                "owner",
                "mentionedPeople",
                "visibility",
                "components",
                "status",
                "statusCategory",
                "pins",
                "priority",
                "assignedTo",
                "updatedBy",
                "labels",
                "collections",
                "datasourceId",
                "interactions",
                "verification",
                "viewerInfo",
                "permissions",
                "visitCount",
                "shortcuts",
                "path",
                "customData",
                "documentCategory",
                "contactPerson",
                "thumbnail",
                "indexStatus",
                "ancestors",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
