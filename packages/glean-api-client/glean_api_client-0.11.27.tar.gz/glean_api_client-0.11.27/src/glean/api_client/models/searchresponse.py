"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .facetfilter import FacetFilter, FacetFilterTypedDict
from .facetresult import FacetResult, FacetResultTypedDict
from .generatedqna import GeneratedQna, GeneratedQnaTypedDict
from .gleandataerror import GleanDataError, GleanDataErrorTypedDict
from .resultsdescription import ResultsDescription, ResultsDescriptionTypedDict
from .resulttab import ResultTab, ResultTabTypedDict
from .searchresponsemetadata import (
    SearchResponseMetadata,
    SearchResponseMetadataTypedDict,
)
from .searchresult import SearchResult, SearchResultTypedDict
from .sessioninfo import SessionInfo, SessionInfoTypedDict
from .structuredresult import StructuredResult, StructuredResultTypedDict
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class SearchResponseTypedDict(TypedDict):
    tracking_token: NotRequired[str]
    r"""A token that should be passed for additional requests related to this request (such as more results requests)."""
    session_info: NotRequired[SessionInfoTypedDict]
    results: NotRequired[List[SearchResultTypedDict]]
    structured_results: NotRequired[List[StructuredResultTypedDict]]
    generated_qna_result: NotRequired[GeneratedQnaTypedDict]
    glean_data_error: NotRequired[GleanDataErrorTypedDict]
    request_id: NotRequired[str]
    r"""A platform-generated request ID to correlate backend logs."""
    backend_time_millis: NotRequired[int]
    r"""Time in milliseconds the backend took to respond to the request."""
    experiment_ids: NotRequired[List[int]]
    r"""List of experiment ids for the corresponding request."""
    metadata: NotRequired[SearchResponseMetadataTypedDict]
    facet_results: NotRequired[List[FacetResultTypedDict]]
    result_tabs: NotRequired[List[ResultTabTypedDict]]
    r"""All result tabs available for the current query. Populated if QUERY_METADATA is specified in the request."""
    result_tab_ids: NotRequired[List[str]]
    r"""The unique IDs of the result tabs to which this response belongs."""
    results_description: NotRequired[ResultsDescriptionTypedDict]
    rewritten_facet_filters: NotRequired[List[FacetFilterTypedDict]]
    r"""The actual applied facet filters based on the operators and facetFilters in the query. Useful for mapping typed operators to visual facets."""
    cursor: NotRequired[str]
    r"""Cursor that indicates the start of the next page of results. To be passed in \"more\" requests for this query."""
    has_more_results: NotRequired[bool]
    r"""Whether more results are available. Use cursor to retrieve them."""


class SearchResponse(BaseModel):
    tracking_token: Annotated[Optional[str], pydantic.Field(alias="trackingToken")] = (
        None
    )
    r"""A token that should be passed for additional requests related to this request (such as more results requests)."""

    session_info: Annotated[
        Optional[SessionInfo], pydantic.Field(alias="sessionInfo")
    ] = None

    results: Optional[List[SearchResult]] = None

    structured_results: Annotated[
        Optional[List[StructuredResult]], pydantic.Field(alias="structuredResults")
    ] = None

    generated_qna_result: Annotated[
        Optional[GeneratedQna], pydantic.Field(alias="generatedQnaResult")
    ] = None

    glean_data_error: Annotated[
        Optional[GleanDataError], pydantic.Field(alias="errorInfo")
    ] = None

    request_id: Annotated[Optional[str], pydantic.Field(alias="requestID")] = None
    r"""A platform-generated request ID to correlate backend logs."""

    backend_time_millis: Annotated[
        Optional[int], pydantic.Field(alias="backendTimeMillis")
    ] = None
    r"""Time in milliseconds the backend took to respond to the request."""

    experiment_ids: Annotated[
        Optional[List[int]], pydantic.Field(alias="experimentIds")
    ] = None
    r"""List of experiment ids for the corresponding request."""

    metadata: Optional[SearchResponseMetadata] = None

    facet_results: Annotated[
        Optional[List[FacetResult]], pydantic.Field(alias="facetResults")
    ] = None

    result_tabs: Annotated[
        Optional[List[ResultTab]], pydantic.Field(alias="resultTabs")
    ] = None
    r"""All result tabs available for the current query. Populated if QUERY_METADATA is specified in the request."""

    result_tab_ids: Annotated[
        Optional[List[str]], pydantic.Field(alias="resultTabIds")
    ] = None
    r"""The unique IDs of the result tabs to which this response belongs."""

    results_description: Annotated[
        Optional[ResultsDescription], pydantic.Field(alias="resultsDescription")
    ] = None

    rewritten_facet_filters: Annotated[
        Optional[List[FacetFilter]], pydantic.Field(alias="rewrittenFacetFilters")
    ] = None
    r"""The actual applied facet filters based on the operators and facetFilters in the query. Useful for mapping typed operators to visual facets."""

    cursor: Optional[str] = None
    r"""Cursor that indicates the start of the next page of results. To be passed in \"more\" requests for this query."""

    has_more_results: Annotated[
        Optional[bool], pydantic.Field(alias="hasMoreResults")
    ] = None
    r"""Whether more results are available. Use cursor to retrieve them."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "trackingToken",
                "sessionInfo",
                "results",
                "structuredResults",
                "generatedQnaResult",
                "GleanDataError",
                "requestID",
                "backendTimeMillis",
                "experimentIds",
                "metadata",
                "facetResults",
                "resultTabs",
                "resultTabIds",
                "resultsDescription",
                "rewrittenFacetFilters",
                "cursor",
                "hasMoreResults",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
