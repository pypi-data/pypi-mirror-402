"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .clustertypeenum import ClusterTypeEnum
from .searchresultprominenceenum import SearchResultProminenceEnum
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional, TYPE_CHECKING
from typing_extensions import Annotated, NotRequired, TypedDict

if TYPE_CHECKING:
    from .clustergroup import ClusterGroup, ClusterGroupTypedDict
    from .document import Document, DocumentTypedDict
    from .pindocument import PinDocument, PinDocumentTypedDict
    from .querysuggestion import QuerySuggestion, QuerySuggestionTypedDict
    from .querysuggestionlist import QuerySuggestionList, QuerySuggestionListTypedDict
    from .relateddocuments import RelatedDocuments, RelatedDocumentsTypedDict
    from .searchresultsnippet import SearchResultSnippet, SearchResultSnippetTypedDict
    from .structuredresult import StructuredResult, StructuredResultTypedDict


class SearchResultTypedDict(TypedDict):
    url: str
    structured_results: NotRequired[List["StructuredResultTypedDict"]]
    r"""An array of entities in the work graph retrieved via a data request."""
    tracking_token: NotRequired[str]
    r"""An opaque token that represents this particular result in this particular query. To be used for /feedback reporting."""
    document: NotRequired["DocumentTypedDict"]
    title: NotRequired[str]
    native_app_url: NotRequired[str]
    r"""A deep link, if available, into the datasource's native application for the user's platform (e.g. slack://...)."""
    snippets: NotRequired[List["SearchResultSnippetTypedDict"]]
    r"""Text content from the result document which contains search query terms, if available."""
    full_text: NotRequired[str]
    r"""The full body text of the result if not already contained in the snippets. Only populated for conversation results (e.g. results from a messaging app such as Slack)."""
    full_text_list: NotRequired[List[str]]
    r"""The full body text of the result if not already contained in the snippets; each item in the array represents a separate line in the original text. Only populated for conversation results (e.g. results from a messaging app such as Slack)."""
    related_results: NotRequired[List["RelatedDocumentsTypedDict"]]
    r"""A list of results related to this search result. Eg. for conversation results it contains individual messages from the conversation document which will be shown on SERP."""
    clustered_results: NotRequired[List[SearchResultTypedDict]]
    r"""A list of results that should be displayed as associated with this result."""
    all_clustered_results: NotRequired[List["ClusterGroupTypedDict"]]
    r"""A list of results that should be displayed as associated with this result."""
    attachment_count: NotRequired[int]
    r"""The total number of attachments."""
    attachments: NotRequired[List[SearchResultTypedDict]]
    r"""A (potentially partial) list of results representing documents attached to the main result document."""
    backlink_results: NotRequired[List[SearchResultTypedDict]]
    r"""A list of results that should be displayed as backlinks of this result in reverse chronological order."""
    cluster_type: NotRequired[ClusterTypeEnum]
    r"""The reason for inclusion of clusteredResults."""
    must_include_suggestions: NotRequired["QuerySuggestionListTypedDict"]
    query_suggestion: NotRequired["QuerySuggestionTypedDict"]
    prominence: NotRequired[SearchResultProminenceEnum]
    r"""The level of visual distinction that should be given to a result.

    """
    attachment_context: NotRequired[str]
    r"""Additional context for the relationship between the result and the document it's attached to."""
    pins: NotRequired[List["PinDocumentTypedDict"]]
    r"""A list of pins associated with this search result."""


class SearchResult(BaseModel):
    url: str

    structured_results: Annotated[
        Optional[List["StructuredResult"]], pydantic.Field(alias="structuredResults")
    ] = None
    r"""An array of entities in the work graph retrieved via a data request."""

    tracking_token: Annotated[Optional[str], pydantic.Field(alias="trackingToken")] = (
        None
    )
    r"""An opaque token that represents this particular result in this particular query. To be used for /feedback reporting."""

    document: Optional["Document"] = None

    title: Optional[str] = None

    native_app_url: Annotated[Optional[str], pydantic.Field(alias="nativeAppUrl")] = (
        None
    )
    r"""A deep link, if available, into the datasource's native application for the user's platform (e.g. slack://...)."""

    snippets: Optional[List["SearchResultSnippet"]] = None
    r"""Text content from the result document which contains search query terms, if available."""

    full_text: Annotated[Optional[str], pydantic.Field(alias="fullText")] = None
    r"""The full body text of the result if not already contained in the snippets. Only populated for conversation results (e.g. results from a messaging app such as Slack)."""

    full_text_list: Annotated[
        Optional[List[str]], pydantic.Field(alias="fullTextList")
    ] = None
    r"""The full body text of the result if not already contained in the snippets; each item in the array represents a separate line in the original text. Only populated for conversation results (e.g. results from a messaging app such as Slack)."""

    related_results: Annotated[
        Optional[List["RelatedDocuments"]], pydantic.Field(alias="relatedResults")
    ] = None
    r"""A list of results related to this search result. Eg. for conversation results it contains individual messages from the conversation document which will be shown on SERP."""

    clustered_results: Annotated[
        Optional[List[SearchResult]], pydantic.Field(alias="clusteredResults")
    ] = None
    r"""A list of results that should be displayed as associated with this result."""

    all_clustered_results: Annotated[
        Optional[List["ClusterGroup"]], pydantic.Field(alias="allClusteredResults")
    ] = None
    r"""A list of results that should be displayed as associated with this result."""

    attachment_count: Annotated[
        Optional[int], pydantic.Field(alias="attachmentCount")
    ] = None
    r"""The total number of attachments."""

    attachments: Optional[List[SearchResult]] = None
    r"""A (potentially partial) list of results representing documents attached to the main result document."""

    backlink_results: Annotated[
        Optional[List[SearchResult]], pydantic.Field(alias="backlinkResults")
    ] = None
    r"""A list of results that should be displayed as backlinks of this result in reverse chronological order."""

    cluster_type: Annotated[
        Optional[ClusterTypeEnum], pydantic.Field(alias="clusterType")
    ] = None
    r"""The reason for inclusion of clusteredResults."""

    must_include_suggestions: Annotated[
        Optional["QuerySuggestionList"], pydantic.Field(alias="mustIncludeSuggestions")
    ] = None

    query_suggestion: Annotated[
        Optional["QuerySuggestion"], pydantic.Field(alias="querySuggestion")
    ] = None

    prominence: Optional[SearchResultProminenceEnum] = None
    r"""The level of visual distinction that should be given to a result.

    """

    attachment_context: Annotated[
        Optional[str], pydantic.Field(alias="attachmentContext")
    ] = None
    r"""Additional context for the relationship between the result and the document it's attached to."""

    pins: Optional[List["PinDocument"]] = None
    r"""A list of pins associated with this search result."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "structuredResults",
                "trackingToken",
                "document",
                "title",
                "nativeAppUrl",
                "snippets",
                "fullText",
                "fullTextList",
                "relatedResults",
                "clusteredResults",
                "allClusteredResults",
                "attachmentCount",
                "attachments",
                "backlinkResults",
                "clusterType",
                "mustIncludeSuggestions",
                "querySuggestion",
                "prominence",
                "attachmentContext",
                "pins",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
