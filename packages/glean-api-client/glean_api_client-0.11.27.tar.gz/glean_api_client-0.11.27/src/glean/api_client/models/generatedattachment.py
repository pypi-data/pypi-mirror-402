"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .customer import Customer, CustomerTypedDict
from .document import Document, DocumentTypedDict
from .eventstrategyname import EventStrategyName
from .generatedattachmentcontent import (
    GeneratedAttachmentContent,
    GeneratedAttachmentContentTypedDict,
)
from .person import Person, PersonTypedDict
from .structuredlink import StructuredLink, StructuredLinkTypedDict
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class GeneratedAttachmentTypedDict(TypedDict):
    r"""These are attachments that aren't natively present on the event, and have been smartly suggested."""

    strategy_name: NotRequired[EventStrategyName]
    r"""The name of method used to surface relevant data for a given calendar event."""
    documents: NotRequired[List[DocumentTypedDict]]
    person: NotRequired[PersonTypedDict]
    customer: NotRequired[CustomerTypedDict]
    external_links: NotRequired[List[StructuredLinkTypedDict]]
    r"""A list of links to external sources outside of Glean."""
    content: NotRequired[List[GeneratedAttachmentContentTypedDict]]


class GeneratedAttachment(BaseModel):
    r"""These are attachments that aren't natively present on the event, and have been smartly suggested."""

    strategy_name: Annotated[
        Optional[EventStrategyName], pydantic.Field(alias="strategyName")
    ] = None
    r"""The name of method used to surface relevant data for a given calendar event."""

    documents: Optional[List[Document]] = None

    person: Optional[Person] = None

    customer: Optional[Customer] = None

    external_links: Annotated[
        Optional[List[StructuredLink]], pydantic.Field(alias="externalLinks")
    ] = None
    r"""A list of links to external sources outside of Glean."""

    content: Optional[List[GeneratedAttachmentContent]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "strategyName",
                "documents",
                "person",
                "customer",
                "externalLinks",
                "content",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
