"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .authtoken import AuthToken, AuthTokenTypedDict
from .sessioninfo import SessionInfo, SessionInfoTypedDict
from enum import Enum
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class AutocompleteRequestResultType(str, Enum):
    ADDITIONAL_DOCUMENT = "ADDITIONAL_DOCUMENT"
    APP = "APP"
    BROWSER_HISTORY = "BROWSER_HISTORY"
    DATASOURCE = "DATASOURCE"
    DOCUMENT = "DOCUMENT"
    ENTITY = "ENTITY"
    GOLINK = "GOLINK"
    HISTORY = "HISTORY"
    CHAT_HISTORY = "CHAT_HISTORY"
    NEW_CHAT = "NEW_CHAT"
    OPERATOR = "OPERATOR"
    OPERATOR_VALUE = "OPERATOR_VALUE"
    QUICKLINK = "QUICKLINK"
    SUGGESTION = "SUGGESTION"


class AutocompleteRequestTypedDict(TypedDict):
    tracking_token: NotRequired[str]
    session_info: NotRequired[SessionInfoTypedDict]
    query: NotRequired[str]
    r"""Partially typed query."""
    datasources_filter: NotRequired[List[str]]
    r"""Filter results to only those relevant to one or more datasources (e.g. jira, gdrive). Results are unfiltered if missing."""
    datasource: NotRequired[str]
    r"""Filter to only return results relevant to the given datasource."""
    result_types: NotRequired[List[AutocompleteRequestResultType]]
    r"""Filter to only return results of the given type(s). All types may be returned if omitted."""
    result_size: NotRequired[int]
    r"""Maximum number of results to be returned. If no value is provided, the backend will cap at 200.

    """
    auth_tokens: NotRequired[List[AuthTokenTypedDict]]
    r"""Auth tokens which may be used for federated results."""


class AutocompleteRequest(BaseModel):
    tracking_token: Annotated[Optional[str], pydantic.Field(alias="trackingToken")] = (
        None
    )

    session_info: Annotated[
        Optional[SessionInfo], pydantic.Field(alias="sessionInfo")
    ] = None

    query: Optional[str] = None
    r"""Partially typed query."""

    datasources_filter: Annotated[
        Optional[List[str]], pydantic.Field(alias="datasourcesFilter")
    ] = None
    r"""Filter results to only those relevant to one or more datasources (e.g. jira, gdrive). Results are unfiltered if missing."""

    datasource: Optional[str] = None
    r"""Filter to only return results relevant to the given datasource."""

    result_types: Annotated[
        Optional[List[AutocompleteRequestResultType]],
        pydantic.Field(alias="resultTypes"),
    ] = None
    r"""Filter to only return results of the given type(s). All types may be returned if omitted."""

    result_size: Annotated[Optional[int], pydantic.Field(alias="resultSize")] = None
    r"""Maximum number of results to be returned. If no value is provided, the backend will cap at 200.

    """

    auth_tokens: Annotated[
        Optional[List[AuthToken]], pydantic.Field(alias="authTokens")
    ] = None
    r"""Auth tokens which may be used for federated results."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "trackingToken",
                "sessionInfo",
                "query",
                "datasourcesFilter",
                "datasource",
                "resultTypes",
                "resultSize",
                "authTokens",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
