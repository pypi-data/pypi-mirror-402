"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .feedbackchatexchange import FeedbackChatExchange, FeedbackChatExchangeTypedDict
from enum import Enum
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class ManualFeedbackInfoSource(str, Enum):
    r"""The source associated with the Feedback.event.MANUAL_FEEDBACK event."""

    AUTOCOMPLETE = "AUTOCOMPLETE"
    CALENDAR = "CALENDAR"
    CHAT = "CHAT"
    CHAT_GENERAL = "CHAT_GENERAL"
    CONCEPT_CARD = "CONCEPT_CARD"
    DESKTOP_APP = "DESKTOP_APP"
    DISAMBIGUATION_CARD = "DISAMBIGUATION_CARD"
    EXPERT_DETECTION = "EXPERT_DETECTION"
    FEED = "FEED"
    GENERATED_Q_AND_A = "GENERATED_Q_AND_A"
    INLINE_MENU = "INLINE_MENU"
    NATIVE_RESULT = "NATIVE_RESULT"
    PRISM = "PRISM"
    Q_AND_A = "Q_AND_A"
    RELATED_QUESTIONS = "RELATED_QUESTIONS"
    REPORT_ISSUE = "REPORT_ISSUE"
    SCIOBOT = "SCIOBOT"
    SEARCH = "SEARCH"
    SIDEBAR = "SIDEBAR"
    SUMMARY = "SUMMARY"
    TASKS = "TASKS"
    TASK_EXECUTION = "TASK_EXECUTION"


class Issue(str, Enum):
    INACCURATE_RESPONSE = "INACCURATE_RESPONSE"
    INCOMPLETE_OR_NO_ANSWER = "INCOMPLETE_OR_NO_ANSWER"
    INCORRECT_CITATION = "INCORRECT_CITATION"
    MISSING_CITATION = "MISSING_CITATION"
    OTHER = "OTHER"
    OUTDATED_RESPONSE = "OUTDATED_RESPONSE"
    RESULT_MISSING = "RESULT_MISSING"
    RESULT_SHOULD_NOT_APPEAR = "RESULT_SHOULD_NOT_APPEAR"
    RESULTS_HELPFUL = "RESULTS_HELPFUL"
    RESULTS_POOR_ORDER = "RESULTS_POOR_ORDER"
    TOO_MUCH_ONE_KIND = "TOO_MUCH_ONE_KIND"


class ManualFeedbackInfoVote(str, Enum):
    r"""The vote associated with the Feedback.event.MANUAL_FEEDBACK event."""

    UPVOTE = "UPVOTE"
    DOWNVOTE = "DOWNVOTE"


class ManualFeedbackInfoTypedDict(TypedDict):
    email: NotRequired[str]
    r"""The email address of the user who submitted the Feedback.event.MANUAL_FEEDBACK event."""
    source: NotRequired[ManualFeedbackInfoSource]
    r"""The source associated with the Feedback.event.MANUAL_FEEDBACK event."""
    issue: NotRequired[str]
    r"""The issue the user indicated in the feedback."""
    issues: NotRequired[List[Issue]]
    r"""The issue(s) the user indicated in the feedback."""
    image_urls: NotRequired[List[str]]
    r"""URLs of images uploaded by user when providing feedback"""
    query: NotRequired[str]
    r"""The query associated with the Feedback.event.MANUAL_FEEDBACK event."""
    obscured_query: NotRequired[str]
    r"""The query associated with the Feedback.event.MANUAL_FEEDBACK event, but obscured such that the vowels are replaced with special characters. For search feedback events only."""
    active_tab: NotRequired[str]
    r"""Which tabs the user had chosen at the time of the Feedback.event.MANUAL_FEEDBACK event. For search feedback events only."""
    comments: NotRequired[str]
    r"""The comments users can optionally add to the Feedback.event.MANUAL_FEEDBACK events."""
    search_results: NotRequired[List[str]]
    r"""The array of search result Glean Document IDs, ordered by top to bottom result."""
    previous_messages: NotRequired[List[str]]
    r"""The array of previous messages in a chat session, ordered by oldest to newest."""
    chat_transcript: NotRequired[List[FeedbackChatExchangeTypedDict]]
    r"""Array of previous request/response exchanges, ordered by oldest to newest."""
    num_queries_from_first_run: NotRequired[int]
    r"""How many times this query has been run in the past."""
    vote: NotRequired[ManualFeedbackInfoVote]
    r"""The vote associated with the Feedback.event.MANUAL_FEEDBACK event."""
    rating: NotRequired[int]
    r"""A rating associated with the user feedback. The value will be between one and the maximum given by ratingScale, inclusive."""
    rating_key: NotRequired[str]
    r"""A description of the rating that contextualizes how it appeared to the user, e.g. \"satisfied\"."""
    rating_scale: NotRequired[int]
    r"""The scale of comparison for a rating associated with the feedback. Rating values start from one and go up to the maximum specified by ratingScale. For example, a five-option satisfaction rating will have a ratingScale of 5 and a thumbs-up/thumbs-down rating will have a ratingScale of 2."""


class ManualFeedbackInfo(BaseModel):
    email: Annotated[
        Optional[str],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None
    r"""The email address of the user who submitted the Feedback.event.MANUAL_FEEDBACK event."""

    source: Optional[ManualFeedbackInfoSource] = None
    r"""The source associated with the Feedback.event.MANUAL_FEEDBACK event."""

    issue: Annotated[
        Optional[str],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None
    r"""The issue the user indicated in the feedback."""

    issues: Optional[List[Issue]] = None
    r"""The issue(s) the user indicated in the feedback."""

    image_urls: Annotated[Optional[List[str]], pydantic.Field(alias="imageUrls")] = None
    r"""URLs of images uploaded by user when providing feedback"""

    query: Optional[str] = None
    r"""The query associated with the Feedback.event.MANUAL_FEEDBACK event."""

    obscured_query: Annotated[Optional[str], pydantic.Field(alias="obscuredQuery")] = (
        None
    )
    r"""The query associated with the Feedback.event.MANUAL_FEEDBACK event, but obscured such that the vowels are replaced with special characters. For search feedback events only."""

    active_tab: Annotated[Optional[str], pydantic.Field(alias="activeTab")] = None
    r"""Which tabs the user had chosen at the time of the Feedback.event.MANUAL_FEEDBACK event. For search feedback events only."""

    comments: Optional[str] = None
    r"""The comments users can optionally add to the Feedback.event.MANUAL_FEEDBACK events."""

    search_results: Annotated[
        Optional[List[str]], pydantic.Field(alias="searchResults")
    ] = None
    r"""The array of search result Glean Document IDs, ordered by top to bottom result."""

    previous_messages: Annotated[
        Optional[List[str]], pydantic.Field(alias="previousMessages")
    ] = None
    r"""The array of previous messages in a chat session, ordered by oldest to newest."""

    chat_transcript: Annotated[
        Optional[List[FeedbackChatExchange]], pydantic.Field(alias="chatTranscript")
    ] = None
    r"""Array of previous request/response exchanges, ordered by oldest to newest."""

    num_queries_from_first_run: Annotated[
        Optional[int], pydantic.Field(alias="numQueriesFromFirstRun")
    ] = None
    r"""How many times this query has been run in the past."""

    vote: Optional[ManualFeedbackInfoVote] = None
    r"""The vote associated with the Feedback.event.MANUAL_FEEDBACK event."""

    rating: Optional[int] = None
    r"""A rating associated with the user feedback. The value will be between one and the maximum given by ratingScale, inclusive."""

    rating_key: Annotated[Optional[str], pydantic.Field(alias="ratingKey")] = None
    r"""A description of the rating that contextualizes how it appeared to the user, e.g. \"satisfied\"."""

    rating_scale: Annotated[Optional[int], pydantic.Field(alias="ratingScale")] = None
    r"""The scale of comparison for a rating associated with the feedback. Rating values start from one and go up to the maximum specified by ratingScale. For example, a five-option satisfaction rating will have a ratingScale of 5 and a thumbs-up/thumbs-down rating will have a ratingScale of 2."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "email",
                "source",
                "issue",
                "issues",
                "imageUrls",
                "query",
                "obscuredQuery",
                "activeTab",
                "comments",
                "searchResults",
                "previousMessages",
                "chatTranscript",
                "numQueriesFromFirstRun",
                "vote",
                "rating",
                "ratingKey",
                "ratingScale",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
