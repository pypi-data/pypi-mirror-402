"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .appresult import AppResult, AppResultTypedDict
from .disambiguation import Disambiguation, DisambiguationTypedDict
from enum import Enum
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional, TYPE_CHECKING
from typing_extensions import Annotated, NotRequired, TypedDict

if TYPE_CHECKING:
    from .answer import Answer, AnswerTypedDict
    from .chatmetadata import ChatMetadata, ChatMetadataTypedDict
    from .code import Code, CodeTypedDict
    from .collection import Collection, CollectionTypedDict
    from .customentity import CustomEntity, CustomEntityTypedDict
    from .customer import Customer, CustomerTypedDict
    from .document import Document, DocumentTypedDict
    from .extractedqna import ExtractedQnA, ExtractedQnATypedDict
    from .generatedqna import GeneratedQna, GeneratedQnaTypedDict
    from .meeting import Meeting, MeetingTypedDict
    from .person import Person, PersonTypedDict
    from .querysuggestionlist import QuerySuggestionList, QuerySuggestionListTypedDict
    from .relateddocuments import RelatedDocuments, RelatedDocumentsTypedDict
    from .relatedquestion import RelatedQuestion, RelatedQuestionTypedDict
    from .searchresultsnippet import SearchResultSnippet, SearchResultSnippetTypedDict
    from .shortcut import Shortcut, ShortcutTypedDict
    from .team import Team, TeamTypedDict


class Prominence(str, Enum):
    r"""The level of visual distinction that should be given to a result."""

    # A high-confidence result that should feature prominently on the page.
    HERO = "HERO"
    # May not be the best result but should be given additional visual distinction.
    PROMOTED = "PROMOTED"
    # Should not be distinct from any other results.
    STANDARD = "STANDARD"


class StructuredResultSource(str, Enum):
    r"""Source context for this result. Possible values depend on the result type."""

    EXPERT_DETECTION = "EXPERT_DETECTION"
    ENTITY_NLQ = "ENTITY_NLQ"
    CALENDAR_EVENT = "CALENDAR_EVENT"
    AGENT = "AGENT"


class StructuredResultTypedDict(TypedDict):
    r"""A single object that can support any object in the work graph. Only a single object will be populated."""

    document: NotRequired["DocumentTypedDict"]
    person: NotRequired["PersonTypedDict"]
    customer: NotRequired["CustomerTypedDict"]
    team: NotRequired["TeamTypedDict"]
    custom_entity: NotRequired["CustomEntityTypedDict"]
    answer: NotRequired["AnswerTypedDict"]
    generated_qna: NotRequired["GeneratedQnaTypedDict"]
    extracted_qn_a: NotRequired["ExtractedQnATypedDict"]
    meeting: NotRequired["MeetingTypedDict"]
    app: NotRequired[AppResultTypedDict]
    collection: NotRequired["CollectionTypedDict"]
    code: NotRequired["CodeTypedDict"]
    shortcut: NotRequired["ShortcutTypedDict"]
    query_suggestions: NotRequired["QuerySuggestionListTypedDict"]
    chat: NotRequired["ChatMetadataTypedDict"]
    r"""Metadata of a Chat a user had with Glean Assistant. This contains no actual conversational content."""
    related_documents: NotRequired[List["RelatedDocumentsTypedDict"]]
    r"""A list of documents related to this structured result."""
    related_question: NotRequired["RelatedQuestionTypedDict"]
    disambiguation: NotRequired[DisambiguationTypedDict]
    r"""A disambiguation between multiple entities with the same name"""
    snippets: NotRequired[List["SearchResultSnippetTypedDict"]]
    r"""Any snippets associated to the populated object."""
    tracking_token: NotRequired[str]
    r"""An opaque token that represents this particular result in this particular query. To be used for /feedback reporting."""
    prominence: NotRequired[Prominence]
    r"""The level of visual distinction that should be given to a result."""
    source: NotRequired[StructuredResultSource]
    r"""Source context for this result. Possible values depend on the result type."""


class StructuredResult(BaseModel):
    r"""A single object that can support any object in the work graph. Only a single object will be populated."""

    document: Optional["Document"] = None

    person: Optional["Person"] = None

    customer: Optional["Customer"] = None

    team: Optional["Team"] = None

    custom_entity: Annotated[
        Optional["CustomEntity"], pydantic.Field(alias="customEntity")
    ] = None

    answer: Optional["Answer"] = None

    generated_qna: Annotated[
        Optional["GeneratedQna"], pydantic.Field(alias="generatedQna")
    ] = None

    extracted_qn_a: Annotated[
        Optional["ExtractedQnA"], pydantic.Field(alias="extractedQnA")
    ] = None

    meeting: Optional["Meeting"] = None

    app: Optional[AppResult] = None

    collection: Optional["Collection"] = None

    code: Optional["Code"] = None

    shortcut: Optional["Shortcut"] = None

    query_suggestions: Annotated[
        Optional["QuerySuggestionList"], pydantic.Field(alias="querySuggestions")
    ] = None

    chat: Optional["ChatMetadata"] = None
    r"""Metadata of a Chat a user had with Glean Assistant. This contains no actual conversational content."""

    related_documents: Annotated[
        Optional[List["RelatedDocuments"]], pydantic.Field(alias="relatedDocuments")
    ] = None
    r"""A list of documents related to this structured result."""

    related_question: Annotated[
        Optional["RelatedQuestion"], pydantic.Field(alias="relatedQuestion")
    ] = None

    disambiguation: Optional[Disambiguation] = None
    r"""A disambiguation between multiple entities with the same name"""

    snippets: Optional[List["SearchResultSnippet"]] = None
    r"""Any snippets associated to the populated object."""

    tracking_token: Annotated[Optional[str], pydantic.Field(alias="trackingToken")] = (
        None
    )
    r"""An opaque token that represents this particular result in this particular query. To be used for /feedback reporting."""

    prominence: Optional[Prominence] = None
    r"""The level of visual distinction that should be given to a result."""

    source: Optional[StructuredResultSource] = None
    r"""Source context for this result. Possible values depend on the result type."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "document",
                "person",
                "customer",
                "team",
                "customEntity",
                "answer",
                "generatedQna",
                "extractedQnA",
                "meeting",
                "app",
                "collection",
                "code",
                "shortcut",
                "querySuggestions",
                "chat",
                "relatedDocuments",
                "relatedQuestion",
                "disambiguation",
                "snippets",
                "trackingToken",
                "prominence",
                "source",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
