"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .announcement import Announcement, AnnouncementTypedDict
from .appresult import AppResult, AppResultTypedDict
from .calendarevent import CalendarEvent, CalendarEventTypedDict
from .chatsuggestion import ChatSuggestion, ChatSuggestionTypedDict
from .collection import Collection, CollectionTypedDict
from .collectionitem import CollectionItem, CollectionItemTypedDict
from .countinfo import CountInfo, CountInfoTypedDict
from .digest import Digest, DigestTypedDict
from .displayablelistitemuiconfig import (
    DisplayableListItemUIConfig,
    DisplayableListItemUIConfigTypedDict,
)
from .document import Document, DocumentTypedDict
from .person import Person, PersonTypedDict
from .prompttemplateresult import PromptTemplateResult, PromptTemplateResultTypedDict
from .thumbnail import Thumbnail, ThumbnailTypedDict
from .useractivity import UserActivity, UserActivityTypedDict
from .workflowresult import WorkflowResult, WorkflowResultTypedDict
from enum import Enum
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class Format(str, Enum):
    r"""defines how to render this particular displayable list card"""

    LIST = "LIST"


class UIConfigTypedDict(TypedDict):
    format_: NotRequired[Format]
    r"""defines how to render this particular displayable list card"""
    additional_flags: NotRequired[DisplayableListItemUIConfigTypedDict]
    r"""UI configurations for each item of the list"""


class UIConfig(BaseModel):
    format_: Annotated[Optional[Format], pydantic.Field(alias="format")] = None
    r"""defines how to render this particular displayable list card"""

    additional_flags: Annotated[
        Optional[DisplayableListItemUIConfig], pydantic.Field(alias="additionalFlags")
    ] = None
    r"""UI configurations for each item of the list"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["format", "additionalFlags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class JustificationType(str, Enum):
    r"""Type of the justification."""

    FREQUENTLY_ACCESSED = "FREQUENTLY_ACCESSED"
    RECENTLY_ACCESSED = "RECENTLY_ACCESSED"
    TRENDING_DOCUMENT = "TRENDING_DOCUMENT"
    VERIFICATION_REMINDER = "VERIFICATION_REMINDER"
    SUGGESTED_DOCUMENT = "SUGGESTED_DOCUMENT"
    EMPTY_STATE_SUGGESTION = "EMPTY_STATE_SUGGESTION"
    FRECENCY_SCORED = "FRECENCY_SCORED"
    SERVER_GENERATED = "SERVER_GENERATED"
    USE_CASE = "USE_CASE"
    UPDATE_SINCE_LAST_VIEW = "UPDATE_SINCE_LAST_VIEW"
    RECENTLY_STARTED = "RECENTLY_STARTED"
    EVENT = "EVENT"
    USER_MENTION = "USER_MENTION"
    ANNOUNCEMENT = "ANNOUNCEMENT"
    EXTERNAL_ANNOUNCEMENT = "EXTERNAL_ANNOUNCEMENT"
    POPULARITY_BASED_TRENDING = "POPULARITY_BASED_TRENDING"
    COMPANY_RESOURCE = "COMPANY_RESOURCE"
    EVENT_DOCUMENT_FROM_CONTENT = "EVENT_DOCUMENT_FROM_CONTENT"
    EVENT_DOCUMENT_FROM_SEARCH = "EVENT_DOCUMENT_FROM_SEARCH"
    VISIT_AFFINITY_SCORED = "VISIT_AFFINITY_SCORED"
    SUGGESTED_APP = "SUGGESTED_APP"
    SUGGESTED_PERSON = "SUGGESTED_PERSON"
    ACTIVITY_HIGHLIGHT = "ACTIVITY_HIGHLIGHT"
    SAVED_SEARCH = "SAVED_SEARCH"
    SUGGESTED_CHANNEL = "SUGGESTED_CHANNEL"
    PEOPLE_CELEBRATIONS = "PEOPLE_CELEBRATIONS"
    SOCIAL_LINK = "SOCIAL_LINK"
    ZERO_STATE_CHAT_SUGGESTION = "ZERO_STATE_CHAT_SUGGESTION"
    ZERO_STATE_CHAT_TOOL_SUGGESTION = "ZERO_STATE_CHAT_TOOL_SUGGESTION"
    ZERO_STATE_PROMPT_TEMPLATE_SUGGESTION = "ZERO_STATE_PROMPT_TEMPLATE_SUGGESTION"
    ZERO_STATE_STATIC_WORKFLOW_SUGGESTION = "ZERO_STATE_STATIC_WORKFLOW_SUGGESTION"
    ZERO_STATE_AGENT_SUGGESTION = "ZERO_STATE_AGENT_SUGGESTION"
    PERSONALIZED_CHAT_SUGGESTION = "PERSONALIZED_CHAT_SUGGESTION"
    DAILY_DIGEST = "DAILY_DIGEST"


class FeedEntryTypedDict(TypedDict):
    title: str
    r"""Title for the result. Can be document title, event title and so on."""
    entry_id: NotRequired[str]
    r"""optional ID associated with a single feed entry (displayable_list_id)"""
    thumbnail: NotRequired[ThumbnailTypedDict]
    created_by: NotRequired[PersonTypedDict]
    ui_config: NotRequired[UIConfigTypedDict]
    justification_type: NotRequired[JustificationType]
    r"""Type of the justification."""
    justification: NotRequired[str]
    r"""Server side generated justification string if server provides one."""
    tracking_token: NotRequired[str]
    r"""An opaque token that represents this particular feed entry in this particular response. To be used for /feedback reporting."""
    view_url: NotRequired[str]
    r"""View URL for the entry if based on links that are not documents in Glean."""
    document: NotRequired[DocumentTypedDict]
    event: NotRequired[CalendarEventTypedDict]
    announcement: NotRequired[AnnouncementTypedDict]
    digest: NotRequired[DigestTypedDict]
    collection: NotRequired[CollectionTypedDict]
    collection_item: NotRequired[CollectionItemTypedDict]
    person: NotRequired[PersonTypedDict]
    app: NotRequired[AppResultTypedDict]
    chat_suggestion: NotRequired[ChatSuggestionTypedDict]
    prompt_template: NotRequired[PromptTemplateResultTypedDict]
    workflow: NotRequired[WorkflowResultTypedDict]
    activities: NotRequired[List[UserActivityTypedDict]]
    r"""List of activity where each activity has user, action, timestamp."""
    document_visitor_count: NotRequired[CountInfoTypedDict]


class FeedEntry(BaseModel):
    title: str
    r"""Title for the result. Can be document title, event title and so on."""

    entry_id: Annotated[Optional[str], pydantic.Field(alias="entryId")] = None
    r"""optional ID associated with a single feed entry (displayable_list_id)"""

    thumbnail: Optional[Thumbnail] = None

    created_by: Annotated[Optional[Person], pydantic.Field(alias="createdBy")] = None

    ui_config: Annotated[Optional[UIConfig], pydantic.Field(alias="uiConfig")] = None

    justification_type: Annotated[
        Optional[JustificationType], pydantic.Field(alias="justificationType")
    ] = None
    r"""Type of the justification."""

    justification: Optional[str] = None
    r"""Server side generated justification string if server provides one."""

    tracking_token: Annotated[Optional[str], pydantic.Field(alias="trackingToken")] = (
        None
    )
    r"""An opaque token that represents this particular feed entry in this particular response. To be used for /feedback reporting."""

    view_url: Annotated[Optional[str], pydantic.Field(alias="viewUrl")] = None
    r"""View URL for the entry if based on links that are not documents in Glean."""

    document: Optional[Document] = None

    event: Optional[CalendarEvent] = None

    announcement: Optional[Announcement] = None

    digest: Optional[Digest] = None

    collection: Optional[Collection] = None

    collection_item: Annotated[
        Optional[CollectionItem], pydantic.Field(alias="collectionItem")
    ] = None

    person: Optional[Person] = None

    app: Optional[AppResult] = None

    chat_suggestion: Annotated[
        Optional[ChatSuggestion], pydantic.Field(alias="chatSuggestion")
    ] = None

    prompt_template: Annotated[
        Optional[PromptTemplateResult], pydantic.Field(alias="promptTemplate")
    ] = None

    workflow: Optional[WorkflowResult] = None

    activities: Optional[List[UserActivity]] = None
    r"""List of activity where each activity has user, action, timestamp."""

    document_visitor_count: Annotated[
        Optional[CountInfo], pydantic.Field(alias="documentVisitorCount")
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "entryId",
                "thumbnail",
                "createdBy",
                "uiConfig",
                "justificationType",
                "justification",
                "trackingToken",
                "viewUrl",
                "document",
                "event",
                "announcement",
                "digest",
                "collection",
                "collectionItem",
                "person",
                "app",
                "chatSuggestion",
                "promptTemplate",
                "workflow",
                "activities",
                "documentVisitorCount",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
