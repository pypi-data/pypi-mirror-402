"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .agentconfig import AgentConfig, AgentConfigTypedDict
from .chatmessagecitation import ChatMessageCitation, ChatMessageCitationTypedDict
from .chatmessagefragment import ChatMessageFragment, ChatMessageFragmentTypedDict
from enum import Enum
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class Author(str, Enum):
    USER = "USER"
    GLEAN_AI = "GLEAN_AI"


class MessageType(str, Enum):
    r"""Semantically groups content of a certain type. It can be used for purposes such as differential UI treatment. USER authored messages should be of type CONTENT and do not need `messageType` specified."""

    # An intermediate state message for progress updates.
    UPDATE = "UPDATE"
    # A user query or response message.
    CONTENT = "CONTENT"
    # A message providing context in addition to the user query.
    CONTEXT = "CONTEXT"
    # A debug message. Strictly used internally.
    DEBUG = "DEBUG"
    # A debug message to be used while debugging Action creation.
    DEBUG_EXTERNAL = "DEBUG_EXTERNAL"
    # A message that describes an error while processing the request.
    ERROR = "ERROR"
    # A heading message used to distinguish different sections of the holistic response.
    HEADING = "HEADING"
    # A warning message to be shown to the user.
    WARNING = "WARNING"
    # A message used to for server-side tool auth/use, for request and response.
    SERVER_TOOL = "SERVER_TOOL"


class ChatMessageTypedDict(TypedDict):
    r"""A message that is rendered as one coherent unit with one given sender."""

    agent_config: NotRequired[AgentConfigTypedDict]
    r"""Describes the agent that executes the request."""
    author: NotRequired[Author]
    citations: NotRequired[List[ChatMessageCitationTypedDict]]
    r"""A list of Citations that were used to generate the response."""
    uploaded_file_ids: NotRequired[List[str]]
    r"""IDs of files uploaded in the message that are referenced to generate the answer."""
    fragments: NotRequired[List[ChatMessageFragmentTypedDict]]
    r"""A list of rich data used to represent the response or formulate a request. These are linearly stitched together to support richer data formats beyond simple text."""
    ts: NotRequired[str]
    r"""Response timestamp of the message."""
    message_id: NotRequired[str]
    r"""A unique server-side generated ID used to identify a message, automatically populated for any USER authored messages."""
    message_tracking_token: NotRequired[str]
    r"""Opaque tracking token generated server-side."""
    message_type: NotRequired[MessageType]
    r"""Semantically groups content of a certain type. It can be used for purposes such as differential UI treatment. USER authored messages should be of type CONTENT and do not need `messageType` specified."""
    has_more_fragments: NotRequired[bool]
    r"""Signals there are additional response fragments incoming."""


class ChatMessage(BaseModel):
    r"""A message that is rendered as one coherent unit with one given sender."""

    agent_config: Annotated[
        Optional[AgentConfig], pydantic.Field(alias="agentConfig")
    ] = None
    r"""Describes the agent that executes the request."""

    author: Optional[Author] = Author.USER

    citations: Optional[List[ChatMessageCitation]] = None
    r"""A list of Citations that were used to generate the response."""

    uploaded_file_ids: Annotated[
        Optional[List[str]], pydantic.Field(alias="uploadedFileIds")
    ] = None
    r"""IDs of files uploaded in the message that are referenced to generate the answer."""

    fragments: Optional[List[ChatMessageFragment]] = None
    r"""A list of rich data used to represent the response or formulate a request. These are linearly stitched together to support richer data formats beyond simple text."""

    ts: Optional[str] = None
    r"""Response timestamp of the message."""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""A unique server-side generated ID used to identify a message, automatically populated for any USER authored messages."""

    message_tracking_token: Annotated[
        Optional[str], pydantic.Field(alias="messageTrackingToken")
    ] = None
    r"""Opaque tracking token generated server-side."""

    message_type: Annotated[
        Optional[MessageType], pydantic.Field(alias="messageType")
    ] = MessageType.CONTENT
    r"""Semantically groups content of a certain type. It can be used for purposes such as differential UI treatment. USER authored messages should be of type CONTENT and do not need `messageType` specified."""

    has_more_fragments: Annotated[
        Optional[bool],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible.",
            alias="hasMoreFragments",
        ),
    ] = None
    r"""Signals there are additional response fragments incoming."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "agentConfig",
                "author",
                "citations",
                "uploadedFileIds",
                "fragments",
                "ts",
                "messageId",
                "messageTrackingToken",
                "messageType",
                "hasMoreFragments",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
