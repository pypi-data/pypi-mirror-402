"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .calendarattendees import CalendarAttendees, CalendarAttendeesTypedDict
from .conferencedata import ConferenceData, ConferenceDataTypedDict
from .eventclassification import EventClassification, EventClassificationTypedDict
from .generatedattachment import GeneratedAttachment, GeneratedAttachmentTypedDict
from .timeinterval import TimeInterval, TimeIntervalTypedDict
from enum import Enum
from glean.api_client.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class CalendarEventEventType(str, Enum):
    r"""The nature of the event, for example \"out of office\"."""

    DEFAULT = "DEFAULT"
    OUT_OF_OFFICE = "OUT_OF_OFFICE"


class CalendarEventTypedDict(TypedDict):
    r"""A generic, light-weight calendar event."""

    id: str
    r"""The calendar event id"""
    url: str
    r"""A permalink for this calendar event"""
    time: NotRequired[TimeIntervalTypedDict]
    event_type: NotRequired[CalendarEventEventType]
    r"""The nature of the event, for example \"out of office\"."""
    attendees: NotRequired[CalendarAttendeesTypedDict]
    location: NotRequired[str]
    r"""The location that this event is taking place at."""
    conference_data: NotRequired[ConferenceDataTypedDict]
    description: NotRequired[str]
    r"""The HTML description of the event."""
    datasource: NotRequired[str]
    r"""The app or other repository type from which the event was extracted"""
    has_transcript: NotRequired[bool]
    r"""The event has a transcript associated with it enabling features like summarization"""
    transcript_url: NotRequired[str]
    r"""A link to the transcript of the event"""
    classifications: NotRequired[List[EventClassificationTypedDict]]
    generated_attachments: NotRequired[List[GeneratedAttachmentTypedDict]]


class CalendarEvent(BaseModel):
    r"""A generic, light-weight calendar event."""

    id: str
    r"""The calendar event id"""

    url: str
    r"""A permalink for this calendar event"""

    time: Optional[TimeInterval] = None

    event_type: Annotated[
        Optional[CalendarEventEventType], pydantic.Field(alias="eventType")
    ] = None
    r"""The nature of the event, for example \"out of office\"."""

    attendees: Optional[CalendarAttendees] = None

    location: Optional[str] = None
    r"""The location that this event is taking place at."""

    conference_data: Annotated[
        Optional[ConferenceData], pydantic.Field(alias="conferenceData")
    ] = None

    description: Optional[str] = None
    r"""The HTML description of the event."""

    datasource: Optional[str] = None
    r"""The app or other repository type from which the event was extracted"""

    has_transcript: Annotated[Optional[bool], pydantic.Field(alias="hasTranscript")] = (
        None
    )
    r"""The event has a transcript associated with it enabling features like summarization"""

    transcript_url: Annotated[Optional[str], pydantic.Field(alias="transcriptUrl")] = (
        None
    )
    r"""A link to the transcript of the event"""

    classifications: Optional[List[EventClassification]] = None

    generated_attachments: Annotated[
        Optional[List[GeneratedAttachment]],
        pydantic.Field(alias="generatedAttachments"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "time",
                "eventType",
                "attendees",
                "location",
                "conferenceData",
                "description",
                "datasource",
                "hasTranscript",
                "transcriptUrl",
                "classifications",
                "generatedAttachments",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
