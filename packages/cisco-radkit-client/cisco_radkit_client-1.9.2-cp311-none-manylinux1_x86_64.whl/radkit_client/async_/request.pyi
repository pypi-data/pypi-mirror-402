import _hashlib
from .client import AsyncClient
from .exceptions import ClientError
from .rpc_translation import AnyOutgoingRPCRequest
from .service import AsyncService
from .state import AsyncServiceState
from _typeshed import Incomplete
from collections.abc import AsyncGenerator, Awaitable, Callable, Coroutine, Sequence
from contextlib import AbstractAsyncContextManager
from cryptography import x509
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from radkit_common.domains import Domain
from radkit_common.identities import ClientID, ServiceID
from radkit_common.rpc import RPCTarget
from radkit_common.rpc.definition import NOTHING, RPCName, RPC_Definition
from typing import Any, Generic
from typing_extensions import Self

__all__ = ['RequestEvent', 'RequestStatus', 'RequestPendingError', 'AsyncStreamRequest', 'AsyncSimpleRequestHandlerParam', 'AsyncSimpleRequest', 'AsyncFillerRequest', 'AsyncTransformedFillerRequest', 'AsyncBaseRequest', 'UpdateStatus', 'format_request_timestamp', 'AsyncE2EEInformation']

class RequestStatus(Enum):
    NOT_YET_SUBMITTED = 'NOT_YET_SUBMITTED'
    SUBMITTED = 'SUBMITTED'
    PUBLISHED = 'PUBLISHED'
    DELIVERED = 'DELIVERED'
    SUCCESS = 'SUCCESS'
    PROCESSING = 'PROCESSING'
    SEND_TIMEOUT = 'SEND_TIMEOUT'
    FAILURE = 'FAILURE'
    TIMEOUT = 'TIMEOUT'
    CANCELLED = 'CANCELLED'
    REQUEST_HANDLER_FAILED = 'REQUEST_HANDLER_FAILED'
    PARTIAL_SUCCESS = 'PARTIAL_SUCCESS'

class RequestPendingError(ClientError): ...
class RequestNotYetSentError(ClientError): ...

@dataclass
class RequestEvent:
    message: str
    timestamp: datetime = field(default_factory=Incomplete)

class AsyncBaseRequest(Generic[_T_RequestModel, _T_ResponseModel, _T_UploadModel]):
    rpc_definition: Incomplete
    request_object: Incomplete
    sent_timestamp: datetime | None
    forwarder_base_url: str | None
    def __init__(self, service_state: AsyncServiceState, rpc_definition: RPC_Definition[_T_RequestModel, _T_ResponseModel, _T_UploadModel], request_object: _T_RequestModel, message: str) -> None: ...
    def rpc_name(self) -> RPCName: ...
    def message(self) -> str: ...
    def client_id(self) -> ClientID | None: ...
    def target(self) -> RPCTarget: ...
    def service_id(self) -> ServiceID | None: ...
    def service_name(self) -> str: ...
    def client(self) -> AsyncClient: ...
    def service(self) -> AsyncService: ...
    def e2ee(self) -> AsyncE2EEInformation: ...
    def e2ee_used(self) -> bool | None: ...
    def compression_used(self) -> str | None: ...
    def h2_multiplexing_used(self) -> bool: ...
    def status(self) -> RequestStatus: ...
    async def send(self) -> None: ...
    async def wait(self, timeout: float | None = None) -> Self: ...
    def done(self) -> bool: ...
    def success(self) -> bool: ...
    def request_success(self) -> bool: ...
    def failure(self) -> bool: ...
    def request_failure(self) -> bool: ...
    def exception(self) -> BaseException | None: ...
    def exception_traceback(self) -> str | None: ...
    def cancel(self) -> None: ...

class AsyncStreamRequest(AsyncBaseRequest[_T_RequestModel, _T_ResponseModel, _T_UploadModel], Generic[_T_RequestModel, _T_ResponseModel, _T_UploadModel]):
    __pt_repr__: Incomplete
    handler: Incomplete
    def __init__(self, service_state: AsyncServiceState, rpc_definition: RPC_Definition[_T_RequestModel, _T_ResponseModel, _T_UploadModel], request_object: _T_RequestModel, message: str, handler: Callable[[Callable[[], AbstractAsyncContextManager[AnyOutgoingRPCRequest[_T_ResponseModel, _T_UploadModel]]]], Coroutine[Any, Any, None]]) -> None: ...
    def result(self) -> None: ...

@dataclass
class AsyncSimpleRequestHandlerParam(Generic[_T_ResponseModel]):
    async def consume_responses(self) -> AsyncGenerator[_T_ResponseModel]: ...
    async def expect_single_response(self) -> _T_ResponseModel: ...

class AsyncSimpleRequest(AsyncBaseRequest[_T_RequestModel, _T_ResponseModel, NOTHING], Generic[_T_RequestModel, _T_ResponseModel, _T_HandlerResult]):
    __pt_repr__: Incomplete
    def __init__(self, service_state: AsyncServiceState, rpc_definition: RPC_Definition[_T_RequestModel, _T_ResponseModel, NOTHING], request_object: _T_RequestModel, message: str, handler: Callable[[AsyncSimpleRequestHandlerParam[_T_ResponseModel]], Coroutine[Any, Any, _T_HandlerResult]]) -> None: ...
    def status(self) -> RequestStatus: ...
    def result(self) -> _T_HandlerResult: ...
    def protocol_results(self) -> Sequence[_T_ResponseModel]: ...

class UpdateStatus(Enum):
    UPDATE_OK = 'UPDATE_OK'
    UPDATE_FAILED = 'UPDATE_FAILED'

class AsyncFillerRequest(AsyncBaseRequest[_T_RequestModel, _T_ResponseModel, NOTHING], Generic[_T_RequestModel, _T_ResponseModel, _T_HandlerResult]):
    __pt_repr__: Incomplete
    initializer: Incomplete
    updater: Incomplete
    def __init__(self, service_state: AsyncServiceState, rpc_definition: RPC_Definition[_T_RequestModel, _T_ResponseModel, NOTHING], request_object: _T_RequestModel, message: str, initializer: Callable[[], Awaitable[_T_HandlerResult]], updater: Callable[[_T_HandlerResult, _T_ResponseModel], Awaitable[UpdateStatus]]) -> None: ...
    def status(self) -> RequestStatus: ...
    def total_updates(self) -> int: ...
    def failed_updates(self) -> int: ...
    def succeeded_updates(self) -> int: ...
    def result(self) -> _T_HandlerResult: ...
    def full_result(self) -> _T_HandlerResult: ...
    def protocol_results(self) -> list[_T_ResponseModel]: ...

class AsyncTransformedFillerRequest(Generic[_T_RequestModel, _T_ResponseModel, _T_HandlerResult, _T_FinalResult]):
    transform_func: Incomplete
    transform_message: Incomplete
    def __init__(self, filler_request: AsyncFillerRequest[_T_RequestModel, _T_ResponseModel, _T_HandlerResult], transform_func: Callable[[_T_HandlerResult], _T_FinalResult], transform_message: Callable[[str], str] | None = None) -> None: ...
    __pt_repr__: Incomplete
    def filler_request(self) -> AsyncFillerRequest[_T_RequestModel, _T_ResponseModel, _T_HandlerResult]: ...
    def rpc_name(self) -> RPCName: ...
    def done(self) -> bool: ...
    def success(self) -> bool: ...
    def failure(self) -> bool: ...
    def exception(self) -> BaseException | None: ...
    def exception_traceback(self) -> str | None: ...
    def cancel(self) -> None: ...
    def client_id(self) -> ClientID | None: ...
    def service_id(self) -> ServiceID | None: ...
    def client(self) -> AsyncClient: ...
    def service(self) -> AsyncService: ...
    def result(self) -> _T_FinalResult: ...
    def full_result(self) -> _T_HandlerResult | None: ...
    def message(self) -> str: ...
    def status(self) -> RequestStatus: ...
    def total_updates(self) -> int: ...
    def failed_updates(self) -> int: ...
    def succeeded_updates(self) -> int: ...
    def e2ee_used(self) -> bool | None: ...
    def e2ee(self) -> AsyncE2EEInformation: ...
    def compression_used(self) -> str | None: ...
    def h2_multiplexing_used(self) -> bool: ...
    def protocol_results(self) -> list[_T_ResponseModel]: ...
    async def wait(self, timeout: float | None = None) -> Self: ...

def format_request_timestamp(timestamp: datetime | None) -> str | None: ...

class AsyncE2EEInformation:
    __pt_repr__: Incomplete
    def __init__(self, service_state: AsyncServiceState, request: AsyncBaseRequest[Any, Any, Any]) -> None: ...
    def request(self) -> AsyncBaseRequest[Any, Any, Any]: ...
    def client_id(self) -> ClientID | None: ...
    def client(self) -> AsyncClient: ...
    def domain(self) -> Domain | None: ...
    def domain_name(self) -> str | None: ...
    def service_id(self) -> ServiceID | None: ...
    def service_name(self) -> str: ...
    def service(self) -> AsyncService: ...
    def e2ee_used(self) -> bool: ...
    def binary_peercert(self) -> bytes | None: ...
    def sha256_hash(self) -> _hashlib.HASH | None: ...
    def sha256_hash_hexdigest(self) -> str | None: ...
    def x509_certificate(self) -> x509.Certificate | None: ...

class _ResultNotSet: ...
