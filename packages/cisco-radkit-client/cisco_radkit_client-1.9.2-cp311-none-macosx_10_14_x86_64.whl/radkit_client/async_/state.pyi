import os
from .auto_incrementing_id import Id
from .client import AsyncClient
from .integrations.cxd.state import CXDState
from .rpc_translation import AnyOutgoingRPCRequest, TranslatingRPCClient
from .settings import AllClientSettings
from .terminal import AnyAsyncTerminalConnection, AsyncFileReadConnection, AsyncFileWriteConnection, AsyncInteractiveConnection
from .terminal.streams import AsyncBinaryStreamRequest
from _typeshed import Incomplete
from anyio import CancelScope
from anyio.abc import TaskStatus
from collections.abc import AsyncGenerator, Callable, Coroutine, Generator, Iterator, Mapping, Sequence
from contextlib import AbstractAsyncContextManager, asynccontextmanager, contextmanager
from dataclasses import dataclass, field
from multidict import CIMultiDict
from pathlib import Path
from pydantic import BaseModel
from radkit_client.async_.exceptions import ClientError
from radkit_client.async_.model import ClientModel, ServiceModel
from radkit_client.async_.port_forwarding import AsyncProxyPortForwarder, AsyncTCPPortForwarder
from radkit_client.async_.request import AsyncBaseRequest, AsyncFillerRequest, AsyncSimpleRequest, AsyncSimpleRequestHandlerParam, AsyncStreamRequest, UpdateStatus
from radkit_client.async_.ssh_forwarding import AsyncProxySshForwarder
from radkit_client.async_.terminal.connection import AsyncSessionLog as AsyncSessionLog
from radkit_common.access.client.auth_flows import AsyncAuthFlow
from radkit_common.domains import Domain
from radkit_common.identities import ClientID, ServiceID
from radkit_common.protocol.terminal import FileTransferMethod
from radkit_common.rpc import CloudConnectionId, CombinedRPCClientTransport, InMemoryRPCTarget, NOTHING, RPCName, RPCProxy, RPCTarget, RPC_Definition
from radkit_common.rpc.client_transports.cloud import DomainAndForwarderClient
from typing import Any, Protocol
from typing_extensions import Self
from uuid import UUID

__all__ = ['AsyncCloudConnectionState', 'AsyncClientState', 'AsyncServiceState', 'AsyncRequestsDict', 'AsyncSessionLog', 'AsyncSessionLogsDict', 'AsyncSessionsDict', 'AsyncTCPPortForwardsDict', 'ClientIsTerminatedError']

class _StartTaskCallable(Protocol[_T]):
    async def __call__(self, *, task_status: TaskStatus[_T]) -> None: ...

@dataclass(frozen=True)
class AsyncCloudConnectionState:
    auth_flow: AsyncAuthFlow
    cancel_scope: CancelScope

@dataclass(eq=False)
class AsyncClientState:
    settings: AllClientSettings
    rpc_client: TranslatingRPCClient
    rpc_transport: CombinedRPCClientTransport
    model: ClientModel
    requests: list[AsyncBaseRequest[Any, Any, Any]] = field(default_factory=list)
    cloud_connections: dict[CloudConnectionId, AsyncCloudConnectionState] = field(default_factory=dict)
    integrated_cancel_scope: dict[InMemoryRPCTarget, CancelScope] = field(default_factory=dict)
    terminal_connections: list[AnyAsyncTerminalConnection] = field(default_factory=list)
    tcp_port_forwarders: list[AsyncTCPPortForwarder] = field(default_factory=list)
    socks_proxy: AsyncProxyPortForwarder | None = ...
    http_proxy: AsyncProxyPortForwarder | None = ...
    ssh_proxy: AsyncProxySshForwarder | None = ...
    cxd_state: CXDState = field(default_factory=_create_cxd_targets_state)
    rpc_proxies: dict[RPCTarget, tuple[CancelScope, RPCProxy]] = field(default_factory=dict)
    terminated: bool = ...
    logger = ...
    def __post_init__(self) -> None: ...
    @classmethod
    @asynccontextmanager
    async def create(cls, settings: AllClientSettings) -> AsyncGenerator[Self]: ...
    def get_all_forwarder_clients(self) -> Sequence[DomainAndForwarderClient]: ...
    @contextmanager
    def register_cloud_connection(self, auth_flow: AsyncAuthFlow) -> Generator[CloudConnectionId]: ...
    def get_domain(self, domain: Domain | str | None = None) -> Domain: ...
    def set_default_domain(self, domain: Domain | str) -> None: ...
    def get_default_domain(self) -> Domain: ...
    def get_service_state(self, name: str) -> AsyncServiceState | None: ...
    def add_service(self, target: RPCTarget, name: str | None = None) -> AsyncServiceState: ...
    def start_task_soon(self, func: Callable[[], Coroutine[Any, Any, None]]) -> None: ...
    async def start_task(self, func: _StartTaskCallable[_T]) -> _T: ...

@dataclass(frozen=True)
class AsyncServiceState:
    client_state: AsyncClientState
    service_name: str
    def model(self) -> ClientModel: ...
    def target(self) -> RPCTarget: ...
    def get_service_model(self) -> ServiceModel: ...
    def domain(self) -> Domain | None: ...
    def domain_name(self) -> str | None: ...
    def device_http_overlay_headers(self) -> dict[UUID, CIMultiDict[str]]: ...
    def client_id(self) -> ClientID | None: ...
    def service_id(self) -> ServiceID | None: ...
    def supports_rpc_call(self, rpc_name: RPCName) -> bool: ...
    def create_simple_request(self, rpc_definition: RPC_Definition[_T_RequestModel, _T_ResponseModel, NOTHING], request_object: _T_RequestModel, message: str, handler: Callable[[AsyncSimpleRequestHandlerParam[_T_ResponseModel]], Coroutine[Any, Any, _T_HandlerResult]]) -> AsyncSimpleRequest[_T_RequestModel, _T_ResponseModel, _T_HandlerResult]: ...
    def create_stream_request(self, rpc_definition: RPC_Definition[_T_RequestModel, _T_ResponseModel, _T_UploadModel], request_object: _T_RequestModel, message: str, handler: Callable[[Callable[[], AbstractAsyncContextManager[AnyOutgoingRPCRequest[_T_ResponseModel, _T_UploadModel]]]], Coroutine[Any, Any, None]]) -> AsyncStreamRequest[_T_RequestModel, _T_ResponseModel, _T_UploadModel]: ...
    def create_binary_stream_request(self, rpc_definition: RPC_Definition[_T_RequestModel, _T_ResponseModel, _T_UploadModel], request_object: _T_RequestModel, message: str, session_log_filepath: Path | None = None, session_log_file_size_limit_bytes: int | None = None, on_connected: Callable[[], Coroutine[Any, Any, None]] | None = None, handle_special_data: Callable[[_T_ResponseModel], Coroutine[Any, Any, None]] | None = None) -> AsyncBinaryStreamRequest[_T_RequestModel, _T_ResponseModel, _T_UploadModel]: ...
    def create_filler_request(self, rpc_definition: RPC_Definition[_T_RequestModel, _T_ResponseModel, NOTHING], request_object: _T_RequestModel, message: str, initializer: Callable[[], Coroutine[Any, Any, _T_HandlerResult]], updater: Callable[[_T_HandlerResult, _T_ResponseModel], Coroutine[Any, Any, UpdateStatus]]) -> AsyncFillerRequest[_T_RequestModel, _T_ResponseModel, _T_HandlerResult]: ...
    def open_new_terminal_session(self, uuid: UUID, initial_terminal_size: os.terminal_size, term: str | None = None, command: str | None = None, request_pty: bool = True, include_initialization: bool = False) -> AsyncInteractiveConnection: ...
    def open_new_file_download(self, uuid: UUID, transfer_method: FileTransferMethod, remote_path: str, local_path: str | None = None) -> AsyncFileReadConnection: ...
    def open_new_file_upload(self, uuid: UUID, transfer_method: FileTransferMethod, remote_path: str, chmod: str, file_size: int, local_path: str | None = None) -> AsyncFileWriteConnection: ...
    async def forward_tcp_port(self, uuid: UUID, destination_port: int, local_port: int, local_address: str = 'localhost', server_startup_timeout: float = 2.0) -> AsyncTCPPortForwarder: ...

class AsyncRequestsDict(Mapping[int, AsyncBaseRequest[BaseModel, BaseModel, BaseModel]]):
    __pt_repr__: Incomplete
    def __init__(self, client_state: AsyncClientState, filter: Callable[[AsyncBaseRequest[BaseModel, BaseModel, BaseModel]], bool], title: str, exclude_fields: Sequence[str]) -> None: ...
    def __iter__(self) -> Generator[int]: ...
    def __getitem__(self, index: int) -> AsyncBaseRequest[BaseModel, BaseModel, BaseModel]: ...
    def __len__(self) -> int: ...
    def client(self) -> AsyncClient: ...

class AsyncSessionsDict(Mapping[Id, AnyAsyncTerminalConnection]):
    __pt_repr__: Incomplete
    def __init__(self, client_state: AsyncClientState, filter: Callable[[AnyAsyncTerminalConnection], bool], title: str) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Id]: ...
    def __getitem__(self, __key: Id) -> AnyAsyncTerminalConnection: ...
    def client(self) -> AsyncClient: ...

class AsyncSessionLogsDict(Mapping[int, AsyncSessionLog]):
    __pt_repr__: Incomplete
    def __init__(self, client_state: AsyncClientState, filter: Callable[[AnyAsyncTerminalConnection], bool], title: str) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def __getitem__(self, __key: int) -> AsyncSessionLog: ...
    def client(self) -> AsyncClient: ...

class AsyncTCPPortForwardsDict(Mapping[Id, AsyncTCPPortForwarder]):
    __pt_repr__: Incomplete
    def __init__(self, client_state: AsyncClientState, filter: Callable[[AsyncTCPPortForwarder], bool], title: str) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Id]: ...
    def __getitem__(self, __key: Id) -> AsyncTCPPortForwarder: ...
    def client(self) -> AsyncClient: ...

class ClientIsTerminatedError(ClientError): ...

@dataclass
class AlreadyConnectedError(Exception):
    cloud_connection_id: CloudConnectionId
