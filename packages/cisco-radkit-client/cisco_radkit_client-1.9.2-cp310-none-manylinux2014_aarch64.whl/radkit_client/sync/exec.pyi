from .from_async import SyncDictWrapper, SyncWrapper
from _typeshed import Incomplete
from collections.abc import Sequence
from radkit_client.async_.exec import AsyncExecResponseBase, AsyncExecResponse_ByCommand, AsyncExecResponse_ByCommand_ToSingle, AsyncExecResponse_ByDevice, AsyncExecResponse_ByDeviceType, AsyncExecResponse_ByDevice_ByCommand, AsyncExecResponse_ByDevice_ToSingle, AsyncExecResponse_ByIndex, AsyncExecResponse_ByStatus, AsyncSingleExecResponse, ExecError as ExecError, ExecFilterFunction as ExecFilterFunction, ExecMapFunction as ExecMapFunction, ExecPendingError as ExecPendingError, ExecRecord as ExecRecord, ExecSortFunction as ExecSortFunction, ExecStatus as ExecStatus
from typing import Generic, overload
from typing_extensions import Self

__all__ = ['ExecResponseBase', 'ExecResponse_ByStatus', 'ExecResponse_ByIndex', 'ExecResponse_ByDevice_ByCommand', 'ExecResponse_ByCommand', 'ExecResponse_ByCommand_ToSingle', 'ExecResponse_ByDevice_ToSingle', 'SingleExecResponse', 'ExecStatus', 'ExecError', 'ExecPendingError', 'ExecRecord', 'ExecFilterFunction', 'ExecMapFunction', 'ExecSortFunction']

class ExecResponseBase(SyncWrapper[AsyncExecResponseBase[_D]], Generic[_D]):
    status: Incomplete
    success: Incomplete
    sudo: Incomplete
    devices: Incomplete
    commands: Incomplete
    device_names: Incomplete
    requests: Incomplete
    client: Incomplete
    @property
    def unfiltered(self) -> ExecResponse_ByIndex[str]: ...
    @property
    def by_index(self) -> ExecResponse_ByIndex[_D]: ...
    @property
    def by_status(self) -> ExecResponse_ByStatus[_D]: ...
    @property
    def by_command(self) -> ExecResponse_ByCommand[_D]: ...
    @property
    def by_device(self) -> ExecResponse_ByDevice[_D]: ...
    @property
    def by_device_type(self) -> ExecResponse_ByDeviceType[_D]: ...
    @property
    def by_device_by_command(self) -> ExecResponse_ByDevice_ByCommand[_D]: ...
    def filter(self, filter_func: ExecFilterFunction[_D]) -> ExecResponse_ByIndex[_D]: ...
    def map(self, map_func: ExecMapFunction[_D, _D2]) -> ExecResponse_ByIndex[_D2]: ...
    def sort(self, sort_key_func: ExecSortFunction[_D]) -> ExecResponse_ByIndex[_D]: ...
    @property
    def sort_by_device(self) -> ExecResponse_ByIndex[_D]: ...
    @property
    def sort_by_device_type(self) -> ExecResponse_ByIndex[_D]: ...
    @property
    def sort_by_status(self) -> ExecResponse_ByIndex[_D]: ...
    @property
    def sort_by_command(self) -> ExecResponse_ByIndex[_D]: ...
    excluded_commands: Incomplete
    excluded_device_names: Incomplete
    excluded_devices: Incomplete
    cancel: Incomplete
    def wait(self, timeout: float | None = None) -> Self: ...
    show_progress: Incomplete
    @property
    def result(self) -> Self: ...
    @property
    def full_result(self) -> ExecResponse_ByDevice_ByCommand[str]: ...
    def __dir__(self) -> list[str]: ...

class SingleExecResponse(ExecResponseBase[_D], SyncWrapper[AsyncSingleExecResponse[_D]], Generic[_D]):
    request: Incomplete
    device_name: Incomplete
    device_uuid: Incomplete
    device_type: Incomplete
    device: Incomplete
    command: Incomplete
    client_id: Incomplete
    service_id: Incomplete
    @property
    def data(self) -> _D: ...
    raw_data: Incomplete
    errors: Incomplete
    @property
    def status_message(self) -> str: ...

class ExecResponse_ByDevice_ToSingle(ExecResponseBase[_D], SyncDictWrapper[AsyncExecResponse_ByDevice_ToSingle[_D], str, AsyncSingleExecResponse[_D], 'SingleExecResponse[_D]'], Generic[_D]):
    command: Incomplete

class ExecResponse_ByCommand_ToSingle(ExecResponseBase[_D], SyncDictWrapper[AsyncExecResponse_ByCommand_ToSingle[_D], str, AsyncSingleExecResponse[_D], SingleExecResponse[_D]], Generic[_D]):
    device: Incomplete

class ExecResponse_ByIndex(ExecResponseBase[_D], SyncDictWrapper[AsyncExecResponse_ByIndex[_D], int, AsyncSingleExecResponse[_D] | AsyncExecResponse_ByIndex[_D], SingleExecResponse[_D] | 'ExecResponse_ByIndex[_D]'], Generic[_D]):
    @overload
    def __getitem__(self, index: int) -> SingleExecResponse[_D]: ...
    @overload
    def __getitem__(self, index: slice) -> ExecResponse_ByIndex[_D]: ...
    def values(self) -> Sequence[SingleExecResponse[_D]]: ...

class ExecResponse_ByStatus(ExecResponseBase[_D], SyncDictWrapper[AsyncExecResponse_ByStatus[_D], int | ExecStatus, AsyncExecResponse_ByIndex[_D], ExecResponse_ByIndex[_D]], Generic[_D]): ...
class ExecResponse_ByDevice_ByCommand(ExecResponseBase[_D], SyncDictWrapper[AsyncExecResponse_ByDevice_ByCommand[_D], str, AsyncExecResponse_ByCommand_ToSingle[_D], ExecResponse_ByCommand_ToSingle[_D]], Generic[_D]): ...
class ExecResponse_ByCommand(ExecResponseBase[_D], SyncDictWrapper[AsyncExecResponse_ByCommand[_D], str, AsyncExecResponse_ByIndex[_D], ExecResponse_ByIndex[_D]], Generic[_D]): ...
class ExecResponse_ByDevice(ExecResponseBase[_D], SyncDictWrapper[AsyncExecResponse_ByDevice[_D], str, AsyncExecResponse_ByIndex[_D], ExecResponse_ByIndex[_D]], Generic[_D]): ...
class ExecResponse_ByDeviceType(ExecResponseBase[_D], SyncDictWrapper[AsyncExecResponse_ByDeviceType[_D], str, AsyncExecResponse_ByIndex[_D], ExecResponse_ByIndex[_D]], Generic[_D]): ...
