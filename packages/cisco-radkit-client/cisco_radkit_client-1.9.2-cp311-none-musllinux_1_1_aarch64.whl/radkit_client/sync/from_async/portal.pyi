from anyio.from_thread import BlockingPortal
from collections.abc import AsyncGenerator, Callable, Coroutine, Generator
from contextlib import AbstractAsyncContextManager, AbstractContextManager, ExitStack, contextmanager
from types import TracebackType
from typing import Any, Generic, TypeVar
from typing_extensions import Self

__all__ = ['Portal']

class Portal:
    @classmethod
    @contextmanager
    def create(cls, blocking_portal: BlockingPortal | None = None) -> Generator[Self]: ...
    def __init__(self, blocking_portal: BlockingPortal, exit_stack: ExitStack) -> None: ...
    def do_async(self, func: Callable[[], _T]) -> _T: ...
    def do_async_coro(self, func: Callable[[], Coroutine[Any, Any, _T]]) -> _T: ...
    def do_async_generator(self, func: Callable[[], AsyncGenerator[_T]]) -> Generator[_T]: ...
    def wrap_any(self, value: object) -> Any: ...
    def enter_context(self, contextmanager: AbstractContextManager[_T]) -> _T: ...
    def enter_async_context(self, asynccontextmanager: AbstractAsyncContextManager[_T]) -> _T: ...
    def async_context_to_sync_context(self, asynccontextmanager: AbstractAsyncContextManager[_T]) -> AbstractContextManager[_T]: ...
    def terminate(self) -> None: ...
    def terminated(self) -> bool: ...
T_co = TypeVar('T_co')

class _BlockingAsyncContextManager(AbstractContextManager, Generic[T_co]):
    def __init__(self, async_cm: AbstractAsyncContextManager[T_co], portal: BlockingPortal) -> None: ...
    def __enter__(self) -> T_co: ...
    def __exit__(self, __exc_type: type[BaseException] | None, __exc_value: BaseException | None, __traceback: TracebackType | None) -> bool | None: ...
