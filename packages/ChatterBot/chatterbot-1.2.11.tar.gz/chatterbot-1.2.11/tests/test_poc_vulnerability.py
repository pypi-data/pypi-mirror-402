"""
Proof-of-Concept test for the connection pool exhaustion vulnerability (CVE-TBD).

This test demonstrates that the original vulnerability has been fixed.
The PoC from the security report would cause timeout errors before the fix.
"""
import threading
import tempfile
import os
import unittest
from chatterbot import ChatBot
from chatterbot.trainers import ListTrainer


class PoC_VulnerabilityTestCase(unittest.TestCase):
    """
    Test case demonstrating the fix for the connection pool exhaustion vulnerability.
    
    This uses a file-based SQLite database which doesn't have the same
    thread-restrictions as in-memory databases.
    """

    def setUp(self):
        """
        Set up test fixtures.
        """
        # Create a temporary database file
        self.db_fd, self.db_path = tempfile.mkstemp(suffix='.sqlite3')
        
        self.chatbot = ChatBot(
            'TestBot',
            database_uri=f'sqlite:///{self.db_path}',
        )
        
        # Train with basic data
        trainer = ListTrainer(self.chatbot)
        trainer.train(['hello', 'hi there'])

    def tearDown(self):
        """
        Clean up after test.
        """
        self.chatbot.storage.close()
        os.close(self.db_fd)
        os.unlink(self.db_path)

    def test_original_poc_no_longer_causes_timeout(self):
        """
        Test that the original PoC from the security report no longer causes errors.
        
        Before the fix: This would cause SQLAlchemy TimeoutError due to pool exhaustion
        After the fix: All requests complete successfully
        """
        def attack():
            try:
                response = self.chatbot.get_response("hello")
                results.append(('success', str(response)))
            except Exception as e:
                results.append(('error', str(e)))
        
        results = []
        threads = []
        
        # Original PoC used 30 threads
        for _ in range(30):
            t = threading.Thread(target=attack)
            t.start()
            threads.append(t)
        
        for t in threads:
            t.join(timeout=15)  # Should complete well before timeout
        
        # Count successes and errors
        successes = [r for r in results if r[0] == 'success']
        errors = [r for r in results if r[0] == 'error']
        
        # Before fix: Would have many TimeoutError exceptions
        # After fix: All should succeed
        self.assertEqual(len(errors), 0,
                        f"Got {len(errors)} errors (expected 0). Errors: {[e[1] for e in errors][:5]}")
        self.assertEqual(len(successes), 30,
                        f"Got {len(successes)} successes (expected 30)")

    def test_high_concurrency_sustained(self):
        """
        Test sustained high concurrency doesn't cause issues.
        """
        request_count = 0
        lock = threading.Lock()
        
        def make_many_requests():
            nonlocal request_count
            for _ in range(10):
                try:
                    self.chatbot.get_response("hello")
                    with lock:
                        request_count += 1
                except Exception:
                    pass
        
        threads = []
        for _ in range(10):  # 10 threads Ã— 10 requests = 100 total
            t = threading.Thread(target=make_many_requests)
            t.start()
            threads.append(t)
        
        for t in threads:
            t.join(timeout=30)
        
        # Should have completed all 100 requests
        self.assertGreater(request_count, 90,  # Allow for some timing issues
                          f"Only completed {request_count}/100 requests")


class SequentialPerformanceTestCase(unittest.TestCase):
    """
    Test that the fixes don't negatively impact single-threaded performance.
    """

    def setUp(self):
        """
        Set up test fixtures.
        """
        self.db_fd, self.db_path = tempfile.mkstemp(suffix='.sqlite3')
        
        self.chatbot = ChatBot(
            'PerfBot',
            database_uri=f'sqlite:///{self.db_path}',
        )
        
        trainer = ListTrainer(self.chatbot)
        trainer.train(['hello', 'hi', 'how are you', 'good'])

    def tearDown(self):
        """
        Clean up.
        """
        self.chatbot.storage.close()
        os.close(self.db_fd)
        os.unlink(self.db_path)

    def test_sequential_requests_still_work(self):
        """
        Test that normal sequential usage still works correctly.
        """
        for i in range(50):
            response = self.chatbot.get_response(f"message {i}")
            self.assertIsNotNone(response)


if __name__ == '__main__':
    unittest.main()
