from ..graph.node import Node
from ..graph.port import PortType, InputPort, OutputPort


class AudioEditing(Node):
    def __init__(self, id: str | None = None):
        super().__init__(
            node_type="AudioEditing",
            category="mediaEditing",
            task_name="media_editing.audio_editing",
            node_id=id,
            ports={
                "input_audio": InputPort(
                    name="input_audio",
                    port_type=PortType.FILE,
                    value=[],
                    show=True,
                    support_file_types=[".mp3", ".wav", ".ogg", ".m4a"],
                ),
                "audio_processing_logic": InputPort(
                    name="audio_processing_logic",
                    port_type=PortType.SELECT,
                    value="process_each",
                    options=[{"label": "process_each", "value": "process_each"}, {"label": "mix", "value": "mix"}, {"label": "concat", "value": "concat"}],
                    required=False,
                    has_tooltip=True,
                ),
                "trim": InputPort(
                    name="trim",
                    port_type=PortType.CHECKBOX,
                    value=False,
                    required=False,
                ),
                "trim_method": InputPort(
                    name="trim_method",
                    port_type=PortType.SELECT,
                    value="start_duration",
                    options=[
                        {"label": "start_duration", "value": "start_duration"},
                        {"label": "end_duration", "value": "end_duration"},
                        {"label": "start_end_time", "value": "start_end_time"},
                    ],
                    required=False,
                    condition="return fieldsData.trim.value",
                    condition_python=lambda ports: ports["trim"].value,
                ),
                "trim_length": InputPort(
                    name="trim_length",
                    port_type=PortType.NUMBER,
                    value=0,
                    required=False,
                    has_tooltip=True,
                    condition="return fieldsData.trim.value && (fieldsData.trim_method.value === 'start_duration' || fieldsData.trim_method.value === 'end_duration')",
                    condition_python=lambda ports: ports["trim"].value and (ports["trim_method"].value == "start_duration" or ports["trim_method"].value == "end_duration"),
                ),
                "trim_start_time": InputPort(
                    name="trim_start_time",
                    port_type=PortType.INPUT,
                    value="00:00:00",
                    required=False,
                    condition="return fieldsData.trim.value && fieldsData.trim_method.value === 'start_end_time'",
                    condition_python=lambda ports: ports["trim"].value and ports["trim_method"].value == "start_end_time",
                ),
                "trim_end_time": InputPort(
                    name="trim_end_time",
                    port_type=PortType.INPUT,
                    value="00:01:00",
                    required=False,
                    condition="return fieldsData.trim.value && fieldsData.trim_method.value === 'start_end_time'",
                    condition_python=lambda ports: ports["trim"].value and ports["trim_method"].value == "start_end_time",
                ),
                "adjust_volume": InputPort(
                    name="adjust_volume",
                    port_type=PortType.CHECKBOX,
                    value=False,
                    required=False,
                ),
                "volume_adjustment_ratio": InputPort(
                    name="volume_adjustment_ratio",
                    port_type=PortType.NUMBER,
                    value=1.0,
                    required=False,
                    condition="return fieldsData.adjust_volume.value",
                    condition_python=lambda ports: ports["adjust_volume"].value,
                ),
                "fade_in_out": InputPort(
                    name="fade_in_out",
                    port_type=PortType.CHECKBOX,
                    value=False,
                    required=False,
                ),
                "fade_in_out_duration": InputPort(
                    name="fade_in_out_duration",
                    port_type=PortType.NUMBER,
                    value=1,
                    required=False,
                    has_tooltip=True,
                    condition="return fieldsData.fade_in_out.value",
                    condition_python=lambda ports: ports["fade_in_out"].value,
                ),
                "adjust_speed": InputPort(
                    name="adjust_speed",
                    port_type=PortType.CHECKBOX,
                    value=False,
                    required=False,
                ),
                "speed_adjustment_method": InputPort(
                    name="speed_adjustment_method",
                    port_type=PortType.SELECT,
                    value="specified_speed",
                    options=[{"label": "specified_speed", "value": "specified_speed"}, {"label": "specified_final_length", "value": "specified_final_length"}],
                    required=False,
                    condition="return fieldsData.adjust_speed.value",
                    condition_python=lambda ports: ports["adjust_speed"].value,
                ),
                "specified_speed": InputPort(
                    name="specified_speed",
                    port_type=PortType.NUMBER,
                    value=1.0,
                    required=False,
                    condition="return fieldsData.adjust_speed.value && fieldsData.speed_adjustment_method.value === 'specified_speed'",
                    condition_python=lambda ports: ports["adjust_speed"].value and ports["speed_adjustment_method"].value == "specified_speed",
                ),
                "specified_final_length": InputPort(
                    name="specified_final_length",
                    port_type=PortType.NUMBER,
                    value=10,
                    required=False,
                    has_tooltip=True,
                    condition="return fieldsData.adjust_speed.value && fieldsData.speed_adjustment_method.value === 'specified_final_length'",
                    condition_python=lambda ports: ports["adjust_speed"].value and ports["speed_adjustment_method"].value == "specified_final_length",
                ),
                "output_audio_format": InputPort(
                    name="output_audio_format",
                    port_type=PortType.SELECT,
                    value="mp3",
                    options=[{"value": "mp3", "label": "mp3"}, {"value": "wav", "label": "wav"}, {"value": "m4a", "label": "m4a"}],
                    required=False,
                    show=True,
                ),
                "output_type": InputPort(
                    name="output_type",
                    port_type=PortType.SELECT,
                    value="only_link",
                    options=[{"value": "only_link", "label": "only_link"}, {"value": "markdown", "label": "markdown"}, {"value": "html", "label": "html"}],
                    required=False,
                ),
                "output": OutputPort(),
                "adjust_channels": InputPort(
                    name="adjust_channels",
                    port_type=PortType.CHECKBOX,
                    value=False,
                    required=False,
                ),
                "channel_adjustment_method": InputPort(
                    name="channel_adjustment_method",
                    port_type=PortType.SELECT,
                    value="stereo_to_mono",
                    options=[{"label": "stereo_to_mono", "value": "stereo_to_mono"}, {"label": "mono_to_stereo", "value": "mono_to_stereo"}],
                    required=False,
                    condition="return fieldsData.adjust_channels.value",
                    condition_python=lambda ports: ports["adjust_channels"].value,
                ),
            },
        )


class FfmpegProcess(Node):
    def __init__(self, id: str | None = None):
        super().__init__(
            node_type="FfmpegProcess",
            category="mediaEditing",
            task_name="media_editing.ffmpeg_process",
            node_id=id,
            ports={
                "input_files": InputPort(
                    name="input_files",
                    port_type=PortType.FILE,
                    value=[],
                    show=True,
                    support_file_types=[
                        ".mp4",
                        ".avi",
                        ".mov",
                        ".mkv",
                        ".mp3",
                        ".wav",
                        ".ogg",
                        ".m4a",
                        ".jpg",
                        ".jpeg",
                        ".png",
                        ".gif",
                        ".bmp",
                        ".webp",
                        ".webm",
                        ".flv",
                        ".wmv",
                        ".3gp",
                    ],
                ),
                "ffmpeg_command": InputPort(
                    name="ffmpeg_command",
                    port_type=PortType.TEXTAREA,
                    value="",
                    has_tooltip=True,
                ),
                "output_filename": InputPort(
                    name="output_filename",
                    port_type=PortType.INPUT,
                    value="output.mp4",
                    required=False,
                    has_tooltip=True,
                ),
                "output_type": InputPort(
                    name="output_type",
                    port_type=PortType.SELECT,
                    value="only_link",
                    options=[{"value": "only_link", "label": "only_link"}, {"value": "markdown", "label": "markdown"}, {"value": "html", "label": "html"}],
                    required=False,
                ),
                "output": OutputPort(),
                "output_error": OutputPort(name="output_error", has_tooltip=True),
            },
        )


class ImageBackgroundRemoval(Node):
    def __init__(self, id: str | None = None):
        super().__init__(
            node_type="ImageBackgroundRemoval",
            category="mediaEditing",
            task_name="media_editing.image_background_removal",
            node_id=id,
            ports={
                "input_image": InputPort(
                    name="input_image",
                    port_type=PortType.FILE,
                    value=[],
                    show=True,
                    support_file_types=[".jpg", ".jpeg", ".png", ".webp"],
                ),
                "remove_background_method": InputPort(
                    name="remove_background_method",
                    port_type=PortType.SELECT,
                    value="accurate",
                    options=[
                        {"label": "fast", "value": "fast"},
                        {"label": "accurate", "value": "accurate"},
                        {"label": "portrait", "value": "portrait"},
                        {"label": "birefnet", "value": "birefnet"},
                    ],
                    required=False,
                ),
                "transparent_background": InputPort(
                    name="transparent_background",
                    port_type=PortType.CHECKBOX,
                    value=True,
                    required=False,
                ),
                "background_color": InputPort(
                    name="background_color",
                    port_type=PortType.INPUT,
                    value="#ffffff",
                    required=False,
                    has_tooltip=True,
                    condition="return !fieldsData.transparent_background.value",
                    condition_python=lambda ports: not ports["transparent_background"].value,
                ),
                "crop_to_subject": InputPort(
                    name="crop_to_subject",
                    port_type=PortType.CHECKBOX,
                    value=False,
                    required=False,
                    has_tooltip=True,
                ),
                "output_type": InputPort(
                    name="output_type",
                    port_type=PortType.SELECT,
                    value="markdown",
                    options=[{"value": "only_link", "label": "only_link"}, {"value": "markdown", "label": "markdown"}, {"value": "html", "label": "html"}],
                    required=False,
                ),
                "output": OutputPort(),
            },
        )


class ImageEditing(Node):
    def __init__(self, id: str | None = None):
        super().__init__(
            node_type="ImageEditing",
            category="mediaEditing",
            task_name="media_editing.image_editing",
            node_id=id,
            ports={
                "input_image": InputPort(
                    name="input_image",
                    port_type=PortType.FILE,
                    value=[],
                    show=True,
                    support_file_types=[".jpg", ".jpeg", ".png", ".webp"],
                ),
                "crop": InputPort(
                    name="crop",
                    port_type=PortType.CHECKBOX,
                    value=False,
                    required=False,
                ),
                "crop_method": InputPort(
                    name="crop_method",
                    port_type=PortType.SELECT,
                    value="proportional",
                    options=[{"label": "proportional", "value": "proportional"}, {"label": "fixed", "value": "fixed"}],
                    required=False,
                    condition="return fieldsData.crop.value",
                    condition_python=lambda ports: ports["crop"].value,
                ),
                "crop_position": InputPort(
                    name="crop_position",
                    port_type=PortType.SELECT,
                    value="center",
                    options=[
                        {"label": "center", "value": "center"},
                        {"label": "top_left", "value": "top_left"},
                        {"label": "top", "value": "top"},
                        {"label": "top_right", "value": "top_right"},
                        {"label": "right", "value": "right"},
                        {"label": "bottom_right", "value": "bottom_right"},
                        {"label": "bottom", "value": "bottom"},
                        {"label": "bottom_left", "value": "bottom_left"},
                        {"label": "left", "value": "left"},
                        {"label": "absolute", "value": "absolute"},
                    ],
                    required=False,
                    condition="return fieldsData.crop.value",
                    condition_python=lambda ports: ports["crop"].value,
                ),
                "crop_x": InputPort(
                    name="crop_x",
                    port_type=PortType.NUMBER,
                    value=1,
                    condition="return fieldsData.crop_position.value == 'absolute' && fieldsData.crop.value",
                    condition_python=lambda ports: ports["crop_position"].value == "absolute" and ports["crop"].value,
                ),
                "crop_y": InputPort(
                    name="crop_y",
                    port_type=PortType.NUMBER,
                    value=1,
                    condition="return fieldsData.crop_position.value == 'absolute' && fieldsData.crop.value",
                    condition_python=lambda ports: ports["crop_position"].value == "absolute" and ports["crop"].value,
                ),
                "crop_width": InputPort(
                    name="crop_width",
                    port_type=PortType.NUMBER,
                    value=300,
                    has_tooltip=True,
                    condition="return fieldsData.crop.value && fieldsData.crop_method.value == 'fixed'",
                    condition_python=lambda ports: ports["crop"].value and ports["crop_method"].value == "fixed",
                ),
                "crop_height": InputPort(
                    name="crop_height",
                    port_type=PortType.NUMBER,
                    value=300,
                    has_tooltip=True,
                    condition="return fieldsData.crop.value && fieldsData.crop_method.value == 'fixed'",
                    condition_python=lambda ports: ports["crop"].value and ports["crop_method"].value == "fixed",
                ),
                "crop_width_ratio": InputPort(
                    name="crop_width_ratio",
                    port_type=PortType.NUMBER,
                    value=1,
                    condition="return fieldsData.crop.value && fieldsData.crop_method.value == 'proportional'",
                    condition_python=lambda ports: ports["crop"].value and ports["crop_method"].value == "proportional",
                ),
                "crop_height_ratio": InputPort(
                    name="crop_height_ratio",
                    port_type=PortType.NUMBER,
                    value=1,
                    condition="return fieldsData.crop.value && fieldsData.crop_method.value == 'proportional'",
                    condition_python=lambda ports: ports["crop"].value and ports["crop_method"].value == "proportional",
                ),
                "scale": InputPort(
                    name="scale",
                    port_type=PortType.CHECKBOX,
                    value=False,
                    required=False,
                ),
                "scale_method": InputPort(
                    name="scale_method",
                    port_type=PortType.SELECT,
                    value="proportional_scale",
                    options=[{"label": "proportional_scale", "value": "proportional_scale"}, {"label": "fixed_width_height", "value": "fixed_width_height"}],
                    required=False,
                    condition="return fieldsData.scale.value",
                    condition_python=lambda ports: ports["scale"].value,
                ),
                "scale_ratio": InputPort(
                    name="scale_ratio",
                    port_type=PortType.NUMBER,
                    value=1,
                    required=False,
                    condition="return fieldsData.scale.value && fieldsData.scale_method.value == 'proportional_scale'",
                    condition_python=lambda ports: ports["scale"].value and ports["scale_method"].value == "proportional_scale",
                ),
                "scale_width": InputPort(
                    name="scale_width",
                    port_type=PortType.NUMBER,
                    value=0,
                    has_tooltip=True,
                    condition="return fieldsData.scale.value && fieldsData.scale_method.value == 'fixed_width_height'",
                    condition_python=lambda ports: ports["scale"].value and ports["scale_method"].value == "fixed_width_height",
                ),
                "scale_height": InputPort(
                    name="scale_height",
                    port_type=PortType.NUMBER,
                    value=0,
                    has_tooltip=True,
                    condition="return fieldsData.scale.value && fieldsData.scale_method.value == 'fixed_width_height'",
                    condition_python=lambda ports: ports["scale"].value and ports["scale_method"].value == "fixed_width_height",
                ),
                "compress": InputPort(
                    name="compress",
                    port_type=PortType.NUMBER,
                    value=100,
                    required=False,
                    has_tooltip=True,
                ),
                "rotate": InputPort(
                    name="rotate",
                    port_type=PortType.NUMBER,
                    value=0,
                ),
                "output_type": InputPort(
                    name="output_type",
                    port_type=PortType.SELECT,
                    value="markdown",
                    options=[{"value": "only_link", "label": "only_link"}, {"value": "markdown", "label": "markdown"}, {"value": "html", "label": "html"}],
                    required=False,
                ),
                "output": OutputPort(),
            },
        )


class ImageSegmentation(Node):
    def __init__(self, id: str | None = None):
        super().__init__(
            node_type="ImageSegmentation",
            category="mediaEditing",
            task_name="media_editing.image_segmentation",
            node_id=id,
            ports={
                "input_image": InputPort(
                    name="input_image",
                    port_type=PortType.FILE,
                    value=[],
                    show=True,
                    support_file_types=[".jpg", ".jpeg", ".png", ".webp"],
                ),
                "selection_method": InputPort(
                    name="selection_method",
                    port_type=PortType.RADIO,
                    value="prompt",
                    options=[{"value": "prompt", "label": "prompt"}, {"value": "coordinates", "label": "coordinates"}],
                    required=False,
                ),
                "prompt": InputPort(
                    name="prompt",
                    port_type=PortType.TEXTAREA,
                    value="",
                    has_tooltip=True,
                    condition='return fieldsData.selection_method.value === "prompt"',
                    condition_python=lambda ports: ports["selection_method"].value == "prompt",
                ),
                "coordinates": InputPort(
                    name="coordinates",
                    port_type=PortType.TEXTAREA,
                    value="",
                    condition='return fieldsData.selection_method.value === "coordinates"',
                    condition_python=lambda ports: ports["selection_method"].value == "coordinates",
                ),
                "remove_coordinates": InputPort(
                    name="remove_coordinates",
                    port_type=PortType.TEXTAREA,
                    value="",
                    required=False,
                ),
                "overlay_mask": InputPort(
                    name="overlay_mask",
                    port_type=PortType.CHECKBOX,
                    value=False,
                    required=False,
                    has_tooltip=True,
                ),
                "output_type": InputPort(
                    name="output_type",
                    port_type=PortType.SELECT,
                    value="markdown",
                    options=[{"value": "only_link", "label": "only_link"}, {"value": "markdown", "label": "markdown"}, {"value": "html", "label": "html"}],
                    required=False,
                ),
                "output": OutputPort(),
            },
        )


class ImageWatermark(Node):
    def __init__(self, id: str | None = None):
        super().__init__(
            node_type="ImageWatermark",
            category="mediaEditing",
            task_name="media_editing.image_watermark",
            node_id=id,
            ports={
                "input_image": InputPort(
                    name="input_image",
                    port_type=PortType.FILE,
                    value=[],
                    show=True,
                    support_file_types=[".jpg", ".jpeg", ".png", ".webp"],
                ),
                "image_or_text": InputPort(
                    name="image_or_text",
                    port_type=PortType.RADIO,
                    value="text",
                    options=[{"value": "text", "label": "text"}, {"value": "image", "label": "image"}],
                    required=False,
                ),
                "watermark_image": InputPort(
                    name="watermark_image",
                    port_type=PortType.FILE,
                    value=[],
                    required=False,
                    support_file_types=[".jpg", ".jpeg", ".png", ".webp"],
                    condition='return fieldsData.image_or_text.value == "image"',
                    condition_python=lambda ports: ports["image_or_text"].value == "image",
                ),
                "watermark_image_width_ratio": InputPort(
                    name="watermark_image_width_ratio",
                    port_type=PortType.NUMBER,
                    value=0.3,
                    required=False,
                    has_tooltip=True,
                    condition='return fieldsData.image_or_text.value == "image"',
                    condition_python=lambda ports: ports["image_or_text"].value == "image",
                ),
                "watermark_image_height_ratio": InputPort(
                    name="watermark_image_height_ratio",
                    port_type=PortType.NUMBER,
                    value=0,
                    required=False,
                    has_tooltip=True,
                    condition='return fieldsData.image_or_text.value == "image"',
                    condition_python=lambda ports: ports["image_or_text"].value == "image",
                ),
                "watermark_text": InputPort(
                    name="watermark_text",
                    port_type=PortType.TEXTAREA,
                    value="",
                    required=False,
                    condition='return fieldsData.image_or_text.value == "text"',
                    condition_python=lambda ports: ports["image_or_text"].value == "text",
                ),
                "watermark_text_font": InputPort(
                    name="watermark_text_font",
                    port_type=PortType.SELECT,
                    value="source_han_sans_sc",
                    options=[
                        {"label": "source_han_sans_sc", "value": "source_han_sans_sc"},
                        {"label": "source_han_sans_tc", "value": "source_han_sans_tc"},
                        {"label": "source_han_sans_jp", "value": "source_han_sans_jp"},
                        {"label": "source_han_sans_kr", "value": "source_han_sans_kr"},
                        {"label": "you_she_biao_ti_hei", "value": "you_she_biao_ti_hei"},
                        {"label": "zi_hun_bian_tao_ti", "value": "zi_hun_bian_tao_ti"},
                        {"label": "ckt_king_kong", "value": "ckt_king_kong"},
                        {"label": "douyin_sans", "value": "douyin_sans"},
                        {"label": "alimama_dong_fang_da_kai", "value": "alimama_dong_fang_da_kai"},
                        {"label": "inter", "value": "inter"},
                        {"label": "custom", "value": "custom"},
                    ],
                    required=False,
                    condition='return fieldsData.image_or_text.value == "text"',
                    condition_python=lambda ports: ports["image_or_text"].value == "text",
                ),
                "watermark_text_font_custom": InputPort(
                    name="watermark_text_font_custom",
                    port_type=PortType.FILE,
                    value=[],
                    support_file_types=[".otf", ".ttf", ".ttc", ".otc"],
                    condition='return fieldsData.image_or_text.value == "text" && fieldsData.watermark_text_font.value == "custom"',
                    condition_python=lambda ports: ports["image_or_text"].value == "text" and ports["watermark_text_font"].value == "custom",
                ),
                "watermark_text_font_size": InputPort(
                    name="watermark_text_font_size",
                    port_type=PortType.NUMBER,
                    value=20,
                    required=False,
                    condition='return fieldsData.image_or_text.value == "text"',
                    condition_python=lambda ports: ports["image_or_text"].value == "text",
                ),
                "watermark_text_font_color": InputPort(
                    name="watermark_text_font_color",
                    port_type=PortType.INPUT,
                    value="#ffffff",
                    required=False,
                    condition='return fieldsData.image_or_text.value == "text"',
                    condition_python=lambda ports: ports["image_or_text"].value == "text",
                ),
                "opacity": InputPort(
                    name="opacity",
                    port_type=PortType.NUMBER,
                    value=0.8,
                    required=False,
                ),
                "position": InputPort(
                    name="position",
                    port_type=PortType.SELECT,
                    value="bottom_right",
                    options=[
                        {"label": "center", "value": "center"},
                        {"label": "top_left", "value": "top_left"},
                        {"label": "top", "value": "top"},
                        {"label": "top_right", "value": "top_right"},
                        {"label": "right", "value": "right"},
                        {"label": "bottom_right", "value": "bottom_right"},
                        {"label": "bottom", "value": "bottom"},
                        {"label": "bottom_left", "value": "bottom_left"},
                        {"label": "left", "value": "left"},
                    ],
                    required=False,
                ),
                "vertical_gap": InputPort(
                    name="vertical_gap",
                    port_type=PortType.NUMBER,
                    value=10,
                ),
                "horizontal_gap": InputPort(
                    name="horizontal_gap",
                    port_type=PortType.NUMBER,
                    value=10,
                ),
                "output_type": InputPort(
                    name="output_type",
                    port_type=PortType.SELECT,
                    value="markdown",
                    options=[{"value": "only_link", "label": "only_link"}, {"value": "markdown", "label": "markdown"}, {"value": "html", "label": "html"}],
                    required=False,
                ),
                "output": OutputPort(),
            },
        )


class VideoBackgroundRemoval(Node):
    def __init__(self, id: str | None = None):
        super().__init__(
            node_type="VideoBackgroundRemoval",
            category="mediaEditing",
            task_name="media_editing.video_background_removal",
            node_id=id,
            ports={
                "input_video": InputPort(
                    name="input_video",
                    port_type=PortType.FILE,
                    value=[],
                    show=True,
                    support_file_types=[".mp4", ".avi", ".mov", ".webm", ".mkv"],
                ),
                "background_color": InputPort(
                    name="background_color",
                    port_type=PortType.SELECT,
                    value="Black",
                    options=[
                        {"label": "Transparent", "value": "Transparent"},
                        {"label": "Black", "value": "Black"},
                        {"label": "White", "value": "White"},
                        {"label": "Gray", "value": "Gray"},
                        {"label": "Red", "value": "Red"},
                        {"label": "Green", "value": "Green"},
                        {"label": "Blue", "value": "Blue"},
                        {"label": "Yellow", "value": "Yellow"},
                        {"label": "Cyan", "value": "Cyan"},
                        {"label": "Magenta", "value": "Magenta"},
                        {"label": "Orange", "value": "Orange"},
                    ],
                    required=False,
                ),
                "output_container_and_codec": InputPort(
                    name="output_container_and_codec",
                    port_type=PortType.SELECT,
                    value="webm_vp9",
                    options=[
                        {"label": "mp4_h265", "value": "mp4_h265"},
                        {"label": "mp4_h264", "value": "mp4_h264"},
                        {"label": "webm_vp9", "value": "webm_vp9"},
                        {"label": "mov_h265", "value": "mov_h265"},
                        {"label": "mov_proresks", "value": "mov_proresks"},
                        {"label": "mkv_h265", "value": "mkv_h265"},
                        {"label": "mkv_h264", "value": "mkv_h264"},
                        {"label": "mkv_vp9", "value": "mkv_vp9"},
                        {"label": "gif", "value": "gif"},
                    ],
                    required=False,
                ),
                "output_type": InputPort(
                    name="output_type",
                    port_type=PortType.SELECT,
                    value="only_link",
                    options=[{"value": "only_link", "label": "only_link"}, {"value": "markdown", "label": "markdown"}, {"value": "html", "label": "html"}],
                    required=False,
                ),
                "output": OutputPort(),
            },
        )


class VideoEditing(Node):
    def __init__(self, id: str | None = None):
        super().__init__(
            node_type="VideoEditing",
            category="mediaEditing",
            task_name="media_editing.video_editing",
            node_id=id,
            ports={
                "input_video": InputPort(
                    name="input_video",
                    port_type=PortType.FILE,
                    value=[],
                    show=True,
                    support_file_types=["video/*"],
                ),
                "video_processing_logic": InputPort(
                    name="video_processing_logic",
                    port_type=PortType.SELECT,
                    value="process_each",
                    options=[{"label": "process_each", "value": "process_each"}, {"label": "merge", "value": "merge"}],
                    required=False,
                ),
                "trim_video": InputPort(
                    name="trim_video",
                    port_type=PortType.CHECKBOX,
                    value=False,
                    required=False,
                ),
                "trim_start_time": InputPort(
                    name="trim_start_time",
                    port_type=PortType.INPUT,
                    value="00:00:00",
                    required=False,
                    condition="return fieldsData.trim_video.value",
                    condition_python=lambda ports: ports["trim_video"].value,
                ),
                "trim_end_time": InputPort(
                    name="trim_end_time",
                    port_type=PortType.INPUT,
                    value="00:01:00",
                    required=False,
                    condition="return fieldsData.trim_video.value",
                    condition_python=lambda ports: ports["trim_video"].value,
                ),
                "rotate_video": InputPort(
                    name="rotate_video",
                    port_type=PortType.SELECT,
                    value=0,
                    options=[{"label": "0", "value": 0}, {"label": "90", "value": 90}, {"label": "180", "value": 180}, {"label": "270", "value": 270}],
                    required=False,
                ),
                "add_watermark": InputPort(
                    name="add_watermark",
                    port_type=PortType.CHECKBOX,
                    value=False,
                    required=False,
                ),
                "watermark_text": InputPort(
                    name="watermark_text",
                    port_type=PortType.INPUT,
                    value="",
                    required=False,
                    condition="return fieldsData.add_watermark.value",
                    condition_python=lambda ports: ports["add_watermark"].value,
                ),
                "output_video_format": InputPort(
                    name="output_video_format",
                    port_type=PortType.SELECT,
                    value="mp4",
                    options=[{"value": "mp4", "label": "mp4"}, {"value": "avi", "label": "avi"}, {"value": "mov", "label": "mov"}],
                    required=False,
                ),
                "use_oversea_node": InputPort(
                    name="use_oversea_node",
                    port_type=PortType.CHECKBOX,
                    value=False,
                ),
                "output": OutputPort(),
            },
        )


class VideoScreenshot(Node):
    def __init__(self, id: str | None = None):
        super().__init__(
            node_type="VideoScreenshot",
            category="mediaEditing",
            task_name="media_editing.video_screenshot",
            node_id=id,
            ports={
                "input_video": InputPort(
                    name="input_video",
                    port_type=PortType.FILE,
                    value=[],
                    show=True,
                    support_file_types=["video/*"],
                ),
                "screenshot_method": InputPort(
                    name="screenshot_method",
                    port_type=PortType.SELECT,
                    value="interval",
                    options=[{"label": "interval", "value": "interval"}, {"label": "timestamps", "value": "timestamps"}],
                    required=False,
                ),
                "screenshot_interval": InputPort(
                    name="screenshot_interval",
                    port_type=PortType.NUMBER,
                    value=10,
                    required=False,
                    has_tooltip=True,
                    condition="return fieldsData.screenshot_method.value === 'interval'",
                    condition_python=lambda ports: ports["screenshot_method"].value == "interval",
                ),
                "screenshot_timestamps": InputPort(
                    name="screenshot_timestamps",
                    port_type=PortType.INPUT,
                    value="",
                    required=False,
                    condition="return fieldsData.screenshot_method.value === 'timestamps'",
                    condition_python=lambda ports: ports["screenshot_method"].value == "timestamps",
                ),
                "output_type": InputPort(
                    name="output_type",
                    port_type=PortType.SELECT,
                    value="markdown",
                    options=[{"value": "only_link", "label": "only_link"}, {"value": "markdown", "label": "markdown"}, {"value": "html", "label": "html"}],
                    required=False,
                ),
                "output": OutputPort(),
            },
        )
