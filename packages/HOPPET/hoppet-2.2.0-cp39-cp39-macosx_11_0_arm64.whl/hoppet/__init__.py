# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.4.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""

A Higher Order Perturbative Parton Evolution Toolkit

HOPPET is a Fortran package for carrying out DGLAP evolution and other 
common manipulations of parton distribution functions (PDFs).

Citation:
G.P. Salam, J. Rojo, 'A Higher Order Perturbative Parton Evolution Toolkit (HOPPET)', 
Comput. Phys. Commun. 180 (2009) 120-156, `arXiv:0804.3755 <https://arXiv.org/abs/0804.3755>`_

and                                                       

A. Karlberg, P. Nason, G.P. Salam, G. Zanderighi & F. Dreyer, 
`arXiv:2510.09310 <https://arXiv.org/abs/2510.09310>`_. 

Example:
--------

   >>> import hoppet as hp
   >>> import numpy as np
   >>> 
   >>> def main():
   >>>     dy = 0.1    
   >>>     nloop = 3
   >>>     # Start hoppet
   >>>     hp.Start(dy, nloop)
   >>>     
   >>>     asQ0 = 0.35
   >>>     Q0 = np.sqrt(2.0)
   >>>     # Do the evolution. 
   >>>     hp.Evolve(asQ0, Q0, nloop, 1.0, hp.BenchmarkPDFunpol, Q0)
   >>> 
   >>>     # Evaluate the PDFs at some x values and print them
   >>>     xvals = [1e-5,1e-4,1e-3,1e-2,0.1,0.3,0.5,0.7,0.9]
   >>>     Q = 100.0
   >>> 
   >>>     print('')
   >>>     print('           Evaluating PDFs at Q =',Q, ' GeV')
   >>>     print('    x      u-ubar      d-dbar    2(ubr+dbr)    c+cbar       gluon')
   >>>     for ix in range(9):
   >>>         pdf_array = hp.Eval(xvals[ix], Q)
   >>>         print('{:7.1E} {:11.4E} {:11.4E} {:11.4E} {:11.4E} {:11.4E}'.format(
   >>>             xvals[ix],
   >>>             pdf_array[6 + 2] - pdf_array[6 - 2], 
   >>>             pdf_array[6 + 1] - pdf_array[6 - 1], 
   >>>             2 * (pdf_array[6 - 1] + pdf_array[6 - 2]),
   >>>             pdf_array[6 - 4] + pdf_array[6 + 4],
   >>>             pdf_array[6 + 0]
   >>>         ))
   >>> 
   >>>     hp.DeleteAll()
   
For more examples, see https://github.com/hoppet-code/hoppet/tree/master/example_py	

"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if getattr(globals().get("__spec__"), "parent", None) or __package__ or "." in __name__:
    from . import _hoppet_swig
else:
    import _hoppet_swig

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



__version__ = "2.2.0"
__author__ = "Frederic Dreyer, Alexander Karlberg, Paolo Nason, Juan Rojo, Gavin Salam, Giulia Zanderighi"


def SetFFN(fixed_nf):
    r"""
    Set things up to be a fixed-flavour number scheme with the given
    fixed_nf number of flavours

    :type fixed_nf: int
    :param fixed_nf: Value of fixed number of flavours (e.g. 5)
    """
    return _hoppet_swig.SetFFN(fixed_nf)

def SetVFN(mc, mb, mt):
    r"""
    Set things up to be a variable-flavour number scheme with the
    given quark (pole) masses. Now deprecated; use
    hoppetSetPoleMassVFN instead, which is what is being called
    undder the hood.

    :type mc: float
    :param mc: Charm mass
    :type mb: float
    :param mb: Bottom mass
    :type mt: float
    :param mt: Top mass
    """
    return _hoppet_swig.SetVFN(mc, mb, mt)

def SetPoleMassVFN(mc, mb, mt):
    r"""
    Set things up to be a variable-flavour number scheme with the
    given quark (pole) masses. Thresholds are crossed at the pole
    masses, both for the coupling and the PDF evolution.

    :type mc: float
    :param mc: Charm mass
    :type mb: float
    :param mb: Bottom mass
    :type mt: float
    :param mt: Top mass
    """
    return _hoppet_swig.SetPoleMassVFN(mc, mb, mt)

def SetMSbarMassVFN(mc, mb, mt):
    r"""
    Set things up to be a variable-flavour number scheme with the given
    quark (MSbar) masses. Thresholds are crossed at the MSbar
    masses, both for the coupling and the PDF evolution.

    :type mc: float
    :param mc: Charm mass
    :type mb: float
    :param mb: Bottom mass
    :type mt: float
    :param mt: Top mass
    """
    return _hoppet_swig.SetMSbarMassVFN(mc, mb, mt)

def SetExactDGLAP(exact_nfthreshold, exact_splitting):
    r"""
    Arrange for the use of exact NNLO splitting and mass-threshold
    functions.

    :type exact_nfthreshold: boolean
    :param exact_nfthreshold: If True use the exact NNLO mass
        threshold functions. If False use the faster parametrisations
    :type exact_splitting: boolean
    :param exact_splitting: If True use the exact NNLO splitting
        functions. If False use the faster parametrisations

    To be called before hoppetStart
    """
    return _hoppet_swig.SetExactDGLAP(exact_nfthreshold, exact_splitting)

def SetApproximateDGLAPN3LO(splitting_variant):
    r"""
    Arrange for the use of various approximate N3LO splitting functions.

    :type splitting_variant: int
    :param splitting_variant: One of the hoppet.n3lo_splitting_approximation_* options.

    To be called before hoppetStart
    """
    return _hoppet_swig.SetApproximateDGLAPN3LO(splitting_variant)

def SetSplittingNNLO(splitting_variant):
    r"""
    Arrange for the use of various NNLO splitting functions.

    :type splitting_variant: int
    :param splitting_variant: One of the hoppet.nnlo_splitting_* options.

    To be called before hoppetStart
    """
    return _hoppet_swig.SetSplittingNNLO(splitting_variant)

def SetSplittingN3LO(splitting_variant):
    r"""
    Change the variant for the N3LO splitting functions.

    :type splitting_variant: int
    :param splitting_variant: One of the hoppet.n3lo_splitting_* options.

    To be called before hoppetStart
    """
    return _hoppet_swig.SetSplittingN3LO(splitting_variant)

def SetN3LOnfthresholds(variant):
    r"""
     Arrange for the use of N3LO mass thresholds or not.

    :type variant: int
    :param variant: One of the hoppet.n3lo_nfthresholds_* options.

    To be called before hoppetStart
    """
    return _hoppet_swig.SetN3LOnfthresholds(variant)

def SetYLnlnQInterpOrders(yorder, lnlnQorder):
    r"""
     Override the default interpolation order in y and lnlnQ.

    :type yorder: int
    :param yorder: The interpolation order in y (default: 5)
    :type lnlnQorder: int
    :param lnlnQorder: The interpolation order in lnlnQ (default: 4)

    2 corresponds to quadratic, 3 to cubic etc.
    """
    return _hoppet_swig.SetYLnlnQInterpOrders(yorder, lnlnQorder)

def SetCoupling(asQ0, Q0alphas, nloop):
    r"""
    Set up the strong coupling such that alphas(Q)=alphas_Q, with the
    given number of loops (nloop).

    The user should have set the quark masses or requested a FFN scheme
    prior to calling this function.

    This function is provided mainly for use in conjunction with
    hoppetAssign (C++) :func:`Assign` (Python).  In particular, it
    has the side effect of modifying the structure of the PDF tables
    to make sure they know about the mass thresholds.

    If QED has been requested, a QED coupling will also be set up
    (its value is not currently configurable from this interface).

    If you call hoppetEvolve (C++) :func:`Evolve` (Python), there is
    no need to separately call this routine.

    :type asQ0: float
    :param asQ0: alphas at the scale Q0
    :type Q0alphas: float
    :param Q0alphas: the scale Q0
    :type nloop: int
    :param nloop: Perturbative order (1: LO, 2: NLO, 3: NNLO, 4: N3LO)
    """
    return _hoppet_swig.SetCoupling(asQ0, Q0alphas, nloop)

def PreEvolve(asQ0, Q0alphas, nloop, muR_Q, Q0pdf):
    r"""
    Prepare a cached evolution.  Once this has been called, one can
    use hoppetCachedEvolve (C++) or :func:`CachedEvolve` (Python) to
    carry out the cached evolution of a specific initial condition.

    :type asQ0: float
    :param asQ0:     Strong coupling at initial scale Q0alphas
    :type Q0alphas: float
    :param Q0alphas: Initial scale for alpha_s [GeV]
    :type nloop: int
    :param nloop:    Number of loops for evolution (1=LO, 2=NLO, 3=NNLO, 4=N3LO)
    :type muR_Q: float
    :param muR_Q:    Ratio of renormalisation scheme to factorisation scale during evolution
    :type Q0pdf: float
    :param Q0pdf:    Initial scale for PDF [GeV]
    """
    return _hoppet_swig.PreEvolve(asQ0, Q0alphas, nloop, muR_Q, Q0pdf)

def AlphaS(Q):
    r"""
    Return the strong coupling at scale Q

    :type Q: float
    :param Q: Scale in GeV
    :rtype: float
    :return: The strong coupling
    """
    return _hoppet_swig.AlphaS(Q)

def AlphaQED(Q):
    r"""
    Return the QED coupling at scale Q

    :type Q: float
    :param Q: Scale in GeV
    :rtype: float
    :return: The QED coupling
    """
    return _hoppet_swig.AlphaQED(Q)

def EvalIFlv(x, Q, iflv):
    r"""
    Return xf(x,Q) for the flavour indicated by iflv, which should
    be one of the hoppet iflv_* constants (iflv_g, iflv_d,
    iflv_ubar, etc.)

    :type x: float
    :param x: Longitudinal momentum fraction (0 < x < 1)
    :type Q: float
    :param Q: Scale in GeV
    :type iflv: int
    :param iflv: One of the hoppet.iflv_g, hoppet.iflv_d, etc.

    :rtype: float
    :return: xf(x,Q) for the flavour indicated by iflv
    """
    return _hoppet_swig.EvalIFlv(x, Q, iflv)

def StartStrFct(order_max):
    r"""
    Minimal setup of structure functions

    :type order_max: int
    :param order_max: highest order in QCD to compute (1: LO, 2: NLO, 3: NNLO, 4: N3LO)
    """
    return _hoppet_swig.StartStrFct(order_max)

def StartStrFctExtended(order_max, nflav, scale_choice, constant_mu, param_coefs, wmass, zmass):
    r"""
    Setup of constants and parameters needed for structure functions

    :type order_max: int
    :param order_max:      highest order in QCD to compute (1: LO, 2: NLO, 3: NNLO, 4: N3LO)
    :type nflav: int
    :param nflav:          integer number of flavours (if negative use variable flavour)
    :type scale_choice: int
    :param scale_choice:   (0: fixed scale, 1: use Q, 2: use arbitrary scale)
    :type constant_mu: float
    :param constant_mu:    if scale_choice = scale_choice_fixed (= 0) then this is the fixed scale
    :type param_coefs: boolean
    :param param_coefs:    if .true. use parametrised coefficients functions
    :type wmass: float
    :param wmass:          Mass of the W boson
    :type zmass: float
    :param zmass:          Mass of the z boson
    """
    return _hoppet_swig.StartStrFctExtended(order_max, nflav, scale_choice, constant_mu, param_coefs, wmass, zmass)

def hoppetwritelhapdfwithlen_c(basename_len, basename, pdf_index):
    return _hoppet_swig.hoppetwritelhapdfwithlen_c(basename_len, basename, pdf_index)

def WriteLHAPDFGrid(basename, pdf_index):
    r"""
    Write out the contents of tables(0) (assumed to be the PDF) in the
    LHAPDF format

    :type basename: string
    :param basename: The basename of the output
    :type pdf_index: int
    :param pdf_index: The intended index in the LHAPDF meaning. If index is 0 both the PDF and the .info file is saved to disk
    """
    return _hoppet_swig.WriteLHAPDFGrid(basename, pdf_index)

def SetQED(withqed, qcdqed, plq):
    r"""

    Enable or disable QED evolution with photon and lepton PDFs.

    Parameters:
      withqed (int): 1 to enable QED evolution, 0 to disable
      qcdqed (int): Treatment of QCD-QED coupling (implementation-specific)
      plq (int): 1 to enable lepton splitting function

      Note: Must be called before :func:`Start` as it modifies global PDF settings.


    """
    return _hoppet_swig.SetQED(withqed, qcdqed, plq)

def Start(dy, nloop):
    r"""

    Initialize HOPPET evolution tables with basic parameters.

    Parameters:
      dy (float): Step size in ln(1/x). Typical range: 0.05-0.2
      nloop (int): Maximum number of loops (1=LO, 2=NLO, 3=NNLO, 4=N3LO)

      Note: This is the basic initialization. For more control, use
      :func:`StartExtended`.


    """
    return _hoppet_swig.Start(dy, nloop)

def StartExtended(ymax, dy, Qmin, Qmax, dlnlnQ, nloop, order, factscheme):
    r"""

    Initialize HOPPET evolution tables with extended parameters.

    Parameters:
      ymax (float): Highest value of ln(1/x) user wants to access
      dy (float): Internal ln(1/x) grid spacing (0.05-0.2 is sensible)
      Qmin (float): Lower limit of Q range [GeV]
      Qmax (float): Upper limit of Q range [GeV]  
      dlnlnQ (float): Internal table spacing in ln(ln(Q)) (e.g. dy/4)
      nloop (int): Maximum number of loops (1=LO, 2=NLO, 3=NNLO, 4=N3LO)
      order (int): Order of numerical interpolation (e.g. -6)
       factscheme (int): One of the hoppet.factscheme_* factorization scheme identifier (e.g. hoppet.factscheme_MSbar)

    This provides full control over the evolution grid setup.

    """
    return _hoppet_swig.StartExtended(ymax, dy, Qmin, Qmax, dlnlnQ, nloop, order, factscheme)

def InitStrFct(order_max, separate_orders, xR, xF):
    r"""

    Initialize structure function calculations.

    Parameters:
      order_max (int): Maximum perturbative order <=4
      separate_orders (int): Whether to separate by order
      xR (float): Renormalization scale factor
      xF (float): Factorization scale factor

    """
    return _hoppet_swig.InitStrFct(order_max, separate_orders, xR, xF)

def InitStrFctFlav(order_max, separate_orders, xR, xF):
    r"""

    Initialize flavour-decomposed structure function calculations.

    Parameters:
      order_max (int): Maximum perturbative order <=4
      separate_orders (int): Whether to separate by order  
      xR (float): Renormalization scale factor
      xF (float): Factorization scale factor

    """
    return _hoppet_swig.InitStrFctFlav(order_max, separate_orders, xR, xF)

def DeleteAll():
    r"""

    Clean up and free all HOPPET internal arrays and memory.

    Call this at the end of your program to free resources.

    """
    return _hoppet_swig.DeleteAll()

def Assign(callback):
    r"""

    Assign a PDF function to HOPPET without evolution.

    Parameters:
      callback (callable): Python function with signature callback(x, Q) 
                           returning array of 13 PDF values

    The callback should return PDFs in HOPPET order:

    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]

    or if QED evolution is included

    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t, EMPTY, photon, electron, muon, tau]

    """
    return _hoppet_swig.Assign(callback)

def Evolve(asQ0, Q0alphas, nloop, muR_Q, callback, Q0pdf):
    r"""

    Evolve PDFs from initial scale Q0 to all scales in the grid.

    Parameters:
      asQ0 (float): Strong coupling at initial scale
      Q0alphas (float): Reference scale for alpha_s [GeV]
      nloop (int): Number of loops for evolution
      muR_Q (float): Renormalization scale ratio (muR/Q)
      callback (callable): PDF function with signature callback(x, Q)
      Q0pdf (float): Initial scale for PDF [GeV]

    The callback should return PDFs in HOPPET order:

    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]

    or if QED evolution is included

    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t, EMPTY, photon, electron, muon, tau]

    """
    return _hoppet_swig.Evolve(asQ0, Q0alphas, nloop, muR_Q, callback, Q0pdf)

def CachedEvolve(callback):
    r"""

    Perform a cached evolution.

    Parameters:
      callback (callable): PDF function with signature callback(x, Q)
                           returning array of 13/18 PDF values

    More efficient than :func:`Evolve` when doing multiple evolutions. Needs a call to :func:`PreEvolve` first.

    The callback should return PDFs in HOPPET order:

    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]

    or if QED evolution is included

    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t, EMPTY, photon, electron, muon, tau]


    """
    return _hoppet_swig.CachedEvolve(callback)

def Eval(x, Q):
    r"""

    Evaluate evolved PDFs at given x and Q.

    Parameters:
      x (float): Longitudinal momentum fraction (0 < x < 1)
      Q (float): Momentum scale [GeV]

    Returns:
      list: Array of 13/18 PDF values in HOPPET order:
      [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]
      or if QED evolution is included
      [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t, EMPTY, photon, electron, muon, tau]

    """
    return _hoppet_swig.Eval(x, Q)

def EvalSplit(x, Q, iloop, nf):
    r"""

     Return the value of 

        [P(iloop,nf) \otimes pdf] (x,Q)

     where P(iloop,nf) is the iloop-splitting function for the given
     value of nf, and pdf is our internally stored pdf.

     The normalisation is such that the nloop dglap evolution equation is

         dpdf/dlnQ^2 = sum_{iloop=1}^nloop 
                            (alphas/(2*pi))^iloop * P(iloop,nf) \otimes pdf

     Note that each time nf changes relative to a previous call for the
     same iloop, the convolution has to be repeated for the whole
     table. So for efficient results when requiring multiple nf values,
     calls with the same nf value should be grouped together.

     In particular, for repeated calls with the same value of nf, the
     convolutions are carried out only on the first call (i.e. once for
     each value of iloop). Multiple calls with different values for
     iloop can be carried out without problems.

     Note that iloop can also be of the form ij or ijk, which means
     P(i)*P(j)*pdf or P(i)*P(j)*P(k)*pdf. The sum of i+j+k is currently
     bounded to be <= 4.

     The number of loops must be consistent with iloop

    Parameters:
      x (float): Longitudinal momentum fraction (0 < x < 1)
      Q (float): Momentum scale [GeV]
      iloop (int): Perturbative order (1=LO, 2=NLO, etc.)
      nf (int): Number of active flavours

    Returns:
      list: Array of 13/18 PDF values in HOPPET order:
      [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]
      or if QED evolution is included
      [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t, EMPTY, photon, electron, muon, tau]

    """
    return _hoppet_swig.EvalSplit(x, Q, iloop, nf)

def BenchmarkPDFunpol(x, Q):
    r"""

    Evaluate the unpolarized benchmark PDF set.

    Parameters:
      x (float): Longitudinal momentum fraction (0 < x < 1)  
      Q (float): Momentum scale [GeV]

    Returns:
      list: Array of 13 benchmark PDF values

    Useful for testing and validation against known results. For a
    benchmark PDF with photon and leptons look at
    `example_py/tabulation_example_qed.py
    <https://github.com/hoppet-code/hoppet/blob/master/example_py/tabulation_example_qed.py>`_

    """
    return _hoppet_swig.BenchmarkPDFunpol(x, Q)

def StrFct(x, Q, muR_in, muF_in):
    r"""

    Calculate structure functions with specified scales.

    Parameters:
      x (float): Longitudinal momentum fraction
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]

    Returns:
      list: Array of structure function values where the indices correspond to the hoppet.iF1Wp etc. constants

    """
    return _hoppet_swig.StrFct(x, Q, muR_in, muF_in)

def StrFctNoMu(x, Q):
    r"""

    Calculate structure functions with default scale choices.

    Parameters:
      x (float): Longitudinal momentum fraction
      Q (float): Hard scale [GeV] (used for both muR and muF)

    Returns:
      list: Array of structure function values where the indices correspond to the hoppet.iF1Wp etc. constants

    """
    return _hoppet_swig.StrFctNoMu(x, Q)

def StrFctLO(x, Q, muR_in, muF_in):
    r"""

    Calculate leading-order structure functions.

    Parameters:
      x (float): Longitudinal momentum fraction
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]

    Returns:
      list: Array of LO structure function values where the indices correspond to the hoppet.iF1Wp etc. constants

    """
    return _hoppet_swig.StrFctLO(x, Q, muR_in, muF_in)

def StrFctNLO(x, Q, muR_in, muF_in):
    r"""

    Calculate next-to-leading-order structure functions.

    Parameters:
      x (float): Longitudinal momentum fraction
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]

    Returns:
      list: Array of NLO structure function values where the indices correspond to the hoppet.iF1Wp etc. constants

    """
    return _hoppet_swig.StrFctNLO(x, Q, muR_in, muF_in)

def StrFctFlav(x, Q, muR_in, muF_in, flav):
    r"""

    Calculate flavour-decomposed structure functions.

    Parameters:
      x (float): Longitudinal momentum fraction
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]
      flav (int): Flavour index (one of hoppet.iflv* constants)

    Returns:
       list: Array of structure function values for specified flavour where indices correspond to FL, F2, F3

    """
    return _hoppet_swig.StrFctFlav(x, Q, muR_in, muF_in, flav)

def StrFctNoMuFlav(x, Q, flav):
    r"""

    Calculate flavour-decomposed structure functions with default scales.

    Parameters:
      x (float): Longitudinal momentum fraction
      Q (float): Hard scale [GeV]  
      flav (int): Flavour index

    Returns:
      list: Array of structure function values for specified flavour where indices correspond to FL, F2, F3

    """
    return _hoppet_swig.StrFctNoMuFlav(x, Q, flav)

def StrFctLOFlav(x, Q, muR_in, muF_in, flav):
    r"""

    Calculate LO flavour-decomposed structure functions.

    Parameters:
      x (float): Longitudinal momentum fraction
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]
      flav (int): Flavour index

    Returns:
      list: Array of LO structure function values for specified flavour where indices correspond to FL, F2, F3

    """
    return _hoppet_swig.StrFctLOFlav(x, Q, muR_in, muF_in, flav)

def StrFctNLOFlav(x, Q, muR_in, muF_in, flav):
    r"""

    Calculate NLO flavour-decomposed structure functions.

    Parameters:
      x (float): Longitudinal momentum fraction
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]
      flav (int): Flavour index

    Returns:
      list: Array of NLO structure function values for specified flavour where indices correspond to FL, F2, F3

    """
    return _hoppet_swig.StrFctNLOFlav(x, Q, muR_in, muF_in, flav)

def StrFctNNLO(x, Q, muR_in, muF_in):
    r"""

    Calculate next-to-next-to-leading-order structure functions.

    Parameters:
      x (float): Longitudinal momentum fraction
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]  
      muF_in (float): Factorization scale [GeV]

    Returns:
      list: Array of NNLO structure function values where the indices correspond to the hoppet.iF1Wp etc. constants

    """
    return _hoppet_swig.StrFctNNLO(x, Q, muR_in, muF_in)

def StrFctN3LO(x, Q, muR_in, muF_in):
    r"""

    Calculate next-to-next-to-next-to-leading-order structure functions.

    Parameters:
      x (float): Longitudinal momentum fraction
      Q (float): Hard scale [GeV]
      muR_in (float): Renormalization scale [GeV]
      muF_in (float): Factorization scale [GeV]

    Returns:
      list: Array of N3LO structure function values where the indices correspond to the hoppet.iF1Wp etc. constants

    """
    return _hoppet_swig.StrFctN3LO(x, Q, muR_in, muF_in)

cvar = _hoppet_swig.cvar
cc_REAL = cvar.cc_REAL
cc_VIRT = cvar.cc_VIRT
cc_REALVIRT = cvar.cc_REALVIRT
cc_DELTA = cvar.cc_DELTA
iflv_g = cvar.iflv_g
iflv_d = cvar.iflv_d
iflv_u = cvar.iflv_u
iflv_s = cvar.iflv_s
iflv_c = cvar.iflv_c
iflv_b = cvar.iflv_b
iflv_t = cvar.iflv_t
iflv_dbar = cvar.iflv_dbar
iflv_ubar = cvar.iflv_ubar
iflv_sbar = cvar.iflv_sbar
iflv_cbar = cvar.iflv_cbar
iflv_bbar = cvar.iflv_bbar
iflv_tbar = cvar.iflv_tbar
iflv_photon = cvar.iflv_photon
iflv_electron = cvar.iflv_electron
iflv_muon = cvar.iflv_muon
iflv_tau = cvar.iflv_tau
iflv_min = cvar.iflv_min
iflv_max = cvar.iflv_max
iflv_info = cvar.iflv_info
ncompmin = cvar.ncompmin
ncompmax = cvar.ncompmax
iflv_min_fortran = cvar.iflv_min_fortran
iF1Wp = cvar.iF1Wp
iF2Wp = cvar.iF2Wp
iF3Wp = cvar.iF3Wp
iF1Wm = cvar.iF1Wm
iF2Wm = cvar.iF2Wm
iF3Wm = cvar.iF3Wm
iF1Z = cvar.iF1Z
iF2Z = cvar.iF2Z
iF3Z = cvar.iF3Z
iF1EM = cvar.iF1EM
iF2EM = cvar.iF2EM
iF1gZ = cvar.iF1gZ
iF2gZ = cvar.iF2gZ
iF3gZ = cvar.iF3gZ
scale_choice_fixed = cvar.scale_choice_fixed
scale_choice_Q = cvar.scale_choice_Q
scale_choice_arbitrary = cvar.scale_choice_arbitrary
nnlo_splitting_exact = cvar.nnlo_splitting_exact
nnlo_splitting_param = cvar.nnlo_splitting_param
nnlo_splitting_Nfitav = cvar.nnlo_splitting_Nfitav
nnlo_splitting_Nfiterr1 = cvar.nnlo_splitting_Nfiterr1
nnlo_splitting_Nfiterr2 = cvar.nnlo_splitting_Nfiterr2
n3lo_splitting_exact = cvar.n3lo_splitting_exact
n3lo_splitting_param = cvar.n3lo_splitting_param
n3lo_splitting_Nfitav = cvar.n3lo_splitting_Nfitav
n3lo_splitting_Nfiterr1 = cvar.n3lo_splitting_Nfiterr1
n3lo_splitting_Nfiterr2 = cvar.n3lo_splitting_Nfiterr2
n3lo_splitting_approximation_up_to_2310_05744 = cvar.n3lo_splitting_approximation_up_to_2310_05744
n3lo_splitting_approximation_up_to_2404_09701 = cvar.n3lo_splitting_approximation_up_to_2404_09701
n3lo_splitting_approximation_up_to_2410_08089 = cvar.n3lo_splitting_approximation_up_to_2410_08089
n3lo_splitting_approximation_up_to_2310 = cvar.n3lo_splitting_approximation_up_to_2310
n3lo_splitting_approximation_up_to_2404 = cvar.n3lo_splitting_approximation_up_to_2404
n3lo_splitting_approximation_up_to_2410 = cvar.n3lo_splitting_approximation_up_to_2410
n3lo_splitting_approximation_up_to_2512 = cvar.n3lo_splitting_approximation_up_to_2512
nnlo_nfthreshold_exact = cvar.nnlo_nfthreshold_exact
nnlo_nfthreshold_param = cvar.nnlo_nfthreshold_param
n3lo_nfthreshold_libOME_2512 = cvar.n3lo_nfthreshold_libOME_2512
n3lo_nfthreshold_libOME_2510 = cvar.n3lo_nfthreshold_libOME_2510
n3lo_nfthreshold_exact_fortran = cvar.n3lo_nfthreshold_exact_fortran
n3lo_nfthreshold_off = cvar.n3lo_nfthreshold_off
n3lo_nfthreshold_on = cvar.n3lo_nfthreshold_on
n3lo_nfthreshold_libOME = cvar.n3lo_nfthreshold_libOME
factscheme_MSbar = cvar.factscheme_MSbar
factscheme_DIS = cvar.factscheme_DIS
factscheme_PolMSbar = cvar.factscheme_PolMSbar
factscheme_FragMSbar = cvar.factscheme_FragMSbar

