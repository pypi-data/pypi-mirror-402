"""Tests for synthetic particle image generation from discrete data.

These tests verify the core rendering logic that converts particle positions, 
diameters, and intensities into a grayscale grayscale image, including 
noise addition and performance benchmarking.
"""
import timeit

import jax
import jax.numpy as jnp
import pytest
from jax.sharding import Mesh, NamedSharding, PartitionSpec

from synthpix.generate import add_noise_to_image, img_gen_from_data
from synthpix.utils import load_configuration

config = load_configuration("config/testing.yaml")

REPETITIONS = config["REPETITIONS"]
NUMBER_OF_EXECUTIONS = config["EXECUTIONS_IMG_GEN"]


@pytest.mark.parametrize("seed", [0, 1, 42])
@pytest.mark.parametrize("image_shape", [(128, 128)])
@pytest.mark.parametrize(
    "particle_positions",
    [
        jnp.array([[0.5, 0.5], [1.5, 1.5], [2.5, 2.5]]),
        jnp.array([[0.5, 0.5], [1.5, 1.5], [2.5, 2.5], [3.5, 3.5]]),
    ],
)
@pytest.mark.parametrize("noise_uniform", [0.0, 5.0, 255.0])
@pytest.mark.parametrize(
    "noise_gaussian_mean, noise_gaussian_std", [(0.0, 0.0), (10.0, 2.0)]
)
def test_generate_image_from_data(
    seed,
    image_shape,
    particle_positions,
    noise_uniform,
    noise_gaussian_mean,
    noise_gaussian_std,
    visualize=False,
):
    """Test the generation of a synthetic particle image from raw data.

    Verifies that particles are correctly rendered and that noise is 
    applied without violating pixel intensity bounds or image dimensions.
    """
    key = jax.random.PRNGKey(seed)
    diameters_x = jnp.ones(particle_positions.shape[0])
    diameters_y = jnp.ones(particle_positions.shape[0])
    intensities = jnp.ones(particle_positions.shape[0]) * 255
    rho = jnp.ones(particle_positions.shape[0]) * 0.5

    img = img_gen_from_data(
        image_shape=image_shape,
        particle_positions=particle_positions,
        diameters_x=diameters_x,
        diameters_y=diameters_y,
        intensities=intensities,
        rho=rho,
    )

    img_background = add_noise_to_image(
        key,
        img,
        noise_uniform=noise_uniform,
        noise_gaussian_mean=noise_gaussian_mean,
        noise_gaussian_std=noise_gaussian_std,
    )

    if visualize:
        import matplotlib.pyplot as plt
        import numpy as np

        plt.imsave("img.png", np.array(img), cmap="gray")
        plt.imsave("img_background.png", np.array(img_background), cmap="gray")

    assert img.shape == image_shape, "Image shape is incorrect"
    assert img.min() >= 0, "Image contains negative values"
    assert img.max() <= 255, "Image contains values above 255"

    assert img_background.shape == image_shape, "Image shape is incorrect"
    assert img_background.min() >= 0, "Image contains negative values"
    assert img_background.max() <= 255, "Image contains values above 255"


# skipif is used to skip the test if there is no GPU available
@pytest.mark.skipif(
    not all(d.device_kind == "NVIDIA GeForce RTX 4090" for d in jax.devices()),
    reason="user not connect to the server.",
)
@pytest.mark.parametrize("seeding_density", [0.05])
@pytest.mark.parametrize("image_shape", [(1216, 1936)])
@pytest.mark.parametrize("diameter_range", [(1, 2)])
@pytest.mark.parametrize("intensity_range", [(100, 200)])
@pytest.mark.parametrize("rho_range", [(-0.2, 0.2)])
def test_speed_img_gen(
    seeding_density, image_shape, diameter_range, intensity_range, rho_range
):
    """Benchmark performance of GPU-parallelized image generation.

    Uses `shard_map` to distribute the rendering task across multiple 
    GPUs and verifies that the execution time is within expected bounds.
    """

    # Name of the axis for the device mesh
    shard_particles = "particles"

    # Check how many GPUs are available
    devices = jax.devices()
    if len(devices) == 3:
        devices = devices[:2]
    elif len(devices) > 4:
        devices = devices[:4]
    num_devices = len(devices)

    # Limit time in seconds (depends on the number of GPUs)
    if num_devices == 1:
        limit_time = 1e-4
    elif num_devices == 2:
        limit_time = 5e-5
    elif num_devices == 4:
        limit_time = 4e-5

    # Setup device mesh
    # We want to shard the particles and their characteristics
    # across the GPUs.
    # The idea is that each device will generate a image
    # and then stack it with the images generated by the other GPUs.
    mesh = Mesh(devices, axis_names=(shard_particles))

    # 1. Generate random particles and their characteristics
    key = jax.random.PRNGKey(0)
    subkey1, subkey2, subkey3, subkey4, subkey5 = jax.random.split(key, 5)

    particles_number = int(image_shape[0] * image_shape[1] * seeding_density)
    particles = jax.random.uniform(
        subkey1,
        (particles_number * num_devices, 2),
        minval=0.0,
        maxval=jnp.array(image_shape) - 1,
    )
    diameters_x = jax.random.uniform(
        subkey2,
        (particles_number * num_devices,),
        minval=diameter_range[0],
        maxval=diameter_range[1],
    )
    diameters_y = jax.random.uniform(
        subkey3,
        (particles_number * num_devices,),
        minval=diameter_range[0],
        maxval=diameter_range[1],
    )
    intensities = jax.random.uniform(
        subkey4,
        (particles_number * num_devices,),
        minval=intensity_range[0],
        maxval=intensity_range[1],
    )
    rho = jax.random.uniform(
        subkey5,
        (particles_number * num_devices,),
        minval=rho_range[0],
        maxval=rho_range[1],
    )

    # Sending the variables to the devices
    # To make the test also consider the time of sending the variables to the devices
    # comment the next lines
    particles = jax.device_put(
        particles, NamedSharding(mesh, PartitionSpec(shard_particles))
    )
    diameters_x = jax.device_put(
        diameters_x, NamedSharding(mesh, PartitionSpec(shard_particles))
    )
    diameters_y = jax.device_put(
        diameters_y, NamedSharding(mesh, PartitionSpec(shard_particles))
    )
    intensities = jax.device_put(
        intensities, NamedSharding(mesh, PartitionSpec(shard_particles))
    )
    rho = jax.device_put(
        rho, NamedSharding(mesh, PartitionSpec(shard_particles))
    )

    # wait for the variables to be sent to the devices
    jax.block_until_ready(particles)
    jax.block_until_ready(diameters_x)
    jax.block_until_ready(diameters_y)
    jax.block_until_ready(intensities)
    jax.block_until_ready(rho)

    _img_gen_fun = (
        lambda particles,
        diameters_x,
        diameters_y,
        intensities,
        rho: img_gen_from_data(
            image_shape=image_shape,
            particle_positions=particles,
            diameters_x=diameters_x,
            diameters_y=diameters_y,
            intensities=intensities,
            rho=rho,
        )
    )

    # 2. Create the jit function
    img_gen_from_data_jit = jax.jit(
        jax.shard_map(
            _img_gen_fun,
            mesh=mesh,
            in_specs=(
                PartitionSpec(shard_particles),
                PartitionSpec(shard_particles),
                PartitionSpec(shard_particles),
                PartitionSpec(shard_particles),
                PartitionSpec(shard_particles),
            ),
            out_specs=PartitionSpec(shard_particles),
        )
    )

    def run_img_gen_jit():
        img = img_gen_from_data_jit(
            particles,
            diameters_x,
            diameters_y,
            intensities,
            rho,
        )
        img.block_until_ready()

    # Warm up the function
    run_img_gen_jit()

    # 3. Measure the time of the jit function
    # We divide by the number of devices because shard_map
    # will return Number of devices results, like this we keep the number of
    # images generated the same as the number of devices changes
    total_time_jit = timeit.repeat(
        stmt=run_img_gen_jit,
        number=NUMBER_OF_EXECUTIONS // num_devices,
        repeat=REPETITIONS,
    )

    # Average time
    average_time_jit = min(total_time_jit) / NUMBER_OF_EXECUTIONS

    # 4. Check if the time is less than the limit
    assert average_time_jit < limit_time, (
        f"The average time is {average_time_jit}, time limit: {limit_time}"
    )
