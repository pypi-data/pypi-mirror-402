from collections.abc import Iterable, Iterator, Sequence, Set
import datetime
import enum
import os
import pathlib
from typing import Optional, Union, overload

import pymimir.advanced.common
import pymimir.advanced.formalism


class SymmetryPruning(enum.Enum):
    OFF = 0

    GI = 1

    WL1 = 2

OFF: SymmetryPruning = SymmetryPruning.OFF

GI: SymmetryPruning = SymmetryPruning.GI

WL1: SymmetryPruning = SymmetryPruning.WL1

class SearchNodeStatus(enum.Enum):
    NEW = 4

    OPEN = 3

    CLOSED = 2

    DEAD_END = 1

    GOAL = 0

NEW: SearchNodeStatus = SearchNodeStatus.NEW

OPEN: SearchNodeStatus = SearchNodeStatus.OPEN

CLOSED: SearchNodeStatus = SearchNodeStatus.CLOSED

DEAD_END: SearchNodeStatus = SearchNodeStatus.DEAD_END

GOAL: SearchNodeStatus = SearchNodeStatus.GOAL

class SearchStatus(enum.Enum):
    IN_PROGRESS = 0

    OUT_OF_TIME = 1

    OUT_OF_MEMORY = 2

    OUT_OF_STATES = 3

    FAILED = 4

    EXHAUSTED = 5

    SOLVED = 6

    UNSOLVABLE = 7

IN_PROGRESS: SearchStatus = SearchStatus.IN_PROGRESS

OUT_OF_TIME: SearchStatus = SearchStatus.OUT_OF_TIME

OUT_OF_MEMORY: SearchStatus = SearchStatus.OUT_OF_MEMORY

OUT_OF_STATES: SearchStatus = SearchStatus.OUT_OF_STATES

FAILED: SearchStatus = SearchStatus.FAILED

EXHAUSTED: SearchStatus = SearchStatus.EXHAUSTED

SOLVED: SearchStatus = SearchStatus.SOLVED

UNSOLVABLE: SearchStatus = SearchStatus.UNSOLVABLE

class MatchTreeSplitMetric(enum.Enum):
    FREQUENCY = 1

    GINI = 0

class MatchTreeSplitStrategy(enum.Enum):
    DYNAMIC = 0

class MatchTreeOptimizationDirection(enum.Enum):
    MINIMIZE = 0

    MAXIMIZE = 1

class GroundedOptions:
    def __init__(self) -> None: ...

class LiftedExhaustiveOptions:
    def __init__(self) -> None: ...

class LiftedKPKCOptions:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, symmetry_pruning: SymmetryPruning) -> None: ...

class LiftedOptions:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, variant_options: Union[LiftedKPKCOptions, LiftedExhaustiveOptions]) -> None: ...

class SearchContextOptions:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, mode: Union[GroundedOptions, LiftedOptions]) -> None: ...

    @property
    def mode(self) -> Union[GroundedOptions, LiftedOptions]: ...

    @mode.setter
    def mode(self, arg: Union[GroundedOptions, LiftedOptions], /) -> None: ...

class SearchContext:
    @overload
    @staticmethod
    def create(domain_filepath: str | os.PathLike, problem_filepath: str | os.PathLike, options: SearchContextOptions) -> SearchContext: ...

    @overload
    @staticmethod
    def create(problem: pymimir.advanced.formalism.Problem, options: SearchContextOptions) -> SearchContext: ...

    @overload
    @staticmethod
    def create(problem: pymimir.advanced.formalism.Problem, applicable_action_generator: IApplicableActionGenerator, state_repository: StateRepository) -> SearchContext: ...

    def get_problem(self) -> pymimir.advanced.formalism.Problem: ...

    def get_applicable_action_generator(self) -> IApplicableActionGenerator: ...

    def get_state_repository(self) -> StateRepository: ...

class GeneralizedSearchContext:
    @overload
    @staticmethod
    def create(domain_filepath: str | os.PathLike, problem_filepaths: Sequence[str | os.PathLike], options: SearchContextOptions) -> GeneralizedSearchContext: ...

    @overload
    @staticmethod
    def create(domain_filepath: str | os.PathLike, problems_directory: str | os.PathLike, options: SearchContextOptions) -> GeneralizedSearchContext: ...

    @overload
    @staticmethod
    def create(generalized_problem: pymimir.advanced.formalism.GeneralizedProblem, options: SearchContextOptions) -> GeneralizedSearchContext: ...

    @overload
    @staticmethod
    def create(generalized_problem: pymimir.advanced.formalism.GeneralizedProblem, search_contexts: Sequence[SearchContext]) -> GeneralizedSearchContext: ...

    def get_generalized_problem(self) -> pymimir.advanced.formalism.GeneralizedProblem: ...

    def get_search_contexts(self) -> list[SearchContext]: ...

class PackedState:
    def __hash__(self) -> int: ...

    def __eq__(self, arg: PackedState, /) -> bool: ...

class State:
    def __str__(self) -> str: ...

    def __hash__(self) -> int: ...

    def __eq__(self, arg: State, /) -> bool: ...

    def get_fluent_atoms(self) -> Iterator[int]: ...

    def get_derived_atoms(self) -> Iterator[int]: ...

    def get_numeric_variables(self) -> list[float]: ...

    @overload
    def literal_holds(self, literal: pymimir.advanced.formalism.FluentGroundLiteral) -> bool: ...

    @overload
    def literal_holds(self, literal: pymimir.advanced.formalism.DerivedGroundLiteral) -> bool: ...

    @overload
    def literal_holds(self, literals: pymimir.advanced.formalism.FluentGroundLiteralList) -> bool: ...

    @overload
    def literal_holds(self, literals: pymimir.advanced.formalism.DerivedGroundLiteralList) -> bool: ...

    def get_index(self) -> int: ...

class StateList:
    @overload
    def __init__(self) -> None:
        """Default constructor"""

    @overload
    def __init__(self, arg: StateList) -> None:
        """Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[State], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __repr__(self) -> str: ...

    def __iter__(self) -> Iterator[State]: ...

    @overload
    def __getitem__(self, arg: int, /) -> State: ...

    @overload
    def __getitem__(self, arg: slice, /) -> StateList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: State, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: State, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> State:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: StateList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: State, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: StateList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def __eq__(self, arg: object, /) -> bool: ...

    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: State, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: State, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: State, /) -> None:
        """Remove first occurrence of `arg`."""

class Plan:
    def __init__(self, search_context: SearchContext, states: StateList, actions: pymimir.advanced.formalism.GroundActionList, cost: float) -> None: ...

    def __str__(self) -> str: ...

    def __len__(self) -> int: ...

    def get_search_context(self) -> SearchContext: ...

    def get_states(self) -> StateList: ...

    def get_actions(self) -> pymimir.advanced.formalism.GroundActionList: ...

    def get_cost(self) -> float: ...

class PartiallyOrderedPlan:
    def __init__(self, total_ordered_plan: Plan) -> None: ...

    def __str__(self) -> str: ...

    def compute_totally_ordered_plan_with_maximal_makespan(self) -> tuple[Plan, list[int]]: ...

    def get_totally_ordered_plan(self) -> Plan: ...

    def get_graph(self) -> "mimir::PyImmutable<mimir::graphs::DynamicGraph<mimir::graphs::Vertex<std::__1::tuple<>>, mimir::graphs::Edge<std::__1::tuple<>>>>": ...

class ISatisficingBindingGeneratorEventHandler:
    pass

class DefaultSatisficingBindingGeneratorEventHandler(ISatisficingBindingGeneratorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DefaultSatisficingBindingGeneratorEventHandler: ...

class ConjunctiveConditionSatisficingBindingGenerator:
    def __init__(self, conjunctive_condition: pymimir.advanced.formalism.ConjunctiveCondition, problem: pymimir.advanced.formalism.Problem) -> None: ...

    def generate_ground_conjunctions(self, state: State, max_num_groundings: int) -> list[tuple[pymimir.advanced.formalism.ObjectList, tuple[pymimir.advanced.formalism.StaticGroundLiteralList, pymimir.advanced.formalism.FluentGroundLiteralList, pymimir.advanced.formalism.DerivedGroundLiteralList]]]: ...

class ActionSatisficingBindingGenerator:
    def __init__(self, action: pymimir.advanced.formalism.Action, problem: pymimir.advanced.formalism.Problem) -> None: ...

    def generate_ground_conjunctions(self, state: State, max_num_groundings: int) -> list[tuple[pymimir.advanced.formalism.ObjectList, tuple[pymimir.advanced.formalism.StaticGroundLiteralList, pymimir.advanced.formalism.FluentGroundLiteralList, pymimir.advanced.formalism.DerivedGroundLiteralList]]]: ...

class AxiomSatisficingBindingGenerator:
    def __init__(self, axiom: pymimir.advanced.formalism.Axiom, problem: pymimir.advanced.formalism.Problem) -> None: ...

    def generate_ground_conjunctions(self, state: State, max_num_groundings: int) -> list[tuple[pymimir.advanced.formalism.ObjectList, tuple[pymimir.advanced.formalism.StaticGroundLiteralList, pymimir.advanced.formalism.FluentGroundLiteralList, pymimir.advanced.formalism.DerivedGroundLiteralList]]]: ...

def is_applicable(action: pymimir.advanced.formalism.GroundAction, state: State) -> bool: ...

class IApplicableActionGenerator:
    def get_problem(self) -> pymimir.advanced.formalism.Problem: ...

    def generate_applicable_actions(self, state: State) -> pymimir.advanced.formalism.GroundActionList: ...

class IExhaustiveLiftedApplicableActionGeneratorEventHandler:
    pass

class DefaultExhaustiveLiftedApplicableActionGeneratorEventHandler(IExhaustiveLiftedApplicableActionGeneratorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DefaultExhaustiveLiftedApplicableActionGeneratorEventHandler: ...

class DebugExhaustiveLiftedApplicableActionGeneratorEventHandler(IExhaustiveLiftedApplicableActionGeneratorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DebugExhaustiveLiftedApplicableActionGeneratorEventHandler: ...

class ExhaustiveLiftedApplicableActionGenerator(IApplicableActionGenerator):
    @staticmethod
    def create(problem: pymimir.advanced.formalism.Problem, event_handler: Optional[IExhaustiveLiftedApplicableActionGeneratorEventHandler] = None, binding_event_handler: Optional[ISatisficingBindingGeneratorEventHandler] = None) -> ExhaustiveLiftedApplicableActionGenerator: ...

class IKPKCLiftedApplicableActionGeneratorEventHandler:
    pass

class DefaultKPKCLiftedApplicableActionGeneratorEventHandler(IKPKCLiftedApplicableActionGeneratorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DefaultKPKCLiftedApplicableActionGeneratorEventHandler: ...

class DebugKPKCLiftedApplicableActionGeneratorEventHandler(IKPKCLiftedApplicableActionGeneratorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DebugKPKCLiftedApplicableActionGeneratorEventHandler: ...

class KPKCLiftedApplicableActionGenerator(IApplicableActionGenerator):
    @staticmethod
    def create(problem: pymimir.advanced.formalism.Problem, options: LiftedKPKCOptions, event_handler: Optional[IKPKCLiftedApplicableActionGeneratorEventHandler] = None, binding_event_handler: Optional[ISatisficingBindingGeneratorEventHandler] = None) -> KPKCLiftedApplicableActionGenerator: ...

class IGroundedApplicableActionGeneratorEventHandler:
    pass

class DefaultGroundedApplicableActionGeneratorEventHandler(IGroundedApplicableActionGeneratorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DefaultGroundedApplicableActionGeneratorEventHandler: ...

class DebugGroundedApplicableActionGeneratorEventHandler(IGroundedApplicableActionGeneratorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DebugGroundedApplicableActionGeneratorEventHandler: ...

class GroundedApplicableActionGenerator(IApplicableActionGenerator):
    pass

class IAxiomEvaluator:
    def get_problem(self) -> pymimir.advanced.formalism.Problem: ...

class IExhaustiveLiftedAxiomEvaluatorEventHandler:
    pass

class DefaultExhaustiveLiftedAxiomEvaluatorEventHandler(IExhaustiveLiftedAxiomEvaluatorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DefaultExhaustiveLiftedAxiomEvaluatorEventHandler: ...

class DebugExhaustiveLiftedAxiomEvaluatorEventHandler(IExhaustiveLiftedAxiomEvaluatorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DebugExhaustiveLiftedAxiomEvaluatorEventHandler: ...

class ExhaustiveLiftedAxiomEvaluator(IAxiomEvaluator):
    @staticmethod
    def create(problem: pymimir.advanced.formalism.Problem, event_handler: Optional[IExhaustiveLiftedAxiomEvaluatorEventHandler] = None, binding_event_handler: Optional[ISatisficingBindingGeneratorEventHandler] = None) -> ExhaustiveLiftedAxiomEvaluator: ...

class IKPKCLiftedAxiomEvaluatorEventHandler:
    pass

class DefaultKPKCLiftedAxiomEvaluatorEventHandler(IKPKCLiftedAxiomEvaluatorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DefaultKPKCLiftedAxiomEvaluatorEventHandler: ...

class DebugKPKCLiftedAxiomEvaluatorEventHandler(IKPKCLiftedAxiomEvaluatorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DebugKPKCLiftedAxiomEvaluatorEventHandler: ...

class KPKCLiftedAxiomEvaluator(IAxiomEvaluator):
    @staticmethod
    def create(problem: pymimir.advanced.formalism.Problem, event_handler: Optional[IKPKCLiftedAxiomEvaluatorEventHandler] = None, binding_event_handler: Optional[ISatisficingBindingGeneratorEventHandler] = None) -> KPKCLiftedAxiomEvaluator: ...

class IGroundedAxiomEvaluatorEventHandler:
    pass

class DefaultGroundedAxiomEvaluatorEventHandler(IGroundedAxiomEvaluatorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DefaultGroundedAxiomEvaluatorEventHandler: ...

class DebugGroundedAxiomEvaluatorEventHandler(IGroundedAxiomEvaluatorEventHandler):
    @staticmethod
    def create(quiet: bool = True) -> DefaultGroundedAxiomEvaluatorEventHandler: ...

class GroundedAxiomEvaluator(IAxiomEvaluator):
    pass

def compute_state_metric_value(state: State) -> float: ...

class StateRepository:
    @staticmethod
    def create(axiom_evaluator: IAxiomEvaluator) -> StateRepository: ...

    def get_or_create_initial_state(self) -> tuple[State, float]: ...

    def get_or_create_state(self, fluent_atoms: pymimir.advanced.formalism.FluentGroundAtomList, numeric_variables: Sequence[float]) -> tuple[State, float]: ...

    def get_or_create_successor_state(self, state: State, action: pymimir.advanced.formalism.GroundAction, state_metric_value: float) -> tuple[State, float]: ...

    def get_state(self, packed_state: PackedState) -> State: ...

    def get_state_index(self, packed_state: PackedState) -> int: ...

    def get_state_count(self) -> int: ...

    def get_reached_fluent_ground_atoms_bitset(self) -> pymimir.advanced.common.FlatBitset: ...

    def get_reached_derived_ground_atoms_bitset(self) -> pymimir.advanced.common.FlatBitset: ...

class MatchTreeOptions:
    def __init__(self) -> None: ...

    @property
    def enable_dump_dot_file(self) -> bool: ...

    @enable_dump_dot_file.setter
    def enable_dump_dot_file(self, arg: bool, /) -> None: ...

    @property
    def output_dot_file(self) -> pathlib.Path: ...

    @output_dot_file.setter
    def output_dot_file(self, arg: str | os.PathLike, /) -> None: ...

    @property
    def max_num_nodes(self) -> int: ...

    @max_num_nodes.setter
    def max_num_nodes(self, arg: int, /) -> None: ...

    @property
    def split_strategy(self) -> MatchTreeSplitStrategy: ...

    @split_strategy.setter
    def split_strategy(self, arg: MatchTreeSplitStrategy, /) -> None: ...

    @property
    def split_metric(self) -> MatchTreeSplitMetric: ...

    @split_metric.setter
    def split_metric(self, arg: MatchTreeSplitMetric, /) -> None: ...

    @property
    def optimization_direction(self) -> MatchTreeOptimizationDirection: ...

    @optimization_direction.setter
    def optimization_direction(self, arg: MatchTreeOptimizationDirection, /) -> None: ...

class IGrounder:
    def create_ground_actions(self) -> pymimir.advanced.formalism.GroundActionList: ...

    def create_ground_axioms(self) -> pymimir.advanced.formalism.GroundAxiomList: ...

    def create_grounded_axiom_evaluator(self, match_tree_options: MatchTreeOptions, axiom_evaluator_event_handler: Optional[IGroundedAxiomEvaluatorEventHandler] = None) -> GroundedAxiomEvaluator: ...

    def create_grounded_applicable_action_generator(self, match_tree_options: MatchTreeOptions, axiom_evaluator_event_handler: Optional[IGroundedApplicableActionGeneratorEventHandler] = None) -> GroundedApplicableActionGenerator: ...

class LiftedGrounder(IGrounder):
    def __init__(self, problem: pymimir.advanced.formalism.Problem) -> None: ...

class PreferredActions:
    @property
    def data(self) -> set[pymimir.advanced.formalism.GroundAction]: ...

    @data.setter
    def data(self, arg: Set[pymimir.advanced.formalism.GroundAction], /) -> None: ...

class IHeuristic:
    def __init__(self) -> None: ...

    def compute_heuristic(self, state: State, goal: Optional[pymimir.advanced.formalism.GroundConjunctiveCondition] = None) -> float: ...

    def get_preferred_actions(self) -> PreferredActions: ...

class BlindHeuristic(IHeuristic):
    @staticmethod
    def create(problem: pymimir.advanced.formalism.Problem) -> BlindHeuristic: ...

class PerfectHeuristic(IHeuristic):
    @staticmethod
    def create(search_context: SearchContext) -> PerfectHeuristic: ...

class MaxHeuristic(IHeuristic):
    @staticmethod
    def create(delete_relaxed_problem_explorator: IGrounder) -> MaxHeuristic: ...

class AddHeuristic(IHeuristic):
    @staticmethod
    def create(delete_relaxed_problem_explorator: IGrounder) -> AddHeuristic: ...

class SetAddHeuristic(IHeuristic):
    @staticmethod
    def create(delete_relaxed_problem_explorator: IGrounder) -> SetAddHeuristic: ...

class FFHeuristic(IHeuristic):
    @staticmethod
    def create(delete_relaxed_problem_explorator: IGrounder) -> FFHeuristic: ...

class H2Heuristic(IHeuristic):
    @staticmethod
    def create(delete_relaxed_problem_explorator: IGrounder) -> H2Heuristic: ...

class SearchResult:
    def __init__(self) -> None: ...

    @property
    def status(self) -> SearchStatus: ...

    @status.setter
    def status(self, arg: SearchStatus, /) -> None: ...

    @property
    def plan(self) -> Optional[Plan]: ...

    @plan.setter
    def plan(self, arg: Plan, /) -> None: ...

    @property
    def goal_state(self) -> Optional[State]: ...

    @goal_state.setter
    def goal_state(self, arg: State, /) -> None: ...

class IGoalStrategy:
    def __init__(self) -> None: ...

    def test_static_goal(self) -> bool: ...

    def test_dynamic_goal(self, state: State) -> bool: ...

class ProblemGoalStrategy(IGoalStrategy):
    @staticmethod
    def create(problem: pymimir.advanced.formalism.Problem) -> ProblemGoalStrategy: ...

class IPruningStrategy:
    def __init__(self) -> None: ...

    def test_prune_initial_state(self, initial_state: State) -> bool: ...

    def test_prune_successor_state(self, state: State, successor_state: State, is_new_successor: bool) -> bool: ...

class NoPruningStrategy(IPruningStrategy):
    def __init__(self) -> None: ...

    @staticmethod
    def create() -> NoPruningStrategy: ...

class DuplicatePruningStrategy(IPruningStrategy):
    def __init__(self) -> None: ...

    @staticmethod
    def create() -> DuplicatePruningStrategy: ...

class ArityZeroNoveltyPruningStrategy(IPruningStrategy):
    def __init__(self, initial_state: State) -> None: ...

    @staticmethod
    def create(initial_state: State) -> IPruningStrategy: ...

class ArityKNoveltyPruningStrategy(IPruningStrategy):
    def __init__(self, arity: int, num_atoms: int) -> None: ...

    @staticmethod
    def create(arity: int, num_atoms: int) -> IPruningStrategy: ...

class IExplorationStrategy:
    def __init__(self) -> None: ...

    def on_generate_state(self, state: State, action: pymimir.advanced.formalism.GroundAction, succ_state: State) -> bool: ...

class AStarEagerStatistics:
    def __init__(self) -> None: ...

    def __str__(self) -> str: ...

    def get_num_generated(self) -> int: ...

    def get_num_expanded(self) -> int: ...

    def get_num_deadends(self) -> int: ...

    def get_num_pruned(self) -> int: ...

    def get_num_generated_until_f_value(self) -> dict[float, int]: ...

    def get_num_expanded_until_f_value(self) -> dict[float, int]: ...

    def get_num_deadends_until_f_value(self) -> dict[float, int]: ...

    def get_num_pruned_until_f_value(self) -> dict[float, int]: ...

    def get_search_time_ms(self) -> datetime.timedelta: ...

class IAStarEagerEventHandler:
    def __init__(self) -> None: ...

    def on_expand_state(self, arg: State, /) -> None: ...

    def on_expand_goal_state(self, arg: State, /) -> None: ...

    def on_generate_state(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_generate_state_relaxed(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_generate_state_not_relaxed(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_close_state(self, arg: State, /) -> None: ...

    def on_finish_f_layer(self, arg: float, /) -> None: ...

    def on_prune_state(self, arg: State, /) -> None: ...

    def on_start_search(self, arg0: State, arg1: float, arg2: float, /) -> None: ...

    def on_end_search(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, /) -> None: ...

    def on_solved(self, arg: Plan, /) -> None: ...

    def on_unsolvable(self) -> None: ...

    def on_exhausted(self) -> None: ...

    def get_statistics(self) -> AStarEagerStatistics: ...

class DefaultAStarEagerEventHandler(IAStarEagerEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class DebugAStarEagerEventHandler(IAStarEagerEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class AStarEagerOptions:
    def __init__(self) -> None: ...

    @property
    def start_state(self) -> Optional[State]: ...

    @start_state.setter
    def start_state(self, arg: State, /) -> None: ...

    @property
    def event_handler(self) -> IAStarEagerEventHandler: ...

    @event_handler.setter
    def event_handler(self, arg: IAStarEagerEventHandler, /) -> None: ...

    @property
    def goal_strategy(self) -> IGoalStrategy: ...

    @goal_strategy.setter
    def goal_strategy(self, arg: IGoalStrategy, /) -> None: ...

    @property
    def pruning_strategy(self) -> IPruningStrategy: ...

    @pruning_strategy.setter
    def pruning_strategy(self, arg: IPruningStrategy, /) -> None: ...

    @property
    def max_num_states(self) -> int: ...

    @max_num_states.setter
    def max_num_states(self, arg: int, /) -> None: ...

    @property
    def max_time_in_ms(self) -> int: ...

    @max_time_in_ms.setter
    def max_time_in_ms(self, arg: int, /) -> None: ...

def find_solution_astar_eager(search_context: SearchContext, heuristic: IHeuristic, options: AStarEagerOptions) -> SearchResult: ...

class AStarLazyStatistics:
    def __init__(self) -> None: ...

    def __str__(self) -> str: ...

    def get_num_generated(self) -> int: ...

    def get_num_expanded(self) -> int: ...

    def get_num_deadends(self) -> int: ...

    def get_num_pruned(self) -> int: ...

    def get_num_generated_until_f_value(self) -> dict[float, int]: ...

    def get_num_expanded_until_f_value(self) -> dict[float, int]: ...

    def get_num_deadends_until_f_value(self) -> dict[float, int]: ...

    def get_num_pruned_until_f_value(self) -> dict[float, int]: ...

    def get_search_time_ms(self) -> datetime.timedelta: ...

class IAStarLazyEventHandler:
    def __init__(self) -> None: ...

    def on_expand_state(self, arg: State, /) -> None: ...

    def on_expand_goal_state(self, arg: State, /) -> None: ...

    def on_generate_state(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_generate_state_relaxed(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_generate_state_not_relaxed(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_close_state(self, arg: State, /) -> None: ...

    def on_finish_f_layer(self, arg: float, /) -> None: ...

    def on_prune_state(self, arg: State, /) -> None: ...

    def on_start_search(self, arg0: State, arg1: float, arg2: float, /) -> None: ...

    def on_end_search(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, /) -> None: ...

    def on_solved(self, arg: Plan, /) -> None: ...

    def on_unsolvable(self) -> None: ...

    def on_exhausted(self) -> None: ...

    def get_statistics(self) -> AStarLazyStatistics: ...

class DefaultAStarLazyEventHandler(IAStarLazyEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class DebugAStarLazyEventHandler(IAStarLazyEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class AStarLazyOptions:
    def __init__(self) -> None: ...

    @property
    def start_state(self) -> Optional[State]: ...

    @start_state.setter
    def start_state(self, arg: State, /) -> None: ...

    @property
    def event_handler(self) -> IAStarLazyEventHandler: ...

    @event_handler.setter
    def event_handler(self, arg: IAStarLazyEventHandler, /) -> None: ...

    @property
    def goal_strategy(self) -> IGoalStrategy: ...

    @goal_strategy.setter
    def goal_strategy(self, arg: IGoalStrategy, /) -> None: ...

    @property
    def pruning_strategy(self) -> IPruningStrategy: ...

    @pruning_strategy.setter
    def pruning_strategy(self, arg: IPruningStrategy, /) -> None: ...

    @property
    def max_num_states(self) -> int: ...

    @max_num_states.setter
    def max_num_states(self, arg: int, /) -> None: ...

    @property
    def max_time_in_ms(self) -> int: ...

    @max_time_in_ms.setter
    def max_time_in_ms(self, arg: int, /) -> None: ...

    @property
    def openlist_weights(self) -> list[int]: ...

    @openlist_weights.setter
    def openlist_weights(self, arg: Sequence[int], /) -> None: ...

def find_solution_astar_lazy(search_context: SearchContext, heuristic: IHeuristic, options: AStarLazyOptions) -> SearchResult: ...

class BrFSStatistics:
    def __init__(self) -> None: ...

    def __str__(self) -> str: ...

    def get_num_generated(self) -> int: ...

    def get_num_expanded(self) -> int: ...

    def get_num_deadends(self) -> int: ...

    def get_num_pruned(self) -> int: ...

    def get_num_generated_until_g_value(self) -> list[int]: ...

    def get_num_expanded_until_g_value(self) -> list[int]: ...

    def get_num_deadends_until_g_value(self) -> list[int]: ...

    def get_num_pruned_until_g_value(self) -> list[int]: ...

    def get_search_time_ms(self) -> datetime.timedelta: ...

class IBrFSEventHandler:
    def __init__(self) -> None: ...

    def on_expand_state(self, arg: State, /) -> None: ...

    def on_expand_goal_state(self, arg: State, /) -> None: ...

    def on_generate_state(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_generate_state_in_search_tree(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_generate_state_not_in_search_tree(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_finish_g_layer(self, arg: int, /) -> None: ...

    def on_start_search(self, arg: State, /) -> None: ...

    def on_end_search(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, /) -> None: ...

    def on_solved(self, arg: Plan, /) -> None: ...

    def on_unsolvable(self) -> None: ...

    def on_exhausted(self) -> None: ...

    def get_statistics(self) -> BrFSStatistics: ...

class DefaultBrFSEventHandler(IBrFSEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class DebugBrFSEventHandler(IBrFSEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class BrFSOptions:
    def __init__(self) -> None: ...

    @property
    def start_state(self) -> Optional[State]: ...

    @start_state.setter
    def start_state(self, arg: State, /) -> None: ...

    @property
    def event_handler(self) -> IBrFSEventHandler: ...

    @event_handler.setter
    def event_handler(self, arg: IBrFSEventHandler, /) -> None: ...

    @property
    def goal_strategy(self) -> IGoalStrategy: ...

    @goal_strategy.setter
    def goal_strategy(self, arg: IGoalStrategy, /) -> None: ...

    @property
    def pruning_strategy(self) -> IPruningStrategy: ...

    @pruning_strategy.setter
    def pruning_strategy(self, arg: IPruningStrategy, /) -> None: ...

    @property
    def stop_if_goal(self) -> bool: ...

    @stop_if_goal.setter
    def stop_if_goal(self, arg: bool, /) -> None: ...

    @property
    def max_num_states(self) -> int: ...

    @max_num_states.setter
    def max_num_states(self, arg: int, /) -> None: ...

    @property
    def max_time_in_ms(self) -> int: ...

    @max_time_in_ms.setter
    def max_time_in_ms(self, arg: int, /) -> None: ...

def find_solution_brfs(search_context: SearchContext, options: BrFSOptions) -> SearchResult: ...

class GBFSEagerStatistics:
    def __init__(self) -> None: ...

    def __str__(self) -> str: ...

    def get_num_generated(self) -> int: ...

    def get_num_expanded(self) -> int: ...

    def get_num_deadends(self) -> int: ...

    def get_num_pruned(self) -> int: ...

    def get_search_time_ms(self) -> datetime.timedelta: ...

class IGBFSEagerEventHandler:
    def __init__(self) -> None: ...

    def on_expand_state(self, arg: State, /) -> None: ...

    def on_expand_goal_state(self, arg: State, /) -> None: ...

    def on_generate_state(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_prune_state(self, arg: State, /) -> None: ...

    def on_start_search(self, arg0: State, arg1: float, arg2: float, /) -> None: ...

    def on_new_best_h_value(self, arg: float, /) -> None: ...

    def on_end_search(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, /) -> None: ...

    def on_solved(self, arg: Plan, /) -> None: ...

    def on_unsolvable(self) -> None: ...

    def on_exhausted(self) -> None: ...

    def get_statistics(self) -> GBFSEagerStatistics: ...

class DefaultGBFSEagerEventHandler(IGBFSEagerEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class DebugGBFSEagerEventHandler(IGBFSEagerEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class GBFSEagerOptions:
    def __init__(self) -> None: ...

    @property
    def start_state(self) -> Optional[State]: ...

    @start_state.setter
    def start_state(self, arg: State, /) -> None: ...

    @property
    def event_handler(self) -> IGBFSEagerEventHandler: ...

    @event_handler.setter
    def event_handler(self, arg: IGBFSEagerEventHandler, /) -> None: ...

    @property
    def goal_strategy(self) -> IGoalStrategy: ...

    @goal_strategy.setter
    def goal_strategy(self, arg: IGoalStrategy, /) -> None: ...

    @property
    def pruning_strategy(self) -> IPruningStrategy: ...

    @pruning_strategy.setter
    def pruning_strategy(self, arg: IPruningStrategy, /) -> None: ...

    @property
    def max_num_states(self) -> int: ...

    @max_num_states.setter
    def max_num_states(self, arg: int, /) -> None: ...

    @property
    def max_time_in_ms(self) -> int: ...

    @max_time_in_ms.setter
    def max_time_in_ms(self, arg: int, /) -> None: ...

def find_solution_gbfs_eager(search_context: SearchContext, heuristic: IHeuristic, options: GBFSEagerOptions) -> SearchResult: ...

class GBFSLazyStatistics:
    def __init__(self) -> None: ...

    def __str__(self) -> str: ...

    def get_num_generated(self) -> int: ...

    def get_num_expanded(self) -> int: ...

    def get_num_deadends(self) -> int: ...

    def get_num_pruned(self) -> int: ...

    def get_search_time_ms(self) -> datetime.timedelta: ...

class IGBFSLazyEventHandler:
    def __init__(self) -> None: ...

    def on_expand_state(self, arg: State, /) -> None: ...

    def on_expand_goal_state(self, arg: State, /) -> None: ...

    def on_generate_state(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_prune_state(self, arg: State, /) -> None: ...

    def on_start_search(self, arg0: State, arg1: float, arg2: float, /) -> None: ...

    def on_new_best_h_value(self, arg: float, /) -> None: ...

    def on_end_search(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, /) -> None: ...

    def on_solved(self, arg: Plan, /) -> None: ...

    def on_unsolvable(self) -> None: ...

    def on_exhausted(self) -> None: ...

    def get_statistics(self) -> GBFSLazyStatistics: ...

class DefaultGBFSLazyEventHandler(IGBFSLazyEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class DebugGBFSLazyEventHandler(IGBFSLazyEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class GBFSLazyOptions:
    def __init__(self) -> None: ...

    @property
    def start_state(self) -> Optional[State]: ...

    @start_state.setter
    def start_state(self, arg: State, /) -> None: ...

    @property
    def event_handler(self) -> IGBFSLazyEventHandler: ...

    @event_handler.setter
    def event_handler(self, arg: IGBFSLazyEventHandler, /) -> None: ...

    @property
    def goal_strategy(self) -> IGoalStrategy: ...

    @goal_strategy.setter
    def goal_strategy(self, arg: IGoalStrategy, /) -> None: ...

    @property
    def pruning_strategy(self) -> IPruningStrategy: ...

    @pruning_strategy.setter
    def pruning_strategy(self, arg: IPruningStrategy, /) -> None: ...

    @property
    def exploration_strategy(self) -> IExplorationStrategy: ...

    @exploration_strategy.setter
    def exploration_strategy(self, arg: IExplorationStrategy, /) -> None: ...

    @property
    def max_num_states(self) -> int: ...

    @max_num_states.setter
    def max_num_states(self, arg: int, /) -> None: ...

    @property
    def max_time_in_ms(self) -> int: ...

    @max_time_in_ms.setter
    def max_time_in_ms(self, arg: int, /) -> None: ...

    @property
    def openlist_weights(self) -> list[int]: ...

    @openlist_weights.setter
    def openlist_weights(self, arg: Sequence[int], /) -> None: ...

def find_solution_gbfs_lazy(search_context: SearchContext, heuristic: IHeuristic, options: GBFSLazyOptions) -> SearchResult: ...

class TupleIndexMapper:
    def __init__(self, arity: int, num_atoms: int) -> None: ...

    def to_tuple_index(self, atom_indices: Sequence[int]) -> int: ...

    def to_atom_indices(self, tuple_index: int) -> list[int]: ...

    def initialize(self, arity: int, num_atoms: int) -> None: ...

    def tuple_index_to_string(self, tuple_index: int) -> str: ...

    def get_num_atoms(self) -> int: ...

    def get_arity(self) -> int: ...

    def get_factors(self) -> list[int]: ...

    def get_max_tuple_index(self) -> int: ...

    def get_empty_tuple_index(self) -> int: ...

class DynamicNoveltyTable:
    @overload
    def __init__(self, arity: int) -> None: ...

    @overload
    def __init__(self, arity: int, num_atoms: int) -> None: ...

    def compute_novel_tuples(self, state: State) -> list[list[int]]: ...

    def insert_tuples(self, tuples: Sequence[Sequence[int]]) -> None: ...

    @overload
    def test_novelty_and_update_table(self, state: State) -> bool: ...

    @overload
    def test_novelty_and_update_table(self, state: State, succ_state: State) -> bool: ...

    def reset(self) -> None: ...

    def get_tuple_index_mapper(self) -> TupleIndexMapper: ...

class StateTupleIndexGenerator:
    def __init__(self, tuple_index_mapper: TupleIndexMapper) -> None: ...

    def __iter__(self, arg: State, /) -> Iterator[int]: ...

class StatePairTupleIndexGenerator:
    def __init__(self, tuple_index_mapper: TupleIndexMapper) -> None: ...

    def __iter__(self, arg0: State, arg1: State, /) -> Iterator[int]: ...

class IWStatistics:
    def __init__(self) -> None: ...

    def __str__(self) -> str: ...

    def get_effective_width(self) -> int: ...

    def get_brfs_statistics_by_arity(self) -> list[BrFSStatistics]: ...

    def get_search_time_ms(self) -> datetime.timedelta: ...

class IIWEventHandler:
    def get_statistics(self) -> IWStatistics: ...

class DefaultIWEventHandler(IIWEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class IWOptions:
    def __init__(self) -> None: ...

    @property
    def start_state(self) -> Optional[State]: ...

    @start_state.setter
    def start_state(self, arg: State, /) -> None: ...

    @property
    def iw_event_handler(self) -> IIWEventHandler: ...

    @iw_event_handler.setter
    def iw_event_handler(self, arg: IIWEventHandler, /) -> None: ...

    @property
    def brfs_event_handler(self) -> IBrFSEventHandler: ...

    @brfs_event_handler.setter
    def brfs_event_handler(self, arg: IBrFSEventHandler, /) -> None: ...

    @property
    def goal_strategy(self) -> IGoalStrategy: ...

    @goal_strategy.setter
    def goal_strategy(self, arg: IGoalStrategy, /) -> None: ...

    @property
    def max_arity(self) -> int: ...

    @max_arity.setter
    def max_arity(self, arg: int, /) -> None: ...

def find_solution_iw(search_context: SearchContext, options: IWOptions) -> SearchResult: ...

class SIWStatistics:
    def __init__(self) -> None: ...

    def __str__(self) -> str: ...

    def get_maximum_effective_width(self) -> int: ...

    def get_average_effective_width(self) -> float: ...

    def get_iw_statistics_by_subproblem(self) -> list[IWStatistics]: ...

    def get_search_time_ms(self) -> datetime.timedelta: ...

class ISIWEventHandler:
    def get_statistics(self) -> SIWStatistics: ...

class DefaultSIWEventHandler(ISIWEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class SIWOptions:
    def __init__(self) -> None: ...

    @property
    def start_state(self) -> Optional[State]: ...

    @start_state.setter
    def start_state(self, arg: State, /) -> None: ...

    @property
    def siw_event_handler(self) -> ISIWEventHandler: ...

    @siw_event_handler.setter
    def siw_event_handler(self, arg: ISIWEventHandler, /) -> None: ...

    @property
    def iw_event_handler(self) -> IIWEventHandler: ...

    @iw_event_handler.setter
    def iw_event_handler(self, arg: IIWEventHandler, /) -> None: ...

    @property
    def brfs_event_handler(self) -> IBrFSEventHandler: ...

    @brfs_event_handler.setter
    def brfs_event_handler(self, arg: IBrFSEventHandler, /) -> None: ...

    @property
    def goal_strategy(self) -> IGoalStrategy: ...

    @goal_strategy.setter
    def goal_strategy(self, arg: IGoalStrategy, /) -> None: ...

    @property
    def max_arity(self) -> int: ...

    @max_arity.setter
    def max_arity(self, arg: int, /) -> None: ...

def find_solution_siw(search_context: SearchContext, options: SIWOptions) -> SearchResult: ...
