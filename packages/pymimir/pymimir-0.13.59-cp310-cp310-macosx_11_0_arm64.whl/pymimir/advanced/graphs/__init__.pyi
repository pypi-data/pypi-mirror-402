from collections.abc import Iterator, Mapping, Sequence
from typing import overload


class PyVertex:
    def get_index(self) -> int: ...

    def get_properties(self) -> PropertyValue: ...

class PyEdge:
    def get_index(self) -> int: ...

    def get_source(self) -> int: ...

    def get_target(self) -> int: ...

    def get_properties(self) -> PropertyValue: ...

class StaticPyGraph:
    def __init__(self) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> tuple[StaticPyGraph, list[int], list[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> tuple[StaticPyGraph, list[int], list[tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def clear(self) -> None: ...

    @overload
    def add_vertex(self, arg: PropertyValue, /) -> int: ...

    @overload
    def add_vertex(self, arg: PyVertex, /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: PropertyValue, /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: PyEdge, /) -> int: ...

    def add_undirected_edge(self, arg0: int, arg1: int, arg2: PropertyValue, /) -> tuple[int, int]: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[PyVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[PyVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[PyEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[PyEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[PyVertex]: ...

    def get_vertex(self, vertex_index: int) -> PyVertex: ...

    def get_edges(self) -> list[PyEdge]: ...

    def get_edge(self, edge_index: int) -> PyEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> tuple[list[int], list[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> tuple[list[int], list[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> list[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> tuple[list[int], list[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> tuple[list[int], list[float]]: ...

    def compute_strong_components(self) -> tuple[int, list[int]]: ...

@overload
def compute_color_refinement_certificate(vertex_colored_graph: StaticPyGraph) -> CertificateColorRefinement: ...

@overload
def compute_color_refinement_certificate(arg: ImmutableStaticPyGraph, /) -> CertificateColorRefinement: ...

@overload
def compute_color_refinement_certificate(vertex_colored_graph: ForwardStaticPyGraph) -> CertificateColorRefinement: ...

@overload
def compute_color_refinement_certificate(vertex_colored_graph: BidirectionalStaticPyGraph) -> CertificateColorRefinement: ...

@overload
def compute_2fwl_certificate(vertex_colored_graph: StaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate2FWL: ...

@overload
def compute_2fwl_certificate(vertex_colored_graph: ImmutableStaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate2FWL: ...

@overload
def compute_2fwl_certificate(vertex_colored_graph: ForwardStaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate2FWL: ...

@overload
def compute_2fwl_certificate(vertex_colored_graph: BidirectionalStaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate2FWL: ...

@overload
def compute_3fwl_certificate(vertex_colored_graph: StaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate3FWL: ...

@overload
def compute_3fwl_certificate(vertex_colored_graph: ImmutableStaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate3FWL: ...

@overload
def compute_3fwl_certificate(vertex_colored_graph: ForwardStaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate3FWL: ...

@overload
def compute_3fwl_certificate(vertex_colored_graph: BidirectionalStaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate3FWL: ...

@overload
def compute_4fwl_certificate(vertex_colored_graph: StaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate4FWL: ...

@overload
def compute_4fwl_certificate(vertex_colored_graph: ImmutableStaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate4FWL: ...

@overload
def compute_4fwl_certificate(vertex_colored_graph: ForwardStaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate4FWL: ...

@overload
def compute_4fwl_certificate(vertex_colored_graph: BidirectionalStaticPyGraph, isomorphism_type_compression_function: KFWLIsomorphismTypeCompressionFunction) -> Certficate4FWL: ...

@overload
def is_undirected(arg: StaticPyGraph, /) -> bool: ...

@overload
def is_undirected(arg: ImmutableStaticPyGraph, /) -> bool: ...

@overload
def is_undirected(arg: ForwardStaticPyGraph, /) -> bool: ...

@overload
def is_undirected(arg: BidirectionalStaticPyGraph, /) -> bool: ...

@overload
def is_undirected(arg: DynamicPyGraph, /) -> bool: ...

@overload
def is_multi(arg: StaticPyGraph, /) -> bool: ...

@overload
def is_multi(arg: ImmutableStaticPyGraph, /) -> bool: ...

@overload
def is_multi(arg: ForwardStaticPyGraph, /) -> bool: ...

@overload
def is_multi(arg: BidirectionalStaticPyGraph, /) -> bool: ...

@overload
def is_multi(arg: DynamicPyGraph, /) -> bool: ...

@overload
def is_loopless(arg: StaticPyGraph, /) -> bool: ...

@overload
def is_loopless(arg: ImmutableStaticPyGraph, /) -> bool: ...

@overload
def is_loopless(arg: ForwardStaticPyGraph, /) -> bool: ...

@overload
def is_loopless(arg: BidirectionalStaticPyGraph, /) -> bool: ...

@overload
def is_loopless(arg: DynamicPyGraph, /) -> bool: ...

@overload
def is_acyclic(arg: StaticPyGraph, /) -> bool: ...

@overload
def is_acyclic(arg: ImmutableStaticPyGraph, /) -> bool: ...

@overload
def is_acyclic(arg: ForwardStaticPyGraph, /) -> bool: ...

@overload
def is_acyclic(arg: BidirectionalStaticPyGraph, /) -> bool: ...

@overload
def is_acyclic(arg: DynamicPyGraph, /) -> bool: ...

class ImmutableStaticPyGraph:
    def __init__(self, arg: StaticPyGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> tuple[StaticPyGraph, list[int], list[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> tuple[StaticPyGraph, list[int], list[tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[PyVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[PyVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[PyEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[PyEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[PyVertex]: ...

    def get_vertex(self, vertex_index: int) -> PyVertex: ...

    def get_edges(self) -> list[PyEdge]: ...

    def get_edge(self, edge_index: int) -> PyEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> tuple[list[int], list[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> tuple[list[int], list[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> list[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> tuple[list[int], list[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> tuple[list[int], list[float]]: ...

    def compute_strong_components(self) -> tuple[int, list[int]]: ...

class ForwardStaticPyGraph:
    @overload
    def __init__(self, arg: StaticPyGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticPyGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> tuple[ForwardStaticPyGraph, list[int], list[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> tuple[ForwardStaticPyGraph, list[int], list[tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[PyVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[PyVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[PyEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[PyEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[PyVertex]: ...

    def get_vertex(self, vertex_index: int) -> PyVertex: ...

    def get_edges(self) -> list[PyEdge]: ...

    def get_edge(self, edge_index: int) -> PyEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> tuple[list[int], list[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> tuple[list[int], list[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> list[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> tuple[list[int], list[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> tuple[list[int], list[float]]: ...

    def compute_strong_components(self) -> tuple[int, list[int]]: ...

class BidirectionalStaticPyGraph:
    @overload
    def __init__(self, arg: StaticPyGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticPyGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> tuple[BidirectionalStaticPyGraph, list[int], list[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> tuple[BidirectionalStaticPyGraph, list[int], list[tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[PyVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[PyVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[PyEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[PyEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[PyVertex]: ...

    def get_vertex(self, vertex_index: int) -> PyVertex: ...

    def get_edges(self) -> list[PyEdge]: ...

    def get_edge(self, edge_index: int) -> PyEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> tuple[list[int], list[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> tuple[list[int], list[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> list[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> tuple[list[int], list[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> tuple[list[int], list[float]]: ...

    def compute_strong_components(self) -> tuple[int, list[int]]: ...

class DynamicPyGraph:
    def __init__(self) -> None: ...

    def __str__(self) -> str: ...

    def clear(self) -> None: ...

    @overload
    def add_vertex(self, arg: PropertyValue, /) -> int: ...

    @overload
    def add_vertex(self, arg: PyVertex, /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: PropertyValue, /) -> None: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: PyEdge, /) -> int: ...

    def add_undirected_edge(self, arg0: int, arg1: int, arg2: PropertyValue, /) -> None: ...

    def remove_vertex(self, vertex_index: int) -> None: ...

    def remove_edge(self, remove_edge: int) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> tuple[DynamicPyGraph, dict[int, int], dict[int, int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> tuple[DynamicPyGraph, dict[int, int], dict[int, tuple[int, int]]]: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[PyVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[PyVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[PyEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[PyEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> dict[int, PyVertex]: ...

    def get_vertex(self, vertex_index: int) -> PyVertex: ...

    def get_edges(self) -> dict[int, PyEdge]: ...

    def get_edge(self, edge_index: int) -> PyEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> dict[int, int]: ...

    def get_backward_degrees(self) -> dict[int, int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Mapping[int, float]) -> dict[int, dict[int, float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Mapping[int, float]) -> dict[int, dict[int, float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> tuple[dict[int, int], dict[int, int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> tuple[dict[int, int], dict[int, int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> dict[int, int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> dict[int, int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Mapping[int, float], source_vertex_indices: Sequence[int]) -> tuple[dict[int, int], dict[int, float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Mapping[int, float], source_vertex_indices: Sequence[int]) -> tuple[dict[int, int], dict[int, float]]: ...

    def compute_strong_components(self) -> tuple[int, dict[int, int]]: ...

class CertificateColorRefinement:
    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __eq__(self, arg: CertificateColorRefinement, /) -> bool: ...

    def __ne__(self, arg: CertificateColorRefinement, /) -> bool: ...

    def __hash__(self) -> int: ...

    def get_canonical_color_compression_function(self) -> dict[PropertyValue, int]: ...

    def get_canonical_configuration_compression_function(self) -> dict: ...

    def get_hash_to_color(self) -> list[int]: ...

class KFWLIsomorphismTypeCompressionFunction:
    def __init__(self) -> None: ...

class Certficate2FWL:
    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __eq__(self, arg: Certficate2FWL, /) -> bool: ...

    def __ne__(self, arg: Certficate2FWL, /) -> bool: ...

    def __hash__(self) -> int: ...

    def get_canonical_color_compression_function(self) -> dict[PropertyValue, int]: ...

    def get_canonical_configuration_compression_function(self) -> dict: ...

    def get_hash_to_color(self) -> list[int]: ...

class Certficate3FWL:
    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __eq__(self, arg: Certficate3FWL, /) -> bool: ...

    def __ne__(self, arg: Certficate3FWL, /) -> bool: ...

    def __hash__(self) -> int: ...

    def get_canonical_color_compression_function(self) -> dict[PropertyValue, int]: ...

    def get_canonical_configuration_compression_function(self) -> dict: ...

    def get_hash_to_color(self) -> list[int]: ...

class Certficate4FWL:
    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __eq__(self, arg: Certficate4FWL, /) -> bool: ...

    def __ne__(self, arg: Certficate4FWL, /) -> bool: ...

    def __hash__(self) -> int: ...

    def get_canonical_color_compression_function(self) -> dict[PropertyValue, int]: ...

    def get_canonical_configuration_compression_function(self) -> dict: ...

    def get_hash_to_color(self) -> list[int]: ...

class IProperty:
    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __hash__(self) -> int: ...

    def __eq__(self, arg: IProperty, /) -> bool: ...

    def __lt__(self, arg: IProperty, /) -> bool: ...

class PyProperty(IProperty):
    def __init__(self, obj: object) -> None:
        """Wrap any Python object as a runtime property"""

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __hash__(self) -> int: ...

    def __eq__(self, arg: IProperty, /) -> bool: ...

    def __lt__(self, arg: IProperty, /) -> bool: ...

class PropertyValue:
    def __init__(self, impl: IProperty) -> None: ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __hash__(self) -> int: ...

    def __eq__(self, arg: PropertyValue, /) -> bool: ...

    def __lt__(self, arg: PropertyValue, /) -> bool: ...

class NautySparseGraph:
    @overload
    def __init__(self, arg: StaticPyGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ForwardStaticPyGraph, /) -> None: ...

    @overload
    def __init__(self, arg: BidirectionalStaticPyGraph, /) -> None: ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __eq__(self, arg: NautySparseGraph, /) -> bool: ...

    def __ne__(self, arg: NautySparseGraph, /) -> bool: ...

    def __hash__(self) -> int: ...

    def canonize(self) -> NautySparseGraph: ...
