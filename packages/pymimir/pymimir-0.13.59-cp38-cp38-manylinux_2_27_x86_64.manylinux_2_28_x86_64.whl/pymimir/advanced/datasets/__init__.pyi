from typing import (
    Iterator,
    List,
    Optional,
    Sequence,
    Set,
    Tuple,
    overload
)

import pymimir.advanced.formalism
import pymimir.advanced.search


class ProblemVertex:
    def get_index(self) -> int: ...

    def get_properties(self) -> Tuple[pymimir.advanced.search.PackedState, pymimir.advanced.search.StateRepository, int, float, bool, bool, bool, bool]: ...

def get_state(vertex: ProblemVertex) -> pymimir.advanced.search.State: ...

def get_state_repository(vertex: ProblemVertex) -> pymimir.advanced.search.StateRepository: ...

@overload
def get_problem(vertex: ProblemVertex) -> pymimir.advanced.formalism.Problem: ...

@overload
def get_problem(edge: ProblemEdge) -> pymimir.advanced.formalism.Problem: ...

def get_unit_goal_distance(vertex: ProblemVertex) -> int: ...

def get_action_goal_distance(vertex: ProblemVertex) -> float: ...

def is_initial(vertex: ProblemVertex) -> bool: ...

def is_goal(vertex: ProblemVertex) -> bool: ...

def is_unsolvable(vertex: ProblemVertex) -> bool: ...

def is_alive(vertex: ProblemVertex) -> bool: ...

class ProblemEdge:
    def get_index(self) -> int: ...

    def get_source(self) -> int: ...

    def get_target(self) -> int: ...

    def get_properties(self) -> Tuple[pymimir.advanced.formalism.GroundAction, pymimir.advanced.formalism.Problem, float]: ...

def get_action(edge: ProblemEdge) -> pymimir.advanced.formalism.GroundAction: ...

def get_action_cost(edge: ProblemEdge) -> float: ...

class StaticProblemGraph:
    def __init__(self) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[StaticProblemGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[StaticProblemGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def clear(self) -> None: ...

    @overload
    def add_vertex(self, arg: Tuple[pymimir.advanced.search.PackedState, pymimir.advanced.search.StateRepository, int, float, bool, bool, bool, bool], /) -> int: ...

    @overload
    def add_vertex(self, arg: ProblemVertex, /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: Tuple[pymimir.advanced.formalism.GroundAction, pymimir.advanced.formalism.Problem, float], /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: ProblemEdge, /) -> int: ...

    def add_undirected_edge(self, arg0: int, arg1: int, arg2: Tuple[pymimir.advanced.formalism.GroundAction, pymimir.advanced.formalism.Problem, float], /) -> Tuple[int, int]: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> List[ProblemEdge]: ...

    def get_edge(self, edge_index: int) -> ProblemEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

@overload
def is_undirected(arg: StaticProblemGraph, /) -> bool: ...

@overload
def is_undirected(arg: ImmutableStaticProblemGraph, /) -> bool: ...

@overload
def is_undirected(arg: ForwardStaticProblemGraph, /) -> bool: ...

@overload
def is_undirected(arg: BidirectionalStaticProblemGraph, /) -> bool: ...

@overload
def is_undirected(arg: StaticClassGraph, /) -> bool: ...

@overload
def is_undirected(arg: ImmutableStaticClassGraph, /) -> bool: ...

@overload
def is_undirected(arg: ForwardStaticClassGraph, /) -> bool: ...

@overload
def is_undirected(arg: BidirectionalStaticClassGraph, /) -> bool: ...

@overload
def is_undirected(arg: StaticTupleGraph, /) -> bool: ...

@overload
def is_undirected(arg: ImmutableStaticTupleGraph, /) -> bool: ...

@overload
def is_undirected(arg: ForwardStaticTupleGraph, /) -> bool: ...

@overload
def is_undirected(arg: BidirectionalStaticTupleGraph, /) -> bool: ...

@overload
def is_multi(arg: StaticProblemGraph, /) -> bool: ...

@overload
def is_multi(arg: ImmutableStaticProblemGraph, /) -> bool: ...

@overload
def is_multi(arg: ForwardStaticProblemGraph, /) -> bool: ...

@overload
def is_multi(arg: BidirectionalStaticProblemGraph, /) -> bool: ...

@overload
def is_multi(arg: StaticClassGraph, /) -> bool: ...

@overload
def is_multi(arg: ImmutableStaticClassGraph, /) -> bool: ...

@overload
def is_multi(arg: ForwardStaticClassGraph, /) -> bool: ...

@overload
def is_multi(arg: BidirectionalStaticClassGraph, /) -> bool: ...

@overload
def is_multi(arg: StaticTupleGraph, /) -> bool: ...

@overload
def is_multi(arg: ImmutableStaticTupleGraph, /) -> bool: ...

@overload
def is_multi(arg: ForwardStaticTupleGraph, /) -> bool: ...

@overload
def is_multi(arg: BidirectionalStaticTupleGraph, /) -> bool: ...

@overload
def is_loopless(arg: StaticProblemGraph, /) -> bool: ...

@overload
def is_loopless(arg: ImmutableStaticProblemGraph, /) -> bool: ...

@overload
def is_loopless(arg: ForwardStaticProblemGraph, /) -> bool: ...

@overload
def is_loopless(arg: BidirectionalStaticProblemGraph, /) -> bool: ...

@overload
def is_loopless(arg: StaticClassGraph, /) -> bool: ...

@overload
def is_loopless(arg: ImmutableStaticClassGraph, /) -> bool: ...

@overload
def is_loopless(arg: ForwardStaticClassGraph, /) -> bool: ...

@overload
def is_loopless(arg: BidirectionalStaticClassGraph, /) -> bool: ...

@overload
def is_loopless(arg: StaticTupleGraph, /) -> bool: ...

@overload
def is_loopless(arg: ImmutableStaticTupleGraph, /) -> bool: ...

@overload
def is_loopless(arg: ForwardStaticTupleGraph, /) -> bool: ...

@overload
def is_loopless(arg: BidirectionalStaticTupleGraph, /) -> bool: ...

@overload
def is_acyclic(arg: StaticProblemGraph, /) -> bool: ...

@overload
def is_acyclic(arg: ImmutableStaticProblemGraph, /) -> bool: ...

@overload
def is_acyclic(arg: ForwardStaticProblemGraph, /) -> bool: ...

@overload
def is_acyclic(arg: BidirectionalStaticProblemGraph, /) -> bool: ...

@overload
def is_acyclic(arg: StaticClassGraph, /) -> bool: ...

@overload
def is_acyclic(arg: ImmutableStaticClassGraph, /) -> bool: ...

@overload
def is_acyclic(arg: ForwardStaticClassGraph, /) -> bool: ...

@overload
def is_acyclic(arg: BidirectionalStaticClassGraph, /) -> bool: ...

@overload
def is_acyclic(arg: StaticTupleGraph, /) -> bool: ...

@overload
def is_acyclic(arg: ImmutableStaticTupleGraph, /) -> bool: ...

@overload
def is_acyclic(arg: ForwardStaticTupleGraph, /) -> bool: ...

@overload
def is_acyclic(arg: BidirectionalStaticTupleGraph, /) -> bool: ...

class ImmutableStaticProblemGraph:
    def __init__(self, arg: StaticProblemGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[StaticProblemGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[StaticProblemGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> List[ProblemEdge]: ...

    def get_edge(self, edge_index: int) -> ProblemEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

class ForwardStaticProblemGraph:
    @overload
    def __init__(self, arg: StaticProblemGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticProblemGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[ForwardStaticProblemGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[ForwardStaticProblemGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> List[ProblemEdge]: ...

    def get_edge(self, edge_index: int) -> ProblemEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

class BidirectionalStaticProblemGraph:
    @overload
    def __init__(self, arg: StaticProblemGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticProblemGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[BidirectionalStaticProblemGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[BidirectionalStaticProblemGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> List[ProblemEdge]: ...

    def get_edge(self, edge_index: int) -> ProblemEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

class ClassVertex:
    def get_index(self) -> int: ...

    def get_properties(self) -> Tuple[int, int]: ...

def get_problem_vertex_index(vertex: ClassVertex) -> int: ...

@overload
def get_problem_index(vertex: ClassVertex) -> int: ...

@overload
def get_problem_index(vertex: ClassEdge) -> int: ...

class ClassEdge:
    def get_index(self) -> int: ...

    def get_source(self) -> int: ...

    def get_target(self) -> int: ...

    def get_properties(self) -> Tuple[int, int]: ...

def get_problem_edge_index(vertex: ClassEdge) -> int: ...

class StaticClassGraph:
    def __init__(self) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[StaticClassGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[StaticClassGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def clear(self) -> None: ...

    @overload
    def add_vertex(self, arg: Tuple[int, int], /) -> int: ...

    @overload
    def add_vertex(self, arg: ClassVertex, /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: Tuple[int, int], /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: ClassEdge, /) -> int: ...

    def add_undirected_edge(self, arg0: int, arg1: int, arg2: Tuple[int, int], /) -> Tuple[int, int]: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> List[ClassEdge]: ...

    def get_edge(self, edge_index: int) -> ClassEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

class ImmutableStaticClassGraph:
    def __init__(self, arg: StaticClassGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[StaticClassGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[StaticClassGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> List[ClassEdge]: ...

    def get_edge(self, edge_index: int) -> ClassEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

class ForwardStaticClassGraph:
    @overload
    def __init__(self, arg: StaticClassGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticClassGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[ForwardStaticClassGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[ForwardStaticClassGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> List[ClassEdge]: ...

    def get_edge(self, edge_index: int) -> ClassEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

class BidirectionalStaticClassGraph:
    @overload
    def __init__(self, arg: StaticClassGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticClassGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[BidirectionalStaticClassGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[BidirectionalStaticClassGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> List[ClassEdge]: ...

    def get_edge(self, edge_index: int) -> ClassEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

class TupleGraphVertex:
    def get_index(self) -> int: ...

    def get_properties(self) -> Tuple[List[int], List[int]]: ...

def get_atom_tuple(vertex: TupleGraphVertex) -> List[int]: ...

def get_problem_vertices(vertex: TupleGraphVertex) -> List[int]: ...

class StaticTupleGraph:
    def __init__(self) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[StaticTupleGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[StaticTupleGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def clear(self) -> None: ...

    @overload
    def add_vertex(self, arg: Tuple[Sequence[int], Sequence[int]], /) -> int: ...

    @overload
    def add_vertex(self, arg: TupleGraphVertex, /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: Tuple[()], /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: "mimir::graphs::Edge<std::tuple<> >", /) -> int: ...

    def add_undirected_edge(self, arg0: int, arg1: int, arg2: Tuple[()], /) -> Tuple[int, int]: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[TupleGraphVertex]: ...

    def get_vertex(self, vertex_index: int) -> TupleGraphVertex: ...

    def get_edges(self) -> List["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_edge(self, edge_index: int) -> "mimir::graphs::Edge<std::tuple<> >": ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

class ImmutableStaticTupleGraph:
    def __init__(self, arg: StaticTupleGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[StaticTupleGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[StaticTupleGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[TupleGraphVertex]: ...

    def get_vertex(self, vertex_index: int) -> TupleGraphVertex: ...

    def get_edges(self) -> List["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_edge(self, edge_index: int) -> "mimir::graphs::Edge<std::tuple<> >": ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

class ForwardStaticTupleGraph:
    @overload
    def __init__(self, arg: StaticTupleGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticTupleGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[ForwardStaticTupleGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[ForwardStaticTupleGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[TupleGraphVertex]: ...

    def get_vertex(self, vertex_index: int) -> TupleGraphVertex: ...

    def get_edges(self) -> List["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_edge(self, edge_index: int) -> "mimir::graphs::Edge<std::tuple<> >": ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

class BidirectionalStaticTupleGraph:
    @overload
    def __init__(self, arg: StaticTupleGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticTupleGraph, /) -> None: ...

    def create_induced_subgraph(self, arg: Sequence[int], /) -> Tuple[BidirectionalStaticTupleGraph, List[int], List[int]]:
        """vertex_indices"""

    def create_undirected_graph(self) -> Tuple[BidirectionalStaticTupleGraph, List[int], List[Tuple[int, int]]]: ...

    def __str__(self) -> str: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> List[TupleGraphVertex]: ...

    def get_vertex(self, vertex_index: int) -> TupleGraphVertex: ...

    def get_edges(self) -> List["mimir::graphs::Edge<std::tuple<> >"]: ...

    def get_edge(self, edge_index: int) -> "mimir::graphs::Edge<std::tuple<> >": ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> List[int]: ...

    def get_backward_degrees(self) -> List[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> List[int]: ...

    def compute_backward_topological_sort(self) -> List[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, edge_weights: Sequence[float]) -> List[List[float]]: ...

    def compute_forward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_backward_breadth_first_search(self, source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[int]]: ...

    def compute_forward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_backward_depth_first_search(self, source_vertex_indices: Sequence[int]) -> List[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_backward_dijkstra_shortest_paths(self, edge_weights: Sequence[float], source_vertex_indices: Sequence[int]) -> Tuple[List[int], List[float]]: ...

    def compute_strong_components(self) -> Tuple[int, List[int]]: ...

class StateSpaceOptions:
    def __init__(self) -> None: ...

    @property
    def sort_ascending_by_num_states(self) -> bool: ...

    @sort_ascending_by_num_states.setter
    def sort_ascending_by_num_states(self, arg: bool, /) -> None: ...

    @property
    def symmetry_pruning(self) -> bool: ...

    @symmetry_pruning.setter
    def symmetry_pruning(self, arg: bool, /) -> None: ...

    @property
    def remove_if_unsolvable(self) -> bool: ...

    @remove_if_unsolvable.setter
    def remove_if_unsolvable(self, arg: bool, /) -> None: ...

    @property
    def max_num_states(self) -> int: ...

    @max_num_states.setter
    def max_num_states(self, arg: int, /) -> None: ...

    @property
    def timeout_ms(self) -> int: ...

    @timeout_ms.setter
    def timeout_ms(self, arg: int, /) -> None: ...

class TupleGraphOptions:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, width: int, enable_dominance_pruning: bool) -> None: ...

    @property
    def width(self) -> int: ...

    @width.setter
    def width(self, arg: int, /) -> None: ...

    @property
    def enable_dominance_pruning(self) -> bool: ...

    @enable_dominance_pruning.setter
    def enable_dominance_pruning(self, arg: bool, /) -> None: ...

class GeneralizedStateSpaceOptions:
    def __init__(self) -> None: ...

class KnowledgeBaseOptions:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, state_space_options: StateSpaceOptions, generalized_state_space_options: GeneralizedStateSpaceOptions, tuple_graph_options: Optional[TupleGraphOptions] = None) -> None: ...

    @property
    def state_space_options(self) -> StateSpaceOptions: ...

    @state_space_options.setter
    def state_space_options(self, arg: StateSpaceOptions, /) -> None: ...

    @property
    def generalized_state_space_options(self) -> Optional[GeneralizedStateSpaceOptions]: ...

    @generalized_state_space_options.setter
    def generalized_state_space_options(self, arg: GeneralizedStateSpaceOptions, /) -> None: ...

    @property
    def tuple_graph_options(self) -> Optional[TupleGraphOptions]: ...

    @tuple_graph_options.setter
    def tuple_graph_options(self, arg: TupleGraphOptions, /) -> None: ...

class StateSpace:
    def __str__(self) -> str: ...

    @overload
    @staticmethod
    def create(context: pymimir.advanced.search.SearchContext, options: StateSpaceOptions) -> Optional[Tuple[StateSpace, Optional["mimir::datasets::CertificateMaps"]]]: ...

    @overload
    @staticmethod
    def create(contexts: pymimir.advanced.search.GeneralizedSearchContext, options: StateSpaceOptions) -> List[Tuple[StateSpace, Optional["mimir::datasets::CertificateMaps"]]]: ...

    def get_search_context(self) -> pymimir.advanced.search.SearchContext: ...

    def get_graph(self) -> BidirectionalStaticProblemGraph: ...

    def get_initial_vertex(self) -> int: ...

    def get_goal_vertices(self) -> Set[int]: ...

    def get_unsolvable_vertices(self) -> Set[int]: ...

class GeneralizedStateSpace:
    def __str__(self) -> str: ...

    @staticmethod
    def create(state_spaces: Sequence[Tuple[StateSpace, Optional["mimir::datasets::CertificateMaps"]]], options: GeneralizedStateSpaceOptions) -> Tuple[GeneralizedStateSpace, Optional[List["mimir::datasets::CertificateMaps"]]]: ...

    def get_state_spaces(self) -> List[StateSpace]: ...

    def get_graph(self) -> BidirectionalStaticClassGraph: ...

    def get_initial_vertices(self) -> Set[int]: ...

    def get_goal_vertices(self) -> Set[int]: ...

    def get_unsolvable_vertices(self) -> Set[int]: ...

    @overload
    def get_state_space(self, class_vertex: ClassVertex) -> StateSpace: ...

    @overload
    def get_state_space(self, class_edge: ClassEdge) -> StateSpace: ...

    def get_problem_vertex(self, class_vertex: ClassVertex) -> ProblemVertex: ...

    def get_problem_edge(self, class_edge: ClassEdge) -> ProblemEdge: ...

    def get_class_vertex(self, problem_vertex: ProblemVertex) -> ClassVertex: ...

    def get_class_edge(self, problem_edge: ProblemEdge) -> ClassEdge: ...

    def create_induced_subgraph_from_class_vertex_indices(self, class_vertex_indices: Sequence[int]) -> Tuple[BidirectionalStaticClassGraph, List[int], List[int]]: ...

    def create_induced_subgraph_from_problem_indices(self, problem_vertex_indices: Sequence[int]) -> Tuple[BidirectionalStaticClassGraph, List[int], List[int]]: ...

class TupleGraph:
    def __str__(self) -> str: ...

    def get_state_space(self) -> StateSpace: ...

    def get_graph(self) -> BidirectionalStaticTupleGraph: ...

    def get_tuple_vertex_indices_grouped_by_distance(self) -> List[List[int]]: ...

    def get_problem_vertex_indices_grouped_by_distance(self) -> List[List[int]]: ...

class KnowledgeBase:
    @staticmethod
    def create(contexts: pymimir.advanced.search.GeneralizedSearchContext, options: KnowledgeBaseOptions) -> KnowledgeBase: ...

    def get_domain(self) -> pymimir.advanced.formalism.Domain: ...

    def get_state_spaces(self) -> List[StateSpace]: ...

    def get_generalized_state_space(self) -> Optional[GeneralizedStateSpace]: ...

    def get_tuple_graphs(self) -> Optional[List[List[TupleGraph]]]: ...

def create_object_graph(state: pymimir.advanced.search.State, problem: pymimir.advanced.formalism.Problem) -> "mimir::graphs::StaticGraph<mimir::graphs::Vertex<mimir::graphs::PropertyValue>, mimir::graphs::Edge<std::tuple<> > >": ...

class StateSpaceSampler:
    def __init__(self, state_space: StateSpace) -> None: ...

    def get_state_space(self) -> StateSpace: ...

    def sample_state(self) -> pymimir.advanced.search.State: ...

    def sample_state_n_steps_from_goal(self, n: int) -> pymimir.advanced.search.State: ...

    def sample_dead_end_state(self) -> pymimir.advanced.search.State: ...

    def get_state(self, index: int) -> pymimir.advanced.search.State: ...

    def get_states(self) -> pymimir.advanced.search.StateList: ...

    def get_num_states(self) -> int: ...

    def get_num_dead_end_states(self) -> int: ...

    def get_num_alive_states(self) -> int: ...

    def get_max_steps_to_goal(self) -> int: ...

    def is_dead_end_state(self, state: pymimir.advanced.search.State) -> bool: ...

    def is_goal_state(self, state: pymimir.advanced.search.State) -> bool: ...

    def is_initial_state(self, state: pymimir.advanced.search.State) -> bool: ...

    def get_steps_to_goal(self, state: pymimir.advanced.search.State) -> int: ...

    def get_cost_to_goal(self, state: pymimir.advanced.search.State) -> float: ...

    def get_forward_transitions(self, state: pymimir.advanced.search.State) -> List[Tuple[pymimir.advanced.formalism.GroundAction, pymimir.advanced.search.State]]: ...

    def get_backward_transitions(self, state: pymimir.advanced.search.State) -> List[Tuple[pymimir.advanced.formalism.GroundAction, pymimir.advanced.search.State]]: ...

    def set_seed(self, seed: int) -> None: ...
