from __future__ import annotations
from collections.abc import Awaitable, Callable, Coroutine, Sequence
from dataclasses import field
from types import NoneType
from typing import TYPE_CHECKING, Any, Concatenate, Generic, Literal, ParamSpec, Protocol, TypeAlias, TypeGuard, cast, overload
from qtmui.immutable import Immutable
from typing_extensions import TypeVar
class BaseAction:
class BaseEvent:
class InitAction:
class FinishAction:
class FinishEvent:
EventHandler: TypeAlias
class CompleteReducerResult:
    state: State
    actions: Any
    events: Any
ReducerResult: TypeAlias
ReducerType: TypeAlias
class InitializationActionError:
    def __init__(self: InitializationActionError, action: BaseAction): ...
def is_complete_reducer_result(result: ReducerResult[State, Action, Event]): ...
def is_state_reducer_result(result: ReducerResult[State, Action, Event]): ...
class Scheduler:
    def __call__(self: Scheduler, callback: Callable): ...
class TaskCreatorCallback:
    def __call__(self: TaskCreatorCallback, task: Task): ...
class TaskCreator:
    def __call__(self: TaskCreator, coro: Coroutine): ...
class ActionMiddleware:
    def __call__(self: ActionMiddleware, action: Action): ...
class EventMiddleware:
    def __call__(self: EventMiddleware, event: Event): ...
class StoreOptions:
    auto_init: bool
    side_effect_threads: int
    scheduler: Any
    action_middlewares: Sequence[ActionMiddleware[Any]]
    event_middlewares: Sequence[EventMiddleware[Any]]
    task_creator: Any
    on_finish: Any
    grace_time_in_seconds: float
    autorun_class: type[Autorun]
    side_effect_runner_class: type[SideEffectRunner]
class AutorunOptionsType:
    default_value: Any
    auto_await: AutoAwait
    initial_call: bool
    reactive: bool
    memoization: bool
    keep_ref: bool
    subscribers_initial_run: bool
    subscribers_keep_ref: bool
    def __init__(self: AutorunOptionsType[ReturnType, Any]): ...
    def __init__(self: AutorunOptionsType[ReturnType, Literal[Any]]): ...
    def __init__(self: AutorunOptionsType[ReturnType, Literal[Any]]): ...
    def __init__(self: AutorunOptionsType): ...
class AutorunOptionsImplementation:
    default_value: Any
    auto_await: AutoAwait
    initial_call: bool
    reactive: bool
    memoization: bool
    keep_ref: bool
    subscribers_initial_run: bool
    subscribers_keep_ref: bool
class AutorunReturnType:
    def __call__(self: AutorunReturnType, *args, **kwargs): ...
    def value(self: AutorunReturnType): ...
    def subscribe(self: AutorunReturnType, callback: Callable[Any, Any]): ...
    def unsubscribe(self: AutorunReturnType): ...
    __name__: str
class MethodAutorunReturnType:
    def __call__(self: AutorunReturnType, self_: MethodSelf, *args, **kwargs): ...
class AutorunDecorator:
    def __call__(self: AutorunDecorator[ReturnType, SelectorOutput, Any], func: Callable[Concatenate[SelectorOutput, Args], Awaitable[ReturnType]]): ...
    def __call__(self: AutorunDecorator[ReturnType, SelectorOutput, Any], func: Callable[Concatenate[MethodSelf, SelectorOutput, Args], Awaitable[ReturnType]]): ...
    def __call__(self: AutorunDecorator[ReturnType, SelectorOutput, Any], func: Callable[Concatenate[SelectorOutput, Args], ReturnType]): ...
    def __call__(self: AutorunDecorator[ReturnType, SelectorOutput, Any], func: Callable[Concatenate[MethodSelf, SelectorOutput, Args], ReturnType]): ...
    def __call__(self: AutorunDecorator[ReturnType, SelectorOutput, Literal[Any]], func: Callable[Concatenate[SelectorOutput, Args], Awaitable[ReturnType]]): ...
    def __call__(self: AutorunDecorator[ReturnType, SelectorOutput, Literal[Any]], func: Callable[Concatenate[MethodSelf, SelectorOutput, Args], Awaitable[ReturnType]]): ...
    def __call__(self: AutorunDecorator[ReturnType, SelectorOutput, Literal[Any]], func: Callable[Concatenate[SelectorOutput, Args], Awaitable[ReturnType]]): ...
    def __call__(self: AutorunDecorator[ReturnType, SelectorOutput, Literal[Any]], func: Callable[Concatenate[MethodSelf, SelectorOutput, Args], Awaitable[ReturnType]]): ...
    def __call__(self: AutorunDecorator[ReturnType, SelectorOutput, bool], func: Callable[Concatenate[SelectorOutput, Args], ReturnType]): ...
    def __call__(self: AutorunDecorator[ReturnType, SelectorOutput, bool], func: Callable[Concatenate[MethodSelf, SelectorOutput, Args], ReturnType]): ...
class ViewOptions:
    default_value: Any
    memoization: bool
    keep_ref: bool
    subscribers_initial_run: bool
    subscribers_keep_ref: bool
class ViewReturnType:
    def __call__(self: ViewReturnType, *args, **kwargs): ...
    def value(self: ViewReturnType): ...
    def subscribe(self: ViewReturnType, callback: Callable[Any, Any]): ...
    def unsubscribe(self: ViewReturnType): ...
class ViewDecorator:
    def __call__(self: ViewDecorator, func: Callable[Concatenate[SelectorOutput, Args], Awaitable[ReturnType]]): ...
    def __call__(self: ViewDecorator, func: Callable[Concatenate[MethodSelf, SelectorOutput, Args], Awaitable[ReturnType]]): ...
    def __call__(self: ViewDecorator, func: Callable[Concatenate[SelectorOutput, Args], ReturnType]): ...
    def __call__(self: ViewDecorator, func: Callable[Concatenate[MethodSelf, SelectorOutput, Args], ReturnType]): ...
class WithStateDecorator:
    def __call__(self: WithStateDecorator, func: Callable[Concatenate[SelectorOutput, Args], ReturnType]): ...
    def __call__(self: WithStateDecorator, func: Callable[Concatenate[MethodSelf, SelectorOutput, Args], ReturnType]): ...
class EventSubscriber:
    def __call__(self: EventSubscriber, event_type: type[Event], handler: EventHandler[Event]): ...
DispatchParameters: TypeAlias
class Dispatch:
    def __call__(self: Dispatch, *items): ...
class BaseCombineReducerState:
    combine_reducers_id: str
class CombineReducerAction:
    combine_reducers_id: str
class CombineReducerInitAction:
    key: str
    payload: Any
class CombineReducerRegisterAction:
    key: str
    reducer: ReducerType
    payload: Any
class CombineReducerUnregisterAction:
    key: str
class SubscribeEventCleanup:
    unsubscribe: Callable[Any, Any]
    handler: EventHandler[StrictEvent]
    def __call__(self: SubscribeEventCleanup): ...