// ============================================================================
// Bundlebase Custom SQL Grammar
// ============================================================================
// This grammar covers bundlebase-specific SQL extensions that aren't
// recognized by sqlparser-rs. Standard SQL continues to use sqlparser-rs.
//
// Operations covered:
// - FILTER WHERE <condition>
// - ATTACH '<path>' [AS <name>] [WITH (...)]
// - [join_type] JOIN AS <name> ON <expression>
// - REINDEX [ON data(<column>)]
// - CREATE SOURCE <function> WITH (...) [ON <pack>]
// - FETCH
// ============================================================================

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "--" ~ (!"\n" ~ ANY)* ~ "\n" }

// ============================================================================
// Entry Point
// ============================================================================

statement = { SOI ~ (filter_stmt | attach_stmt | join_stmt | reindex_stmt | create_source_stmt | fetch_stmt | drop_join_stmt | rename_join_stmt) ~ EOI }

// ============================================================================
// FILTER Statement
// ============================================================================
// Syntax: FILTER WHERE <condition>
// Example: FILTER WHERE country = 'USA' AND age > 21

filter_stmt = {
    ^"filter" ~ ^"where" ~ where_condition
}

where_condition = @{
    // Capture everything from WHERE to end as raw text
    // This allows DataFusion to parse the expression later
    (!EOI ~ ANY)+
}

// ============================================================================
// ATTACH Statement
// ============================================================================
// Syntax: ATTACH '<path>' [TO <pack_name>] [WITH (<options>)]
// Examples:
//   ATTACH 'data.parquet'                    -- attaches to base pack
//   ATTACH 'data.parquet' TO users           -- attaches to 'users' join pack
//   ATTACH 'data.csv' WITH (delimiter = ',', header = true)

attach_stmt = {
    ^"attach" ~ quoted_string ~ (^"to" ~ identifier)? ~ (^"with" ~ with_options)?
}

with_options = {
    "(" ~ option_pair ~ ("," ~ option_pair)* ~ ")"
}

option_pair = {
    identifier ~ "=" ~ option_value
}

option_value = {
    quoted_string | number | boolean | identifier
}

boolean = { ^"true" | ^"false" }

// ============================================================================
// JOIN Statement
// ============================================================================
// Syntax: [join_type] JOIN '<source>' AS <name> ON <expression>
// Examples:
//   JOIN 'other.csv' AS other ON id = other.id
//   LEFT JOIN 'users.parquet' AS users ON user_id = users.id
//   FULL OUTER JOIN 'data.json' AS data ON key = data.key

join_stmt = {
    join_type? ~ ^"join" ~ quoted_string ~ ^"as" ~ identifier ~ ^"on" ~ join_condition
}

join_type = {
    (^"full" ~ ^"outer") | ^"full" | ^"left" | ^"right" | ^"inner" | ^"outer"
}

join_condition = @{
    // Capture everything from ON to end as raw text
    (!EOI ~ ANY)+
}

// ============================================================================
// REINDEX Statement
// ============================================================================
// Syntax: REINDEX [ON data(<column>)]
// Examples:
//   REINDEX
//   REINDEX ON data(id)

reindex_stmt = {
    ^"reindex" ~ (^"on" ~ ^"data" ~ "(" ~ identifier ~ ")")?
}

// ============================================================================
// CREATE SOURCE Statement
// ============================================================================
// Syntax: CREATE SOURCE <function> WITH (<args>) [ON <pack>]
// Examples:
//   CREATE SOURCE remote_dir WITH (url = 's3://bucket/data/', patterns = '**/*.parquet')
//   CREATE SOURCE remote_dir WITH (url = 'file:///data/') ON users

create_source_stmt = {
    ^"create" ~ ^"source" ~ identifier ~ ^"with" ~ source_args ~ (^"on" ~ identifier)?
}

source_args = {
    "(" ~ source_arg_pair ~ ("," ~ source_arg_pair)* ~ ")"
}

source_arg_pair = {
    identifier ~ "=" ~ quoted_string
}

// ============================================================================
// FETCH Statement
// ============================================================================
// Syntax: FETCH [<pack>] | FETCH ALL
// Examples:
//   FETCH              -- fetch from base pack sources
//   FETCH users        -- fetch from 'users' pack sources
//   FETCH ALL          -- fetch from all sources

fetch_stmt = {
    ^"fetch" ~ (^"all" | identifier)?
}

// ============================================================================
// DROP JOIN Statement
// ============================================================================
// Syntax: DROP JOIN <name>
// Examples:
//   DROP JOIN customers

drop_join_stmt = {
    ^"drop" ~ ^"join" ~ identifier
}

// ============================================================================
// RENAME JOIN Statement
// ============================================================================
// Syntax: RENAME JOIN <old_name> TO <new_name>
// Examples:
//   RENAME JOIN customers TO clients

rename_join_stmt = {
    ^"rename" ~ ^"join" ~ identifier ~ ^"to" ~ identifier
}

// ============================================================================
// Lexical Elements
// ============================================================================

identifier = @{
    // SQL identifier: starts with letter/underscore, contains alphanumeric/underscore
    (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

quoted_string = @{
    single_quoted | double_quoted
}

single_quoted = @{
    "'" ~ single_quoted_content ~ "'"
}

single_quoted_content = @{
    (escape_sequence | (!"'" ~ !"\\" ~ ANY))*
}

double_quoted = @{
    "\"" ~ double_quoted_content ~ "\""
}

double_quoted_content = @{
    (escape_sequence | !"\"" ~ !"\\" ~ ANY)*
}

escape_sequence = @{
    "\\\\" | "\\'" | "\\\"" | "\\n" | "\\r" | "\\t"
}

number = @{
    "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}
