import json
import sys
import xml.etree.ElementTree as ET
from os import path
from pathlib import Path
from typing import Annotated, Generator, List

from junitparser import TestCase, TestSuite  # type: ignore

import smart_tests.args4p.converters as converters
import smart_tests.args4p.typer as typer

from ..commands.subset import Subset
from ..testpath import TestPath
from ..utils.logger import Logger
from . import smart_tests


def make_test_path(pkg, target) -> TestPath:
    return [{'type': 'package', 'name': pkg}, {'type': 'target', 'name': target}]


@smart_tests.subset
def subset(client: Subset):
    # Read targets from stdin, which generally looks like //foo/bar:zot
    for label in client.stdin():
        # //foo/bar:zot -> //foo/bar & zot
        if label.startswith('//'):
            pkg, target = label.rstrip('\n').split(':')
            # TODO: error checks and more robustness
            client.test_path(make_test_path(pkg.lstrip('//'), target))

    client.formatter = lambda x: x[0]['name'] + ":" + x[1]['name']
    client.run()


smart_tests.CommonDetectFlakesImpls(__name__, formatter=lambda x: x[0]['name'] + ":" + x[1]['name']).detect_flakes()


@smart_tests.record.tests
def record_tests(
    client,
    workspace: Annotated[str, typer.Argument(help="Bazel workspace directory")],
    build_event_json_files: Annotated[List[Path] | None, typer.Option(
        "--build-event-json",
        help="set file path generated by --build_event_json_file",
        multiple=True,
        type=converters.path(exists=True)
    )] = None,
):
    """
    Takes Bazel workspace, then report all its test results
    """
    base = Path(workspace).joinpath('bazel-testlogs').resolve()
    if not base.exists():
        sys.exit("No such directory: %s" % str(base))

    default_path_builder = client.path_builder

    def f(case: TestCase, suite: TestSuite, report_file: str) -> TestPath:
        # In Bazel, report path name contains package & target.
        # for example, for //foo/bar:zot, the report file is at bazel-testlogs/foo/bar/zot/test.xml
        # TODO: robustness
        pkgNtarget = report_file[len(str(base)) + 1:-len("/test.xml")]

        # last path component is the target, the rest is package
        # TODO: does this work correctly when on Windows?
        tp = make_test_path(path.dirname(pkgNtarget), path.basename(pkgNtarget))

        # let the normal path building kicks in
        tp.extend(default_path_builder(case, suite, report_file))
        return tp

    client.path_builder = f
    client.check_timestamp = False

    def parse_func(report: str) -> ET.ElementTree:
        """
        test result XML generated by Bazel's java_test rule (and possibly others) do not capture system-out/system-err.
        The whole thing gets captured separately as test.log file in the same directory as test.xml.
        This limits our ability to do useful things with data, so we go out of our way to capture it.
        Ideally Bazel should do this. test.log captures the entire output from the whole session, and therefore
        it is incapable of splitting log between different test classes.
        """
        tree = ET.parse(report)
        root = tree.getroot()
        for ts in root.findall('testsuite'):
            # be defensive -- future/non-Java test rules might capture those
            if ts.findtext('system-out', '') == "" and ts.findtext('system-err', '') == "":
                logfile = path.join(path.dirname(report), 'test.log')
                if path.exists(logfile):
                    print("Found {}".format(logfile))
                    for x in ts.findall('system-out'):
                        ts.remove(x)
                    with open(logfile, 'r', encoding='utf-8', errors='replace') as log_file:
                        log = log_file.read()

                    for c in ts.findall('testcase'):
                        if c.findtext('system-out', '') == "" and c.findtext('system-err', '') == "":
                            system_out = ET.SubElement(c, 'system-out')
                            system_out.text = log

        return tree  # type: ignore

    client.junitxml_parse_func = parse_func

    if build_event_json_files:
        for l in parse_build_event_json(build_event_json_files):
            if l is None:
                continue

            client.report(str(Path(base).joinpath(l, 'test.xml')))
    else:
        client.scan(str(base), '**/test.xml')

    client.run()


def parse_build_event_json(files: List[Path]) -> Generator:
    for file in files:
        with open(file) as f:
            for line in f:
                try:
                    d = json.loads(line)
                except Exception:
                    Logger().error(f"Can not parse build event json {line}")
                    yield
                if "id" in d:
                    if "testResult" in d["id"]:
                        if "label" in d["id"]["testResult"]:
                            label = d["id"]["testResult"]["label"]
                            # replace //foo/bar:zot to /foo/bar/zot
                            label = label.lstrip("/").replace(":", "/")
                            yield label
