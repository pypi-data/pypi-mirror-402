"""
RasFixit - Automated Geometry Repair for HEC-RAS Models.

This module provides automated fix capabilities for common HEC-RAS geometry issues.
All methods are static and follow ras-commander conventions.

Supported Fixes:
    - Blocked Obstruction Overlaps: Resolves overlapping obstructions using max elevation
    - HTAB Starting Elevation: Fixes starting_el < invert issues (version upgrade problem)

Engineering Review Requirements:
    All fixes generated by RasFixit modify hydraulic model geometry.
    Results should be reviewed by a licensed professional engineer
    before accepting changes to production models.

    The visualization output provides an audit trail showing:
    - Original obstruction configuration
    - Fixed obstruction configuration
    - Algorithm decisions made

Example:
    >>> from ras_commander import RasFixit
    >>> results = RasFixit.fix_blocked_obstructions("model.g01", visualize=True)
    >>> print(f"Fixed {results.total_xs_fixed} cross sections")
"""

import re
import shutil
from pathlib import Path
from typing import Union, Optional, List, Tuple
from datetime import datetime

from ..Decorators import log_call
from ..LoggingConfig import get_logger
from .results import FixResults, FixMessage, FixAction
from .obstructions import (
    BlockedObstruction,
    parse_obstructions,
    format_obstructions,
    create_elevation_envelope,
    has_overlaps,
)

logger = get_logger(__name__)


class RasFixit:
    """
    Automated geometry repair for HEC-RAS models.

    All methods are static and designed for geometry file path input.
    This follows the ras-commander convention of static classes.

    Integration with RasCheck:
        RasCheck.check_xs() detects obstruction issues (XS_BO_01, XS_BO_02)
        RasFixit.fix_blocked_obstructions() repairs those issues

        RasCheck.check_htab_params() detects HTAB issues (HTAB_SE_01)
        RasFixit.fix_htab_starting_elevations() repairs those issues

    Example:
        >>> from ras_commander import RasFixit, RasCheck
        >>>
        >>> # First detect issues
        >>> check_results = RasCheck.check_xs(geom_hdf)
        >>> obstruction_issues = [m for m in check_results.messages
        ...                       if m.message_id.startswith('XS_BO')]
        >>>
        >>> if obstruction_issues:
        ...     # Then fix them
        ...     fix_results = RasFixit.fix_blocked_obstructions(
        ...         "model.g01", visualize=True
        ...     )
        ...     print(f"Fixed {fix_results.total_xs_fixed} cross sections")
    """

    # Geometry file section terminators (marks end of obstruction data block)
    _TERMINATORS = ('Bank Sta=', '#XS Ineff=', '#Mann=',
                    'XS Rating Curve=', 'XS HTab', 'Exp/Cntr=')

    @staticmethod
    @log_call
    def fix_blocked_obstructions(
        geom_path: Union[str, Path],
        backup: bool = True,
        visualize: bool = False,
        dry_run: bool = False
    ) -> FixResults:
        """
        Fix overlapping blocked obstructions in a geometry file.

        Uses max-elevation envelope algorithm to resolve overlaps while
        preserving conservative hydraulic behavior. Creates verification
        outputs for engineering review.

        Args:
            geom_path: Path to HEC-RAS geometry file (.g##)
            backup: Create timestamped backup before modification (default True)
            visualize: Generate before/after PNG comparisons (default False)
            dry_run: Detect issues without modifying file (default False)

        Returns:
            FixResults with messages for each fixed cross section.
            Use results.to_dataframe() for pandas DataFrame output.

        Raises:
            FileNotFoundError: If geometry file doesn't exist.

        Example:
            >>> results = RasFixit.fix_blocked_obstructions(
            ...     "BaldEagle.g01",
            ...     backup=True,
            ...     visualize=True
            ... )
            >>> for msg in results.messages:
            ...     print(f"RS {msg.station}: {msg.action.value}")

        Note:
            The algorithm uses maximum elevations in overlap zones, which is
            hydraulically conservative (preserves flow restrictions).
            All changes should be reviewed by a licensed professional engineer.
        """
        geom_path = Path(geom_path)
        if not geom_path.exists():
            raise FileNotFoundError(f"Geometry file not found: {geom_path}")

        results = FixResults()

        # Create backup if requested and not dry run
        if backup and not dry_run:
            backup_path = RasFixit._create_backup(geom_path)
            results.backup_path = backup_path
            logger.info(f"Created backup: {backup_path}")

        # Read geometry file
        with open(geom_path, 'r') as f:
            content = f.read()

        # Split into cross section blocks
        sections = re.split(r'(?=^Type RM Length)', content, flags=re.MULTILINE)
        header = sections[0]
        xs_sections = sections[1:]

        results.total_xs_checked = len(xs_sections)

        # Setup visualization folder if needed
        viz_folder = None
        if visualize and not dry_run:
            viz_folder = RasFixit._create_viz_folder(geom_path)
            results.visualization_folder = viz_folder
            logger.info(f"Saving visualizations to: {viz_folder}")

        # Process each cross section
        modified_sections = []
        for xs_content in xs_sections:
            processed, msg = RasFixit._process_xs_obstructions(
                xs_content, viz_folder, dry_run
            )

            if msg is not None:
                results.messages.append(msg)
                if msg.action != FixAction.NO_ACTION:
                    results.total_xs_fixed += 1

            modified_sections.append(processed)

        # Write modified file if not dry run and changes were made
        if not dry_run and results.total_xs_fixed > 0:
            final_content = header + "".join(modified_sections)
            with open(geom_path, 'w') as f:
                f.write(final_content)
            logger.info(f"Fixed {results.total_xs_fixed} cross sections in {geom_path.name}")

        return results

    @staticmethod
    @log_call
    def detect_obstruction_overlaps(geom_path: Union[str, Path]) -> FixResults:
        """
        Detect overlapping blocked obstructions without modifying the file.

        This is equivalent to fix_blocked_obstructions(dry_run=True).
        Useful for pre-flight checks before applying fixes.

        Args:
            geom_path: Path to HEC-RAS geometry file (.g##)

        Returns:
            FixResults with detection messages (no modifications made).

        Example:
            >>> results = RasFixit.detect_obstruction_overlaps("model.g04")
            >>> print(f"Found {results.total_xs_fixed} cross sections with overlaps")
        """
        return RasFixit.fix_blocked_obstructions(
            geom_path, backup=False, visualize=False, dry_run=True
        )

    @staticmethod
    def _create_backup(geom_path: Path) -> Path:
        """Create timestamped backup of geometry file."""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_path = geom_path.parent / f"{geom_path.name}.backup_{timestamp}"
        shutil.copy2(geom_path, backup_path)
        return backup_path

    @staticmethod
    def _create_viz_folder(geom_path: Path) -> Path:
        """Create visualization output folder."""
        # Extract geometry number
        g_match = re.search(r'\.g(\d+)(?:\.|$)', geom_path.name, re.IGNORECASE)
        g_num = g_match.group(1) if g_match else "XX"

        # Extract project name (everything before .g##)
        project_name = re.sub(r'\.g\d+.*', '', geom_path.name)

        # Create folder name: ProjectName_g##_Obstructions_Fixed
        dir_name = f"{project_name}_g{g_num}_Obstructions_Fixed"

        viz_folder = geom_path.parent / dir_name
        viz_folder.mkdir(exist_ok=True)

        return viz_folder

    @staticmethod
    def _process_xs_obstructions(
        xs_content: str,
        viz_folder: Optional[Path],
        dry_run: bool
    ) -> Tuple[str, Optional[FixMessage]]:
        """
        Process single cross section for obstruction overlaps.

        Args:
            xs_content: Full content of cross section block.
            viz_folder: Folder for visualization output (or None).
            dry_run: If True, don't modify content.

        Returns:
            Tuple of (processed_content, FixMessage or None).
        """
        xs_lines = xs_content.split('\n')

        # Extract river station ID from first line
        rs_match = re.search(r'RM\s*Length[^=]*=\s*[\d.]+\s*,([\d.]+)', xs_lines[0])
        rs_id = rs_match.group(1).strip() if rs_match else "Unknown"

        # Find obstruction header
        header_idx = -1
        for i, line in enumerate(xs_lines):
            if line.strip().startswith('#Block Obstruct='):
                header_idx = i
                break

        if header_idx == -1:
            return "\n".join(xs_lines), None  # No obstructions

        # Parse obstruction count
        header_line = xs_lines[header_idx]
        match = re.search(r'=\s*(\d+)', header_line)
        if not match:
            return "\n".join(xs_lines), None

        expected_count = int(match.group(1))
        if expected_count == 0:
            return "\n".join(xs_lines), None

        # Find data block boundaries
        table_start = header_idx + 1
        table_end = len(xs_lines)

        for i in range(table_start, len(xs_lines)):
            if xs_lines[i].strip().startswith(RasFixit._TERMINATORS):
                table_end = i
                break

        # Parse obstructions
        data_lines = [l for l in xs_lines[table_start:table_end] if l.strip()]
        original = parse_obstructions(data_lines, expected_count)

        if len(original) < 2:
            return "\n".join(xs_lines), None  # Need 2+ to have overlap

        # Check for overlaps
        if not has_overlaps(original):
            return "\n".join(xs_lines), None

        # Fix overlaps
        fixed = create_elevation_envelope(original)

        # Create fix message
        msg = FixMessage(
            message_id="FX_BO_01",
            fix_type="OBSTRUCTION",
            station=rs_id,
            action=FixAction.OVERLAP_RESOLVED,
            message=f"Resolved {len(original)} overlapping obstructions to {len(fixed)} non-overlapping",
            original_count=len(original),
            fixed_count=len(fixed),
            original_data=[o.to_tuple() for o in original],
            fixed_data=[o.to_tuple() for o in fixed]
        )

        logger.debug(f"RS {rs_id}: {len(original)} -> {len(fixed)} obstructions")

        # Generate visualization if requested
        if viz_folder and not dry_run:
            viz_path = viz_folder / f"RS_{rs_id.replace('.', '_')}.png"
            msg.visualization_path = viz_path
            RasFixit._visualize(original, fixed, rs_id, viz_path)

        # If dry run, return original content
        if dry_run:
            return "\n".join(xs_lines), msg

        # Update geometry content
        new_header = re.sub(r'=\s*\d+', f'= {len(fixed)}', header_line)
        xs_lines[header_idx] = new_header

        new_data_lines = format_obstructions(fixed)

        del xs_lines[table_start:table_end]
        for i, new_line in enumerate(new_data_lines):
            xs_lines.insert(table_start + i, new_line)

        return "\n".join(xs_lines), msg

    @staticmethod
    def _visualize(
        original: List[BlockedObstruction],
        fixed: List[BlockedObstruction],
        rs_id: str,
        save_path: Path
    ) -> bool:
        """
        Generate before/after visualization PNG.

        Lazy loads matplotlib to avoid import overhead when visualization
        is not requested.

        Args:
            original: Original overlapping obstructions.
            fixed: Fixed non-overlapping obstructions.
            rs_id: River station identifier.
            save_path: Output PNG path.

        Returns:
            True if visualization was created, False otherwise.
        """
        from .visualization import visualize_obstruction_fix
        return visualize_obstruction_fix(original, fixed, rs_id, save_path)

    # =========================================================================
    # HTAB (Hydraulic Table) Fixes
    # =========================================================================

    @staticmethod
    @log_call
    def fix_htab_starting_elevations(
        geom_path: Union[str, Path],
        backup: bool = True,
        dry_run: bool = False,
        margin: float = 0.0
    ) -> FixResults:
        """
        Fix HTAB starting elevation issues in a geometry file.

        HTAB (Hydraulic Table) starting elevation must be >= cross section invert.
        This is a hard HEC-RAS requirement - models with starting_el < invert will
        fail during preprocessing (common issue when upgrading from older HEC-RAS versions).

        This method identifies all cross sections where starting_el < invert and
        automatically corrects them by setting starting_el = invert + margin.

        Args:
            geom_path: Path to HEC-RAS geometry file (.g##)
            backup: Create timestamped backup before modification (default True)
            dry_run: Detect issues without modifying file (default False)
            margin: Additional margin above invert for starting elevation (default 0.0 ft)
                   Use small positive value (e.g., 0.1) for extra safety margin.

        Returns:
            FixResults with messages for each fixed cross section.
            - total_xs_checked: Number of XS with HTAB parameters examined
            - total_xs_fixed: Number of XS with starting_el corrected
            - messages: List of FixMessage objects with before/after values
            Use results.to_dataframe() for pandas DataFrame output.

        Raises:
            FileNotFoundError: If geometry file doesn't exist.

        Example:
            >>> from ras_commander import RasFixit
            >>>
            >>> # Fix all HTAB starting elevation issues
            >>> results = RasFixit.fix_htab_starting_elevations("model.g01")
            >>> print(f"Fixed {results.total_xs_fixed} cross sections")
            >>>
            >>> # Detection only (no modifications)
            >>> results = RasFixit.fix_htab_starting_elevations(
            ...     "model.g01", dry_run=True
            ... )
            >>> print(f"Found {results.total_xs_fixed} cross sections with issues")
            >>>
            >>> # View details
            >>> df = results.to_dataframe()
            >>> print(df[['river', 'reach', 'station', 'message']])

        Note:
            This fix is required after HEC-RAS version upgrades or when importing
            geometry from external sources. HEC-RAS will fail with an error during
            geometry preprocessing if starting_el < invert.

        Integration with RasCheck:
            RasCheck.check_htab_params() detects HTAB_SE_01 errors (starting_el < invert)
            RasFixit.fix_htab_starting_elevations() repairs those issues

        See Also:
            - GeomCrossSection.get_xs_htab_params(): Read HTAB parameters
            - GeomCrossSection.set_xs_htab_params(): Write HTAB parameters
            - RasCheck.check_htab_params(): Validate HTAB parameters
        """
        from ..geom.GeomCrossSection import GeomCrossSection

        geom_path = Path(geom_path)
        if not geom_path.exists():
            raise FileNotFoundError(f"Geometry file not found: {geom_path}")

        results = FixResults()

        # Create backup if requested and not dry run
        if backup and not dry_run:
            backup_path = RasFixit._create_backup(geom_path)
            results.backup_path = backup_path
            logger.info(f"Created backup: {backup_path}")

        try:
            # Get all cross sections from geometry file
            xs_df = GeomCrossSection.get_cross_sections(geom_path)

            if xs_df.empty:
                logger.info(f"No cross sections found in {geom_path.name}")
                return results

            logger.info(f"Checking HTAB starting elevations for {len(xs_df)} cross sections")

            xs_to_fix = []  # List of dicts with fix info

            for _, row in xs_df.iterrows():
                river = row['River']
                reach = row['Reach']
                rs = row['RS']

                try:
                    # Get HTAB parameters for this XS
                    htab_params = GeomCrossSection.get_xs_htab_params(
                        geom_path, river, reach, rs
                    )

                    starting_el = htab_params.get('starting_el')
                    invert = htab_params.get('invert')

                    # Skip if no HTAB params or no starting elevation defined
                    if starting_el is None or invert is None:
                        continue

                    results.total_xs_checked += 1

                    # Check if starting_el < invert (ERROR condition)
                    if starting_el < invert:
                        corrected_starting_el = invert + margin
                        xs_to_fix.append({
                            'river': river,
                            'reach': reach,
                            'rs': rs,
                            'original_starting_el': starting_el,
                            'invert': invert,
                            'corrected_starting_el': corrected_starting_el,
                            'increment': htab_params.get('increment'),
                            'num_points': htab_params.get('num_points')
                        })

                        # Create fix message
                        msg = FixMessage(
                            message_id="FX_HTAB_01",
                            fix_type="HTAB",
                            river=river,
                            reach=reach,
                            station=str(rs),
                            action=FixAction.HTAB_STARTING_EL_FIXED,
                            message=(
                                f"HTAB starting elevation corrected from {starting_el:.2f} "
                                f"to {corrected_starting_el:.2f} (invert={invert:.2f})"
                            ),
                            original_data=[(starting_el, invert, 0.0)],
                            fixed_data=[(corrected_starting_el, invert, 0.0)]
                        )
                        results.messages.append(msg)

                        logger.debug(
                            f"{river}/{reach}/RS {rs}: starting_el {starting_el:.2f} -> "
                            f"{corrected_starting_el:.2f} (invert={invert:.2f})"
                        )

                except Exception as e:
                    logger.warning(f"Error checking HTAB for {river}/{reach}/RS {rs}: {e}")
                    continue

            results.total_xs_fixed = len(xs_to_fix)

            # Apply fixes if not dry run
            if not dry_run and xs_to_fix:
                logger.info(f"Applying fixes to {len(xs_to_fix)} cross sections")

                for xs_info in xs_to_fix:
                    try:
                        GeomCrossSection.set_xs_htab_params(
                            geom_path,
                            xs_info['river'],
                            xs_info['reach'],
                            xs_info['rs'],
                            starting_el=xs_info['corrected_starting_el'],
                            increment=xs_info['increment'],
                            num_points=xs_info['num_points']
                        )
                    except Exception as e:
                        logger.error(
                            f"Failed to fix HTAB for {xs_info['river']}/{xs_info['reach']}/"
                            f"RS {xs_info['rs']}: {e}"
                        )

                logger.info(
                    f"Fixed HTAB starting elevations for {len(xs_to_fix)} cross sections "
                    f"in {geom_path.name}"
                )
            elif dry_run and xs_to_fix:
                logger.info(
                    f"Dry run: Found {len(xs_to_fix)} cross sections with HTAB starting_el < invert"
                )

            # Add statistics
            results.statistics = {
                'total_xs_in_file': len(xs_df),
                'xs_with_htab': results.total_xs_checked,
                'xs_with_issues': results.total_xs_fixed,
                'margin_used': margin
            }

        except Exception as e:
            logger.error(f"Failed to fix HTAB starting elevations: {e}")
            raise

        return results

    @staticmethod
    @log_call
    def detect_htab_issues(geom_path: Union[str, Path]) -> FixResults:
        """
        Detect HTAB starting elevation issues without modifying the file.

        This is equivalent to fix_htab_starting_elevations(dry_run=True).
        Useful for pre-flight checks before applying fixes.

        Args:
            geom_path: Path to HEC-RAS geometry file (.g##)

        Returns:
            FixResults with detection messages (no modifications made).

        Example:
            >>> results = RasFixit.detect_htab_issues("model.g01")
            >>> print(f"Found {results.total_xs_fixed} cross sections with HTAB issues")
            >>> for msg in results.messages:
            ...     print(f"  {msg.river}/{msg.reach}/RS {msg.station}: {msg.message}")
        """
        return RasFixit.fix_htab_starting_elevations(
            geom_path, backup=False, dry_run=True
        )
