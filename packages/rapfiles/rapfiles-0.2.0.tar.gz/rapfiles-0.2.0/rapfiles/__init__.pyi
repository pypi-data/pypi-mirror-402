"""Type stubs for rapfiles public API."""

from typing import (
    Any,
    Optional,
    Union,
    List,
    Tuple,
    Dict,
)

from ._rapfiles import FileMetadata as _FileMetadata

__version__: str

# Re-export FileMetadata for type checking  
__all__: List[str]

# Explicit re-export for mypy
FileMetadata: type[_FileMetadata]  # type: ignore[misc]

# Convenience async functions
async def read_file(path: str) -> str: ...
async def write_file(path: str, contents: str) -> None: ...
async def read_file_bytes(path: str) -> bytes: ...
async def write_file_bytes(path: str, contents: bytes) -> None: ...
async def append_file(path: str, contents: str) -> None: ...

# Directory operations
async def create_dir(path: str) -> None: ...
async def create_dir_all(path: str) -> None: ...
async def remove_dir(path: str) -> None: ...
async def remove_dir_all(path: str) -> None: ...
async def list_dir(path: str) -> List[str]: ...
async def exists(path: str) -> bool: ...
async def is_file(path: str) -> bool: ...
async def is_dir(path: str) -> bool: ...

# Metadata operations
async def stat(path: str) -> FileMetadata: ...
async def metadata(path: str) -> FileMetadata: ...

# Directory traversal
async def walk_dir(path: str) -> List[Tuple[str, bool]]: ...

# File manipulation operations
async def copy_file(src: str, dst: str) -> None: ...
async def move_file(src: str, dst: str) -> None: ...
async def rename(src: str, dst: str) -> None: ...
async def remove_file(path: str) -> None: ...
async def hard_link(src: str, dst: str) -> None: ...
async def symlink(src: str, dst: str) -> None: ...
async def canonicalize(path: str) -> str: ...

# Atomic operations
async def atomic_write_file(path: str, contents: str) -> None: ...
async def atomic_write_file_bytes(path: str, contents: bytes) -> None: ...
async def atomic_move_file(src: str, dst: str) -> None: ...

# File locking
def lock_file(path: str, exclusive: bool = ...) -> Any: ...  # Returns _LockContextManager
def lock_file_shared(path: str) -> Any: ...  # Returns _LockContextManager

# Batch operations
async def read_files(paths: List[str]) -> List[Tuple[str, bytes]]: ...
async def read_files_dict(paths: List[str]) -> Dict[str, bytes]: ...
async def write_files(files: Dict[str, bytes]) -> None: ...
async def copy_files(files: List[Tuple[str, str]]) -> None: ...

# File opening - returns an async context manager
def open(
    file: Union[str, bytes],
    mode: str = ...,
    buffering: int = ...,
    encoding: Optional[str] = ...,
    errors: Optional[str] = ...,
    newline: Optional[str] = ...,
    closefd: bool = ...,
    opener: Optional[Any] = ...,
) -> Any: ...  # Returns _OpenContextManager which is internal

# File handle class
class AsyncFile:
    async def read(self, size: int = ...) -> Union[str, bytes]: ...
    async def write(self, data: Union[str, bytes]) -> int: ...
    async def readline(self, size: int = ...) -> Union[str, bytes]: ...
    async def readlines(self, hint: int = ...) -> Union[List[str], List[bytes]]: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def tell(self) -> int: ...
    async def close(self) -> None: ...
    async def __aenter__(self) -> "AsyncFile": ...
    async def __aexit__(
        self,
        exc_type: Optional[type],
        exc_val: Optional[BaseException],
        exc_tb: Optional[Any],
    ) -> Optional[bool]: ...

