# coding: utf-8

"""
    Mixpeek API

    This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.

    The version of the OpenAPI document: 1.3.0
    Contact: info@mixpeek.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import json
from enum import Enum
from typing_extensions import Self


class FusionStrategy(str, Enum):
    """
    Score fusion strategies for combining multiple feature searches.  ┌──────────┬──────────────┬─────────────────────────────────────────────────────┐ │ Strategy │ Qdrant Native│ Description                                         │ ├──────────┼──────────────┼─────────────────────────────────────────────────────┤ │ rrf      │ ✅ Yes       │ Rank-based fusion, robust default (recommended)     │ │ dbsf     │ ✅ Yes       │ Score-based with statistical normalization          │ │ weighted │ ❌ No        │ Manual score-weighted fusion with custom weights    │ │ max      │ ❌ No        │ Take maximum score across features                  │ │ learned  │ ❌ No        │ Bandit-learned weights, enables personalization     │ └──────────┴──────────────┴─────────────────────────────────────────────────────┘  Performance Note:     - rrf/dbsf: Single Qdrant call (fastest)     - weighted/max/learned: Separate queries per feature, merged client-side  ═══════════════════════════════════════════════════════════════════════════════ RRF (Reciprocal Rank Fusion) - RECOMMENDED DEFAULT ═══════════════════════════════════════════════════════════════════════════════     Formula: score = Σ(1 / (k + rank_i))     - Rank-based: ignores raw scores, uses position only     - Robust to score scale differences between embedding models     - No tuning required, works well out-of-the-box     - Qdrant default k=2 (configurable)     - Best for: General-purpose multi-vector search  ═══════════════════════════════════════════════════════════════════════════════ DBSF (Distribution-Based Score Fusion) ═══════════════════════════════════════════════════════════════════════════════     Formula: Normalizes scores using mean ± 3σ, then sums     - Score-based with statistical normalization     - Handles different score distributions across features     - Available since Qdrant v1.11     - Best for: When score magnitudes matter but scales differ  ═══════════════════════════════════════════════════════════════════════════════ WEIGHTED (Manual Weight Fusion) ═══════════════════════════════════════════════════════════════════════════════     Formula: score = Σ(weight_i * score_i)     - User specifies weight per feature search     - Weights defined in each FeatureSearchConfig.weight field     - Runs N separate queries, merges results client-side     - Best for: When you know relative feature importance upfront  ═══════════════════════════════════════════════════════════════════════════════ MAX (Maximum Score Fusion) ═══════════════════════════════════════════════════════════════════════════════     Formula: score = max(score_1, score_2, ..., score_n)     - Takes best match from any single feature     - Good when any modality match is sufficient     - Runs N separate queries, merges results client-side     - Best for: \"OR\" semantics (match text OR image OR audio)  ═══════════════════════════════════════════════════════════════════════════════ LEARNED (Bandit-Learned Fusion) ═══════════════════════════════════════════════════════════════════════════════     Formula: score = Σ(learned_weight_i * score_i)     - Learns optimal weights from user feedback (clicks, purchases, etc.)     - Uses Thompson Sampling (Beta-Bernoulli bandit) by default     - Supports personalization via context (user_id, segment, etc.)     - Cold start handling with hierarchical fallback     - REQUIRES learning_config to be specified     - Runs N separate queries to get per-feature scores for learning     - Best for: Personalized search, learning feature importance over time  Example Usage:     ```python     # Fast, no tuning needed (recommended)     fusion = FusionStrategy.RRF      # Score-aware with normalization     fusion = FusionStrategy.DBSF      # Manual weights (0.7 text, 0.3 image)     fusion = FusionStrategy.WEIGHTED     searches = [         {\"feature_uri\": \"...\", \"weight\": 0.7, ...},         {\"feature_uri\": \"...\", \"weight\": 0.3, ...},     ]      # Best match from any feature     fusion = FusionStrategy.MAX      # Personalized, learns from feedback     fusion = FusionStrategy.LEARNED     learning_config = LearnedFusionConfig(         context_features=[\"INPUT.user_id\"],         reward_signal=\"click\"     )     ```
    """

    """
    allowed enum values
    """
    RRF = 'rrf'
    DBSF = 'dbsf'
    WEIGHTED = 'weighted'
    MAX = 'max'
    LEARNED = 'learned'

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of FusionStrategy from a JSON string"""
        return cls(json.loads(json_str))


