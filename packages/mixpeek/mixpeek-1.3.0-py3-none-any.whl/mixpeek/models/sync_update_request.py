# coding: utf-8

"""
    Mixpeek API

    This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.

    The version of the OpenAPI document: 1.3.0
    Contact: info@mixpeek.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from mixpeek.models.schema_mapping_input import SchemaMappingInput
from mixpeek.models.task_status_enum import TaskStatusEnum
from typing import Optional, Set
from typing_extensions import Self

class SyncUpdateRequest(BaseModel):
    """
    Request to update an existing sync configuration.  Allows partial updates to sync settings without recreating the configuration. All fields are optional - only provided fields will be updated.  Use Cases:     - Pause/resume syncs by toggling is_active     - Adjust polling intervals based on activity patterns     - Update batch sizes for performance tuning     - Add metadata tags for organization  Requirements:     - All fields are OPTIONAL     - At least one field should be provided for the update     - Changes take effect on the next sync cycle
    """ # noqa: E501
    description: Optional[StrictStr] = Field(default=None, description="Optional human-readable description of the sync configuration. NOT REQUIRED. Used for documentation and UI display. Maximum 500 characters.")
    metadata: Optional[Dict[str, Any]] = Field(default=None, description="Optional custom metadata to replace existing metadata. NOT REQUIRED. Completely replaces existing metadata (not merged). Use for tagging, categorization, or custom attributes. Maximum 50 keys, values must be JSON-serializable.")
    status: Optional[TaskStatusEnum] = Field(default=None, description="Optional status to set for the sync configuration. NOT REQUIRED. Valid values: 'pending', 'processing', 'completed', 'failed', 'paused'. Typically managed automatically but can be manually overridden. Use pause/resume endpoints instead for active control.")
    is_active: Optional[StrictBool] = Field(default=None, description="Optional flag to enable or disable the sync configuration. NOT REQUIRED. When False, sync will not process new files. Prefer using the /pause and /resume endpoints for clarity. Changes take effect immediately.")
    polling_interval_seconds: Optional[Annotated[int, Field(le=900, strict=True, ge=30)]] = Field(default=None, description="Optional new polling interval in seconds. NOT REQUIRED. Must be between 30 and 900 seconds if provided. Only applies to 'continuous' and 'scheduled' sync modes. Lower values increase responsiveness but API usage.")
    batch_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=None, description="Optional new batch size for file processing. NOT REQUIRED. Must be between 1 and 100 if provided. Larger batches improve throughput but use more memory. Changes apply to subsequent batches only.")
    schema_mapping: Optional[SchemaMappingInput] = Field(default=None, description="Optional schema mapping to replace existing mapping. NOT REQUIRED. Completely replaces existing schema_mapping (not merged). Defines how source data maps to bucket schema fields and blobs. See SyncCreateRequest.schema_mapping for detailed documentation.")
    skip_batch_submission: Optional[StrictBool] = Field(default=None, description="If True, sync objects to the bucket without creating or submitting batches for collection processing. Objects are created in the bucket but no tier processing is triggered. NOT REQUIRED. When omitted, existing value is preserved.")
    __properties: ClassVar[List[str]] = ["description", "metadata", "status", "is_active", "polling_interval_seconds", "batch_size", "schema_mapping", "skip_batch_submission"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SyncUpdateRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of schema_mapping
        if self.schema_mapping:
            _dict['schema_mapping'] = self.schema_mapping.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SyncUpdateRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "description": obj.get("description"),
            "metadata": obj.get("metadata"),
            "status": obj.get("status"),
            "is_active": obj.get("is_active"),
            "polling_interval_seconds": obj.get("polling_interval_seconds"),
            "batch_size": obj.get("batch_size"),
            "schema_mapping": SchemaMappingInput.from_dict(obj["schema_mapping"]) if obj.get("schema_mapping") is not None else None,
            "skip_batch_submission": obj.get("skip_batch_submission")
        })
        return _obj


