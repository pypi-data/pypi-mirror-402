# coding: utf-8

"""
    Mixpeek API

    This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.

    The version of the OpenAPI document: 1.3.0
    Contact: info@mixpeek.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class CourseContentExtractorParams(BaseModel):
    """
    Parameters for the course content extractor.
    """ # noqa: E501
    extractor_type: Optional[StrictStr] = Field(default='course_content_extractor', description="Discriminator field. Must be 'course_content_extractor'.")
    target_segment_duration_ms: Optional[Annotated[int, Field(le=600000, strict=True, ge=30000)]] = Field(default=120000, description="Target duration for video segments in milliseconds.")
    min_segment_duration_ms: Optional[Annotated[int, Field(strict=True, ge=10000)]] = Field(default=30000, description="Minimum duration for video segments in milliseconds.")
    segmentation_method: Optional[StrictStr] = Field(default='scene', description="Video segmentation method: 'scene', 'srt', or 'time'.")
    scene_detection_threshold: Optional[Union[Annotated[float, Field(le=0.9, strict=True, ge=0.1)], Annotated[int, Field(le=0, strict=True, ge=1)]]] = Field(default=0.3, description="Scene detection sensitivity (0.0-1.0).")
    use_whisper_asr: Optional[StrictBool] = Field(default=True, description="Use Whisper ASR for transcription instead of SRT subtitles.")
    expand_to_granular_docs: Optional[StrictBool] = Field(default=True, description="Expand each segment into multiple granular documents.")
    ocr_frames_per_segment: Optional[Annotated[int, Field(le=10, strict=True, ge=1)]] = Field(default=3, description="Number of frames to OCR per video segment.")
    pdf_extraction_mode: Optional[StrictStr] = Field(default='per_element', description="How to extract PDF content: 'per_page' or 'per_element'.")
    pdf_render_dpi: Optional[Annotated[int, Field(le=300, strict=True, ge=72)]] = Field(default=150, description="DPI for rendering PDF pages/elements as images.")
    detect_code_in_pdf: Optional[StrictBool] = Field(default=True, description="Whether to detect code blocks in PDF text.")
    segment_functions: Optional[StrictBool] = Field(default=True, description="Whether to segment code files into individual functions.")
    supported_languages: Optional[List[StrictStr]] = Field(default=None, description="Programming languages to extract from code archives.")
    run_text_embedding: Optional[StrictBool] = Field(default=True, description="Generate E5 text embeddings (1024D) for transcripts and text.")
    run_code_embedding: Optional[StrictBool] = Field(default=True, description="Generate Jina Code embeddings (768D) for code snippets.")
    run_visual_embedding: Optional[StrictBool] = Field(default=False, description="Generate SigLIP visual embeddings (768D) for video frames.")
    visual_embedding_use_case: Optional[StrictStr] = Field(default='lecture', description="Content type preset for visual embedding strategy.")
    extract_screen_text: Optional[StrictBool] = Field(default=True, description="Run OCR on video frames to extract on-screen text.")
    generate_thumbnails: Optional[StrictBool] = Field(default=True, description="Generate thumbnail images for each learning unit.")
    use_cdn: Optional[StrictBool] = Field(default=False, description="Use CDN for thumbnail delivery.")
    enrich_with_llm: Optional[StrictBool] = Field(default=False, description="Use Gemini to generate summaries and enhance descriptions.")
    llm_prompt: Optional[StrictStr] = Field(default='Summarize this educational content segment, highlighting key concepts.', description="Prompt for LLM enrichment when enrich_with_llm=True.")
    __properties: ClassVar[List[str]] = ["extractor_type", "target_segment_duration_ms", "min_segment_duration_ms", "segmentation_method", "scene_detection_threshold", "use_whisper_asr", "expand_to_granular_docs", "ocr_frames_per_segment", "pdf_extraction_mode", "pdf_render_dpi", "detect_code_in_pdf", "segment_functions", "supported_languages", "run_text_embedding", "run_code_embedding", "run_visual_embedding", "visual_embedding_use_case", "extract_screen_text", "generate_thumbnails", "use_cdn", "enrich_with_llm", "llm_prompt"]

    @field_validator('extractor_type')
    def extractor_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['course_content_extractor']):
            raise ValueError("must be one of enum values ('course_content_extractor')")
        return value

    @field_validator('segmentation_method')
    def segmentation_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['scene', 'srt', 'time']):
            raise ValueError("must be one of enum values ('scene', 'srt', 'time')")
        return value

    @field_validator('pdf_extraction_mode')
    def pdf_extraction_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['per_page', 'per_element']):
            raise ValueError("must be one of enum values ('per_page', 'per_element')")
        return value

    @field_validator('visual_embedding_use_case')
    def visual_embedding_use_case_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['lecture', 'code_demo', 'tutorial', 'presentation', 'dynamic']):
            raise ValueError("must be one of enum values ('lecture', 'code_demo', 'tutorial', 'presentation', 'dynamic')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CourseContentExtractorParams from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CourseContentExtractorParams from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "extractor_type": obj.get("extractor_type") if obj.get("extractor_type") is not None else 'course_content_extractor',
            "target_segment_duration_ms": obj.get("target_segment_duration_ms") if obj.get("target_segment_duration_ms") is not None else 120000,
            "min_segment_duration_ms": obj.get("min_segment_duration_ms") if obj.get("min_segment_duration_ms") is not None else 30000,
            "segmentation_method": obj.get("segmentation_method") if obj.get("segmentation_method") is not None else 'scene',
            "scene_detection_threshold": obj.get("scene_detection_threshold") if obj.get("scene_detection_threshold") is not None else 0.3,
            "use_whisper_asr": obj.get("use_whisper_asr") if obj.get("use_whisper_asr") is not None else True,
            "expand_to_granular_docs": obj.get("expand_to_granular_docs") if obj.get("expand_to_granular_docs") is not None else True,
            "ocr_frames_per_segment": obj.get("ocr_frames_per_segment") if obj.get("ocr_frames_per_segment") is not None else 3,
            "pdf_extraction_mode": obj.get("pdf_extraction_mode") if obj.get("pdf_extraction_mode") is not None else 'per_element',
            "pdf_render_dpi": obj.get("pdf_render_dpi") if obj.get("pdf_render_dpi") is not None else 150,
            "detect_code_in_pdf": obj.get("detect_code_in_pdf") if obj.get("detect_code_in_pdf") is not None else True,
            "segment_functions": obj.get("segment_functions") if obj.get("segment_functions") is not None else True,
            "supported_languages": obj.get("supported_languages"),
            "run_text_embedding": obj.get("run_text_embedding") if obj.get("run_text_embedding") is not None else True,
            "run_code_embedding": obj.get("run_code_embedding") if obj.get("run_code_embedding") is not None else True,
            "run_visual_embedding": obj.get("run_visual_embedding") if obj.get("run_visual_embedding") is not None else False,
            "visual_embedding_use_case": obj.get("visual_embedding_use_case") if obj.get("visual_embedding_use_case") is not None else 'lecture',
            "extract_screen_text": obj.get("extract_screen_text") if obj.get("extract_screen_text") is not None else True,
            "generate_thumbnails": obj.get("generate_thumbnails") if obj.get("generate_thumbnails") is not None else True,
            "use_cdn": obj.get("use_cdn") if obj.get("use_cdn") is not None else False,
            "enrich_with_llm": obj.get("enrich_with_llm") if obj.get("enrich_with_llm") is not None else False,
            "llm_prompt": obj.get("llm_prompt") if obj.get("llm_prompt") is not None else 'Summarize this educational content segment, highlighting key concepts.'
        })
        return _obj


