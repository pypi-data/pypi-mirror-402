# coding: utf-8

"""
    Mixpeek API

    This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.

    The version of the OpenAPI document: 1.3.0
    Contact: info@mixpeek.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from mixpeek.models.field_passthrough import FieldPassthrough
from mixpeek.models.input_mappings import InputMappings
from mixpeek.models.parameters import Parameters
from typing import Optional, Set
from typing_extensions import Self

class SharedCollectionFeaturesExtractorsModelsFeatureExtractorConfigOutput(BaseModel):
    """
    Configuration for a feature extractor with field passthrough support.  A feature extractor processes source data (from buckets or collections) and produces features (embeddings, extracted text, detected objects, etc.).  With field passthrough, you can also include selected source fields in the output documents alongside the computed features.  Core Concepts:     1. **Feature Extraction**: Extractors compute features from input data        (e.g., text → embeddings, image → detections, video → scenes)     2. **Field Passthrough**: Selectively preserve source fields in output        (e.g., title, category, campaign_id from source → output documents)     3. **Output Schema**: Combination of passed-through fields + extractor outputs        (e.g., {title, category, text_embedding} all in one document)  How Field Passthrough Works:     1. Define which source fields to include via field_passthrough list     2. During processing, these fields are extracted from source     3. They appear in output documents at root level     4. Combine with extractor outputs for complete documents     5. Use target_path to rename fields for cleaner schemas  Field Selection Modes:     - **Explicit** (field_passthrough + include_all=False):       Only listed fields pass through. Clean, controlled output.       Example: passthrough=[title, category] → output has ONLY title, category, embedding      - **Inclusive** (include_all=True):       All source fields pass through, field_passthrough for renaming.       Example: source has 10 fields → output has all 10 + embedding      - **None** (no field_passthrough):       Only extractor outputs in documents.       Example: → output has ONLY embedding (no source fields)  Use Cases:     - **Preserve Identifiers**: Keep campaign_id, product_sku, order_id for tracking     - **Enable Filtering**: Pass category, status, department for query filters     - **Maintain Context**: Include title, description for display     - **Track Metadata**: Preserve author, created_at, source for lineage     - **Business Logic**: Keep priority, region, type for application logic  Common Patterns:     1. **Minimal Passthrough** (recommended):        field_passthrough=[{\"source_path\": \"id\"}], include_all=False        → Clean output, only ID + extractor features      2. **Metadata Preservation**:        field_passthrough=[            {\"source_path\": \"title\"},            {\"source_path\": \"category\"},            {\"source_path\": \"created_at\"}        ]        → Document has context for display and filtering      3. **Field Renaming**:        field_passthrough=[            {\"source_path\": \"doc_title\", \"target_path\": \"title\"},            {\"source_path\": \"metadata.author\", \"target_path\": \"author\"}        ]        → Cleaner output schema with flattened fields      4. **Required Fields**:        field_passthrough=[            {\"source_path\": \"campaign_id\", \"required\": True},            {\"source_path\": \"priority\", \"default\": 0}        ]        → Ensures critical fields always present  Requirements:     - feature_extractor_name: REQUIRED - name of the extractor     - version: REQUIRED - extractor version (e.g., \"v1\")     - parameters: NOT REQUIRED - extractor-specific config (model, thresholds, etc.)     - input_mappings: NOT REQUIRED - maps extractor inputs to source fields     - field_passthrough: NOT REQUIRED - which source fields to preserve (default: none)     - include_all_source_fields: NOT REQUIRED - preserve all fields (default: false)
    """ # noqa: E501
    feature_extractor_name: StrictStr = Field(description="Name of the feature extractor")
    version: StrictStr = Field(description="Version of the feature extractor")
    params: Optional[Dict[str, Any]] = Field(default=None, description="Optional extractor parameters that affect vector index configuration. Parameters set here are locked at namespace creation and determine vector dimensions in Qdrant. Collections using this extractor must use compatible params. Example: {'model': 'siglip_base'}")
    parameters: Optional[Parameters] = None
    input_mappings: Optional[InputMappings] = None
    field_passthrough: Optional[List[FieldPassthrough]] = Field(default=None, description="NOT REQUIRED. List of specific fields to pass through from source to output documents. These fields are included alongside extractor-computed features (embeddings, detections, etc.). Empty list = only extractor outputs in documents (default behavior). With entries = specified fields + extractor outputs in documents.   How It Works: 1. During processing, fields are extracted from source object/document 2. They appear in output documents at the root level 3. Field filtering happens automatically (only listed fields included) 4. Use target_path to rename fields for cleaner schemas  Common Use Cases: - Preserve identifiers: campaign_id, product_sku, order_id - Keep metadata: category, tags, author, created_at - Enable filtering: department, status, priority, region - Maintain context: title, description, source_url  Behavior: - Works with include_all_source_fields=False (default): ONLY these fields included - Works with include_all_source_fields=True: These configs used for renaming/defaults - Fields must exist in source bucket_schema or upstream collection output_schema - Missing optional fields are omitted (unless default provided) - Missing required fields cause processing errors  Output Schema: output_schema = field_passthrough fields + extractor output fields Example: ['title', 'category', 'text_extractor_v1_embedding']")
    include_all_source_fields: Optional[StrictBool] = Field(default=False, description="NOT REQUIRED. Whether to include ALL fields from source object/document in output. Default: False (only field_passthrough fields included).   When False (RECOMMENDED): - Only fields listed in field_passthrough are included in output - Creates clean, predictable output schemas - Prevents data leakage of unwanted fields - Output = field_passthrough fields + extractor outputs  When True (USE WITH CAUTION): - ALL source fields are included in output documents - field_passthrough still used for renaming/defaults/requirements - Can result in large documents if source has many fields - Can leak sensitive or unnecessary data - Output = all source fields + extractor outputs  Use True When: - You want to preserve complete source data - Source has limited, well-defined fields - Downstream processing needs all context  Use False When (MOST CASES): - You want clean, controlled output schemas - Source has many fields you don't need - You want explicit field selection - You're concerned about document size  Examples: False: source={a,b,c,d} + passthrough=[a,b] → output={a,b,embedding} True:  source={a,b,c,d} + passthrough=[a→x] → output={x,b,c,d,embedding}")
    feature_extractor_id: StrictStr = Field(description="Construct unique identifier for the feature extractor instance (name + version).")
    __properties: ClassVar[List[str]] = ["feature_extractor_name", "version", "params", "parameters", "input_mappings", "field_passthrough", "include_all_source_fields", "feature_extractor_id"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SharedCollectionFeaturesExtractorsModelsFeatureExtractorConfigOutput from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "feature_extractor_id",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of parameters
        if self.parameters:
            _dict['parameters'] = self.parameters.to_dict()
        # override the default output from pydantic by calling `to_dict()` of input_mappings
        if self.input_mappings:
            _dict['input_mappings'] = self.input_mappings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in field_passthrough (list)
        _items = []
        if self.field_passthrough:
            for _item_field_passthrough in self.field_passthrough:
                if _item_field_passthrough:
                    _items.append(_item_field_passthrough.to_dict())
            _dict['field_passthrough'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SharedCollectionFeaturesExtractorsModelsFeatureExtractorConfigOutput from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "feature_extractor_name": obj.get("feature_extractor_name"),
            "version": obj.get("version"),
            "params": obj.get("params"),
            "parameters": Parameters.from_dict(obj["parameters"]) if obj.get("parameters") is not None else None,
            "input_mappings": InputMappings.from_dict(obj["input_mappings"]) if obj.get("input_mappings") is not None else None,
            "field_passthrough": [FieldPassthrough.from_dict(_item) for _item in obj["field_passthrough"]] if obj.get("field_passthrough") is not None else None,
            "include_all_source_fields": obj.get("include_all_source_fields") if obj.get("include_all_source_fields") is not None else False,
            "feature_extractor_id": obj.get("feature_extractor_id")
        })
        return _obj


