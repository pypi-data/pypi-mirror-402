# coding: utf-8

"""
    Mixpeek API

    This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.

    The version of the OpenAPI document: 1.3.0
    Contact: info@mixpeek.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ContentInput1(BaseModel):
    """
    Generic content input for automatic content-type detection.  Used for URL or base64 inputs where the content type is not known upfront. The system will automatically detect the content type (image, video, text, etc.) and route to the appropriate feature extractor.  **IMPORTANT**: Exactly one of `url` or `base64` must be provided (mutually exclusive).  Use Cases:     - User provides a URL without specifying content type     - Client sends base64-encoded content     - Generic search where query can be any modality  Requirements:     - Provide exactly ONE: url OR base64 (mutually exclusive)     - System performs automatic content type detection     - Supported content types: images, videos, audio, documents  Examples:     URL input:         ```json         {\"url\": \"https://example.com/image.jpg\"}         ```      Base64 image input:         ```json         {\"base64\": \"data:image/jpeg;base64,/9j/4AAQSkZJRg...\"}         ```      Base64 video input:         ```json         {\"base64\": \"data:video/mp4;base64,AAAAIGZ0eXBpc2...\"}         ```
    """ # noqa: E501
    url: Optional[StrictStr] = Field(default=None, description="OPTIONAL. URL to content for embedding generation. Mutually exclusive with base64 - provide exactly one. System will automatically detect content type (image, video, text, etc.) via HTTP HEAD request and/or file extension analysis. Supported protocols: HTTP, HTTPS, S3 (for Mixpeek-managed buckets). S3 URLs must point to the configured AWS_BUCKET. Examples: image URL, video URL, text file URL, S3 object path.")
    var_base64: Optional[StrictStr] = Field(default=None, description="OPTIONAL. Base64-encoded content for embedding generation. Mutually exclusive with url - provide exactly one. Can include data URI scheme (data:mime/type;base64,...) or just base64 string. System will automatically detect content type from data URI or by decoding. Supported types: images, videos, audio, documents. Maximum size: Limited by your namespace configuration.", alias="base64")
    __properties: ClassVar[List[str]] = ["url", "base64"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ContentInput1 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ContentInput1 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "url": obj.get("url"),
            "base64": obj.get("base64")
        })
        return _obj


