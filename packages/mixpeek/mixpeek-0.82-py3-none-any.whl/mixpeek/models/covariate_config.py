# coding: utf-8

"""
    Mixpeek API

    This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.

    The version of the OpenAPI document: 0.82
    Contact: info@mixpeek.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from mixpeek.models.covariate_type import CovariateType
from typing import Optional, Set
from typing_extensions import Self

class CovariateConfig(BaseModel):
    """
    Configuration for a single covariate/predictor variable in step analytics.  Covariates are used to identify which features predict conversion from one step to another. The system computes \"lift\" for each covariate value, showing whether it increases or decreases conversion likelihood.  Attributes:     field_path: JSONPath to the field in document or metadata (e.g., \"sender_domain\")     covariate_type: How to analyze this covariate (categorical, numeric, embedding, cluster)     name: Human-readable name for analytics results     binning_strategy: For NUMERIC types, how to bin values (quartiles, deciles)     clustering_method: For EMBEDDING types, algorithm to use (kmeans, hdbscan)     n_clusters: For EMBEDDING types, number of clusters to create  Examples:     ```python     # Analyze sender domains (categorical)     CovariateConfig(         field_path=\"sender_domain\",         covariate_type=\"categorical\",         name=\"Email Domain\"     )      # Analyze email length (numeric with quartile binning)     CovariateConfig(         field_path=\"word_count\",         covariate_type=\"numeric\",         name=\"Word Count\",         binning_strategy=\"quartiles\"     )      # Analyze visual similarity (embedding clustering)     CovariateConfig(         field_path=\"features.clip_embedding\",         covariate_type=\"embedding\",         name=\"Visual Cluster\",         clustering_method=\"kmeans\",         n_clusters=10     )     ```
    """ # noqa: E501
    field_path: StrictStr = Field(description="Dot-notation path to covariate field (e.g., 'sender_domain', 'metadata.priority')")
    covariate_type: CovariateType = Field(description="Type of covariate determines analysis strategy (categorical/numeric/embedding/cluster)")
    name: Annotated[str, Field(min_length=1, strict=True, max_length=100)] = Field(description="Human-readable name for this covariate in analytics results")
    binning_strategy: Optional[StrictStr] = Field(default='quartiles', description="How to bin numeric values for lift analysis (only used for NUMERIC type)")
    clustering_method: Optional[StrictStr] = Field(default='kmeans', description="Clustering algorithm for embedding analysis (only used for EMBEDDING type)")
    n_clusters: Optional[Annotated[int, Field(le=100, strict=True, ge=2)]] = Field(default=10, description="Number of clusters for embedding-based predictors (only used for EMBEDDING type)")
    __properties: ClassVar[List[str]] = ["field_path", "covariate_type", "name", "binning_strategy", "clustering_method", "n_clusters"]

    @field_validator('binning_strategy')
    def binning_strategy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['quartiles', 'deciles', 'custom']):
            raise ValueError("must be one of enum values ('quartiles', 'deciles', 'custom')")
        return value

    @field_validator('clustering_method')
    def clustering_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['kmeans', 'hdbscan']):
            raise ValueError("must be one of enum values ('kmeans', 'hdbscan')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CovariateConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CovariateConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "field_path": obj.get("field_path"),
            "covariate_type": obj.get("covariate_type"),
            "name": obj.get("name"),
            "binning_strategy": obj.get("binning_strategy") if obj.get("binning_strategy") is not None else 'quartiles',
            "clustering_method": obj.get("clustering_method") if obj.get("clustering_method") is not None else 'kmeans',
            "n_clusters": obj.get("n_clusters") if obj.get("n_clusters") is not None else 10
        })
        return _obj


