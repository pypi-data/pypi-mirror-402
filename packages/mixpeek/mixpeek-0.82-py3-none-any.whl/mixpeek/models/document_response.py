# coding: utf-8

"""
    Mixpeek API

    This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.

    The version of the OpenAPI document: 0.82
    Contact: info@mixpeek.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from mixpeek.models.blob_url_ref import BlobURLRef
from mixpeek.models.internal_payload_model import InternalPayloadModel
from typing import Optional, Set
from typing_extensions import Self

class DocumentResponse(BaseModel):
    """
    Response model for a single document.  This is the standard response format when fetching documents via API endpoints. Contains all document data plus optional presigned URLs for S3 blobs.  The document payload structure follows native Qdrant format:     - System fields are stored in `_internal` (lineage, metadata, blobs, etc.)     - User fields are at root level (brand_name, thumbnail_url, etc.)     - Only document_id and collection_id are Mixpeek IDs at root level     - No duplication between root and _internal  Query Parameters Affecting Response:     - return_url=true: Adds presigned_url to each document_blobs entry     - return_vectors=true: Includes embedding arrays in response  Use Cases:     - Display document details in UI     - Download source files or generated artifacts     - Understand document provenance and processing     - Access enrichment fields (flat) for filtering/display
    """ # noqa: E501
    document_id: StrictStr = Field(description="REQUIRED. Unique identifier for the document. Format: 'doc_' prefix + alphanumeric characters. Use for: API queries, references, filtering.")
    collection_id: StrictStr = Field(description="REQUIRED. ID of the collection this document belongs to. Format: 'col_' prefix + alphanumeric characters. Use for: Collection-scoped queries, filtering.")
    document_blobs: Optional[List[BlobURLRef]] = Field(default=None, description="Document blobs with presigned URLs when requested")
    internal: Optional[InternalPayloadModel] = Field(default=None, description="System-managed internal fields. Contains all Mixpeek-managed metadata including lineage, processing info, timestamps, and blob references. User-defined fields appear at root level alongside document_id and collection_id.", alias="_internal")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["document_id", "collection_id", "document_blobs", "_internal"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DocumentResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in document_blobs (list)
        _items = []
        if self.document_blobs:
            for _item_document_blobs in self.document_blobs:
                if _item_document_blobs:
                    _items.append(_item_document_blobs.to_dict())
            _dict['document_blobs'] = _items
        # override the default output from pydantic by calling `to_dict()` of internal
        if self.internal:
            _dict['_internal'] = self.internal.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DocumentResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "document_id": obj.get("document_id"),
            "collection_id": obj.get("collection_id"),
            "document_blobs": [BlobURLRef.from_dict(_item) for _item in obj["document_blobs"]] if obj.get("document_blobs") is not None else None,
            "_internal": InternalPayloadModel.from_dict(obj["_internal"]) if obj.get("_internal") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj


