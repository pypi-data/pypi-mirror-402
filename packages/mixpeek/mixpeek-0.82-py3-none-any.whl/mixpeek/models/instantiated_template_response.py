# coding: utf-8

"""
    Mixpeek API

    This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.

    The version of the OpenAPI document: 0.82
    Contact: info@mixpeek.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class InstantiatedTemplateResponse(BaseModel):
    """
    Response after successful template instantiation.  Provides all information needed to start using the newly created namespace, including IDs for API calls and status information.  The namespace is immediately ready for use when status is 'ready'. All collections, documents, and feature stores are fully functional.  Use Cases:     - Retrieve namespace_id for subsequent API calls     - Verify instantiation completed successfully     - Track which template was used for the namespace     - Record creation timestamp for auditing  Fields:     All fields are REQUIRED and populated by the server.
    """ # noqa: E501
    namespace_id: StrictStr = Field(description="ID of the newly created namespace. REQUIRED. Use this ID in the X-Namespace header for all API calls to this namespace. Format: namespace ID starting with 'ns_'. Permanent identifier for the namespace.")
    namespace_name: StrictStr = Field(description="Name of the newly created namespace. REQUIRED. Matches the namespace_name from the request. Human-readable identifier shown in UI. Can be used for namespace lookup via GET /namespaces/{name}.")
    template_id: StrictStr = Field(description="ID of the template that was instantiated. REQUIRED. Reference to the source template used for creation. Useful for tracking which template produced this namespace. Format: template ID starting with 'tmpl_'.")
    status: Optional[StrictStr] = Field(default='cloning', description="Instantiation status. REQUIRED. 'cloning' means the namespace is being created and data is being copied. 'ready' means the namespace is fully functional and ready to use. 'failed' means the cloning process encountered an error. Poll GET /namespaces/{namespace_id} to check when status becomes 'ready'. All data is cloned including collections, vectors, retrievers, and taxonomies.")
    task_id: Optional[StrictStr] = Field(default=None, description="Celery task ID for tracking the clone operation. Can be used to poll task status if needed. Format: UUID string.")
    created_at: Optional[datetime] = Field(default=None, description="Timestamp when namespace was created. REQUIRED. Auto-generated by server. Format: ISO 8601 datetime in UTC. Used for auditing and sorting namespaces by creation time.")
    __properties: ClassVar[List[str]] = ["namespace_id", "namespace_name", "template_id", "status", "task_id", "created_at"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of InstantiatedTemplateResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of InstantiatedTemplateResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "namespace_id": obj.get("namespace_id"),
            "namespace_name": obj.get("namespace_name"),
            "template_id": obj.get("template_id"),
            "status": obj.get("status") if obj.get("status") is not None else 'cloning',
            "task_id": obj.get("task_id"),
            "created_at": obj.get("created_at")
        })
        return _obj


