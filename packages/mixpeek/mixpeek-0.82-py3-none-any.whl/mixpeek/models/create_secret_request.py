# coding: utf-8

"""
    Mixpeek API

    This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.

    The version of the OpenAPI document: 0.82
    Contact: info@mixpeek.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class CreateSecretRequest(BaseModel):
    """
    Request to create a new secret in the organization vault.  Secrets are encrypted at rest using Fernet encryption and stored in the organization document. Use secrets to securely store API keys, tokens, and credentials for external services.  **Use Cases**: - Store API keys for Stripe, GitHub, OpenAI, etc. - Manage authentication tokens for api_call retriever stage - Store credentials for third-party integrations  **Security**: - Secret values are encrypted using ENCRYPTION_KEY from environment - Decrypted values are NEVER returned in API responses - Only secret names are exposed in list operations - Access is logged for audit trail  **Requirements**: - secret_name: REQUIRED, must be unique within organization - secret_value: REQUIRED, plaintext value to encrypt  **Permissions**: Requires ADMIN permission to create secrets.
    """ # noqa: E501
    secret_name: Annotated[str, Field(min_length=1, strict=True, max_length=100)] = Field(description="REQUIRED. Name/key for the secret. Use descriptive names that indicate the service and purpose. Must be unique within the organization. Format: lowercase with underscores (e.g., 'stripe_api_key'). Common patterns: '{service}_{type}_{environment}' like 'stripe_api_key_prod'. This name is used to reference the secret in api_call stage configuration. Examples: 'stripe_api_key', 'github_token', 'openai_api_key', 'weather_api_key'.")
    secret_value: Annotated[str, Field(min_length=1, strict=True)] = Field(description="REQUIRED. Plaintext secret value to encrypt and store. This value will be encrypted at rest using Fernet encryption. The encrypted value is stored in MongoDB with the organization document. The plaintext value is NEVER logged or exposed in API responses. Only the secret name is visible when listing secrets. Use this field to store: API keys, tokens, passwords, credentials. Format: any string (will be encrypted as-is). For Basic auth, use format 'username:password'.")
    __properties: ClassVar[List[str]] = ["secret_name", "secret_value"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateSecretRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateSecretRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "secret_name": obj.get("secret_name"),
            "secret_value": obj.get("secret_value")
        })
        return _obj


