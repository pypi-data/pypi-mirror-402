# coding: utf-8

"""
    Mixpeek API

    This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.

    The version of the OpenAPI document: 0.82
    Contact: info@mixpeek.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from mixpeek.models.base_feature_extractor_model_input import BaseFeatureExtractorModelInput
from mixpeek.models.namespace_infrastructure import NamespaceInfrastructure
from mixpeek.models.payload_index_config_input import PayloadIndexConfigInput
from typing import Optional, Set
from typing_extensions import Self

class CreateNamespaceRequest(BaseModel):
    """
    Request schema for creating a new namespace.
    """ # noqa: E501
    namespace_name: StrictStr = Field(description="Name of the namespace to create")
    description: Optional[StrictStr] = Field(default=None, description="Description of the namespace")
    feature_extractors: Annotated[List[BaseFeatureExtractorModelInput], Field(min_length=1)] = Field(description="List of feature extractors to use. At least one feature extractor must be provided. Optional 'params' can be specified for extractors with configurable settings (e.g., model selection) that affect vector dimensions. These params are locked at namespace creation time.")
    payload_indexes: Optional[List[PayloadIndexConfigInput]] = Field(default=None, description="Optional list of custom payload index configurations. Indexes required by selected feature extractors will be added automatically.")
    auto_create_indexes: Optional[StrictBool] = Field(default=False, description="Enable automatic creation of Qdrant payload indexes based on filter usage patterns. When enabled, the system tracks which fields are most frequently filtered (>100 queries/24h) and automatically creates indexes to improve query performance. Background task runs every 6 hours. Expected performance improvement: 50-90% latency reduction for filtered queries.")
    infrastructure: Optional[NamespaceInfrastructure] = Field(default=None, description="Optional dedicated infrastructure configuration for this namespace. Required for custom plugins and custom models (Enterprise tier). If None, uses shared infrastructure or organization-level infrastructure.")
    __properties: ClassVar[List[str]] = ["namespace_name", "description", "feature_extractors", "payload_indexes", "auto_create_indexes", "infrastructure"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateNamespaceRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in feature_extractors (list)
        _items = []
        if self.feature_extractors:
            for _item_feature_extractors in self.feature_extractors:
                if _item_feature_extractors:
                    _items.append(_item_feature_extractors.to_dict())
            _dict['feature_extractors'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in payload_indexes (list)
        _items = []
        if self.payload_indexes:
            for _item_payload_indexes in self.payload_indexes:
                if _item_payload_indexes:
                    _items.append(_item_payload_indexes.to_dict())
            _dict['payload_indexes'] = _items
        # override the default output from pydantic by calling `to_dict()` of infrastructure
        if self.infrastructure:
            _dict['infrastructure'] = self.infrastructure.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateNamespaceRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "namespace_name": obj.get("namespace_name"),
            "description": obj.get("description"),
            "feature_extractors": [BaseFeatureExtractorModelInput.from_dict(_item) for _item in obj["feature_extractors"]] if obj.get("feature_extractors") is not None else None,
            "payload_indexes": [PayloadIndexConfigInput.from_dict(_item) for _item in obj["payload_indexes"]] if obj.get("payload_indexes") is not None else None,
            "auto_create_indexes": obj.get("auto_create_indexes") if obj.get("auto_create_indexes") is not None else False,
            "infrastructure": NamespaceInfrastructure.from_dict(obj["infrastructure"]) if obj.get("infrastructure") is not None else None
        })
        return _obj


