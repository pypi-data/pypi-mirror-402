# coding: utf-8

"""
    Mixpeek API

    This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.

    The version of the OpenAPI document: 0.82
    Contact: info@mixpeek.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr
from typing import Any, Optional
from typing_extensions import Annotated
from mixpeek.models.list_public_retrievers_response import ListPublicRetrieversResponse
from mixpeek.models.public_interaction_batch_request import PublicInteractionBatchRequest
from mixpeek.models.public_interaction_request import PublicInteractionRequest
from mixpeek.models.public_retriever_config_response import PublicRetrieverConfigResponse
from mixpeek.models.public_retriever_template_response import PublicRetrieverTemplateResponse
from mixpeek.models.retriever_execution_request import RetrieverExecutionRequest
from mixpeek.models.verify_password_request import VerifyPasswordRequest
from mixpeek.models.verify_password_response import VerifyPasswordResponse

from mixpeek.api_client import ApiClient, RequestSerialized
from mixpeek.api_response import ApiResponse
from mixpeek.rest import RESTResponseType


class PublicRetrieverAPIApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def execute_retriever_name(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        x_public_api_key: StrictStr,
        retriever_execution_request: RetrieverExecutionRequest,
        return_presigned_urls: Annotated[Optional[StrictBool], Field(description="Generate fresh presigned download URLs for all blobs with S3 storage. Default: True for public retrievers to enable media rendering. Set to False if you only need metadata without URLs.")] = None,
        x_retriever_password: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Execute Public Retriever

        Execute a published retriever (public endpoint).  **Authentication:** - Requires `X-Public-API-Key` header with the retriever's public API key - If password-protected, also requires `X-Retriever-Password` header  **Rate Limiting:** - Subject to per-retriever rate limits (per minute/hour/day) - May also have IP-based rate limits  **Response:** - Only returns fields specified in `exposed_fields` configuration - Internal metadata is stripped from results - Includes `execution_id` for interaction tracking - Presigned URLs returned by default (return_presigned_urls=true) for media rendering  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/execute\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"inputs\": {\"query\": \"red car\"},     \"pagination\": {\"method\": \"offset\", \"page_number\": 1, \"page_size\": 10}   }' ```  **Example with return_presigned_urls disabled:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/execute?return_presigned_urls=false\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"inputs\": {\"query\": \"red car\"},     \"pagination\": {\"method\": \"offset\", \"page_number\": 1, \"page_size\": 10}   }' ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param x_public_api_key: (required)
        :type x_public_api_key: str
        :param retriever_execution_request: (required)
        :type retriever_execution_request: RetrieverExecutionRequest
        :param return_presigned_urls: Generate fresh presigned download URLs for all blobs with S3 storage. Default: True for public retrievers to enable media rendering. Set to False if you only need metadata without URLs.
        :type return_presigned_urls: bool
        :param x_retriever_password:
        :type x_retriever_password: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._execute_retriever_name_serialize(
            public_name=public_name,
            x_public_api_key=x_public_api_key,
            retriever_execution_request=retriever_execution_request,
            return_presigned_urls=return_presigned_urls,
            x_retriever_password=x_retriever_password,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def execute_retriever_name_with_http_info(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        x_public_api_key: StrictStr,
        retriever_execution_request: RetrieverExecutionRequest,
        return_presigned_urls: Annotated[Optional[StrictBool], Field(description="Generate fresh presigned download URLs for all blobs with S3 storage. Default: True for public retrievers to enable media rendering. Set to False if you only need metadata without URLs.")] = None,
        x_retriever_password: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Execute Public Retriever

        Execute a published retriever (public endpoint).  **Authentication:** - Requires `X-Public-API-Key` header with the retriever's public API key - If password-protected, also requires `X-Retriever-Password` header  **Rate Limiting:** - Subject to per-retriever rate limits (per minute/hour/day) - May also have IP-based rate limits  **Response:** - Only returns fields specified in `exposed_fields` configuration - Internal metadata is stripped from results - Includes `execution_id` for interaction tracking - Presigned URLs returned by default (return_presigned_urls=true) for media rendering  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/execute\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"inputs\": {\"query\": \"red car\"},     \"pagination\": {\"method\": \"offset\", \"page_number\": 1, \"page_size\": 10}   }' ```  **Example with return_presigned_urls disabled:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/execute?return_presigned_urls=false\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"inputs\": {\"query\": \"red car\"},     \"pagination\": {\"method\": \"offset\", \"page_number\": 1, \"page_size\": 10}   }' ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param x_public_api_key: (required)
        :type x_public_api_key: str
        :param retriever_execution_request: (required)
        :type retriever_execution_request: RetrieverExecutionRequest
        :param return_presigned_urls: Generate fresh presigned download URLs for all blobs with S3 storage. Default: True for public retrievers to enable media rendering. Set to False if you only need metadata without URLs.
        :type return_presigned_urls: bool
        :param x_retriever_password:
        :type x_retriever_password: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._execute_retriever_name_serialize(
            public_name=public_name,
            x_public_api_key=x_public_api_key,
            retriever_execution_request=retriever_execution_request,
            return_presigned_urls=return_presigned_urls,
            x_retriever_password=x_retriever_password,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def execute_retriever_name_without_preload_content(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        x_public_api_key: StrictStr,
        retriever_execution_request: RetrieverExecutionRequest,
        return_presigned_urls: Annotated[Optional[StrictBool], Field(description="Generate fresh presigned download URLs for all blobs with S3 storage. Default: True for public retrievers to enable media rendering. Set to False if you only need metadata without URLs.")] = None,
        x_retriever_password: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Execute Public Retriever

        Execute a published retriever (public endpoint).  **Authentication:** - Requires `X-Public-API-Key` header with the retriever's public API key - If password-protected, also requires `X-Retriever-Password` header  **Rate Limiting:** - Subject to per-retriever rate limits (per minute/hour/day) - May also have IP-based rate limits  **Response:** - Only returns fields specified in `exposed_fields` configuration - Internal metadata is stripped from results - Includes `execution_id` for interaction tracking - Presigned URLs returned by default (return_presigned_urls=true) for media rendering  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/execute\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"inputs\": {\"query\": \"red car\"},     \"pagination\": {\"method\": \"offset\", \"page_number\": 1, \"page_size\": 10}   }' ```  **Example with return_presigned_urls disabled:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/execute?return_presigned_urls=false\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"inputs\": {\"query\": \"red car\"},     \"pagination\": {\"method\": \"offset\", \"page_number\": 1, \"page_size\": 10}   }' ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param x_public_api_key: (required)
        :type x_public_api_key: str
        :param retriever_execution_request: (required)
        :type retriever_execution_request: RetrieverExecutionRequest
        :param return_presigned_urls: Generate fresh presigned download URLs for all blobs with S3 storage. Default: True for public retrievers to enable media rendering. Set to False if you only need metadata without URLs.
        :type return_presigned_urls: bool
        :param x_retriever_password:
        :type x_retriever_password: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._execute_retriever_name_serialize(
            public_name=public_name,
            x_public_api_key=x_public_api_key,
            retriever_execution_request=retriever_execution_request,
            return_presigned_urls=return_presigned_urls,
            x_retriever_password=x_retriever_password,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _execute_retriever_name_serialize(
        self,
        public_name,
        x_public_api_key,
        retriever_execution_request,
        return_presigned_urls,
        x_retriever_password,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if public_name is not None:
            _path_params['public_name'] = public_name
        # process the query parameters
        if return_presigned_urls is not None:
            
            _query_params.append(('return_presigned_urls', return_presigned_urls))
            
        # process the header parameters
        if x_public_api_key is not None:
            _header_params['X-Public-API-Key'] = x_public_api_key
        if x_retriever_password is not None:
            _header_params['X-Retriever-Password'] = x_retriever_password
        # process the form parameters
        # process the body parameter
        if retriever_execution_request is not None:
            _body_params = retriever_execution_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/public/retrievers/{public_name}/execute',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_retriever_config_name(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PublicRetrieverConfigResponse:
        """Get Public Retriever Config

        Get display configuration for public page rendering.  Returns the UI configuration needed to render the public search interface. Used by the frontend app at apps.mixpeek.com to dynamically build the UI.  **Authentication:** - NO authentication required - this endpoint is public - Anyone can access the config if they know the public_name - The config includes the public_api_key needed for execute/interact endpoints  **Response includes:** - Display config (logo, theme, components, field rendering) - Title and description - Password protection status - Public API key for subsequent authenticated requests  **Example:** ```bash curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/video-search/config\" ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retriever_config_name_serialize(
            public_name=public_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PublicRetrieverConfigResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_retriever_config_name_with_http_info(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PublicRetrieverConfigResponse]:
        """Get Public Retriever Config

        Get display configuration for public page rendering.  Returns the UI configuration needed to render the public search interface. Used by the frontend app at apps.mixpeek.com to dynamically build the UI.  **Authentication:** - NO authentication required - this endpoint is public - Anyone can access the config if they know the public_name - The config includes the public_api_key needed for execute/interact endpoints  **Response includes:** - Display config (logo, theme, components, field rendering) - Title and description - Password protection status - Public API key for subsequent authenticated requests  **Example:** ```bash curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/video-search/config\" ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retriever_config_name_serialize(
            public_name=public_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PublicRetrieverConfigResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_retriever_config_name_without_preload_content(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Public Retriever Config

        Get display configuration for public page rendering.  Returns the UI configuration needed to render the public search interface. Used by the frontend app at apps.mixpeek.com to dynamically build the UI.  **Authentication:** - NO authentication required - this endpoint is public - Anyone can access the config if they know the public_name - The config includes the public_api_key needed for execute/interact endpoints  **Response includes:** - Display config (logo, theme, components, field rendering) - Title and description - Password protection status - Public API key for subsequent authenticated requests  **Example:** ```bash curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/video-search/config\" ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retriever_config_name_serialize(
            public_name=public_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PublicRetrieverConfigResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_retriever_config_name_serialize(
        self,
        public_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if public_name is not None:
            _path_params['public_name'] = public_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/public/retrievers/{public_name}/config',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_retriever_template_name(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PublicRetrieverTemplateResponse:
        """Get Public Retriever Template

        Get retriever configuration as a reusable template.  Returns the published retriever's configuration in a format that can be directly used to create your own retriever. This is perfect for discovering patterns and adapting them to your own data.  **Authentication:** - NO authentication required - this endpoint is completely public - Anyone can get the template if they know the public_name  **Use Case:** 1. Browse public retrievers to find patterns you like 2. GET this endpoint to get the full configuration 3. Copy the config and modify for your needs (especially `collection_identifiers`) 4. POST to `/v1/retrievers` to create your own retriever 5. Optionally publish it with the same display_config  **What's included:** - Retriever configuration (stages, input_schema, budget_limits) - Display configuration (for publishing with similar UI) - Original metadata for reference  **What you need to change:** - `collection_identifiers`: Replace with your own collection IDs - `retriever_name`: Give it a unique name - Optionally modify stages, inputs, display_config as needed  **Example:** ```bash # 1. Get the template curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/video-search/template\"  # 2. Modify the response and create your own retriever curl -X POST \"https://api.mixpeek.com/v1/retrievers\" \\   -H \"Authorization: Bearer YOUR_API_KEY\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"retriever_name\": \"my_video_search\",     \"collection_identifiers\": [\"my_videos\"],     \"stages\": [...],  # From template     \"input_schema\": {...},  # From template     \"budget_limits\": {...},  # From template     \"display_config\": {...}  # From template (optional)   }' ```  **Response includes:** - All retriever configuration fields - Display config for publishing (optional to use) - Source reference (where this template came from)

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retriever_template_name_serialize(
            public_name=public_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PublicRetrieverTemplateResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_retriever_template_name_with_http_info(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PublicRetrieverTemplateResponse]:
        """Get Public Retriever Template

        Get retriever configuration as a reusable template.  Returns the published retriever's configuration in a format that can be directly used to create your own retriever. This is perfect for discovering patterns and adapting them to your own data.  **Authentication:** - NO authentication required - this endpoint is completely public - Anyone can get the template if they know the public_name  **Use Case:** 1. Browse public retrievers to find patterns you like 2. GET this endpoint to get the full configuration 3. Copy the config and modify for your needs (especially `collection_identifiers`) 4. POST to `/v1/retrievers` to create your own retriever 5. Optionally publish it with the same display_config  **What's included:** - Retriever configuration (stages, input_schema, budget_limits) - Display configuration (for publishing with similar UI) - Original metadata for reference  **What you need to change:** - `collection_identifiers`: Replace with your own collection IDs - `retriever_name`: Give it a unique name - Optionally modify stages, inputs, display_config as needed  **Example:** ```bash # 1. Get the template curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/video-search/template\"  # 2. Modify the response and create your own retriever curl -X POST \"https://api.mixpeek.com/v1/retrievers\" \\   -H \"Authorization: Bearer YOUR_API_KEY\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"retriever_name\": \"my_video_search\",     \"collection_identifiers\": [\"my_videos\"],     \"stages\": [...],  # From template     \"input_schema\": {...},  # From template     \"budget_limits\": {...},  # From template     \"display_config\": {...}  # From template (optional)   }' ```  **Response includes:** - All retriever configuration fields - Display config for publishing (optional to use) - Source reference (where this template came from)

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retriever_template_name_serialize(
            public_name=public_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PublicRetrieverTemplateResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_retriever_template_name_without_preload_content(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Public Retriever Template

        Get retriever configuration as a reusable template.  Returns the published retriever's configuration in a format that can be directly used to create your own retriever. This is perfect for discovering patterns and adapting them to your own data.  **Authentication:** - NO authentication required - this endpoint is completely public - Anyone can get the template if they know the public_name  **Use Case:** 1. Browse public retrievers to find patterns you like 2. GET this endpoint to get the full configuration 3. Copy the config and modify for your needs (especially `collection_identifiers`) 4. POST to `/v1/retrievers` to create your own retriever 5. Optionally publish it with the same display_config  **What's included:** - Retriever configuration (stages, input_schema, budget_limits) - Display configuration (for publishing with similar UI) - Original metadata for reference  **What you need to change:** - `collection_identifiers`: Replace with your own collection IDs - `retriever_name`: Give it a unique name - Optionally modify stages, inputs, display_config as needed  **Example:** ```bash # 1. Get the template curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/video-search/template\"  # 2. Modify the response and create your own retriever curl -X POST \"https://api.mixpeek.com/v1/retrievers\" \\   -H \"Authorization: Bearer YOUR_API_KEY\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"retriever_name\": \"my_video_search\",     \"collection_identifiers\": [\"my_videos\"],     \"stages\": [...],  # From template     \"input_schema\": {...},  # From template     \"budget_limits\": {...},  # From template     \"display_config\": {...}  # From template (optional)   }' ```  **Response includes:** - All retriever configuration fields - Display config for publishing (optional to use) - Source reference (where this template came from)

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retriever_template_name_serialize(
            public_name=public_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PublicRetrieverTemplateResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_retriever_template_name_serialize(
        self,
        public_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if public_name is not None:
            _path_params['public_name'] = public_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/public/retrievers/{public_name}/template',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_retrievers(
        self,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Page number (1-indexed)")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="Results per page")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="Include inactive retrievers in results")] = None,
        search: Annotated[Optional[StrictStr], Field(description="Search query for filtering by title or description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListPublicRetrieversResponse:
        """List Public Retrievers

        List all public retrievers with pagination and search.  This endpoint allows browsing and discovering all published retrievers across all organizations. No authentication required.  **Authentication:** - NO authentication required - completely public endpoint - Discover retrievers created by all Mixpeek users  **Pagination:** - Default: page=1, page_size=20 - Maximum page_size: 100 - Returns total count and total pages  **Search:** - Search across retriever titles and descriptions - Case-insensitive regex matching - Combine with pagination  **Filtering:** - By default, only active retrievers are shown - Set `include_inactive=true` to see all retrievers  **Response includes:** - List of public retrievers with basic info - Pagination details (page, page_size, total_count, total_pages) - Aggregate statistics (total active, password protected, open)  **What's NOT exposed:** - API keys (except in individual config endpoint) - Internal IDs or organization details - Full retriever configuration (use template endpoint for that) - Password values (only password_protected: true/false)  **Example:** ```bash # List all public retrievers (first page) curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/\"  # Search for video-related retrievers curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/?search=video&page_size=50\"  # Get page 2 with custom page size curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/?page=2&page_size=50\" ```  **Use Cases:** - Browse available public retrievers - Discover search patterns and implementations - Find retrievers to use as templates - Explore what others have built

        :param page: Page number (1-indexed)
        :type page: int
        :param page_size: Results per page
        :type page_size: int
        :param include_inactive: Include inactive retrievers in results
        :type include_inactive: bool
        :param search: Search query for filtering by title or description
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_retrievers_serialize(
            page=page,
            page_size=page_size,
            include_inactive=include_inactive,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPublicRetrieversResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_retrievers_with_http_info(
        self,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Page number (1-indexed)")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="Results per page")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="Include inactive retrievers in results")] = None,
        search: Annotated[Optional[StrictStr], Field(description="Search query for filtering by title or description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListPublicRetrieversResponse]:
        """List Public Retrievers

        List all public retrievers with pagination and search.  This endpoint allows browsing and discovering all published retrievers across all organizations. No authentication required.  **Authentication:** - NO authentication required - completely public endpoint - Discover retrievers created by all Mixpeek users  **Pagination:** - Default: page=1, page_size=20 - Maximum page_size: 100 - Returns total count and total pages  **Search:** - Search across retriever titles and descriptions - Case-insensitive regex matching - Combine with pagination  **Filtering:** - By default, only active retrievers are shown - Set `include_inactive=true` to see all retrievers  **Response includes:** - List of public retrievers with basic info - Pagination details (page, page_size, total_count, total_pages) - Aggregate statistics (total active, password protected, open)  **What's NOT exposed:** - API keys (except in individual config endpoint) - Internal IDs or organization details - Full retriever configuration (use template endpoint for that) - Password values (only password_protected: true/false)  **Example:** ```bash # List all public retrievers (first page) curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/\"  # Search for video-related retrievers curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/?search=video&page_size=50\"  # Get page 2 with custom page size curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/?page=2&page_size=50\" ```  **Use Cases:** - Browse available public retrievers - Discover search patterns and implementations - Find retrievers to use as templates - Explore what others have built

        :param page: Page number (1-indexed)
        :type page: int
        :param page_size: Results per page
        :type page_size: int
        :param include_inactive: Include inactive retrievers in results
        :type include_inactive: bool
        :param search: Search query for filtering by title or description
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_retrievers_serialize(
            page=page,
            page_size=page_size,
            include_inactive=include_inactive,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPublicRetrieversResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_retrievers_without_preload_content(
        self,
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="Page number (1-indexed)")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="Results per page")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="Include inactive retrievers in results")] = None,
        search: Annotated[Optional[StrictStr], Field(description="Search query for filtering by title or description")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Public Retrievers

        List all public retrievers with pagination and search.  This endpoint allows browsing and discovering all published retrievers across all organizations. No authentication required.  **Authentication:** - NO authentication required - completely public endpoint - Discover retrievers created by all Mixpeek users  **Pagination:** - Default: page=1, page_size=20 - Maximum page_size: 100 - Returns total count and total pages  **Search:** - Search across retriever titles and descriptions - Case-insensitive regex matching - Combine with pagination  **Filtering:** - By default, only active retrievers are shown - Set `include_inactive=true` to see all retrievers  **Response includes:** - List of public retrievers with basic info - Pagination details (page, page_size, total_count, total_pages) - Aggregate statistics (total active, password protected, open)  **What's NOT exposed:** - API keys (except in individual config endpoint) - Internal IDs or organization details - Full retriever configuration (use template endpoint for that) - Password values (only password_protected: true/false)  **Example:** ```bash # List all public retrievers (first page) curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/\"  # Search for video-related retrievers curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/?search=video&page_size=50\"  # Get page 2 with custom page size curl -X GET \"https://api.mixpeek.com/v1/public/retrievers/?page=2&page_size=50\" ```  **Use Cases:** - Browse available public retrievers - Discover search patterns and implementations - Find retrievers to use as templates - Explore what others have built

        :param page: Page number (1-indexed)
        :type page: int
        :param page_size: Results per page
        :type page_size: int
        :param include_inactive: Include inactive retrievers in results
        :type include_inactive: bool
        :param search: Search query for filtering by title or description
        :type search: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_retrievers_serialize(
            page=page,
            page_size=page_size,
            include_inactive=include_inactive,
            search=search,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPublicRetrieversResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_retrievers_serialize(
        self,
        page,
        page_size,
        include_inactive,
        search,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if page_size is not None:
            
            _query_params.append(('page_size', page_size))
            
        if include_inactive is not None:
            
            _query_params.append(('include_inactive', include_inactive))
            
        if search is not None:
            
            _query_params.append(('search', search))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/public/retrievers/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def track_interaction_batch_retrievers_name(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        x_public_api_key: StrictStr,
        public_interaction_batch_request: PublicInteractionBatchRequest,
        x_session_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Track Interaction Batch

        Track multiple interactions in a single request (batching).  More efficient than sending individual interaction requests. Use this for batching viewport visibility, bulk actions, etc.  **Authentication:** - Requires `X-Public-API-Key` header - Password NOT required (tracking should work even without auth)  **Recommended Headers:** - `X-Session-ID`: Applied to all interactions in the batch  **Limits:** - Maximum 100 interactions per batch  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/interactions/batch\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"X-Session-ID: sess_xyz...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"interactions\": [       {         \"document_id\": \"doc_123\",         \"interaction_type\": [\"VIEW\"],         \"position\": 0,         \"execution_id\": \"exec_abc\"       },       {         \"document_id\": \"doc_456\",         \"interaction_type\": [\"VIEW\"],         \"position\": 1,         \"execution_id\": \"exec_abc\"       }     ]   }' ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param x_public_api_key: (required)
        :type x_public_api_key: str
        :param public_interaction_batch_request: (required)
        :type public_interaction_batch_request: PublicInteractionBatchRequest
        :param x_session_id:
        :type x_session_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._track_interaction_batch_retrievers_name_serialize(
            public_name=public_name,
            x_public_api_key=x_public_api_key,
            public_interaction_batch_request=public_interaction_batch_request,
            x_session_id=x_session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def track_interaction_batch_retrievers_name_with_http_info(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        x_public_api_key: StrictStr,
        public_interaction_batch_request: PublicInteractionBatchRequest,
        x_session_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Track Interaction Batch

        Track multiple interactions in a single request (batching).  More efficient than sending individual interaction requests. Use this for batching viewport visibility, bulk actions, etc.  **Authentication:** - Requires `X-Public-API-Key` header - Password NOT required (tracking should work even without auth)  **Recommended Headers:** - `X-Session-ID`: Applied to all interactions in the batch  **Limits:** - Maximum 100 interactions per batch  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/interactions/batch\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"X-Session-ID: sess_xyz...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"interactions\": [       {         \"document_id\": \"doc_123\",         \"interaction_type\": [\"VIEW\"],         \"position\": 0,         \"execution_id\": \"exec_abc\"       },       {         \"document_id\": \"doc_456\",         \"interaction_type\": [\"VIEW\"],         \"position\": 1,         \"execution_id\": \"exec_abc\"       }     ]   }' ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param x_public_api_key: (required)
        :type x_public_api_key: str
        :param public_interaction_batch_request: (required)
        :type public_interaction_batch_request: PublicInteractionBatchRequest
        :param x_session_id:
        :type x_session_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._track_interaction_batch_retrievers_name_serialize(
            public_name=public_name,
            x_public_api_key=x_public_api_key,
            public_interaction_batch_request=public_interaction_batch_request,
            x_session_id=x_session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def track_interaction_batch_retrievers_name_without_preload_content(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        x_public_api_key: StrictStr,
        public_interaction_batch_request: PublicInteractionBatchRequest,
        x_session_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Track Interaction Batch

        Track multiple interactions in a single request (batching).  More efficient than sending individual interaction requests. Use this for batching viewport visibility, bulk actions, etc.  **Authentication:** - Requires `X-Public-API-Key` header - Password NOT required (tracking should work even without auth)  **Recommended Headers:** - `X-Session-ID`: Applied to all interactions in the batch  **Limits:** - Maximum 100 interactions per batch  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/interactions/batch\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"X-Session-ID: sess_xyz...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"interactions\": [       {         \"document_id\": \"doc_123\",         \"interaction_type\": [\"VIEW\"],         \"position\": 0,         \"execution_id\": \"exec_abc\"       },       {         \"document_id\": \"doc_456\",         \"interaction_type\": [\"VIEW\"],         \"position\": 1,         \"execution_id\": \"exec_abc\"       }     ]   }' ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param x_public_api_key: (required)
        :type x_public_api_key: str
        :param public_interaction_batch_request: (required)
        :type public_interaction_batch_request: PublicInteractionBatchRequest
        :param x_session_id:
        :type x_session_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._track_interaction_batch_retrievers_name_serialize(
            public_name=public_name,
            x_public_api_key=x_public_api_key,
            public_interaction_batch_request=public_interaction_batch_request,
            x_session_id=x_session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _track_interaction_batch_retrievers_name_serialize(
        self,
        public_name,
        x_public_api_key,
        public_interaction_batch_request,
        x_session_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if public_name is not None:
            _path_params['public_name'] = public_name
        # process the query parameters
        # process the header parameters
        if x_session_id is not None:
            _header_params['X-Session-ID'] = x_session_id
        if x_public_api_key is not None:
            _header_params['X-Public-API-Key'] = x_public_api_key
        # process the form parameters
        # process the body parameter
        if public_interaction_batch_request is not None:
            _body_params = public_interaction_batch_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/public/retrievers/{public_name}/interactions/batch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def track_interaction_retrievers_name(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        x_public_api_key: StrictStr,
        public_interaction_request: PublicInteractionRequest,
        x_session_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Track Interaction

        Track user interaction with search results.  Records user engagement (clicks, views, etc.) for analytics and potential search optimization (Learning to Rank).  **Authentication:** - Requires `X-Public-API-Key` header - Password NOT required (tracking should work even without auth)  **Recommended Headers:** - `X-Session-ID`: Session identifier for tracking user journey  **Interaction Types:** - `VIEW`: Result was visible in viewport - `CLICK`: User clicked on result - `POSITIVE_FEEDBACK`: User explicitly liked result - `NEGATIVE_FEEDBACK`: User explicitly disliked result - `PURCHASE`: User purchased/converted - `ADD_TO_CART`: User added to cart - `WISHLIST`: User added to wishlist - `LONG_VIEW`: User spent significant time viewing - `SHARE`: User shared result - `BOOKMARK`: User bookmarked result  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/interactions\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"X-Session-ID: sess_xyz...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"document_id\": \"doc_123\",     \"interaction_type\": [\"CLICK\"],     \"position\": 2,     \"execution_id\": \"exec_abc\",     \"query_snapshot\": {\"query\": \"red car\"}   }' ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param x_public_api_key: (required)
        :type x_public_api_key: str
        :param public_interaction_request: (required)
        :type public_interaction_request: PublicInteractionRequest
        :param x_session_id:
        :type x_session_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._track_interaction_retrievers_name_serialize(
            public_name=public_name,
            x_public_api_key=x_public_api_key,
            public_interaction_request=public_interaction_request,
            x_session_id=x_session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def track_interaction_retrievers_name_with_http_info(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        x_public_api_key: StrictStr,
        public_interaction_request: PublicInteractionRequest,
        x_session_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Track Interaction

        Track user interaction with search results.  Records user engagement (clicks, views, etc.) for analytics and potential search optimization (Learning to Rank).  **Authentication:** - Requires `X-Public-API-Key` header - Password NOT required (tracking should work even without auth)  **Recommended Headers:** - `X-Session-ID`: Session identifier for tracking user journey  **Interaction Types:** - `VIEW`: Result was visible in viewport - `CLICK`: User clicked on result - `POSITIVE_FEEDBACK`: User explicitly liked result - `NEGATIVE_FEEDBACK`: User explicitly disliked result - `PURCHASE`: User purchased/converted - `ADD_TO_CART`: User added to cart - `WISHLIST`: User added to wishlist - `LONG_VIEW`: User spent significant time viewing - `SHARE`: User shared result - `BOOKMARK`: User bookmarked result  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/interactions\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"X-Session-ID: sess_xyz...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"document_id\": \"doc_123\",     \"interaction_type\": [\"CLICK\"],     \"position\": 2,     \"execution_id\": \"exec_abc\",     \"query_snapshot\": {\"query\": \"red car\"}   }' ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param x_public_api_key: (required)
        :type x_public_api_key: str
        :param public_interaction_request: (required)
        :type public_interaction_request: PublicInteractionRequest
        :param x_session_id:
        :type x_session_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._track_interaction_retrievers_name_serialize(
            public_name=public_name,
            x_public_api_key=x_public_api_key,
            public_interaction_request=public_interaction_request,
            x_session_id=x_session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def track_interaction_retrievers_name_without_preload_content(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        x_public_api_key: StrictStr,
        public_interaction_request: PublicInteractionRequest,
        x_session_id: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Track Interaction

        Track user interaction with search results.  Records user engagement (clicks, views, etc.) for analytics and potential search optimization (Learning to Rank).  **Authentication:** - Requires `X-Public-API-Key` header - Password NOT required (tracking should work even without auth)  **Recommended Headers:** - `X-Session-ID`: Session identifier for tracking user journey  **Interaction Types:** - `VIEW`: Result was visible in viewport - `CLICK`: User clicked on result - `POSITIVE_FEEDBACK`: User explicitly liked result - `NEGATIVE_FEEDBACK`: User explicitly disliked result - `PURCHASE`: User purchased/converted - `ADD_TO_CART`: User added to cart - `WISHLIST`: User added to wishlist - `LONG_VIEW`: User spent significant time viewing - `SHARE`: User shared result - `BOOKMARK`: User bookmarked result  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/video-search/interactions\" \\   -H \"X-Public-API-Key: prk_abc123...\" \\   -H \"X-Session-ID: sess_xyz...\" \\   -H \"Content-Type: application/json\" \\   -d '{     \"document_id\": \"doc_123\",     \"interaction_type\": [\"CLICK\"],     \"position\": 2,     \"execution_id\": \"exec_abc\",     \"query_snapshot\": {\"query\": \"red car\"}   }' ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param x_public_api_key: (required)
        :type x_public_api_key: str
        :param public_interaction_request: (required)
        :type public_interaction_request: PublicInteractionRequest
        :param x_session_id:
        :type x_session_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._track_interaction_retrievers_name_serialize(
            public_name=public_name,
            x_public_api_key=x_public_api_key,
            public_interaction_request=public_interaction_request,
            x_session_id=x_session_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _track_interaction_retrievers_name_serialize(
        self,
        public_name,
        x_public_api_key,
        public_interaction_request,
        x_session_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if public_name is not None:
            _path_params['public_name'] = public_name
        # process the query parameters
        # process the header parameters
        if x_session_id is not None:
            _header_params['X-Session-ID'] = x_session_id
        if x_public_api_key is not None:
            _header_params['X-Public-API-Key'] = x_public_api_key
        # process the form parameters
        # process the body parameter
        if public_interaction_request is not None:
            _body_params = public_interaction_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/public/retrievers/{public_name}/interactions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def verify_password_retrievers_name(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        verify_password_request: VerifyPasswordRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> VerifyPasswordResponse:
        """Verify Password

        Verify password for a password-protected retriever.  Allows the frontend to check if a password is valid before attempting to execute a password-protected retriever. Returns the public API key if the password is valid.  **Authentication:** - NO authentication required - this endpoint is public - The password is verified against the retriever's configured password  **Use Case:** 1. Frontend detects that a retriever is password-protected (from /config endpoint) 2. User enters password in the UI 3. Frontend calls this endpoint to verify the password 4. If valid, frontend receives the public_api_key to use for subsequent requests  **Response:** - `valid`: Whether the password is correct - `public_api_key`: The API key to use for execute/interact endpoints (only if valid)  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/private-search/verify\" \\   -H \"Content-Type: application/json\" \\   -d '{\"password\": \"secret123\"}' ```  **Response if valid:** ```json {   \"valid\": true,   \"public_api_key\": \"prk_abc123...\" } ```  **Response if invalid:** ```json {   \"valid\": false,   \"public_api_key\": null } ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param verify_password_request: (required)
        :type verify_password_request: VerifyPasswordRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_password_retrievers_name_serialize(
            public_name=public_name,
            verify_password_request=verify_password_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VerifyPasswordResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def verify_password_retrievers_name_with_http_info(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        verify_password_request: VerifyPasswordRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[VerifyPasswordResponse]:
        """Verify Password

        Verify password for a password-protected retriever.  Allows the frontend to check if a password is valid before attempting to execute a password-protected retriever. Returns the public API key if the password is valid.  **Authentication:** - NO authentication required - this endpoint is public - The password is verified against the retriever's configured password  **Use Case:** 1. Frontend detects that a retriever is password-protected (from /config endpoint) 2. User enters password in the UI 3. Frontend calls this endpoint to verify the password 4. If valid, frontend receives the public_api_key to use for subsequent requests  **Response:** - `valid`: Whether the password is correct - `public_api_key`: The API key to use for execute/interact endpoints (only if valid)  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/private-search/verify\" \\   -H \"Content-Type: application/json\" \\   -d '{\"password\": \"secret123\"}' ```  **Response if valid:** ```json {   \"valid\": true,   \"public_api_key\": \"prk_abc123...\" } ```  **Response if invalid:** ```json {   \"valid\": false,   \"public_api_key\": null } ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param verify_password_request: (required)
        :type verify_password_request: VerifyPasswordRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_password_retrievers_name_serialize(
            public_name=public_name,
            verify_password_request=verify_password_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VerifyPasswordResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def verify_password_retrievers_name_without_preload_content(
        self,
        public_name: Annotated[StrictStr, Field(description="Public name of the published retriever")],
        verify_password_request: VerifyPasswordRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Verify Password

        Verify password for a password-protected retriever.  Allows the frontend to check if a password is valid before attempting to execute a password-protected retriever. Returns the public API key if the password is valid.  **Authentication:** - NO authentication required - this endpoint is public - The password is verified against the retriever's configured password  **Use Case:** 1. Frontend detects that a retriever is password-protected (from /config endpoint) 2. User enters password in the UI 3. Frontend calls this endpoint to verify the password 4. If valid, frontend receives the public_api_key to use for subsequent requests  **Response:** - `valid`: Whether the password is correct - `public_api_key`: The API key to use for execute/interact endpoints (only if valid)  **Example:** ```bash curl -X POST \"https://api.mixpeek.com/v1/public/retrievers/private-search/verify\" \\   -H \"Content-Type: application/json\" \\   -d '{\"password\": \"secret123\"}' ```  **Response if valid:** ```json {   \"valid\": true,   \"public_api_key\": \"prk_abc123...\" } ```  **Response if invalid:** ```json {   \"valid\": false,   \"public_api_key\": null } ```

        :param public_name: Public name of the published retriever (required)
        :type public_name: str
        :param verify_password_request: (required)
        :type verify_password_request: VerifyPasswordRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_password_retrievers_name_serialize(
            public_name=public_name,
            verify_password_request=verify_password_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "VerifyPasswordResponse",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _verify_password_retrievers_name_serialize(
        self,
        public_name,
        verify_password_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if public_name is not None:
            _path_params['public_name'] = public_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if verify_password_request is not None:
            _body_params = verify_password_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/public/retrievers/{public_name}/verify',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


