<!DOCTYPE html>
<html lang="en">
<!-- Don't request favicon.ico -->
<link rel="icon" href="data:,">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TDF Viewer</title>
    <link href="https://unpkg.com/tabulator-tables@6.3.0/dist/css/tabulator.min.css" rel="stylesheet">
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.3.0/dist/js/tabulator.min.js"></script>
</head>
<style>
    .tabulator {
        font-family: monospace;
    }

    .sidebar {
        height: 100%; /* 100% Full-height */
        width: 0; /* 0 width - change this with JavaScript */
        position: fixed; /* Stay in place */
        z-index: 1; /* Stay on top */
        top: 0;
        right: 0;
        background-color: #ffffff; /* White */
        overflow-x: hidden; /* Disable horizontal scroll */
    }

    #tdf-show {
        vertical-align: top;
    }

    #app-show {
        vertical-align: top;
    }

    #data-table {
        width: 100%;
    };
</style>

<body>
    <h1>Infuse-IoT TDF Viewer</h1>

    <div id="filteringSidebar" class="sidebar">
        <span id="tdf-show"></span>
        <span id="app-show"></span>
    </div>
    <div>
        <b>
        Filtering:
        <button class="openbtn" onclick="openFiltering()">&#9776; Options</button>
        </b>

        <b>
        <label for="update_pause">Pause updating: </label>
        <input type="checkbox" id="update_pause" name="update_pause" value="pause">
        </b>
    </div>
    <div id="data-table"></div>

    <script>
        // Filtering controls visible or not
        function openFiltering() {
            let elem = document.getElementById("filteringSidebar");
            let open_width = "275px";

            // Toggle sidebar with filtering options
            if (elem.style.width == open_width) {
                elem.style.width = "0px";
            } else {
                elem.style.width = open_width;
            }
        }

        let filtering_update = false;
        // Initialize the Tabulator table
        const dataTable = new Tabulator("#data-table", {
            layout: "fitDataTable",
            pagination: "local",
            paginationSize: 25,
            paginationSizeSelector: [10, 25, 50, 100],
            paginationCounter: "rows",
        });
        const shownTdfTable = new Tabulator("#tdf-show", {
            layout: "fitDataTable",
            columns: [
                { title: "TDF", field: "name", width: 200 },
                {
                    title: "Show",
                    field: "checked",
                    hozAlign: "center",
                    formatter: "tickCross",
                    cellClick: function (ev, cell) {
                        filtering_update = true;
                        cell.setValue(!cell.getValue());
                    },
                },
            ]
        });
        const shownAppTable = new Tabulator("#app-show", {
            layout: "fitDataTable",
            columns: [
                { title: "Application", field: "name", width: 200 },
                {
                    title: "Show",
                    field: "checked",
                    hozAlign: "center",
                    formatter: "tickCross",
                    cellClick: function (ev, cell) {
                        filtering_update = true;
                        cell.setValue(!cell.getValue());
                    },
                },
            ]
        });

        // Connect to the WebSocket server
        const ws = new WebSocket("ws://localhost:" + location.port + "/ws");
        let shownTDFs = {};
        let currentTDFs = [];
        let current_num_columns = 0;
        let currentApps = [];

        const arraysEqual = (a, b) =>
            a.length === b.length &&
            a.every((element, index) => element === b[index]);

        ws.onmessage = function (event) {
            const { columns, rows, tdfs, apps } = JSON.parse(event.data);

            if (!arraysEqual(currentTDFs, tdfs)) {
                // Merge new data with the existing table data
                const currentRows = shownTdfTable.getData();
                const updatedData = tdfs.map((str, index) => {
                    const existingRow = currentRows.find(row => row.name === str);
                    return existingRow
                        ? existingRow // Preserve the existing row if found
                        : { id: `row-${index}`, name: str, checked: true };
                });
                // Update table and refresh the checked state map
                shownTdfTable.replaceData(updatedData);
                shownTDFs = Object.fromEntries(
                    updatedData.map(row => [row.name, row.checked])
                );
                currentTDFs = tdfs;
            }
            const disableData = shownTdfTable.getData();
            shownTDFs = Object.fromEntries(
                disableData.map(row => [row.name, row.checked])
            );

            if (!arraysEqual(currentApps, apps)) {
                // Merge new data with the existing table data
                const currentRows = shownAppTable.getData();
                const updatedData = apps.map((str, index) => {
                    const existingRow = currentRows.find(row => row.name === str);
                    return existingRow
                        ? existingRow // Preserve the existing row if found
                        : { id: `row-${index}`, name: str, checked: true };
                });
                shownAppTable.replaceData(updatedData);
                currentApps = apps
                filtering_update = true;
            }

            // Update column definitions if new TDFs have appeared
            if (columns.length != current_num_columns) {
                dataTable.setColumns(columns);
                current_num_columns = columns.length;
                filtering_update = true;
            }

            // Dynamically set the table content
            if (current_num_columns > 0) {
                if (!document.getElementById('update_pause').checked) {
                    dataTable.replaceData(rows);
                }
            }

            if (filtering_update) {
                // Hide columns as requested
                dataTable.getColumns().forEach(column => {
                    // Split field name into [TDF_NAME, subfields]
                    const field = column.getField().split('.');
                    if (shownTDFs[field[0]] ?? true) {
                        column.show();
                    } else {
                        column.hide();
                    }
                });

                // Filter applications as requested
                appShow = Object.fromEntries(
                    shownAppTable.getData().map(row => [row.name, row.checked])
                );
                enabledApps = currentApps.filter(a => appShow[a]);

                dataTable.clearFilter();
                dataTable.setFilter("application", "in", enabledApps);

                filtering_update = false;
            }
        };

        ws.onopen = function () {
            console.log("WebSocket connected");
        };

        ws.onerror = function (error) {
            console.error("WebSocket error:", error);
        };
    </script>
</body>

</html>
