from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple

import requests

from base_handler import ArchitectureHandler


class LLMAgentHandler(ArchitectureHandler):
    """Handler for the LLM Agent FastAPI service.

    Supports two operations via generate():
      - kind='text': send a user utterance
        required keys: {kind='text', client_id: str, utterance: str}
      - kind='person': update visible persons (may trigger event)
        required keys: {kind='person', client_id: str, person_info: List[{name:str, age:int, autogenerated_name:bool}]}

    Configuration:
      - host, port specify the FastAPI base (http://host:port)
      - text_path: default '/input/text'
      - person_path: default '/input/person'
      - dry_run: if True, returns stubbed responses without HTTP.
    """

    def __init__(
        self,
        *,
        api_key: Optional[str] = None,
        host: Optional[str] = None,
        port: Optional[int] = None,
        text_path: str = "/input/text",
        person_path: str = "/input/person",
        dry_run: bool = False,
        # base args
        run_as_thread: bool = False,
        disable_thread: bool = True,
        max_queue_size: int = 128,
        result_queue_size: Optional[int] = None,
        verbose: bool = False,
        expected_type: Optional[type] = None,
        network_timeout: Optional[float] = 10.0,
        client_id_prefix: str = "client",
        generate_results_callback: Optional[Any] = None,
    ) -> None:
        super().__init__(
            host=host,
            port=port,
            auth=None,
            run_as_thread=run_as_thread,
            disable_thread=disable_thread,
            max_queue_size=max_queue_size,
            result_queue_size=result_queue_size,
            verbose=verbose,
            expected_type=expected_type,
            network_timeout=network_timeout,
            client_id_prefix=client_id_prefix,
            generate_results_callback=generate_results_callback,
        )
        self.text_path = text_path
        self.person_path = person_path
        self.dry_run = bool(dry_run)
        self.api_key = api_key

    # ---- Convenience methods ----
    def send_text(self, client_id: str, utterance: str) -> Dict[str, Any]:
        item = {"kind": "text", "client_id": client_id, "utterance": utterance}
        return self.generate(item)

    async def async_send_text(self, client_id: str, utterance: str) -> Dict[str, Any]:
        return await self.async_generate({"kind": "text", "client_id": client_id, "utterance": utterance})

    def send_person_batch(self, client_id: str, person_info: List[Dict[str, Any]]) -> Dict[str, Any]:
        item = {"kind": "person", "client_id": client_id, "person_info": person_info}
        return self.generate(item)

    async def async_send_person_batch(self, client_id: str, person_info: List[Dict[str, Any]]) -> Dict[str, Any]:
        return await self.async_generate({"kind": "person", "client_id": client_id, "person_info": person_info})

    # ---- Validation & Preprocess ----
    def validate_item(self, item: Any, extra: Dict[str, Any]) -> bool:  # type: ignore[override]
        if not isinstance(item, dict):
            return False
        kind = item.get("kind")
        if kind == "text":
            return isinstance(item.get("client_id"), str) and isinstance(item.get("utterance"), str)
        if kind == "person":
            if not isinstance(item.get("client_id"), str):
                return False
            pi = item.get("person_info")
            if not isinstance(pi, list):
                return False
            for p in pi:
                if not isinstance(p, dict):
                    return False
                if not isinstance(p.get("name"), str):
                    return False
                if not isinstance(p.get("age"), int):
                    return False
                if not isinstance(p.get("autogenerated_name"), bool):
                    return False
            return True
        return False

    def preprocess_item(self, item: Dict[str, Any], extra: Dict[str, Any]):  # type: ignore[override]
        # No transformation required; pass through
        return item, extra

    # ---- Generation ----
    def generate_results(self, item: Dict[str, Any], extra: Dict[str, Any]):  # type: ignore[override]
        payload = self._prepare_request_payload(item, extra)
        return self.perform_request(payload)

    # ---- Networking ----
    def _base_url(self) -> Optional[str]:
        if not (self.host and self.port):
            return None
        return f"http://{self.host}:{self.port}"

    def _text_url(self) -> Optional[str]:
        base = self._base_url()
        return f"{base}{self.text_path}" if base else None

    def _person_url(self) -> Optional[str]:
        base = self._base_url()
        return f"{base}{self.person_path}" if base else None

    def _prepare_request_payload(self, item: Dict[str, Any], extra: Dict[str, Any]) -> Dict[str, Any]:  # type: ignore[override]
        kind = item.get("kind")
        if kind == "text":
            return {
                "kind": "text",
                "url": self._text_url(),
                "json": {"client_id": item["client_id"], "utterance": item["utterance"]},
                "timeout": float(self.network_timeout or 10.0),
                "headers": {
                    "x-api-key": self.api_key or "",
                },
            }
        if kind == "person":
            return {
                "kind": "person",
                "url": self._person_url(),
                "json": {"client_id": item["client_id"], "person_info": item["person_info"]},
                "timeout": float(self.network_timeout or 10.0),
                "headers": {
                    "x-api-key": self.api_key or "",
                },
            }
        # Should not reach due to validation
        return {"kind": "unknown", "url": None}

    def _perform_request(self, payload: Dict[str, Any]):  # type: ignore[override]
        kind = payload.get("kind")
        url = payload.get("url")
        if self.dry_run or not url:
            # Minimal local stubs
            if kind == "text":
                data = payload.get("json", {})
                return {"client_id": data.get("client_id"), "response": "IGNORE"}
            if kind == "person":
                data = payload.get("json", {})
                names = [p.get("name") for p in data.get("person_info", [])]
                return {"client_id": data.get("client_id"), "updated_visible_faces": names}
            return {"status": "dry_run"}
        timeout = payload.get("timeout", float(self.network_timeout or 10.0))
        resp = requests.post(url, json=payload.get("json", {}), timeout=timeout)
        resp.raise_for_status()
        return resp.json()

