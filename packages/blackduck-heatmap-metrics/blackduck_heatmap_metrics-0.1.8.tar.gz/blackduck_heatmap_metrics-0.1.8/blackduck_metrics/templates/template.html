<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heatmap Metrics Analysis Report</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js" crossorigin="anonymous"></script>
    <script>
        // Fallback error message if Plotly fails to load
        window.addEventListener('load', function() {
            setTimeout(function() {
                if (typeof Plotly === 'undefined') {
                    var errorDiv = document.createElement('div');
                    errorDiv.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #ff4444; color: white; padding: 20px; border-radius: 8px; z-index: 10000; max-width: 600px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);';
                    errorDiv.innerHTML = '<strong>‚ö†Ô∏è Charts Cannot Load</strong><br><br>' +
                        'The Plotly library failed to load. This commonly happens on Safari when opening local HTML files.<br><br>' +
                        '<strong>Solutions:</strong><br>' +
                        '1. Use Chrome or Firefox instead<br>' +
                        '2. Host the file on a web server<br>' +
                        '3. In Safari: Develop menu ‚Üí Disable Local File Restrictions';
                    document.body.appendChild(errorDiv);
                }
            }, 2000);
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0066cc 0%, #003d7a 100%);
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        h1 {
            color: #0066cc;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            color: #666;
            font-size: 14px;
        }
        
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
            transition: transform 0.2s;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card-title {
            color: #666;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .card-value {
            font-size: 36px;
            font-weight: bold;
            margin: 10px 0;
            color: #3182ce;
        }
        
        .section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        h2 {
            color: #0066cc;
            margin-bottom: 20px;
            font-size: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .file-section {
            margin-bottom: 40px;
            padding-bottom: 40px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .file-section:last-child {
            border-bottom: none;
        }
        
        h3 {
            color: #0066cc;
            margin: 20px 0 15px 0;
        }
        
        h4 {
            color: #333;
            margin: 15px 0 10px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            overflow-x: auto;
            display: block;
        }
        
        thead {
            background: #f7fafc;
        }
        
        th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #4a5568;
            border-bottom: 2px solid #e2e8f0;
        }
        
        th:hover {
            background: #edf2f7;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        tbody tr:hover {
            background: #f7fafc;
        }
        
        .chart-container {
            margin: 20px 0;
            min-height: 400px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat-box {
            background: #f7fafc;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #0066cc;
        }
        
        .stat-label {
            font-weight: bold;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.3em;
            color: #0066cc;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 10px 20px;
            background: #f7fafc;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: #333;
        }
        
        .tab:hover {
            background: #edf2f7;
        }
        
        .tab.active {
            background: #0066cc;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .footer {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
            color: #666;
            font-size: 12px;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            background: #e6f3ff;
            color: #0066cc;
            border-radius: 3px;
            font-size: 0.85em;
            margin: 2px;
        }
        
        .value-count-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .value-count-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            color: white;
        }
        
        .value-count-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        
        .value-count-label {
            font-weight: 600;
            font-size: 1em;
            color: white;
        }
        
        .value-count-value {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            font-weight: bold;
            font-size: 1.3em;
            padding: 5px 15px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            word-break: break-all;
            max-width: 100%;
        }
        
        /* Project filter search styles */
        .project-filter-container {
            position: relative;
            display: inline-block;
        }
        
        #projectFilterInput {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 5px;
            border: 2px solid white;
            background: white;
            color: #667eea;
            cursor: pointer;
            min-width: 250px;
            max-width: 300px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            direction: ltr;
        }
        
        #projectFilterInput:focus {
            outline: none;
            border-color: #764ba2;
        }
        
        select option {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        @media (max-width: 768px) {
            .summary-cards {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìä Heatmap Metrics Analysis Report</h1>
            <div class="subtitle">
                Generated on {{ generated_date }}
                {% if analysis.available_files and analysis.available_files|length == 1 %}
                <br>Analyzing: <strong>{{ analysis.available_files[0] }}</strong>
                {% elif analysis.available_files and analysis.available_files|length > 1 %}
                <br>Analyzing <strong>{{ analysis.available_files|length }}</strong> files (combined data)
                {% endif %}
            </div>
            <div style="margin-top: 20px; display: flex; gap: 20px; flex-wrap: wrap;">
                {% if analysis.available_files and analysis.available_files|length > 1 %}
                <div>
                    <label for="fileFilter" style="font-size: 1.1em; margin-right: 10px;">Filter by File:</label>
                    <select id="fileFilter" onchange="updateProjectListForFile(); applyFilters()" style="padding: 8px 15px; font-size: 1em; border-radius: 5px; border: 2px solid white; background: white; color: #667eea; cursor: pointer;">
                        <option value="all">All Files (Aggregated)</option>
                        {% for file in analysis.available_files %}
                        <option value="{{ file }}">{{ file }}</option>
                        {% endfor %}
                    </select>
                </div>
                {% endif %}
                {% if analysis.available_years %}
                <div>
                    <label for="yearFilter" style="font-size: 1.1em; margin-right: 10px;">Filter by Year:</label>
                    <select id="yearFilter" onchange="applyFilters()" style="padding: 8px 15px; font-size: 1em; border-radius: 5px; border: 2px solid white; background: white; color: #667eea; cursor: pointer;">
                        <option value="all">All Years</option>
                        {% for year in analysis.available_years %}
                        <option value="{{ year }}">{{ year }}</option>
                        {% endfor %}
                    </select>
                </div>
                {% endif %}
                {% if analysis.available_projects %}
                <div class="project-filter-container">
                    <label for="projectFilterInput" style="font-size: 1.1em; margin-right: 10px;">Filter by Project:</label>
                    <input 
                        type="text" 
                        id="projectFilterInput" 
                        list="projectList" 
                        placeholder="All Projects (type to search...)"
                        onchange="applyProjectFilter()"
                        oninput="handleProjectInput()"
                        style="padding: 8px 15px; font-size: 1em; border-radius: 5px; border: 2px solid white; background: white; color: #667eea; min-width: 250px; max-width: 300px;"
                    >
                    <datalist id="projectList">
                        <option value="all">All Projects</option>
                        {% for project in analysis.available_projects %}
                        <option value="{{ project }}">{{ project }}</option>
                        {% endfor %}
                    </datalist>
                </div>
                {% endif %}
                <div>
                    <label for="statusFilter" style="font-size: 1.1em; margin-right: 10px;">Filter by Status:</label>
                    <select id="statusFilter" onchange="applyFilters()" style="padding: 8px 15px; font-size: 1em; border-radius: 5px; border: 2px solid white; background: white; color: #667eea; cursor: pointer;">
                        <option value="all">All Scans</option>
                        <option value="success">‚úÖ Successful Only</option>
                        <option value="failed">‚ùå Failed Only</option>
                    </select>
                </div>
                {% if analysis.available_projects %}
                <div>
                    <button onclick="clearAllFilters()" style="padding: 8px 20px; font-size: 1em; border-radius: 5px; border: 2px solid white; background: white; color: #667eea; cursor: pointer; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.background='#667eea'; this.style.color='white';" onmouseout="this.style.background='white'; this.style.color='#667eea';">
                        üîÑ Clear Filters
                    </button>
                </div>
                {% endif %}
            </div>
        </header>
        
        <div class="summary-cards">
            <div class="card">
                <div class="card-title">Total Files</div>
                <div class="card-value" id="totalFiles">{{ analysis.summary.total_files }}</div>
            </div>
            <div class="card">
                <div class="card-title">Total Records</div>
                <div class="card-value" id="totalRecords">{{ analysis.summary.total_rows | default('N/A') }}</div>
            </div>
            <div class="card">
                <div class="card-title">Unique Projects</div>
                <div class="card-value" id="uniqueProjects">{{ analysis.summary.unique_projects | default('N/A') }}</div>
            </div>
            <div class="card">
                <div class="card-title">Total Scans</div>
                <div class="card-value" id="totalScans">{{ analysis.summary.total_scans | default('N/A') }}</div>
            </div>
        </div>
        
        <div class="summary-cards">
            <div class="card">
                <div class="card-title">Successful Scans</div>
                <div class="card-value" id="successfulScans" style="color: #38a169;">{{ analysis.summary.successful_scans | default('N/A') }}</div>
            </div>
            <div class="card">
                <div class="card-title">Failed Scans</div>
                <div class="card-value" id="failedScans" style="color: #e53e3e;">{{ analysis.summary.failed_scans | default('N/A') }}</div>
            </div>
            <div class="card">
                <div class="card-title">Success Rate</div>
                <div class="card-value" id="successRate" style="color: #3182ce;">
                    {% if analysis.summary.total_scans and analysis.summary.total_scans > 0 %}
                        {{ "%.1f" | format((analysis.summary.successful_scans / analysis.summary.total_scans * 100)) }}%
                    {% else %}
                        N/A
                    {% endif %}
                </div>
            </div>
        </div>
        
        <div class="summary-cards">
            <div class="card">
                <div class="card-title">üî• Busiest Hours</div>
                <div class="card-value" id="busiestHour" style="color: #e53e3e;">
                    {% if analysis.summary.busiest_hour is not none %}
                        {{ "%02d" | format(analysis.summary.busiest_hour) }}:00-{{ "%02d" | format(analysis.summary.busiest_hour_end) }}:00
                        <div style="font-size: 0.4em; color: #666; margin-top: 5px;">{{ analysis.summary.busiest_count }} scans ({{ analysis.summary.busiest_percentage }}%)</div>
                    {% else %}
                        N/A
                    {% endif %}
                </div>
            </div>
            <div class="card">
                <div class="card-title">üò¥ Quietest Hours</div>
                <div class="card-value" id="quietestHour" style="color: #38a169;">
                    {% if analysis.summary.quietest_hour is not none %}
                        {{ "%02d" | format(analysis.summary.quietest_hour) }}:00-{{ "%02d" | format(analysis.summary.quietest_hour_end) }}:00
                        <div style="font-size: 0.4em; color: #666; margin-top: 5px;">{{ analysis.summary.quietest_count }} scans ({{ analysis.summary.quietest_percentage }}%)</div>
                    {% else %}
                        N/A
                    {% endif %}
                </div>
            </div>
        </div>
        
        {% if analysis.aggregated %}
        <div class="section">
            <h2>üéØ Black Duck Scan Overview</h2>
            
            {% if analysis.aggregated.scan_types %}
            {% set total_scans = analysis.aggregated.scan_types.values()|sum %}
            <div style="background: white; padding: 25px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-top: 20px;">
                <h3 style="margin-top: 0; color: #2d3748; font-size: 1.4em;">üîç Scan Types Breakdown</h3>
                <div class="value-count-grid" id="scanTypesBreakdown">
                    {% for scan_type, count in analysis.aggregated.scan_types.items() %}
                    {% set percentage = ((count / total_scans) * 100)|round(1) if total_scans > 0 else 0 %}
                    <div class="value-count-item">
                        <span class="value-count-label"><span class="scan-type-icon" data-type="{{ scan_type }}"></span> {{ scan_type }}</span>
                        <span class="value-count-value">{{ count }} <span style="color: #fff; font-size: 0.85em; font-weight: 700;">({{ percentage }}%)</span></span>
                    </div>
                    {% endfor %}
                </div>
            </div>
            <script>
                // Map scan types to appropriate icons and display names
                function getScanTypeIcon(scanType) {
                    const iconMap = {
                        'SIGNATURE': '‚úçÔ∏è',
                        'SNIPPET': '‚úÇÔ∏è',
                        'BINARY': 'üíæ',
                        'CONTAINER': 'üì¶',
                        'SOURCE': 'üìÑ',
                        'DEPENDENCY': 'üîó',
                        'PACKAGE_MANAGER': 'üìö',
                        'DETECTOR': 'üîç',
                        'MANUAL': 'üë§',
                        'INFRASTRUCTURE_AS_CODE': 'üèóÔ∏è',
                        'DEFAULT': 'üìä'
                    };
                    return iconMap[scanType.toUpperCase()] || iconMap['DEFAULT'];
                }
                
                function getScanTypeDisplayName(scanType) {
                    const displayNameMap = {
                        'INFRASTRUCTURE_AS_CODE': 'INFRA AS CODE'
                    };
                    return displayNameMap[scanType.toUpperCase()] || scanType;
                }
                
                // Apply icons and display names to scan type elements
                document.querySelectorAll('.scan-type-icon').forEach(el => {
                    const scanType = el.getAttribute('data-type');
                    const icon = getScanTypeIcon(scanType);
                    const displayName = getScanTypeDisplayName(scanType);
                    const label = el.parentElement;
                    label.innerHTML = `<span class="scan-type-icon">${icon}</span> ${displayName}`;
                });
            </script>
            {% endif %}
            
            <h3 style="margin-top: 30px;">Top Projects</h3>
            <div style="margin-bottom: 15px;">
                <label for="scanTypeFilter" style="font-weight: 600; margin-right: 10px;">Filter by Scan Type:</label>
                <select id="scanTypeFilter" onchange="filterProjectsByScanType()" style="padding: 8px 15px; font-size: 0.95em; border-radius: 5px; border: 1px solid #e2e8f0; background: white; cursor: pointer;">
                    <option value="all">All Scan Types</option>
                    {% for scan_type in analysis.aggregated.scan_types.keys() %}
                    <option value="{{ scan_type }}">{{ scan_type }}</option>
                    {% endfor %}
                </select>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin-top: 20px;">
                <div id="projectBarChart" class="chart-container" style="min-height: 400px;"></div>
                <div id="scanTypePieChart" class="chart-container" style="min-height: 400px;"></div>
            </div>
        </div>
        {% endif %}
        
        {% if chart_data %}
        <div class="section">
            <h2>üìà Time Series Trends</h2>
            <div id="timeSeriesChart" class="chart-container"></div>
            
            <h3 style="margin-top: 30px;">Scan Type Evolution Over Time</h3>
            <div id="scanTypeEvolutionSection">
                <div style="margin-bottom: 15px;">
                    <label style="font-weight: 600; margin-right: 10px;">Select Scan Types to Display:</label>
                    <div id="scanTypeCheckboxes" style="display: flex; flex-wrap: wrap; gap: 15px; margin-top: 10px;">
                        {% for scan_type in analysis.aggregated.scan_types.keys() %}
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" class="scan-type-checkbox" value="{{ scan_type }}" checked onchange="updateScanTypeEvolution()">
                            <span>{{ scan_type }}</span>
                        </label>
                        {% endfor %}
                    </div>
                </div>
                <div id="scanTypeEvolutionChart" class="chart-container"></div>
            </div>
            
            {% if chart_data.trends %}
            <h3 style="margin-top: 30px;">Metric Trends</h3>
            <div id="metricsChart" class="chart-container"></div>
            {% endif %}
        </div>
        {% endif %}
        
        <div class="footer">
            <p>Generated by Heatmap Metrics Analyzer</p>
        </div>
    </div>
    
    <script>
        // Config for all charts
        const config = {
            responsive: true,
            displayModeBar: true,
            displaylogo: false
        };
        
        // Store year-specific data
        const yearData = {{ analysis.by_year | tojson | safe }};
        
        // Store project-specific data
        const projectData = {{ analysis.by_project | tojson | safe }};
        
        // Store combined year-project data
        const yearProjectData = {{ analysis.by_year_project | tojson | safe }};
        
        // Store file-specific data (for multi-file zips)
        const fileDataByFile = {{ analysis.by_file | tojson | safe }};
        
        const allData = {
            total_files: {{ analysis.summary.total_files }},
            total_rows: {{ analysis.summary.total_rows | default(0) }},
            unique_projects: {{ analysis.summary.unique_projects | default(0) }},
            total_scans: {{ analysis.summary.total_scans | default(0) }},
            successful_scans: {{ analysis.summary.successful_scans | default(0) }},
            failed_scans: {{ analysis.summary.failed_scans | default(0) }},
            scan_types: {{ analysis.summary.scan_types | default({}) | tojson | safe }},
            scan_types_success: {{ analysis.summary.scan_types_success | default({}) | tojson | safe }},
            scan_types_failed: {{ analysis.summary.scan_types_failed | default({}) | tojson | safe }},
            top_projects: {{ analysis.aggregated.top_projects | tojson | safe }},
            top_projects_success: {{ analysis.aggregated.top_projects_success | default({}) | tojson | safe }},
            top_projects_failed: {{ analysis.aggregated.top_projects_failed | default({}) | tojson | safe }},
            projects_by_scan_type: {{ analysis.aggregated.projects_by_scan_type | tojson | safe }},
            projects_by_scan_type_success: {{ analysis.aggregated.projects_by_scan_type_success | default({}) | tojson | safe }},
            projects_by_scan_type_failed: {{ analysis.aggregated.projects_by_scan_type_failed | default({}) | tojson | safe }},
            busiest_hour: {{ analysis.summary.busiest_hour | default('null') }},
            busiest_hour_end: {{ analysis.summary.busiest_hour_end | default('null') }},
            busiest_count: {{ analysis.summary.busiest_count | default(0) }},
            busiest_percentage: {{ analysis.summary.busiest_percentage | default(0) }},
            quietest_hour: {{ analysis.summary.quietest_hour | default('null') }},
            quietest_hour_end: {{ analysis.summary.quietest_hour_end | default('null') }},
            quietest_count: {{ analysis.summary.quietest_count | default(0) }},
            quietest_percentage: {{ analysis.summary.quietest_percentage | default(0) }},
            busiest_hour_success: {{ analysis.summary.busiest_hour_success | default('null') }},
            busiest_hour_end_success: {{ analysis.summary.busiest_hour_end_success | default('null') }},
            busiest_count_success: {{ analysis.summary.busiest_count_success | default(0) }},
            busiest_percentage_success: {{ analysis.summary.busiest_percentage_success | default(0) }},
            quietest_hour_success: {{ analysis.summary.quietest_hour_success | default('null') }},
            quietest_hour_end_success: {{ analysis.summary.quietest_hour_end_success | default('null') }},
            quietest_count_success: {{ analysis.summary.quietest_count_success | default(0) }},
            quietest_percentage_success: {{ analysis.summary.quietest_percentage_success | default(0) }},
            busiest_hour_failed: {{ analysis.summary.busiest_hour_failed | default('null') }},
            busiest_hour_end_failed: {{ analysis.summary.busiest_hour_end_failed | default('null') }},
            busiest_count_failed: {{ analysis.summary.busiest_count_failed | default(0) }},
            busiest_percentage_failed: {{ analysis.summary.busiest_percentage_failed | default(0) }},
            quietest_hour_failed: {{ analysis.summary.quietest_hour_failed | default('null') }},
            quietest_hour_end_failed: {{ analysis.summary.quietest_hour_end_failed | default('null') }},
            quietest_count_failed: {{ analysis.summary.quietest_count_failed | default(0) }},
            quietest_percentage_failed: {{ analysis.summary.quietest_percentage_failed | default(0) }}
        };
        
        // Generate charts
        const chartData = {{ chart_data | safe }};
        let scanTypeEvolutionData = chartData && chartData.scan_type_evolution ? chartData.scan_type_evolution : {};
        
        // Debug output
        // Check if Plotly is loaded
        if (typeof Plotly === 'undefined') {
            console.error('Plotly is not loaded!');
        } else {
        }
        
        // Filter data by file, year and/or project
        function applyFilters() {
            const fileFilterEl = document.getElementById('fileFilter');
            const yearFilterEl = document.getElementById('yearFilter');
            const projectFilterInput = document.getElementById('projectFilterInput');
            
            if (!yearFilterEl) {
                console.error('Year filter element not found');
                return;
            }
            
            const selectedFile = fileFilterEl ? fileFilterEl.value : 'all';
            const selectedYear = yearFilterEl.value;
            let selectedProject = 'all';
            const selectedStatus = document.getElementById('statusFilter') ? document.getElementById('statusFilter').value : 'all';
            
            // Store current status filter globally for chart title updates
            window.currentStatusFilter = selectedStatus;
            
            if (projectFilterInput) {
                const inputValue = projectFilterInput.value.trim();
                if (inputValue === '' || inputValue.toLowerCase() === 'all projects') {
                    selectedProject = 'all';
                    projectFilterInput.value = '';
                    projectFilterInput.placeholder = 'All Projects (type to search...)';
                } else {
                    selectedProject = inputValue;
                }
            }
            // Handle file filter with year/project combinations
            if (selectedFile !== 'all') {
                const fileData = fileDataByFile[selectedFile];
                if (!fileData) {
                    console.error('No data found for file:', selectedFile);
                    return;
                }
                
                // Apply year and project filters to file data
                if (selectedYear === 'all' && selectedProject === 'all') {
                    // Show all data for this file
                    updateDisplay(fileData, selectedYear, selectedProject, selectedFile, selectedStatus);
                } else if (selectedYear !== 'all' && selectedProject === 'all') {
                    // Filter by year within this file
                    const yearFileData = fileData.by_year && fileData.by_year[selectedYear];
                    if (yearFileData) {
                        const displayData = {
                            total_files: 1,
                            total_rows: yearFileData.total_rows,
                            unique_projects: yearFileData.unique_projects,
                            total_scans: yearFileData.total_scans,
                            successful_scans: yearFileData.successful_scans || 0,
                            failed_scans: yearFileData.failed_scans || 0,
                            scan_types: yearFileData.scan_types,
                            scan_types_success: yearFileData.scan_types_success || {},
                            scan_types_failed: yearFileData.scan_types_failed || {},
                            top_projects: yearFileData.top_projects,
                            top_projects_success: yearFileData.top_projects_success || {},
                            top_projects_failed: yearFileData.top_projects_failed || {}
                        };
                        updateDisplay(displayData, selectedYear, selectedProject, selectedFile, selectedStatus);
                    } else {
                        console.error('No data found for year:', selectedYear, 'in file:', selectedFile);
                    }
                } else if (selectedYear === 'all' && selectedProject !== 'all') {
                    // Filter by project within this file
                    const projectFileData = fileData.by_project && fileData.by_project[selectedProject];
                    if (projectFileData) {
                        const displayData = {
                            total_files: 1,
                            total_rows: projectFileData.total_scans,
                            unique_projects: 1,
                            total_scans: projectFileData.total_scans,
                            successful_scans: projectFileData.successful_scans || 0,
                            failed_scans: projectFileData.failed_scans || 0,
                            scan_types: projectFileData.scan_types,
                            scan_types_success: projectFileData.scan_types_success || {},
                            scan_types_failed: projectFileData.scan_types_failed || {},
                            top_projects: {}
                        };
                        displayData.top_projects[selectedProject] = projectFileData.total_scans;
                        displayData.top_projects_success = {};
                        displayData.top_projects_success[selectedProject] = projectFileData.successful_scans || 0;
                        displayData.top_projects_failed = {};
                        displayData.top_projects_failed[selectedProject] = projectFileData.failed_scans || 0;
                        updateDisplay(displayData, selectedYear, selectedProject, selectedFile, selectedStatus);
                    } else {
                        console.error('No data found for project:', selectedProject, 'in file:', selectedFile);
                    }
                } else {
                    // Filter by both year and project within this file
                    const yearProjectFileData = fileData.by_year_project && 
                                               fileData.by_year_project[selectedYear] && 
                                               fileData.by_year_project[selectedYear][selectedProject];
                    if (yearProjectFileData) {
                        const displayData = {
                            total_files: 1,
                            total_rows: yearProjectFileData.total_scans,
                            unique_projects: 1,
                            total_scans: yearProjectFileData.total_scans,
                            successful_scans: yearProjectFileData.successful_scans || 0,
                            failed_scans: yearProjectFileData.failed_scans || 0,
                            scan_types: yearProjectFileData.scan_types,
                            scan_types_success: yearProjectFileData.scan_types_success || {},
                            scan_types_failed: yearProjectFileData.scan_types_failed || {},
                            top_projects: {}
                        };
                        displayData.top_projects[selectedProject] = yearProjectFileData.total_scans;
                        displayData.top_projects_success = {};
                        displayData.top_projects_success[selectedProject] = yearProjectFileData.successful_scans || 0;
                        displayData.top_projects_failed = {};
                        displayData.top_projects_failed[selectedProject] = yearProjectFileData.failed_scans || 0;
                        updateDisplay(displayData, selectedYear, selectedProject, selectedFile, selectedStatus);
                    } else {
                    }
                }
                return;
            }
            
            if (selectedYear === 'all' && selectedProject === 'all') {
                // Show all data
                updateDisplay(allData, selectedYear, selectedProject, selectedFile, selectedStatus);
            } else if (selectedYear !== 'all' && selectedProject === 'all') {
                // Filter by year only
                const data = yearData[selectedYear];
                if (data) {
                    const displayData = {
                        total_files: allData.total_files,
                        total_rows: data.total_rows,
                        unique_projects: data.unique_projects,
                        total_scans: data.total_scans,
                        successful_scans: data.successful_scans || 0,
                        failed_scans: data.failed_scans || 0,
                        scan_types: data.scan_types || {},
                        scan_types_success: data.scan_types_success || {},
                        scan_types_failed: data.scan_types_failed || {},
                        top_projects: data.top_projects,
                        top_projects_success: data.top_projects_success || {},
                        top_projects_failed: data.top_projects_failed || {},
                        busiest_hour: data.busiest_hour,
                        busiest_hour_end: data.busiest_hour_end,
                        busiest_count: data.busiest_count,
                        busiest_percentage: data.busiest_percentage,
                        quietest_hour: data.quietest_hour,
                        quietest_hour_end: data.quietest_hour_end,
                        quietest_count: data.quietest_count,
                        quietest_percentage: data.quietest_percentage,
                        busiest_hour_success: data.busiest_hour_success,
                        busiest_hour_end_success: data.busiest_hour_end_success,
                        busiest_count_success: data.busiest_count_success,
                        busiest_percentage_success: data.busiest_percentage_success,
                        quietest_hour_success: data.quietest_hour_success,
                        quietest_hour_end_success: data.quietest_hour_end_success,
                        quietest_count_success: data.quietest_count_success,
                        quietest_percentage_success: data.quietest_percentage_success,
                        busiest_hour_failed: data.busiest_hour_failed,
                        busiest_hour_end_failed: data.busiest_hour_end_failed,
                        busiest_count_failed: data.busiest_count_failed,
                        busiest_percentage_failed: data.busiest_percentage_failed,
                        quietest_hour_failed: data.quietest_hour_failed,
                        quietest_hour_end_failed: data.quietest_hour_end_failed,
                        quietest_count_failed: data.quietest_count_failed,
                        quietest_percentage_failed: data.quietest_percentage_failed
                    };
                    updateDisplay(displayData, selectedYear, selectedProject, selectedFile, selectedStatus);
                } else {
                    console.error('No data found for year:', selectedYear);
                }
            } else if (selectedYear === 'all' && selectedProject !== 'all') {
                // Filter by project only
                const data = projectData[selectedProject];
                if (data) {
                    const displayData = {
                        total_files: allData.total_files,
                        total_rows: data.total_scans,  // For a single project, rows = scans
                        unique_projects: 1,
                        total_scans: data.total_scans,
                        successful_scans: data.successful_scans || 0,
                        failed_scans: data.failed_scans || 0,
                        scan_types: data.scan_types || {},
                        scan_types_success: data.scan_types_success || {},
                        scan_types_failed: data.scan_types_failed || {},
                        top_projects: {},
                        busiest_hour: data.busiest_hour,
                        busiest_hour_end: data.busiest_hour_end,
                        busiest_count: data.busiest_count,
                        busiest_percentage: data.busiest_percentage,
                        quietest_hour: data.quietest_hour,
                        quietest_hour_end: data.quietest_hour_end,
                        quietest_count: data.quietest_count,
                        quietest_percentage: data.quietest_percentage,
                        busiest_hour_success: data.busiest_hour_success,
                        busiest_hour_end_success: data.busiest_hour_end_success,
                        busiest_count_success: data.busiest_count_success,
                        busiest_percentage_success: data.busiest_percentage_success,
                        quietest_hour_success: data.quietest_hour_success,
                        quietest_hour_end_success: data.quietest_hour_end_success,
                        quietest_count_success: data.quietest_count_success,
                        quietest_percentage_success: data.quietest_percentage_success,
                        busiest_hour_failed: data.busiest_hour_failed,
                        busiest_hour_end_failed: data.busiest_hour_end_failed,
                        busiest_count_failed: data.busiest_count_failed,
                        busiest_percentage_failed: data.busiest_percentage_failed,
                        quietest_hour_failed: data.quietest_hour_failed,
                        quietest_hour_end_failed: data.quietest_hour_end_failed,
                        quietest_count_failed: data.quietest_count_failed,
                        quietest_percentage_failed: data.quietest_percentage_failed
                    };
                    displayData.top_projects[selectedProject] = data.total_scans;
                    displayData.top_projects_success = {};
                    displayData.top_projects_success[selectedProject] = data.successful_scans || 0;
                    displayData.top_projects_failed = {};
                    displayData.top_projects_failed[selectedProject] = data.failed_scans || 0;
                    updateDisplay(displayData, selectedYear, selectedProject, selectedFile, selectedStatus);
                } else {
                    console.error('No data found for project:', selectedProject);
                }
            } else {
                // Filter by both year and project
                if (yearProjectData[selectedYear] && yearProjectData[selectedYear][selectedProject]) {
                    const data = yearProjectData[selectedYear][selectedProject];
                    const displayData = {
                        total_files: allData.total_files,
                        total_rows: data.total_scans,
                        unique_projects: 1,
                        total_scans: data.total_scans,
                        successful_scans: data.successful_scans || 0,
                        failed_scans: data.failed_scans || 0,
                        scan_types: data.scan_types,
                        scan_types_success: data.scan_types_success || {},
                        scan_types_failed: data.scan_types_failed || {},
                        top_projects: {},
                        busiest_hour: data.busiest_hour,
                        busiest_hour_end: data.busiest_hour_end,
                        busiest_count: data.busiest_count,
                        busiest_percentage: data.busiest_percentage,
                        quietest_hour: data.quietest_hour,
                        quietest_hour_end: data.quietest_hour_end,
                        quietest_count: data.quietest_count,
                        quietest_percentage: data.quietest_percentage,
                        busiest_hour_success: data.busiest_hour_success,
                        busiest_hour_end_success: data.busiest_hour_end_success,
                        busiest_count_success: data.busiest_count_success,
                        busiest_percentage_success: data.busiest_percentage_success,
                        quietest_hour_success: data.quietest_hour_success,
                        quietest_hour_end_success: data.quietest_hour_end_success,
                        quietest_count_success: data.quietest_count_success,
                        quietest_percentage_success: data.quietest_percentage_success,
                        busiest_hour_failed: data.busiest_hour_failed,
                        busiest_hour_end_failed: data.busiest_hour_end_failed,
                        busiest_count_failed: data.busiest_count_failed,
                        busiest_percentage_failed: data.busiest_percentage_failed,
                        quietest_hour_failed: data.quietest_hour_failed,
                        quietest_hour_end_failed: data.quietest_hour_end_failed,
                        quietest_count_failed: data.quietest_count_failed,
                        quietest_percentage_failed: data.quietest_percentage_failed
                    };
                    displayData.top_projects[selectedProject] = data.total_scans;
                    displayData.top_projects_success = {};
                    displayData.top_projects_success[selectedProject] = data.successful_scans || 0;
                    displayData.top_projects_failed = {};
                    displayData.top_projects_failed[selectedProject] = data.failed_scans || 0;
                    updateDisplay(displayData, selectedYear, selectedProject, selectedFile, selectedStatus);
                } else {
                    // Show empty data - this project had no scans in this year
                    const displayData = {
                        total_files: allData.total_files,
                        total_rows: 0,
                        unique_projects: 0,
                        total_scans: 0,
                        successful_scans: 0,
                        failed_scans: 0,
                        scan_types: {},
                        top_projects: {}
                    };
                    updateDisplay(displayData, selectedYear, selectedProject, selectedFile, selectedStatus);
                }
            }
        }
        
        function applyProjectFilter() {
            applyFilters();
        }
        
        function handleProjectInput() {
            const input = document.getElementById('projectFilterInput');
            if (input && input.value === '') {
                input.placeholder = 'All Projects (type to search...)';
            }
        }
        
        function updateProjectListForFile() {
            const fileFilter = document.getElementById('fileFilter');
            const projectList = document.getElementById('projectList');
            const projectFilterInput = document.getElementById('projectFilterInput');
            
            if (!projectList) return;
            
            const selectedFile = fileFilter ? fileFilter.value : 'all';
            let projectsToShow = [];
            
            if (selectedFile === 'all') {
                // Show all projects from all files
                projectsToShow = {{ analysis.available_projects | tojson | safe }};
            } else {
                // Show only projects from selected file
                const fileData = fileDataByFile[selectedFile];
                if (fileData && fileData.available_projects) {
                    projectsToShow = fileData.available_projects;
                } else {
                    projectsToShow = [];
                }
            }
            
            // Update the datalist
            projectList.innerHTML = '<option value="all">All Projects</option>' + 
                projectsToShow.map(p => `<option value="${p}">${p}</option>`).join('');
            
            // Clear current project filter input if the selected project is not in the new list
            if (projectFilterInput && projectFilterInput.value) {
                const currentProject = projectFilterInput.value;
                if (!projectsToShow.includes(currentProject) && currentProject !== '' && currentProject.toLowerCase() !== 'all projects') {
                    projectFilterInput.value = '';
                    projectFilterInput.placeholder = 'All Projects (type to search...)';
                }
            }
        }
        
        function clearAllFilters() {
            // Reset file filter
            const fileFilter = document.getElementById('fileFilter');
            if (fileFilter) {
                fileFilter.value = 'all';
            }
            
            // Update project list to show all projects
            updateProjectListForFile();
            
            // Reset year filter
            const yearFilter = document.getElementById('yearFilter');
            if (yearFilter) {
                yearFilter.value = 'all';
            }
            
            // Reset project filter
            const projectFilter = document.getElementById('projectFilterInput');
            if (projectFilter) {
                projectFilter.value = '';
                projectFilter.placeholder = 'All Projects (type to search...)';
            }
            
            // Reset status filter
            const statusFilter = document.getElementById('statusFilter');
            if (statusFilter) {
                statusFilter.value = 'all';
            }
            
            // Apply filters to refresh display with all resets
            applyFilters();
        }
        
        function applyStatusFilter(data, status) {
            // Create a filtered version of the data based on status
            const filteredData = JSON.parse(JSON.stringify(data)); // Deep copy
            
            if (status === 'success') {
                // Show only successful scans
                filteredData.total_scans = data.successful_scans || 0;
                filteredData.failed_scans = 0;
                filteredData.total_rows = data.successful_scans || 0;
                
                // Use success-specific busiest/quietest hours (fallback to all scans if not available)
                if (data.busiest_hour_success !== null && data.busiest_hour_success !== undefined) {
                    filteredData.busiest_hour = data.busiest_hour_success;
                    filteredData.busiest_hour_end = data.busiest_hour_end_success;
                    filteredData.busiest_count = data.busiest_count_success;
                    filteredData.busiest_percentage = data.busiest_percentage_success;
                }
                if (data.quietest_hour_success !== null && data.quietest_hour_success !== undefined) {
                    filteredData.quietest_hour = data.quietest_hour_success;
                    filteredData.quietest_hour_end = data.quietest_hour_end_success;
                    filteredData.quietest_count = data.quietest_count_success;
                    filteredData.quietest_percentage = data.quietest_percentage_success;
                }
                
                // Use success-specific scan types (fallback to all scans if not available)
                if (data.scan_types_success && Object.keys(data.scan_types_success).length > 0) {
                    filteredData.scan_types = data.scan_types_success;
                }
                
                // Use success-specific top projects (fallback to all scans if not available)
                if (data.top_projects_success && Object.keys(data.top_projects_success).length > 0) {
                    filteredData.top_projects = data.top_projects_success;
                }
            } else if (status === 'failed') {
                // Show only failed scans
                filteredData.total_scans = data.failed_scans || 0;
                filteredData.successful_scans = 0;
                filteredData.total_rows = data.failed_scans || 0;
                
                // Use failed-specific busiest/quietest hours (fallback to all scans if not available)
                if (data.busiest_hour_failed !== null && data.busiest_hour_failed !== undefined) {
                    filteredData.busiest_hour = data.busiest_hour_failed;
                    filteredData.busiest_hour_end = data.busiest_hour_end_failed;
                    filteredData.busiest_count = data.busiest_count_failed;
                    filteredData.busiest_percentage = data.busiest_percentage_failed;
                }
                if (data.quietest_hour_failed !== null && data.quietest_hour_failed !== undefined) {
                    filteredData.quietest_hour = data.quietest_hour_failed;
                    filteredData.quietest_hour_end = data.quietest_hour_end_failed;
                    filteredData.quietest_count = data.quietest_count_failed;
                    filteredData.quietest_percentage = data.quietest_percentage_failed;
                }
                
                // Use failed-specific scan types (fallback to all scans if not available)
                if (data.scan_types_failed && Object.keys(data.scan_types_failed).length > 0) {
                    filteredData.scan_types = data.scan_types_failed;
                }
                
                // Use failed-specific top projects (fallback to all scans if not available)
                if (data.top_projects_failed && Object.keys(data.top_projects_failed).length > 0) {
                    filteredData.top_projects = data.top_projects_failed;
                }
            }
            
            return filteredData;
        }
        
        function updateDisplay(data, selectedYear, selectedProject, selectedFile, selectedStatus) {
            selectedFile = selectedFile || 'all';
            selectedStatus = selectedStatus || 'all';
            // Apply status filter if needed
            let displayData = data;
            if (selectedStatus !== 'all') {
                displayData = applyStatusFilter(data, selectedStatus);
            } else {
            }
            
            try {
                document.getElementById('totalFiles').textContent = displayData.total_files;
                document.getElementById('totalRecords').textContent = displayData.total_rows;
                document.getElementById('uniqueProjects').textContent = displayData.unique_projects;
                document.getElementById('totalScans').textContent = displayData.total_scans;
                document.getElementById('successfulScans').textContent = displayData.successful_scans;
                document.getElementById('failedScans').textContent = displayData.failed_scans;
                updateSuccessRate(displayData.successful_scans, displayData.total_scans);
                
                // Update busiest and quietest hours
                updateBusiestQuietestHours(displayData.busiest_hour, displayData.busiest_count, displayData.quietest_hour, displayData.quietest_count, displayData.busiest_percentage, displayData.quietest_percentage, displayData.busiest_hour_end, displayData.quietest_hour_end);
            } catch (err) {
                console.error('Error updating stats:', err);
            }
            
            try {
                // Update scan types
                updateScanTypes(displayData.scan_types);
            } catch (err) {
                console.error('Error updating scan types:', err);
            }
            
            try {
                // Update project chart - use filterProjectsByScanType to respect both status and scan type filters
                filterProjectsByScanType();
            } catch (err) {
                console.error('Error updating project chart:', err);
            }
            
            try {
                updateScanTypePie(displayData.scan_types);
            } catch (err) {
                console.error('Error updating scan type pie:', err);
            }
            
            try {
                // Update time series chart based on filters
                updateTimeSeriesChart(selectedYear, selectedProject, selectedFile, selectedStatus);
            } catch (err) {
                console.error('Error updating time series chart:', err);
            }
            
            try {
                // Update scan type evolution data and chart
                updateScanTypeEvolutionData(selectedYear, selectedProject, selectedFile, selectedStatus);
            } catch (err) {
                console.error('Error updating scan type evolution:', err);
            }
        }
        
        function updateScanTypeEvolutionData(selectedYear, selectedProject, selectedFile, selectedStatus) {
            console.log('selectedProject type:', typeof selectedProject, 'value:', JSON.stringify(selectedProject));
            selectedFile = selectedFile || 'all';
            selectedStatus = selectedStatus || 'all';
            // Normalize empty string to 'all'
            if (selectedProject === '' || selectedProject === undefined || selectedProject === null) {
                selectedProject = 'all';
            }
            if (!chartData) {
                return;
            }
            console.log('chartData object keys:', Object.keys(chartData));
            console.log('chartData.scan_type_evolution keys:', chartData.scan_type_evolution ? Object.keys(chartData.scan_type_evolution).length : 0);
            
            // Determine which scan type evolution key to use based on status
            let statusKey = 'scan_type_evolution';
            if (selectedStatus === 'success') {
                statusKey = 'scan_type_evolution_success';
            } else if (selectedStatus === 'failed') {
                statusKey = 'scan_type_evolution_failed';
            }
            
            // Check if file-specific chart data should be used
            if (selectedFile !== 'all' && chartData.by_file && chartData.by_file[selectedFile]) {
                // File-specific data doesn't have status variants yet, use base scan_type_evolution
                scanTypeEvolutionData = chartData.by_file[selectedFile].scan_type_evolution || {};
            } else if (selectedYear === 'all' && selectedProject === 'all') {
                // Show all data with status filter
                scanTypeEvolutionData = chartData[statusKey] || {};
                console.log('Using ' + statusKey, Object.keys(scanTypeEvolutionData).length, 'scan types');
            } else if (selectedYear !== 'all' && selectedProject === 'all') {
                // Show year filtered data with status filter
                if (chartData.scan_type_evolution_by_year && chartData.scan_type_evolution_by_year[selectedYear]) {
                    scanTypeEvolutionData = chartData.scan_type_evolution_by_year[selectedYear][statusKey] || {};
                    console.log('Using scan_type_evolution_by_year[' + selectedYear + '][' + statusKey + ']:', Object.keys(scanTypeEvolutionData).length, 'scan types');
                } else {
                    scanTypeEvolutionData = {};
                }
            } else if (selectedYear === 'all' && selectedProject !== 'all') {
                // Show project filtered data with status filter
                if (chartData.scan_type_evolution_by_project && chartData.scan_type_evolution_by_project[selectedProject]) {
                    scanTypeEvolutionData = chartData.scan_type_evolution_by_project[selectedProject][statusKey] || {};
                    console.log('Using scan_type_evolution_by_project[' + selectedProject + '][' + statusKey + ']:', Object.keys(scanTypeEvolutionData).length, 'scan types');
                } else {
                    scanTypeEvolutionData = {};
                }
            } else {
                // Show year+project filtered data (no status filter for this yet)
                if (chartData.scan_type_evolution_by_year_project && 
                    chartData.scan_type_evolution_by_year_project[selectedYear] && 
                    chartData.scan_type_evolution_by_year_project[selectedYear][selectedProject]) {
                    scanTypeEvolutionData = chartData.scan_type_evolution_by_year_project[selectedYear][selectedProject];
                    console.log('Using scan_type_evolution_by_year_project:', Object.keys(scanTypeEvolutionData).length, 'scan types');
                } else {
                    scanTypeEvolutionData = {};
                }
            }
            
            // Update the checkboxes to reflect available scan types
            const availableScanTypes = Object.keys(scanTypeEvolutionData);
            const checkboxContainer = document.getElementById('scanTypeCheckboxes');
            if (checkboxContainer) {
                if (availableScanTypes.length > 0) {
                    checkboxContainer.innerHTML = availableScanTypes.map(scanType => `
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" class="scan-type-checkbox" value="${scanType}" checked onchange="updateScanTypeEvolution()">
                            <span>${scanType}</span>
                        </label>
                    `).join('');
                } else {
                    // Clear checkboxes if no scan types available
                    checkboxContainer.innerHTML = '';
                }
            }
            
            // Update the chart after a short delay to ensure DOM is updated
            // Capture the data in the closure to prevent it from being overwritten
            const capturedData = scanTypeEvolutionData;
            setTimeout(() => {
                // Use the captured data
                scanTypeEvolutionData = capturedData;
                updateScanTypeEvolution(selectedYear, selectedProject);
            }, 100);
        }
        
        function updateTimeSeriesChart(selectedYear, selectedProject, selectedFile, selectedStatus) {
            selectedFile = selectedFile || 'all';
            selectedStatus = selectedStatus || 'all';
            // Normalize empty string to 'all'
            if (selectedProject === '' || selectedProject === undefined || selectedProject === null) {
                selectedProject = 'all';
            }
            if (!chartData || !document.getElementById('timeSeriesChart')) {
                return;
            }
            console.log('Available chart data keys:', Object.keys(chartData));
            
            let timeSeriesData = [];
            
            // Determine which time series data key to use based on status
            let statusKey = 'time_series';
            if (selectedStatus === 'success') {
                statusKey = 'time_series_success';
            } else if (selectedStatus === 'failed') {
                statusKey = 'time_series_failed';
            }
            
            // Check if file-specific chart data should be used
            if (selectedFile !== 'all' && chartData.by_file && chartData.by_file[selectedFile]) {
                // File-specific data doesn't have status variants yet, use base time_series
                timeSeriesData = chartData.by_file[selectedFile].time_series || [];
            } else if (selectedYear === 'all' && selectedProject === 'all') {
                // Show all data with status filter
                timeSeriesData = chartData[statusKey] || [];
                console.log('Using ' + statusKey + ' (all data):', timeSeriesData.length, 'series');
            } else if (selectedYear !== 'all' && selectedProject === 'all') {
                // Show year filtered data with status filter
                if (chartData.time_series_by_year && chartData.time_series_by_year[selectedYear]) {
                    timeSeriesData = chartData.time_series_by_year[selectedYear][statusKey] || [];
                } else {
                    timeSeriesData = [];
                }
            } else if (selectedYear === 'all' && selectedProject !== 'all') {
                // Show project filtered data with status filter
                console.log('Available projects in time_series_by_project:', chartData.time_series_by_project ? Object.keys(chartData.time_series_by_project).length : 0);
                if (chartData.time_series_by_project && chartData.time_series_by_project[selectedProject]) {
                    timeSeriesData = chartData.time_series_by_project[selectedProject][statusKey] || [];
                } else {
                    timeSeriesData = [];
                }
            } else {
                // Show year+project filtered data (no status filter for this yet)
                if (chartData.time_series_by_year_project && 
                    chartData.time_series_by_year_project[selectedYear] && 
                    chartData.time_series_by_year_project[selectedYear][selectedProject]) {
                    timeSeriesData = chartData.time_series_by_year_project[selectedYear][selectedProject];
                } else {
                    timeSeriesData = [];
                    if (!chartData.time_series_by_year_project || Object.keys(chartData.time_series_by_year_project).length === 0) {
                        console.log('Year-project combinations not generated (report created with --skip-detailed)');
                    } else {
                    }
                }
            }
            
            // Update the chart
            if (timeSeriesData.length > 0) {
                const traces = timeSeriesData.map(function(chart) {
                    return {
                        x: chart.x,
                        y: chart.y,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: chart.name,
                        line: { width: 2 }
                    };
                });
                
                // Dynamic title based on status
                let titleSuffix = '';
                if (selectedStatus === 'success') {
                    titleSuffix = ' (Successful Scans)';
                } else if (selectedStatus === 'failed') {
                    titleSuffix = ' (Failed Scans)';
                }
                
                const layout = {
                    title: 'Scan Activity Over Time' + titleSuffix,
                    xaxis: { title: 'Time', tickangle: -45 },
                    yaxis: { title: 'Count/Size' },
                    hovermode: 'closest',
                    showlegend: true,
                    height: 500
                };
                
                Plotly.react('timeSeriesChart', traces, layout, config);
            } else {
                // Show empty chart with helpful message
                let emptyMessage = 'No time series data available for the selected filters';
                if (selectedProject !== 'all') {
                    emptyMessage = 'No chart data for this project (project has less than {{ min_scans }} scans)';
                } else {
                    emptyMessage = 'No time series data available for the selected filters';
                }
                Plotly.react('timeSeriesChart', [], {
                    title: emptyMessage,
                    height: 500
                }, config);
            }
        }
        
        function filterByYear() {
            applyFilters();
        }
        
        function updateSuccessRate(successful, total) {
            const rateElement = document.getElementById('successRate');
            if (total > 0) {
                const rate = (successful / total * 100).toFixed(1);
                rateElement.textContent = rate + '%';
            } else {
                rateElement.textContent = 'N/A';
            }
        }
        
        function updateBusiestQuietestHours(busiestHour, busiestCount, quietestHour, quietestCount, busiestPercentage, quietestPercentage, busiestHourEnd, quietestHourEnd) {
            const busiestElement = document.getElementById('busiestHour');
            const quietestElement = document.getElementById('quietestHour');
            
            if (busiestHour !== null && busiestHour !== undefined) {
                const hourStart = String(busiestHour).padStart(2, '0');
                const hourEnd = busiestHourEnd !== null && busiestHourEnd !== undefined ? String(busiestHourEnd).padStart(2, '0') : String((busiestHour + 3) % 24).padStart(2, '0');
                const hourRange = hourStart + ':00-' + hourEnd + ':00';
                const percentage = busiestPercentage !== null && busiestPercentage !== undefined ? busiestPercentage : 0;
                busiestElement.innerHTML = hourRange + '<div style="font-size: 0.4em; color: #666; margin-top: 5px;">' + busiestCount + ' scans (' + percentage + '%)</div>';
            } else {
                busiestElement.textContent = 'N/A';
            }
            
            if (quietestHour !== null && quietestHour !== undefined) {
                const hourStart = String(quietestHour).padStart(2, '0');
                const hourEnd = quietestHourEnd !== null && quietestHourEnd !== undefined ? String(quietestHourEnd).padStart(2, '0') : String((quietestHour + 3) % 24).padStart(2, '0');
                const hourRange = hourStart + ':00-' + hourEnd + ':00';
                const percentage = quietestPercentage !== null && quietestPercentage !== undefined ? quietestPercentage : 0;
                quietestElement.innerHTML = hourRange + '<div style="font-size: 0.4em; color: #666; margin-top: 5px;">' + quietestCount + ' scans (' + percentage + '%)</div>';
            } else {
                quietestElement.textContent = 'N/A';
            }
        }
        
        function updateScanTypes(scanTypes) {
            const container = document.getElementById('scanTypesBreakdown');
            if (!container) return;
            
            // Calculate total for percentages
            const total = Object.values(scanTypes).reduce((sum, count) => sum + count, 0);
            
            // Sort scan types alphabetically by display name
            const sortedEntries = Object.entries(scanTypes).sort((a, b) => {
                const nameA = getScanTypeDisplayName(a[0]).toUpperCase();
                const nameB = getScanTypeDisplayName(b[0]).toUpperCase();
                return nameA.localeCompare(nameB);
            });
            
            container.innerHTML = '';
            for (const [type, count] of sortedEntries) {
                const item = document.createElement('div');
                item.className = 'value-count-item';
                const icon = getScanTypeIcon(type);
                const displayName = getScanTypeDisplayName(type);
                const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : '0.0';
                item.innerHTML = `
                    <span class="value-count-label">${icon} ${displayName}</span>
                    <span class="value-count-value">${count} <span style="color: #fff; font-size: 0.85em; font-weight: 700;">(${percentage}%)</span></span>
                `;
                container.appendChild(item);
            }
        }
        
        function updateProjectChart(topProjects, statusFilter) {
            statusFilter = statusFilter || 'all';
            if (!topProjects || Object.keys(topProjects).length === 0) {
                // Clear chart if no data
                Plotly.purge('projectBarChart');
                document.getElementById('projectBarChart').innerHTML = '<p style="text-align: center; padding: 50px; color: #666;">No data available for this filter</p>';
                return;
            }
            
            // Sort and take top 20
            const sorted = Object.entries(topProjects)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);
            
            const labels = sorted.map(item => item[0]);
            const values = sorted.map(item => item[1]);
            // Determine hover text based on status filter
            let hoverTemplate = '%{x} scans';
            if (statusFilter === 'success') {
                hoverTemplate = '%{x} successful scans';
            } else if (statusFilter === 'failed') {
                hoverTemplate = '%{x} failed scans';
            }
            
            const trace = {
                x: values,
                y: labels,
                type: 'bar',
                orientation: 'h',
                hovertemplate: hoverTemplate + '<extra></extra>',
                marker: {
                    color: 'rgba(0, 102, 204, 0.8)',
                    line: {
                        color: 'rgba(0, 102, 204, 1)',
                        width: 1
                    }
                }
            };
            
            // Dynamic title based on status filter
            let titleSuffix = '';
            if (statusFilter === 'success') {
                titleSuffix = ' (Successful Scans)';
            } else if (statusFilter === 'failed') {
                titleSuffix = ' (Failed Scans)';
            }
            
            const layout = {
                title: 'Top Projects by Scan Count' + titleSuffix,
                xaxis: { title: 'Total Scans' },
                yaxis: { title: '' },
                height: 400,
                margin: { l: 200 }
            };
            
            Plotly.react('projectBarChart', [trace], layout, config);
        }
        
        function filterProjectsByScanType() {
            const selectedScanType = document.getElementById('scanTypeFilter').value;
            const selectedStatus = document.getElementById('statusFilter') ? document.getElementById('statusFilter').value : 'all';
            
            if (selectedScanType === 'all') {
                // No scan type filter - use top_projects based on status
                if (selectedStatus === 'success') {
                    updateProjectChart(allData.top_projects_success || {});
                } else if (selectedStatus === 'failed') {
                    updateProjectChart(allData.top_projects_failed || {});
                } else {
                    updateProjectChart(allData.top_projects);
                }
            } else {
                // Scan type filter applied - use projects_by_scan_type based on status
                let projectsForType;
                if (selectedStatus === 'success') {
                    projectsForType = (allData.projects_by_scan_type_success && allData.projects_by_scan_type_success[selectedScanType]) || {};
                } else if (selectedStatus === 'failed') {
                    projectsForType = (allData.projects_by_scan_type_failed && allData.projects_by_scan_type_failed[selectedScanType]) || {};
                } else {
                    projectsForType = (allData.projects_by_scan_type && allData.projects_by_scan_type[selectedScanType]) || {};
                }
                updateProjectChart(projectsForType);
            }
        }
        
        function updateScanTypePie(scanTypes) {
            if (!scanTypes || Object.keys(scanTypes).length === 0) {
                return;
            }
            
            const labels = Object.keys(scanTypes);
            const values = Object.values(scanTypes);
            
            const trace = {
                labels: labels,
                values: values,
                type: 'pie',
                marker: {
                    colors: ['#0066cc', '#3182ce', '#38b2ac', '#48bb78', '#d69e2e', '#dd6b20']
                }
            };
            
            const layout = {
                title: 'Scan Type Distribution',
                height: 400
            };
            
            Plotly.react('scanTypePieChart', [trace], layout, config);
        }
        
        function updateScanTypeEvolution(paramYear, paramProject) {
            // Get selected scan types from checkboxes
            const checkboxes = document.querySelectorAll('.scan-type-checkbox:checked');
            const selectedTypes = Array.from(checkboxes).map(cb => cb.value);
            
            // Check if there is no data available
            if (!scanTypeEvolutionData || Object.keys(scanTypeEvolutionData).length === 0) {
                let emptyMessage = 'No scan type evolution data available for the selected filters';
                // Use passed parameters if available, otherwise read from DOM
                const selectedYear = paramYear !== undefined ? paramYear : (document.getElementById('yearFilter') ? document.getElementById('yearFilter').value : 'all');
                let selectedProject = paramProject !== undefined ? paramProject : 'all';
                
                if (selectedProject !== 'all') {
                    emptyMessage = 'No trend data for this project (project has less than {{ min_scans }} scans)';
                } else if (selectedYear !== 'all' && selectedProject !== 'all' &&
                    (!chartData.scan_type_evolution_by_year_project || Object.keys(chartData.scan_type_evolution_by_year_project).length === 0)) {
                    emptyMessage = 'Year+Project combination data not available - report created without detailed charts (use bdmetrics without --skip-detailed flag to include this data)';
                }
                // Use Plotly to show error message so it can be replaced properly
                Plotly.react('scanTypeEvolutionChart', [], {
                    title: emptyMessage,
                    height: 500,
                    xaxis: { visible: false },
                    yaxis: { visible: false }
                }, config);
                return;
            }
            
            if (selectedTypes.length === 0) {
                // Use Plotly to show message so it can be replaced properly
                Plotly.react('scanTypeEvolutionChart', [], {
                    title: 'Please select at least one scan type',
                    height: 500,
                    xaxis: { visible: false },
                    yaxis: { visible: false }
                }, config);
                return;
            }
            
            // Create traces for selected scan types
            const traces = selectedTypes.map(scanType => {
                const data = scanTypeEvolutionData[scanType];
                if (!data || !data.x || !data.y || data.x.length === 0) {
                    return null;
                }
                
                return {
                    x: data.x,
                    y: data.y,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: scanType,
                    line: { width: 2 }
                };
            }).filter(trace => trace !== null);
            console.log('Total data points:', traces.reduce((sum, t) => sum + (t.x ? t.x.length : 0), 0));
            
            if (traces.length === 0) {
                document.getElementById('scanTypeEvolutionChart').innerHTML = '<p style="text-align: center; padding: 50px; color: #666;">No data available for selected scan types</p>';
                return;
            }
            
            const layout = {
                title: 'Scan Type Evolution Over Time' + (window.currentStatusFilter && window.currentStatusFilter !== 'all' ? 
                    (window.currentStatusFilter === 'success' ? ' (Successful Scans)' : ' (Failed Scans)') : ''),
                xaxis: { title: 'Time', tickangle: -45 },
                yaxis: { title: 'Scan Count' },
                hovermode: 'closest',
                height: 500
            };
            
            try {
                Plotly.react('scanTypeEvolutionChart', traces, layout, config);
            } catch (err) {
                console.error('Error rendering scan type evolution chart:', err);
                document.getElementById('scanTypeEvolutionChart').innerHTML = '<p style="text-align: center; padding: 50px; color: #ff0000;">Error rendering chart: ' + err.message + '</p>';
            }
        }
        
        // Tab switching with lazy chart loading
        function showTab(tabId, event) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabId).classList.add('active');
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // Lazy load charts when tabs become visible
            if (tabId === 'trendsTab' && !window.trendsChartLoaded) {
                setTimeout(() => renderTrendsChart(), 100);
            } else if (tabId === 'scanTypeTab' && !window.scanTypeEvolutionChartLoaded) {
                setTimeout(() => renderScanTypeEvolutionChart(), 100);
            }
        }
        
        // Initialize charts on page load
        document.addEventListener('DOMContentLoaded', function() {
            try {
                console.log('yearData keys:', Object.keys(yearData));
                
                // Verify Plotly is loaded
                if (typeof Plotly === 'undefined') {
                    console.error('ERROR: Plotly is not loaded!');
                    return;
                }
                // Render critical charts immediately (visible on load)
                // Time series chart - render immediately as it's on the default tab
                if (chartData && chartData.time_series && chartData.time_series.length > 0) {
                    const traces = chartData.time_series.map(function(chart) {
                        return {
                            x: chart.x,
                            y: chart.y,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: chart.name,
                            line: { width: 2 }
                        };
                    });
                    
                    const layout = {
                        title: 'Scan Activity Over Time',
                        xaxis: { title: 'Time', tickangle: -45 },
                        yaxis: { title: 'Count/Size' },
                        hovermode: 'closest',
                        showlegend: true,
                        height: 500
                    };
                    
                    Plotly.newPlot('timeSeriesChart', traces, layout, config);
                } else {
                }
            } catch (err) {
                console.error('Error in time series chart:', err);
            }
            
            // Defer non-critical charts to improve initial load performance
            // Skip metrics trends chart - will be lazy loaded when tab is shown
            try {
                // Top projects bar chart
                if (chartData && chartData.project_bars && chartData.project_bars.labels && chartData.project_bars.labels.length > 0) {
                    const trace = {
                        x: chartData.project_bars.values,
                        y: chartData.project_bars.labels,
                        type: 'bar',
                        orientation: 'h',
                        marker: {
                            color: 'rgba(0, 102, 204, 0.8)',
                            line: {
                                color: 'rgba(0, 102, 204, 1)',
                                width: 1
                            }
                        }
                    };
                    
                    const layout = {
                        title: 'Top Projects by Scan Count',
                        xaxis: { title: 'Total Scans' },
                        yaxis: { title: '' },
                        height: 400,
                        margin: { l: 200 }
                    };
                    
                    Plotly.newPlot('projectBarChart', [trace], layout, config);
                } else {
                    // Initialize with allData instead
                    if (allData && allData.top_projects) {
                        updateProjectChart(allData.top_projects);
                    }
                }
            } catch (err) {
                console.error('Error in project bar chart:', err);
            }
            
            try {
                // Scan type pie chart
                if (chartData && chartData.scan_type_pie && chartData.scan_type_pie.labels && chartData.scan_type_pie.labels.length > 0) {
                    const trace = {
                        labels: chartData.scan_type_pie.labels,
                        values: chartData.scan_type_pie.values,
                        type: 'pie',
                        marker: {
                            colors: ['#0066cc', '#3182ce', '#38b2ac', '#48bb78', '#d69e2e', '#dd6b20']
                        }
                    };
                    
                    const layout = {
                        title: 'Scan Type Distribution',
                        height: 400
                    };
                    
                    Plotly.newPlot('scanTypePieChart', [trace], layout, config);
                } else {
                    // Initialize with allData instead
                    if (allData && allData.scan_types) {
                        updateScanTypePie(allData.scan_types);
                    }
                }
            } catch (err) {
                console.error('Error in scan type pie chart:', err);
            }
            
            try {
                // Scan type evolution chart
                if (scanTypeEvolutionData && Object.keys(scanTypeEvolutionData).length > 0) {
                    updateScanTypeEvolution();
                }
            } catch (err) {
                console.error('Error in scan type evolution chart:', err);
            }
        });
    </script>
</body>
</html>
