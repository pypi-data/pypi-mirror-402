<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heatmap Metrics Analysis Report</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0066cc 0%, #003d7a 100%);
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        h1 {
            color: #0066cc;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            color: #666;
            font-size: 14px;
        }
        
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
            transition: transform 0.2s;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card-title {
            color: #666;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .card-value {
            font-size: 36px;
            font-weight: bold;
            margin: 10px 0;
            color: #3182ce;
        }
        
        .section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        h2 {
            color: #0066cc;
            margin-bottom: 20px;
            font-size: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .file-section {
            margin-bottom: 40px;
            padding-bottom: 40px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .file-section:last-child {
            border-bottom: none;
        }
        
        h3 {
            color: #0066cc;
            margin: 20px 0 15px 0;
        }
        
        h4 {
            color: #333;
            margin: 15px 0 10px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            overflow-x: auto;
            display: block;
        }
        
        thead {
            background: #f7fafc;
        }
        
        th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #4a5568;
            border-bottom: 2px solid #e2e8f0;
        }
        
        th:hover {
            background: #edf2f7;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        tbody tr:hover {
            background: #f7fafc;
        }
        
        .chart-container {
            margin: 20px 0;
            min-height: 400px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat-box {
            background: #f7fafc;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #0066cc;
        }
        
        .stat-label {
            font-weight: bold;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.3em;
            color: #0066cc;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 10px 20px;
            background: #f7fafc;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            color: #333;
        }
        
        .tab:hover {
            background: #edf2f7;
        }
        
        .tab.active {
            background: #0066cc;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .footer {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
            color: #666;
            font-size: 12px;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            background: #e6f3ff;
            color: #0066cc;
            border-radius: 3px;
            font-size: 0.85em;
            margin: 2px;
        }
        
        .value-count-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .value-count-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            color: white;
        }
        
        .value-count-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        
        .value-count-label {
            font-weight: 600;
            font-size: 1em;
            color: white;
        }
        
        .value-count-value {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            font-weight: bold;
            font-size: 1.3em;
            padding: 5px 15px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            word-break: break-all;
            max-width: 100%;
        }
        
        /* Project filter search styles */
        .project-filter-container {
            position: relative;
            display: inline-block;
        }
        
        #projectFilterInput {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 5px;
            border: 2px solid white;
            background: white;
            color: #667eea;
            cursor: pointer;
            min-width: 250px;
            max-width: 300px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            direction: ltr;
        }
        
        #projectFilterInput:focus {
            outline: none;
            border-color: #764ba2;
        }
        
        select option {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        @media (max-width: 768px) {
            .summary-cards {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìä Heatmap Metrics Analysis Report</h1>
            <div class="subtitle">
                Generated on {{ generated_date }}
                {% if analysis.available_files and analysis.available_files|length == 1 %}
                <br>Analyzing: <strong>{{ analysis.available_files[0] }}</strong>
                {% elif analysis.available_files and analysis.available_files|length > 1 %}
                <br>Analyzing <strong>{{ analysis.available_files|length }}</strong> files (combined data)
                {% endif %}
            </div>
            <div style="margin-top: 20px; display: flex; gap: 20px; flex-wrap: wrap;">
                {% if analysis.available_files and analysis.available_files|length > 1 %}
                <div>
                    <label for="fileFilter" style="font-size: 1.1em; margin-right: 10px;">Filter by File:</label>
                    <select id="fileFilter" onchange="updateProjectListForFile(); applyFilters()" style="padding: 8px 15px; font-size: 1em; border-radius: 5px; border: 2px solid white; background: white; color: #667eea; cursor: pointer;">
                        <option value="all">All Files (Aggregated)</option>
                        {% for file in analysis.available_files %}
                        <option value="{{ file }}">{{ file }}</option>
                        {% endfor %}
                    </select>
                </div>
                {% endif %}
                {% if analysis.available_years %}
                <div>
                    <label for="yearFilter" style="font-size: 1.1em; margin-right: 10px;">Filter by Year:</label>
                    <select id="yearFilter" onchange="applyFilters()" style="padding: 8px 15px; font-size: 1em; border-radius: 5px; border: 2px solid white; background: white; color: #667eea; cursor: pointer;">
                        <option value="all">All Years</option>
                        {% for year in analysis.available_years %}
                        <option value="{{ year }}">{{ year }}</option>
                        {% endfor %}
                    </select>
                </div>
                {% endif %}
                {% if analysis.available_projects %}
                <div class="project-filter-container">
                    <label for="projectFilterInput" style="font-size: 1.1em; margin-right: 10px;">Filter by Project:</label>
                    <input 
                        type="text" 
                        id="projectFilterInput" 
                        list="projectList" 
                        placeholder="All Projects (type to search...)"
                        onchange="applyProjectFilter()"
                        oninput="handleProjectInput()"
                        style="padding: 8px 15px; font-size: 1em; border-radius: 5px; border: 2px solid white; background: white; color: #667eea; min-width: 250px; max-width: 300px;"
                    >
                    <datalist id="projectList">
                        <option value="all">All Projects</option>
                        {% for project in analysis.available_projects %}
                        <option value="{{ project }}">{{ project }}</option>
                        {% endfor %}
                    </datalist>
                </div>
                <div>
                    <button onclick="clearAllFilters()" style="padding: 8px 20px; font-size: 1em; border-radius: 5px; border: 2px solid white; background: white; color: #667eea; cursor: pointer; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.background='#667eea'; this.style.color='white';" onmouseout="this.style.background='white'; this.style.color='#667eea';">
                        üîÑ Clear Filters
                    </button>
                </div>
                {% endif %}
            </div>
        </header>
        
        <div class="summary-cards">
            <div class="card">
                <div class="card-title">Total Files</div>
                <div class="card-value" id="totalFiles">{{ analysis.summary.total_files }}</div>
            </div>
            <div class="card">
                <div class="card-title">Total Records</div>
                <div class="card-value" id="totalRecords">{{ analysis.summary.total_rows | default('N/A') }}</div>
            </div>
            <div class="card">
                <div class="card-title">Unique Projects</div>
                <div class="card-value" id="uniqueProjects">{{ analysis.summary.unique_projects | default('N/A') }}</div>
            </div>
            <div class="card">
                <div class="card-title">Total Scans</div>
                <div class="card-value" id="totalScans">{{ analysis.summary.total_scans | default('N/A') }}</div>
            </div>
        </div>
        
        <div class="summary-cards">
            <div class="card">
                <div class="card-title">Successful Scans</div>
                <div class="card-value" id="successfulScans" style="color: #38a169;">{{ analysis.summary.successful_scans | default('N/A') }}</div>
            </div>
            <div class="card">
                <div class="card-title">Failed Scans</div>
                <div class="card-value" id="failedScans" style="color: #e53e3e;">{{ analysis.summary.failed_scans | default('N/A') }}</div>
            </div>
            <div class="card">
                <div class="card-title">Success Rate</div>
                <div class="card-value" id="successRate" style="color: #3182ce;">
                    {% if analysis.summary.total_scans and analysis.summary.total_scans > 0 %}
                        {{ "%.1f" | format((analysis.summary.successful_scans / analysis.summary.total_scans * 100)) }}%
                    {% else %}
                        N/A
                    {% endif %}
                </div>
            </div>
        </div>
        
        {% if analysis.aggregated %}
        <div class="section">
            <h2>üéØ Black Duck Scan Overview</h2>
            
            {% if analysis.aggregated.scan_types %}
            {% set total_scans = analysis.aggregated.scan_types.values()|sum %}
            <div style="background: white; padding: 25px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-top: 20px;">
                <h3 style="margin-top: 0; color: #2d3748; font-size: 1.4em;">üîç Scan Types Breakdown</h3>
                <div class="value-count-grid" id="scanTypesBreakdown">
                    {% for scan_type, count in analysis.aggregated.scan_types.items() %}
                    {% set percentage = ((count / total_scans) * 100)|round(1) if total_scans > 0 else 0 %}
                    <div class="value-count-item">
                        <span class="value-count-label"><span class="scan-type-icon" data-type="{{ scan_type }}"></span> {{ scan_type }}</span>
                        <span class="value-count-value">{{ count }} <span style="color: #fff; font-size: 0.85em; font-weight: 700;">({{ percentage }}%)</span></span>
                    </div>
                    {% endfor %}
                </div>
            </div>
            <script>
                // Map scan types to appropriate icons and display names
                function getScanTypeIcon(scanType) {
                    const iconMap = {
                        'SIGNATURE': '‚úçÔ∏è',
                        'SNIPPET': '‚úÇÔ∏è',
                        'BINARY': 'üíæ',
                        'CONTAINER': 'üì¶',
                        'SOURCE': 'üìÑ',
                        'DEPENDENCY': 'üîó',
                        'PACKAGE_MANAGER': 'üìö',
                        'DETECTOR': 'üîç',
                        'MANUAL': 'üë§',
                        'INFRASTRUCTURE_AS_CODE': 'üèóÔ∏è',
                        'DEFAULT': 'üìä'
                    };
                    return iconMap[scanType.toUpperCase()] || iconMap['DEFAULT'];
                }
                
                function getScanTypeDisplayName(scanType) {
                    const displayNameMap = {
                        'INFRASTRUCTURE_AS_CODE': 'INFRA AS CODE'
                    };
                    return displayNameMap[scanType.toUpperCase()] || scanType;
                }
                
                // Apply icons and display names to scan type elements
                document.querySelectorAll('.scan-type-icon').forEach(el => {
                    const scanType = el.getAttribute('data-type');
                    const icon = getScanTypeIcon(scanType);
                    const displayName = getScanTypeDisplayName(scanType);
                    const label = el.parentElement;
                    label.innerHTML = `<span class="scan-type-icon">${icon}</span> ${displayName}`;
                });
            </script>
            {% endif %}
            
            <h3 style="margin-top: 30px;">Top Projects</h3>
            <div style="margin-bottom: 15px;">
                <label for="scanTypeFilter" style="font-weight: 600; margin-right: 10px;">Filter by Scan Type:</label>
                <select id="scanTypeFilter" onchange="filterProjectsByScanType()" style="padding: 8px 15px; font-size: 0.95em; border-radius: 5px; border: 1px solid #e2e8f0; background: white; cursor: pointer;">
                    <option value="all">All Scan Types</option>
                    {% for scan_type in analysis.aggregated.scan_types.keys() %}
                    <option value="{{ scan_type }}">{{ scan_type }}</option>
                    {% endfor %}
                </select>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; margin-top: 20px;">
                <div id="projectBarChart" class="chart-container" style="min-height: 400px;"></div>
                <div id="scanTypePieChart" class="chart-container" style="min-height: 400px;"></div>
            </div>
        </div>
        {% endif %}
        
        {% if chart_data %}
        <div class="section">
            <h2>üìà Time Series Trends</h2>
            <div id="timeSeriesChart" class="chart-container"></div>
            
            <h3 style="margin-top: 30px;">Scan Type Evolution Over Time</h3>
            <div id="scanTypeEvolutionSection">
                <div style="margin-bottom: 15px;">
                    <label style="font-weight: 600; margin-right: 10px;">Select Scan Types to Display:</label>
                    <div id="scanTypeCheckboxes" style="display: flex; flex-wrap: wrap; gap: 15px; margin-top: 10px;">
                        {% for scan_type in analysis.aggregated.scan_types.keys() %}
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" class="scan-type-checkbox" value="{{ scan_type }}" checked onchange="updateScanTypeEvolution()">
                            <span>{{ scan_type }}</span>
                        </label>
                        {% endfor %}
                    </div>
                </div>
                <div id="scanTypeEvolutionChart" class="chart-container"></div>
            </div>
            
            {% if chart_data.trends %}
            <h3 style="margin-top: 30px;">Metric Trends</h3>
            <div id="metricsChart" class="chart-container"></div>
            {% endif %}
        </div>
        {% endif %}
        
        <div class="footer">
            <p>Generated by Heatmap Metrics Analyzer</p>
        </div>
    </div>
    
    <script>
        // Config for all charts
        const config = {
            responsive: true,
            displayModeBar: true,
            displaylogo: false
        };
        
        // Store year-specific data
        const yearData = {{ analysis.by_year | tojson | safe }};
        
        // Store project-specific data
        const projectData = {{ analysis.by_project | tojson | safe }};
        
        // Store combined year-project data
        const yearProjectData = {{ analysis.by_year_project | tojson | safe }};
        
        // Store file-specific data (for multi-file zips)
        const fileDataByFile = {{ analysis.by_file | tojson | safe }};
        
        const allData = {
            total_files: {{ analysis.summary.total_files }},
            total_rows: {{ analysis.summary.total_rows | default(0) }},
            unique_projects: {{ analysis.summary.unique_projects | default(0) }},
            total_scans: {{ analysis.summary.total_scans | default(0) }},
            successful_scans: {{ analysis.summary.successful_scans | default(0) }},
            failed_scans: {{ analysis.summary.failed_scans | default(0) }},
            scan_types: {{ analysis.aggregated.scan_types | tojson | safe }},
            top_projects: {{ analysis.aggregated.top_projects | tojson | safe }},
            projects_by_scan_type: {{ analysis.aggregated.projects_by_scan_type | tojson | safe }}
        };
        
        // Generate charts
        const chartData = {{ chart_data | safe }};
        let scanTypeEvolutionData = chartData && chartData.scan_type_evolution ? chartData.scan_type_evolution : {};
        
        // Debug output
        console.log('Chart Data:', chartData);
        console.log('Scan Type Evolution Data:', scanTypeEvolutionData);
        console.log('All Data:', allData);
        console.log('Year Data:', yearData);
        
        // Check if Plotly is loaded
        if (typeof Plotly === 'undefined') {
            console.error('Plotly is not loaded!');
        } else {
            console.log('Plotly is loaded successfully');
        }
        
        // Filter data by file, year and/or project
        function applyFilters() {
            const fileFilterEl = document.getElementById('fileFilter');
            const yearFilterEl = document.getElementById('yearFilter');
            const projectFilterInput = document.getElementById('projectFilterInput');
            
            if (!yearFilterEl) {
                console.error('Year filter element not found');
                return;
            }
            
            const selectedFile = fileFilterEl ? fileFilterEl.value : 'all';
            const selectedYear = yearFilterEl.value;
            let selectedProject = 'all';
            
            if (projectFilterInput) {
                const inputValue = projectFilterInput.value.trim();
                if (inputValue === '' || inputValue.toLowerCase() === 'all projects') {
                    selectedProject = 'all';
                    projectFilterInput.value = '';
                    projectFilterInput.placeholder = 'All Projects (type to search...)';
                } else {
                    selectedProject = inputValue;
                }
            }
            
            console.log('applyFilters called - File:', selectedFile, 'Year:', selectedYear, 'Project:', selectedProject);
            
            // Handle file filter with year/project combinations
            if (selectedFile !== 'all') {
                const fileData = fileDataByFile[selectedFile];
                if (!fileData) {
                    console.error('No data found for file:', selectedFile);
                    return;
                }
                
                // Apply year and project filters to file data
                if (selectedYear === 'all' && selectedProject === 'all') {
                    // Show all data for this file
                    updateDisplay(fileData, selectedYear, selectedProject, selectedFile);
                } else if (selectedYear !== 'all' && selectedProject === 'all') {
                    // Filter by year within this file
                    const yearFileData = fileData.by_year && fileData.by_year[selectedYear];
                    if (yearFileData) {
                        const displayData = {
                            total_files: 1,
                            total_rows: yearFileData.total_rows,
                            unique_projects: yearFileData.unique_projects,
                            total_scans: yearFileData.total_scans,
                            successful_scans: yearFileData.successful_scans || 0,
                            failed_scans: yearFileData.failed_scans || 0,
                            scan_types: yearFileData.scan_types,
                            top_projects: yearFileData.top_projects
                        };
                        updateDisplay(displayData, selectedYear, selectedProject, selectedFile);
                    } else {
                        console.error('No data found for year:', selectedYear, 'in file:', selectedFile);
                    }
                } else if (selectedYear === 'all' && selectedProject !== 'all') {
                    // Filter by project within this file
                    const projectFileData = fileData.by_project && fileData.by_project[selectedProject];
                    if (projectFileData) {
                        const displayData = {
                            total_files: 1,
                            total_rows: projectFileData.total_scans,
                            unique_projects: 1,
                            total_scans: projectFileData.total_scans,
                            successful_scans: projectFileData.successful_scans || 0,
                            failed_scans: projectFileData.failed_scans || 0,
                            scan_types: projectFileData.scan_types,
                            top_projects: {}
                        };
                        displayData.top_projects[selectedProject] = projectFileData.total_scans;
                        updateDisplay(displayData, selectedYear, selectedProject, selectedFile);
                    } else {
                        console.error('No data found for project:', selectedProject, 'in file:', selectedFile);
                    }
                } else {
                    // Filter by both year and project within this file
                    const yearProjectFileData = fileData.by_year_project && 
                                               fileData.by_year_project[selectedYear] && 
                                               fileData.by_year_project[selectedYear][selectedProject];
                    if (yearProjectFileData) {
                        const displayData = {
                            total_files: 1,
                            total_rows: yearProjectFileData.total_scans,
                            unique_projects: 1,
                            total_scans: yearProjectFileData.total_scans,
                            successful_scans: yearProjectFileData.successful_scans || 0,
                            failed_scans: yearProjectFileData.failed_scans || 0,
                            scan_types: yearProjectFileData.scan_types,
                            top_projects: {}
                        };
                        displayData.top_projects[selectedProject] = yearProjectFileData.total_scans;
                        updateDisplay(displayData, selectedYear, selectedProject, selectedFile);
                    } else {
                        console.log('No data found for year:', selectedYear, 'and project:', selectedProject, 'in file:', selectedFile);
                    }
                }
                return;
            }
            
            if (selectedYear === 'all' && selectedProject === 'all') {
                // Show all data
                updateDisplay(allData, selectedYear, selectedProject);
            } else if (selectedYear !== 'all' && selectedProject === 'all') {
                // Filter by year only
                const data = yearData[selectedYear];
                if (data) {
                    const displayData = {
                        total_files: allData.total_files,
                        total_rows: data.total_rows,
                        unique_projects: data.unique_projects,
                        total_scans: data.total_scans,
                        successful_scans: data.successful_scans || 0,
                        failed_scans: data.failed_scans || 0,
                        scan_types: data.scan_types,
                        top_projects: data.top_projects
                    };
                    updateDisplay(displayData, selectedYear, selectedProject);
                } else {
                    console.error('No data found for year:', selectedYear);
                }
            } else if (selectedYear === 'all' && selectedProject !== 'all') {
                // Filter by project only
                const data = projectData[selectedProject];
                if (data) {
                    const displayData = {
                        total_files: allData.total_files,
                        total_rows: data.total_scans,  // For a single project, rows = scans
                        unique_projects: 1,
                        total_scans: data.total_scans,
                        successful_scans: data.successful_scans || 0,
                        failed_scans: data.failed_scans || 0,
                        scan_types: data.scan_types,
                        top_projects: {}
                    };
                    displayData.top_projects[selectedProject] = data.total_scans;
                    updateDisplay(displayData, selectedYear, selectedProject);
                } else {
                    console.error('No data found for project:', selectedProject);
                }
            } else {
                // Filter by both year and project
                console.log('Filtering by both year and project');
                
                if (yearProjectData[selectedYear] && yearProjectData[selectedYear][selectedProject]) {
                    const data = yearProjectData[selectedYear][selectedProject];
                    const displayData = {
                        total_files: allData.total_files,
                        total_rows: data.total_scans,
                        unique_projects: 1,
                        total_scans: data.total_scans,
                        successful_scans: data.successful_scans || 0,
                        failed_scans: data.failed_scans || 0,
                        scan_types: data.scan_types,
                        top_projects: {}
                    };
                    displayData.top_projects[selectedProject] = data.total_scans;
                    updateDisplay(displayData, selectedYear, selectedProject);
                } else {
                    console.log('No data found for year:', selectedYear, 'and project:', selectedProject);
                    // Show empty data - this project had no scans in this year
                    const displayData = {
                        total_files: allData.total_files,
                        total_rows: 0,
                        unique_projects: 0,
                        total_scans: 0,
                        successful_scans: 0,
                        failed_scans: 0,
                        scan_types: {},
                        top_projects: {}
                    };
                    updateDisplay(displayData, selectedYear, selectedProject);
                }
            }
        }
        
        function applyProjectFilter() {
            applyFilters();
        }
        
        function handleProjectInput() {
            const input = document.getElementById('projectFilterInput');
            if (input && input.value === '') {
                input.placeholder = 'All Projects (type to search...)';
            }
        }
        
        function updateProjectListForFile() {
            const fileFilter = document.getElementById('fileFilter');
            const projectList = document.getElementById('projectList');
            const projectFilterInput = document.getElementById('projectFilterInput');
            
            if (!projectList) return;
            
            const selectedFile = fileFilter ? fileFilter.value : 'all';
            let projectsToShow = [];
            
            if (selectedFile === 'all') {
                // Show all projects from all files
                projectsToShow = {{ analysis.available_projects | tojson | safe }};
            } else {
                // Show only projects from selected file
                const fileData = fileDataByFile[selectedFile];
                if (fileData && fileData.available_projects) {
                    projectsToShow = fileData.available_projects;
                } else {
                    projectsToShow = [];
                }
            }
            
            // Update the datalist
            projectList.innerHTML = '<option value="all">All Projects</option>' + 
                projectsToShow.map(p => `<option value="${p}">${p}</option>`).join('');
            
            // Clear current project filter input if the selected project is not in the new list
            if (projectFilterInput && projectFilterInput.value) {
                const currentProject = projectFilterInput.value;
                if (!projectsToShow.includes(currentProject) && currentProject !== '' && currentProject.toLowerCase() !== 'all projects') {
                    projectFilterInput.value = '';
                    projectFilterInput.placeholder = 'All Projects (type to search...)';
                }
            }
        }
        
        function clearAllFilters() {
            // Reset file filter
            const fileFilter = document.getElementById('fileFilter');
            if (fileFilter) {
                fileFilter.value = 'all';
            }
            
            // Update project list to show all projects
            updateProjectListForFile();
            
            // Reset year filter
            const yearFilter = document.getElementById('yearFilter');
            if (yearFilter) {
                yearFilter.value = 'all';
            }
            
            // Reset project filter
            const projectFilter = document.getElementById('projectFilterInput');
            if (projectFilter) {
                projectFilter.value = '';
                projectFilter.placeholder = 'All Projects (type to search...)';
            }
            
            // Apply filters to refresh display
            applyFilters();
        }
        
        function updateDisplay(data, selectedYear, selectedProject, selectedFile) {
            selectedFile = selectedFile || 'all';
            console.log('updateDisplay called with:', {data, selectedYear, selectedProject, selectedFile});
            
            try {
                document.getElementById('totalFiles').textContent = data.total_files;
                document.getElementById('totalRecords').textContent = data.total_rows;
                document.getElementById('uniqueProjects').textContent = data.unique_projects;
                document.getElementById('totalScans').textContent = data.total_scans;
                document.getElementById('successfulScans').textContent = data.successful_scans;
                document.getElementById('failedScans').textContent = data.failed_scans;
                updateSuccessRate(data.successful_scans, data.total_scans);
            } catch (err) {
                console.error('Error updating stats:', err);
            }
            
            try {
                // Update scan types
                updateScanTypes(data.scan_types);
            } catch (err) {
                console.error('Error updating scan types:', err);
            }
            
            try {
                // Update charts
                updateProjectChart(data.top_projects);
            } catch (err) {
                console.error('Error updating project chart:', err);
            }
            
            try {
                updateScanTypePie(data.scan_types);
            } catch (err) {
                console.error('Error updating scan type pie:', err);
            }
            
            try {
                // Update time series chart based on filters
                updateTimeSeriesChart(selectedYear, selectedProject, selectedFile);
            } catch (err) {
                console.error('Error updating time series chart:', err);
            }
            
            try {
                // Update scan type evolution data and chart
                updateScanTypeEvolutionData(selectedYear, selectedProject, selectedFile);
            } catch (err) {
                console.error('Error updating scan type evolution:', err);
            }
            
            console.log('updateDisplay completed');
        }
        
        function updateScanTypeEvolutionData(selectedYear, selectedProject, selectedFile) {
            console.log('updateScanTypeEvolutionData RAW inputs - Year:', selectedYear, 'Project:', selectedProject, 'File:', selectedFile);
            console.log('selectedProject type:', typeof selectedProject, 'value:', JSON.stringify(selectedProject));
            selectedFile = selectedFile || 'all';
            // Normalize empty string to 'all'
            if (selectedProject === '' || selectedProject === undefined || selectedProject === null) {
                console.log('Normalizing selectedProject from', selectedProject, 'to "all"');
                selectedProject = 'all';
            }
            if (!chartData) {
                console.log('Chart data not available');
                return;
            }
            
            console.log('updateScanTypeEvolutionData AFTER normalization - Year:', selectedYear, 'Project:', selectedProject, 'File:', selectedFile);
            console.log('chartData object keys:', Object.keys(chartData));
            console.log('chartData.scan_type_evolution exists?', !!chartData.scan_type_evolution);
            console.log('chartData.scan_type_evolution keys:', chartData.scan_type_evolution ? Object.keys(chartData.scan_type_evolution).length : 0);
            // Check if file-specific chart data should be used
            if (selectedFile !== 'all' && chartData.by_file && chartData.by_file[selectedFile]) {
                scanTypeEvolutionData = chartData.by_file[selectedFile].scan_type_evolution || {};
            } else if (selectedYear === 'all' && selectedProject === 'all') {
                scanTypeEvolutionData = chartData.scan_type_evolution || {};
            } else if (selectedYear !== 'all' && selectedProject === 'all') {
                scanTypeEvolutionData = (chartData.scan_type_evolution_by_year && chartData.scan_type_evolution_by_year[selectedYear]) || {};
            } else if (selectedYear === 'all' && selectedProject !== 'all') {
                if (chartData.scan_type_evolution_by_project && chartData.scan_type_evolution_by_project[selectedProject]) {
                    scanTypeEvolutionData = chartData.scan_type_evolution_by_project[selectedProject];
                } else {
                    scanTypeEvolutionData = {};
                }
            } else {
                if (chartData.scan_type_evolution_by_year_project && 
                    chartData.scan_type_evolution_by_year_project[selectedYear] && 
                    chartData.scan_type_evolution_by_year_project[selectedYear][selectedProject]) {
                    scanTypeEvolutionData = chartData.scan_type_evolution_by_year_project[selectedYear][selectedProject];
                } else {
                    scanTypeEvolutionData = {};
                }
            }
            
            // Update the checkboxes to reflect available scan types
            const availableScanTypes = Object.keys(scanTypeEvolutionData);
            const checkboxContainer = document.getElementById('scanTypeCheckboxes');
            if (checkboxContainer) {
                if (availableScanTypes.length > 0) {
                    checkboxContainer.innerHTML = availableScanTypes.map(scanType => `
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="checkbox" class="scan-type-checkbox" value="${scanType}" checked onchange="updateScanTypeEvolution()">
                            <span>${scanType}</span>
                        </label>
                    `).join('');
                } else {
                    // Clear checkboxes if no scan types available
                    checkboxContainer.innerHTML = '';
                }
            }
            
            // Update the chart after a short delay to ensure DOM is updated
            // Capture the data in the closure to prevent it from being overwritten
            const capturedData = scanTypeEvolutionData;
            setTimeout(() => {
                // Use the captured data
                scanTypeEvolutionData = capturedData;
                updateScanTypeEvolution(selectedYear, selectedProject);
            }, 100);
        }
        
        function updateTimeSeriesChart(selectedYear, selectedProject, selectedFile) {
            selectedFile = selectedFile || 'all';
            // Normalize empty string to 'all'
            if (selectedProject === '' || selectedProject === undefined || selectedProject === null) {
                selectedProject = 'all';
            }
            if (!chartData || !document.getElementById('timeSeriesChart')) {
                console.log('Chart data or chart element not available');
                return;
            }
            
            console.log('updateTimeSeriesChart called with Year:', selectedYear, 'Project:', selectedProject, 'File:', selectedFile);
            console.log('Available chart data keys:', Object.keys(chartData));
            
            let timeSeriesData = [];
            
            // Check if file-specific chart data should be used
            if (selectedFile !== 'all' && chartData.by_file && chartData.by_file[selectedFile]) {
                timeSeriesData = chartData.by_file[selectedFile].time_series || [];
                console.log('Using file-specific time_series:', timeSeriesData.length, 'series');
            } else if (selectedYear === 'all' && selectedProject === 'all') {
                // Show all data
                timeSeriesData = chartData.time_series || [];
                console.log('Using time_series (all data):', timeSeriesData.length, 'series');
            } else if (selectedYear !== 'all' && selectedProject === 'all') {
                // Show year filtered data
                timeSeriesData = (chartData.time_series_by_year && chartData.time_series_by_year[selectedYear]) || [];
                console.log('Using time_series_by_year[' + selectedYear + ']:', timeSeriesData.length, 'series');
            } else if (selectedYear === 'all' && selectedProject !== 'all') {
                // Show project filtered data
                console.log('Looking for project:', selectedProject);
                console.log('Available projects in time_series_by_project:', chartData.time_series_by_project ? Object.keys(chartData.time_series_by_project).length : 0);
                if (chartData.time_series_by_project && chartData.time_series_by_project[selectedProject]) {
                    timeSeriesData = chartData.time_series_by_project[selectedProject];
                    console.log('Using time_series_by_project[' + selectedProject + ']:', timeSeriesData.length, 'series');
                } else {
                    timeSeriesData = [];
                    console.log('Project not in chart data');
                }
            } else {
                // Show year+project filtered data
                console.log('Looking for year:', selectedYear, 'and project:', selectedProject);
                if (chartData.time_series_by_year_project && 
                    chartData.time_series_by_year_project[selectedYear] && 
                    chartData.time_series_by_year_project[selectedYear][selectedProject]) {
                    timeSeriesData = chartData.time_series_by_year_project[selectedYear][selectedProject];
                    console.log('Using time_series_by_year_project:', timeSeriesData.length, 'series');
                } else {
                    timeSeriesData = [];
                    if (!chartData.time_series_by_year_project || Object.keys(chartData.time_series_by_year_project).length === 0) {
                        console.log('Year-project combinations not generated (report created with --skip-detailed)');
                    } else {
                        console.log('No data found for this year+project combination');
                    }
                }
            }
            
            // Update the chart
            if (timeSeriesData.length > 0) {
                const traces = timeSeriesData.map(function(chart) {
                    return {
                        x: chart.x,
                        y: chart.y,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: chart.name,
                        line: { width: 2 }
                    };
                });
                
                const layout = {
                    title: 'Scan Activity Over Time',
                    xaxis: { title: 'Time', tickangle: -45 },
                    yaxis: { title: 'Count/Size' },
                    hovermode: 'closest',
                    showlegend: true,
                    height: 500
                };
                
                Plotly.react('timeSeriesChart', traces, layout, config);
            } else {
                // Show empty chart with helpful message
                let emptyMessage = 'No time series data available for the selected filters';
                if (selectedProject !== 'all') {
                    emptyMessage = 'No chart data for this project (project has less than {{ min_scans }} scans)';
                } else if (selectedYear !== 'all' && selectedProject !== 'all' && 
                    (!chartData.time_series_by_year_project || Object.keys(chartData.time_series_by_year_project).length === 0)) {
                    emptyMessage = 'Year+Project combination data not available - report created without detailed charts';
                }
                Plotly.react('timeSeriesChart', [], {
                    title: emptyMessage,
                    height: 500
                }, config);
            }
        }
        
        function filterByYear() {
            applyFilters();
        }
        
        function updateSuccessRate(successful, total) {
            const rateElement = document.getElementById('successRate');
            if (total > 0) {
                const rate = (successful / total * 100).toFixed(1);
                rateElement.textContent = rate + '%';
            } else {
                rateElement.textContent = 'N/A';
            }
        }
        
        function updateScanTypes(scanTypes) {
            const container = document.getElementById('scanTypesBreakdown');
            if (!container) return;
            
            // Calculate total for percentages
            const total = Object.values(scanTypes).reduce((sum, count) => sum + count, 0);
            
            container.innerHTML = '';
            for (const [type, count] of Object.entries(scanTypes)) {
                const item = document.createElement('div');
                item.className = 'value-count-item';
                const icon = getScanTypeIcon(type);
                const displayName = getScanTypeDisplayName(type);
                const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : '0.0';
                item.innerHTML = `
                    <span class="value-count-label">${icon} ${displayName}</span>
                    <span class="value-count-value">${count} <span style="color: #fff; font-size: 0.85em; font-weight: 700;">(${percentage}%)</span></span>
                `;
                container.appendChild(item);
            }
        }
        
        function updateProjectChart(topProjects) {
            console.log('updateProjectChart called with:', topProjects);
            
            if (!topProjects || Object.keys(topProjects).length === 0) {
                // Clear chart if no data
                Plotly.purge('projectBarChart');
                document.getElementById('projectBarChart').innerHTML = '<p style="text-align: center; padding: 50px; color: #666;">No data available for this filter</p>';
                return;
            }
            
            // Sort and take top 20
            const sorted = Object.entries(topProjects)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);
            
            const labels = sorted.map(item => item[0]);
            const values = sorted.map(item => item[1]);
            
            console.log('Creating chart with', labels.length, 'projects');
            
            const trace = {
                x: values,
                y: labels,
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: 'rgba(0, 102, 204, 0.8)',
                    line: {
                        color: 'rgba(0, 102, 204, 1)',
                        width: 1
                    }
                }
            };
            
            const layout = {
                title: 'Top Projects by Scan Count',
                xaxis: { title: 'Total Scans' },
                yaxis: { title: '' },
                height: 400,
                margin: { l: 200 }
            };
            
            Plotly.react('projectBarChart', [trace], layout, config);
        }
        
        function filterProjectsByScanType() {
            const selectedScanType = document.getElementById('scanTypeFilter').value;
            
            if (selectedScanType === 'all') {
                updateProjectChart(allData.top_projects);
            } else {
                const projectsForType = allData.projects_by_scan_type[selectedScanType];
                updateProjectChart(projectsForType);
            }
        }
        
        function updateScanTypePie(scanTypes) {
            console.log('updateScanTypePie called with:', scanTypes);
            
            if (!scanTypes || Object.keys(scanTypes).length === 0) {
                console.log('No scan type data available');
                return;
            }
            
            const labels = Object.keys(scanTypes);
            const values = Object.values(scanTypes);
            
            const trace = {
                labels: labels,
                values: values,
                type: 'pie',
                marker: {
                    colors: ['#0066cc', '#3182ce', '#38b2ac', '#48bb78', '#d69e2e', '#dd6b20']
                }
            };
            
            const layout = {
                title: 'Scan Type Distribution',
                height: 400
            };
            
            Plotly.react('scanTypePieChart', [trace], layout, config);
        }
        
        function updateScanTypeEvolution(paramYear, paramProject) {
            // Get selected scan types from checkboxes
            const checkboxes = document.querySelectorAll('.scan-type-checkbox:checked');
            const selectedTypes = Array.from(checkboxes).map(cb => cb.value);
            
            // Check if there is no data available
            if (!scanTypeEvolutionData || Object.keys(scanTypeEvolutionData).length === 0) {
                let emptyMessage = 'No scan type evolution data available for the selected filters';
                // Use passed parameters if available, otherwise read from DOM
                const selectedYear = paramYear !== undefined ? paramYear : (document.getElementById('yearFilter') ? document.getElementById('yearFilter').value : 'all');
                let selectedProject = paramProject !== undefined ? paramProject : 'all';
                
                if (selectedProject !== 'all') {
                    emptyMessage = 'No trend data for this project (project has less than {{ min_scans }} scans)';
                } else if (selectedYear !== 'all' && selectedProject !== 'all' &&
                    (!chartData.scan_type_evolution_by_year_project || Object.keys(chartData.scan_type_evolution_by_year_project).length === 0)) {
                    emptyMessage = 'Year+Project combination data not available - report created without detailed charts (use bdmetrics without --skip-detailed flag to include this data)';
                }
                // Use Plotly to show error message so it can be replaced properly
                Plotly.react('scanTypeEvolutionChart', [], {
                    title: emptyMessage,
                    height: 500,
                    xaxis: { visible: false },
                    yaxis: { visible: false }
                }, config);
                return;
            }
            
            if (selectedTypes.length === 0) {
                // Use Plotly to show message so it can be replaced properly
                Plotly.react('scanTypeEvolutionChart', [], {
                    title: 'Please select at least one scan type',
                    height: 500,
                    xaxis: { visible: false },
                    yaxis: { visible: false }
                }, config);
                return;
            }
            
            // Create traces for selected scan types
            const traces = selectedTypes.map(scanType => {
                const data = scanTypeEvolutionData[scanType];
                if (!data || !data.x || !data.y || data.x.length === 0) {
                    console.log(`No data for scan type: ${scanType}`);
                    return null;
                }
                
                return {
                    x: data.x,
                    y: data.y,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: scanType,
                    line: { width: 2 }
                };
            }).filter(trace => trace !== null);
            
            console.log('traces:', traces);
            console.log('Total data points:', traces.reduce((sum, t) => sum + (t.x ? t.x.length : 0), 0));
            
            if (traces.length === 0) {
                document.getElementById('scanTypeEvolutionChart').innerHTML = '<p style="text-align: center; padding: 50px; color: #666;">No data available for selected scan types</p>';
                return;
            }
            
            const layout = {
                title: 'Scan Type Evolution Over Time',
                xaxis: { title: 'Time', tickangle: -45 },
                yaxis: { title: 'Scan Count' },
                hovermode: 'closest',
                height: 500
            };
            
            try {
                console.log('Attempting to render scan type evolution chart...');
                Plotly.react('scanTypeEvolutionChart', traces, layout, config);
                console.log('Scan type evolution chart rendered successfully');
            } catch (err) {
                console.error('Error rendering scan type evolution chart:', err);
                document.getElementById('scanTypeEvolutionChart').innerHTML = '<p style="text-align: center; padding: 50px; color: #ff0000;">Error rendering chart: ' + err.message + '</p>';
            }
        }
        
        // Tab switching with lazy chart loading
        function showTab(tabId, event) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabId).classList.add('active');
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // Lazy load charts when tabs become visible
            if (tabId === 'trendsTab' && !window.trendsChartLoaded) {
                setTimeout(() => renderTrendsChart(), 100);
            } else if (tabId === 'scanTypeTab' && !window.scanTypeEvolutionChartLoaded) {
                setTimeout(() => renderScanTypeEvolutionChart(), 100);
            }
        }
        
        // Lazy render functions for heavy charts
        function renderTrendsChart() {
            if (window.trendsChartLoaded) return;
            console.log('Lazy loading trends chart...');
            try {
                if (chartData && chartData.trends && chartData.trends.length > 0) {
                    const traces = chartData.trends.map(function(chart) {
                        return {
                            x: chart.x,
                            y: chart.y,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: chart.name,
                            line: { width: 2 }
                        };
                    });
                    
                    const layout = {
                        title: 'Metric Trends',
                        xaxis: { title: 'Index' },
                        yaxis: { title: 'Value' },
                        hovermode: 'closest',
                        showlegend: true,
                        height: 400
                    };
                    
                    Plotly.newPlot('metricsChart', traces, layout, config);
                    window.trendsChartLoaded = true;
                }
            } catch (err) {
                console.error('Error in trends chart:', err);
            }
        }
        
        function renderScanTypeEvolutionChart() {
            if (window.scanTypeEvolutionChartLoaded) return;
            console.log('Lazy loading scan type evolution chart...');
            window.scanTypeEvolutionChartLoaded = true;
            // The actual chart is rendered by updateScanTypeEvolutionData which is already called
            // This flag just prevents re-initialization
        }
        
        // Initialize charts on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('=== Initializing Page - Using Progressive Loading ===');
            
            try {
                console.log('=== DOM Content Loaded ===');
                console.log('chartData:', chartData);
                console.log('allData:', allData);
                console.log('yearData keys:', Object.keys(yearData));
                
                // Verify Plotly is loaded
                if (typeof Plotly === 'undefined') {
                    console.error('ERROR: Plotly is not loaded!');
                    return;
                }
                console.log('Plotly loaded successfully');
                
                // Render critical charts immediately (visible on load)
                // Time series chart - render immediately as it's on the default tab
                if (chartData && chartData.time_series && chartData.time_series.length > 0) {
                    console.log('Creating time series chart with', chartData.time_series.length, 'series');
                    const traces = chartData.time_series.map(function(chart) {
                        return {
                            x: chart.x,
                            y: chart.y,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: chart.name,
                            line: { width: 2 }
                        };
                    });
                    
                    const layout = {
                        title: 'Scan Activity Over Time',
                        xaxis: { title: 'Time', tickangle: -45 },
                        yaxis: { title: 'Count/Size' },
                        hovermode: 'closest',
                        showlegend: true,
                        height: 500
                    };
                    
                    Plotly.newPlot('timeSeriesChart', traces, layout, config);
                } else {
                    console.log('No time series data available');
                }
            } catch (err) {
                console.error('Error in time series chart:', err);
            }
            
            // Defer non-critical charts to improve initial load performance
            // Skip metrics trends chart - will be lazy loaded when tab is shown
            console.log('Deferring trends chart - will load when tab is visible');
            
            try {
                // Top projects bar chart
                if (chartData && chartData.project_bars && chartData.project_bars.labels && chartData.project_bars.labels.length > 0) {
                    console.log('Creating initial project bar chart');
                    const trace = {
                        x: chartData.project_bars.values,
                        y: chartData.project_bars.labels,
                        type: 'bar',
                        orientation: 'h',
                        marker: {
                            color: 'rgba(0, 102, 204, 0.8)',
                            line: {
                                color: 'rgba(0, 102, 204, 1)',
                                width: 1
                            }
                        }
                    };
                    
                    const layout = {
                        title: 'Top Projects by Scan Count',
                        xaxis: { title: 'Total Scans' },
                        yaxis: { title: '' },
                        height: 400,
                        margin: { l: 200 }
                    };
                    
                    Plotly.newPlot('projectBarChart', [trace], layout, config);
                    console.log('Project bar chart created');
                } else {
                    console.log('No project bar chart data, checking allData...');
                    // Initialize with allData instead
                    if (allData && allData.top_projects) {
                        console.log('Initializing project chart with allData.top_projects');
                        updateProjectChart(allData.top_projects);
                    }
                }
            } catch (err) {
                console.error('Error in project bar chart:', err);
            }
            
            try {
                // Scan type pie chart
                if (chartData && chartData.scan_type_pie && chartData.scan_type_pie.labels && chartData.scan_type_pie.labels.length > 0) {
                    console.log('Creating initial scan type pie chart');
                    const trace = {
                        labels: chartData.scan_type_pie.labels,
                        values: chartData.scan_type_pie.values,
                        type: 'pie',
                        marker: {
                            colors: ['#0066cc', '#3182ce', '#38b2ac', '#48bb78', '#d69e2e', '#dd6b20']
                        }
                    };
                    
                    const layout = {
                        title: 'Scan Type Distribution',
                        height: 400
                    };
                    
                    Plotly.newPlot('scanTypePieChart', [trace], layout, config);
                    console.log('Scan type pie chart created');
                } else {
                    console.log('No scan type pie chart data, checking allData...');
                    // Initialize with allData instead
                    if (allData && allData.scan_types) {
                        console.log('Initializing pie chart with allData.scan_types');
                        updateScanTypePie(allData.scan_types);
                    }
                }
            } catch (err) {
                console.error('Error in scan type pie chart:', err);
            }
            
            try {
                // Scan type evolution chart
                if (scanTypeEvolutionData && Object.keys(scanTypeEvolutionData).length > 0) {
                    updateScanTypeEvolution();
                }
            } catch (err) {
                console.error('Error in scan type evolution chart:', err);
            }
        });
    </script>
</body>
</html>
