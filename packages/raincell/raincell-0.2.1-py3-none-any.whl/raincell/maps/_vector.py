"""This module provides interactive map visualization for Commercial Microwave Link (CML) networks using Folium and GeoPandas. It allows you to explore link geometries on a map with various basemaps and controls."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/21_maps.vector.ipynb.

# %% auto 0
__all__ = ['setup_default_map', 'explore_links', 'explore_sublinks', 'explore_data']

# %% ../../nbs/21_maps.vector.ipynb 2
from typing import Callable, Literal

import numpy as np
import xarray as xr
import geopandas as gpd
import folium
import folium.plugins
from shapely.geometry import LineString
from matplotlib.colors import Normalize, to_hex, ListedColormap
import matplotlib.pyplot as plt

from .. import open_cml_sample

# %% ../../nbs/21_maps.vector.ipynb 5
def setup_default_map(
        m: folium.Map = None, # Optional folium map to be setup with basemaps and controls
        show: Literal["OpenStreetMap", "OpenTopoMap", "Esri.WorldImagery", "Esri.WorldGrayCanvas"] = "Esri.WorldImagery" # Basemap to show by default.
        ) -> folium.Map:
    """ Create a default folium map with common basemaps, layers and controls."""
    m = m or folium.Map(tiles=None)
    for tile in ["OpenStreetMap", "OpenTopoMap", "Esri.WorldImagery", "Esri.WorldGrayCanvas"]:
        folium.TileLayer(tile, name=tile, show=(tile==show)).add_to(m)
    folium.LayerControl().add_to(m)
    folium.plugins.Fullscreen(position="topright",force_separate_button=True).add_to(m)
    folium.plugins.Geocoder(collapsed=True, add_marker=False).add_to(m)
    folium.plugins.MeasureControl(position="bottomright").add_to(m)
    return m

# %% ../../nbs/21_maps.vector.ipynb 8
def rclick_cp_cml_id(m: folium.Map):
    """ Copy cml_id to clipboard when right clicking on a link """
    js_code = """
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
            var map = Object.values(window).find(v => v instanceof L.Map);
            map.eachLayer(function(layer) {
                if (layer.feature && layer.feature.properties && layer.feature.properties.cml_id) {
                    layer.on('contextmenu', function(e) {
                        L.DomEvent.stopPropagation(e);
                        L.DomEvent.preventDefault(e);
                        var cmlId = e.target.feature.properties.cml_id;
                        var jsonObj = JSON.stringify({cml_id: cmlId});
                        navigator.clipboard.writeText(jsonObj);
                        console.log('Copied:', jsonObj);
                    });
                }
            });
        }, 1000);
    });
    </script>
    """

    m.get_root().html.add_child(folium.Element(js_code))

# %% ../../nbs/21_maps.vector.ipynb 9
def explore_links(
    cml: xr.Dataset | xr.DataArray, # CML in OpenSense standard
    default: Callable = setup_default_map, # Function to set up a default map including for example basemaps or controls
    copy_cml_id_on_rclick: bool = True, # Enable copying cml_id to clipboard when right clicking on a link
    **explore_kwargs
    ) -> folium.Map:
    """ Geopandas [explore](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.explore.html) wrapper to visualize CML link structure """
    links_df = cml.cml_id.to_dataframe().drop_duplicates()
    geom = [LineString([(l.site_0_lon, l.site_0_lat), (l.site_1_lon, l.site_1_lat)]) for _, l in links_df.iterrows()]
    links_gdf = gpd.GeoDataFrame(links_df["length"], geometry=geom, crs="EPSG:4326")
    m = links_gdf.explore(tiles=None, **explore_kwargs)
    link_layer, = [c for c in m._children.values() if isinstance(c, folium.features.GeoJson)]
    link_layer.layer_name = "Links"
    if default:
        m = default(m)
    folium.plugins.Search(layer=link_layer, geom_type="LineString", placeholder="CML ID", collapsed=True, search_label="cml_id").add_to(m)
    if copy_cml_id_on_rclick:
        rclick_cp_cml_id(m)
    return m

# %% ../../nbs/21_maps.vector.ipynb 12
def add_sense(m: folium.Map, layer_name: str = "Sublinks"):
    """ Add directional arrows to sublinks showing the transmission sense (direction from transmitter to receiver) """
    layer = [l for l in m._children.values() if isinstance(l, folium.features.GeoJson) and l.layer_name == layer_name]
    layer = layer[0] if len(layer) == 1 else ValueError(f"{len(layer)} matching layers found. There should be only one matching layer")

    fg = folium.FeatureGroup(name=layer_name + "_sense", show=False).add_to(m)
    for feat in layer.data["features"]:
        coords = feat["geometry"]["coordinates"]
        coords = [[coords[0][1], coords[0][0]], [coords[1][1], coords[1][0]]]
        hidden_pl = folium.PolyLine(coords, weight=0).add_to(fg) # Hiden lines required to add sens over them

        ws = "    "
        arrow = 2*ws + ">" + 2*ws if not feat["properties"]["transmitter"] else 3*ws + "<" + ws
        sense = folium.plugins.PolyLineTextPath(hidden_pl, arrow, repeat=True, offset=8, attributes={"font-weight": "bold", "font-size": "24", "fill": "red"})
        sense.add_to(fg)
    return m

# %% ../../nbs/21_maps.vector.ipynb 13
def rclick_cp_ids(m: folium.Map):
    """ Copy cml_id and sublink_id as a python dict to clipboard when right clicking on a sublink """
    js_code = """
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(function() {
            var map = Object.values(window).find(v => v instanceof L.Map);
            map.eachLayer(function(layer) {
                if (layer.feature && layer.feature.properties && layer.feature.properties.cml_id) {
                    layer.on('contextmenu', function(e) {
                        L.DomEvent.stopPropagation(e);
                        L.DomEvent.preventDefault(e);
                        var cmlId = e.target.feature.properties.cml_id;
                        var sublinkId = e.target.feature.properties.sublink_id;
                        var jsonObj = JSON.stringify({cml_id: cmlId, sublink_id: sublinkId});
                        navigator.clipboard.writeText(jsonObj);
                        console.log('Copied:', jsonObj);
                    });
                }
            });
        }, 1000);
    });
    </script>
    """

    m.get_root().html.add_child(folium.Element(js_code))

# %% ../../nbs/21_maps.vector.ipynb 14
def explore_sublinks(
    cml: xr.Dataset | xr.DataArray, # CML in OpenSense standard
    default: Callable = setup_default_map, # Function to set up a default map including for example basemaps or controls
    add_transmission_sense: bool = True, # If true it will overlay an arrow over each sublink showing the sense of the signal
    cp_id_on_rclick: bool = True, # Enable copying cml_id and sublink_id when right clicking on a sublink
    **explore_kwargs
    ) -> folium.Map:
    """ Geopandas [explore](https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.explore.html) wrapper to visualize CML sublink structure by coloring on frequency """
    sublinks_df = cml[["cml_id", "sublink_id"]].to_dataframe().reset_index()
    sublinks_df = sublinks_df.dropna(subset="frequency").reset_index(drop=True)

    offset = 1e-4 # Offset by ~10m in the equator
    cc = sublinks_df.groupby('cml_id').cumcount() * offset
    for coord in ['site_0_lat', 'site_1_lat', 'site_0_lon', 'site_1_lon']:
        sublinks_df[coord] += cc

    cols = [c for c in sublinks_df if "lat" not in c and "lon" not in c]
    geom = [LineString([(l.site_0_lon, l.site_0_lat), (l.site_1_lon, l.site_1_lat)]) for _, l in sublinks_df.iterrows()]
    sl_gdf = gpd.GeoDataFrame(sublinks_df[cols], geometry=geom, crs="EPSG:4326",)
    if "transmitter" in sl_gdf:
        sl_gdf["transmitter"] = sl_gdf["transmitter"].astype(int)
    explore_kwargs = {"tiles": None, "cmap": "gist_rainbow", "vmin": 8000, "vmax": 18000, "tiles": None, **explore_kwargs}
    m = sl_gdf.explore("frequency", **explore_kwargs)
    sublink_layer, = [layer for name, layer in m._children.items() if name.startswith("geo_json_") and isinstance(layer, folium.features.GeoJson)]
    sublink_layer.layer_name = "Sublinks"

    if add_transmission_sense:
        assert "transmitter" in sl_gdf, ValueError("transmitter coordinate is required to add sense")
        add_sense(m, "Sublinks")
    if default:
        m = default(m)
    if rclick_cp_ids:
        rclick_cp_ids(m)

    return m

# %% ../../nbs/21_maps.vector.ipynb 17
def explore_data(
    cml: xr.DataArray, # CML raw or derived data in OpenSense standard
    vmin: float = None, # Minimum value for the colormap
    vmax: float = None, # Maximum value for the colormap
    cmap: ListedColormap = plt.cm.viridis # Matplotlib colormap
) -> folium.Map:
    def assign_style(v, normalizer, cmap):
        return {"color": to_hex(cmap(normalizer(v))), "weight": 2} 
    if not cml.name:
        raise NameError("You must provide a dataset with a valid name")
    var = cml.name
    df = cml.to_dataframe().dropna(subset=var)

    offset = 1e-4 # Offset by ~10m in the equator
    cc = df.groupby(['cml_id', 'time']).cumcount() * offset
    for coord in ['site_0_lat', 'site_1_lat', 'site_0_lon', 'site_1_lon']:
        df[coord] += cc

    cols = [c for c in df if "lat" not in c and "lon" not in c]
    geom = [LineString([(l.site_0_lon, l.site_0_lat), (l.site_1_lon, l.site_1_lat)]) for _, l in df.iterrows()]
    gdf = gpd.GeoDataFrame(df[cols], geometry=geom, crs="EPSG:4326",)
    gdf.reset_index(inplace=True)

    vmin = vmin if vmin is not None else gdf[var].min()
    vmax = vmax if vmax is not None else gdf[var].max()
    normalizer = Normalize(vmin=vmin, vmax=vmax)
    gdf["style"] = gdf[var].apply(assign_style, args=(normalizer, cmap))

    gdf["time"] = gdf['time'].dt.strftime('%Y-%m-%dT%H:%M:%S')
    gdf["times"] = gdf["time"].apply(lambda t: [t, t])
    gdf = gdf.sort_values(by=["time", "cml_id", "sublink_id"])
    gdf.drop(columns="time", inplace=True)

    m = explore_sublinks(cml.to_dataset(), show=False) # Remove .to_dataset() when explore_sublinks will accept xr.DataArray
    folium.plugins.TimestampedGeoJson(
        gdf.__geo_interface__,
        period="PT15M",
        add_last_point=False,
        auto_play=False,
        loop=False,
        max_speed=1,
        loop_button=True,
        time_slider_drag_update=True,
    ).add_to(m)
    return m
