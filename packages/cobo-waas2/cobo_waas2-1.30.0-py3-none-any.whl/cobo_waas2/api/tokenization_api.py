# coding: utf-8

"""
    Cobo Wallet as a Service 2.0

    Contact: help@cobo.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from cobo_waas2.models.estimated_fee import EstimatedFee
from cobo_waas2.models.get_tokenization_allowlist_activation200_response import GetTokenizationAllowlistActivation200Response
from cobo_waas2.models.list_tokenization_blocklist_addresses200_response import ListTokenizationBlocklistAddresses200Response
from cobo_waas2.models.tokenization_activity_info import TokenizationActivityInfo
from cobo_waas2.models.tokenization_activity_status import TokenizationActivityStatus
from cobo_waas2.models.tokenization_allowlist_activation_request import TokenizationAllowlistActivationRequest
from cobo_waas2.models.tokenization_allowlist_addresses_response import TokenizationAllowlistAddressesResponse
from cobo_waas2.models.tokenization_burn_token_request import TokenizationBurnTokenRequest
from cobo_waas2.models.tokenization_contract_call_request import TokenizationContractCallRequest
from cobo_waas2.models.tokenization_estimate_fee_request import TokenizationEstimateFeeRequest
from cobo_waas2.models.tokenization_issued_token_request import TokenizationIssuedTokenRequest
from cobo_waas2.models.tokenization_list_activities_response import TokenizationListActivitiesResponse
from cobo_waas2.models.tokenization_list_enabled_chains_response import TokenizationListEnabledChainsResponse
from cobo_waas2.models.tokenization_list_holdings_response import TokenizationListHoldingsResponse
from cobo_waas2.models.tokenization_list_permissions_response import TokenizationListPermissionsResponse
from cobo_waas2.models.tokenization_list_token_info_response import TokenizationListTokenInfoResponse
from cobo_waas2.models.tokenization_mint_token_request import TokenizationMintTokenRequest
from cobo_waas2.models.tokenization_operation_response import TokenizationOperationResponse
from cobo_waas2.models.tokenization_operation_type import TokenizationOperationType
from cobo_waas2.models.tokenization_pause_token_request import TokenizationPauseTokenRequest
from cobo_waas2.models.tokenization_status import TokenizationStatus
from cobo_waas2.models.tokenization_token_detail_info import TokenizationTokenDetailInfo
from cobo_waas2.models.tokenization_token_standard import TokenizationTokenStandard
from cobo_waas2.models.tokenization_unpause_token_request import TokenizationUnpauseTokenRequest
from cobo_waas2.models.tokenization_update_allowlist_addresses_request import TokenizationUpdateAllowlistAddressesRequest
from cobo_waas2.models.tokenization_update_blocklist_addresses_request import TokenizationUpdateBlocklistAddressesRequest
from cobo_waas2.models.tokenization_update_permissions_request import TokenizationUpdatePermissionsRequest

from cobo_waas2.api_client import ApiClient, RequestSerialized
from cobo_waas2.api_response import ApiResponse
from cobo_waas2.rest import RESTResponseType


class TokenizationApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: ApiClient = None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def burn_tokenization(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_burn_token_request: Annotated[Optional[TokenizationBurnTokenRequest], Field(description="The request body for burning tokens.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationOperationResponse:
        """Burn tokens

        This operation burns tokens from a specified address. Creates a burn transaction that will decrease the token supply.  **Note**: This operation is not supported for CoboERC20Wrapper and SOLWrapper tokens. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_burn_token_request: The request body for burning tokens.
        :type tokenization_burn_token_request: TokenizationBurnTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._burn_tokenization_serialize(
            token_id=token_id,
            tokenization_burn_token_request=tokenization_burn_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def burn_tokenization_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_burn_token_request: Annotated[Optional[TokenizationBurnTokenRequest], Field(description="The request body for burning tokens.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationOperationResponse]:
        """Burn tokens

        This operation burns tokens from a specified address. Creates a burn transaction that will decrease the token supply.  **Note**: This operation is not supported for CoboERC20Wrapper and SOLWrapper tokens. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_burn_token_request: The request body for burning tokens.
        :type tokenization_burn_token_request: TokenizationBurnTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._burn_tokenization_serialize(
            token_id=token_id,
            tokenization_burn_token_request=tokenization_burn_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def burn_tokenization_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_burn_token_request: Annotated[Optional[TokenizationBurnTokenRequest], Field(description="The request body for burning tokens.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Burn tokens

        This operation burns tokens from a specified address. Creates a burn transaction that will decrease the token supply.  **Note**: This operation is not supported for CoboERC20Wrapper and SOLWrapper tokens. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_burn_token_request: The request body for burning tokens.
        :type tokenization_burn_token_request: TokenizationBurnTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._burn_tokenization_serialize(
            token_id=token_id,
            tokenization_burn_token_request=tokenization_burn_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _burn_tokenization_serialize(
        self,
        token_id,
        tokenization_burn_token_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tokenization_burn_token_request is not None:
            _body_params = tokenization_burn_token_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tokenization/tokens/{token_id}/burn',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def estimate_tokenization_fee(
        self,
        tokenization_estimate_fee_request: Annotated[TokenizationEstimateFeeRequest, Field(description="The request body to estimate tokenization operation fee.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> EstimatedFee:
        """Estimate tokenization operation fee

        This operation estimates the fee required for tokenization operations. For EVM-based chains, this calculates the gas cost for the specified operation. 

        :param tokenization_estimate_fee_request: The request body to estimate tokenization operation fee. (required)
        :type tokenization_estimate_fee_request: TokenizationEstimateFeeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._estimate_tokenization_fee_serialize(
            tokenization_estimate_fee_request=tokenization_estimate_fee_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "EstimatedFee",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def estimate_tokenization_fee_with_http_info(
        self,
        tokenization_estimate_fee_request: Annotated[TokenizationEstimateFeeRequest, Field(description="The request body to estimate tokenization operation fee.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[EstimatedFee]:
        """Estimate tokenization operation fee

        This operation estimates the fee required for tokenization operations. For EVM-based chains, this calculates the gas cost for the specified operation. 

        :param tokenization_estimate_fee_request: The request body to estimate tokenization operation fee. (required)
        :type tokenization_estimate_fee_request: TokenizationEstimateFeeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._estimate_tokenization_fee_serialize(
            tokenization_estimate_fee_request=tokenization_estimate_fee_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "EstimatedFee",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def estimate_tokenization_fee_without_preload_content(
        self,
        tokenization_estimate_fee_request: Annotated[TokenizationEstimateFeeRequest, Field(description="The request body to estimate tokenization operation fee.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Estimate tokenization operation fee

        This operation estimates the fee required for tokenization operations. For EVM-based chains, this calculates the gas cost for the specified operation. 

        :param tokenization_estimate_fee_request: The request body to estimate tokenization operation fee. (required)
        :type tokenization_estimate_fee_request: TokenizationEstimateFeeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._estimate_tokenization_fee_serialize(
            tokenization_estimate_fee_request=tokenization_estimate_fee_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "EstimatedFee",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _estimate_tokenization_fee_serialize(
        self,
        tokenization_estimate_fee_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tokenization_estimate_fee_request is not None:
            _body_params = tokenization_estimate_fee_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tokenization/estimate_fee',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_tokenization_activity(
        self,
        activity_id: Annotated[StrictStr, Field(description="The ID of the activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationActivityInfo:
        """Get tokenization activity details

        This operation retrieves the detailed information for a specific tokenization activity by its ID. 

        :param activity_id: The ID of the activity. (required)
        :type activity_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_tokenization_activity_serialize(
            activity_id=activity_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationActivityInfo",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_tokenization_activity_with_http_info(
        self,
        activity_id: Annotated[StrictStr, Field(description="The ID of the activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationActivityInfo]:
        """Get tokenization activity details

        This operation retrieves the detailed information for a specific tokenization activity by its ID. 

        :param activity_id: The ID of the activity. (required)
        :type activity_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_tokenization_activity_serialize(
            activity_id=activity_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationActivityInfo",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_tokenization_activity_without_preload_content(
        self,
        activity_id: Annotated[StrictStr, Field(description="The ID of the activity.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get tokenization activity details

        This operation retrieves the detailed information for a specific tokenization activity by its ID. 

        :param activity_id: The ID of the activity. (required)
        :type activity_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_tokenization_activity_serialize(
            activity_id=activity_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationActivityInfo",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_tokenization_activity_serialize(
        self,
        activity_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if activity_id is not None:
            _path_params['activity_id'] = activity_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tokenization/activities/{activity_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_tokenization_allowlist_activation(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> GetTokenizationAllowlistActivation200Response:
        """Get allowlist activation status

        This operation retrieves the allowlist activation status of the token contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_tokenization_allowlist_activation_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetTokenizationAllowlistActivation200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_tokenization_allowlist_activation_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[GetTokenizationAllowlistActivation200Response]:
        """Get allowlist activation status

        This operation retrieves the allowlist activation status of the token contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_tokenization_allowlist_activation_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetTokenizationAllowlistActivation200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_tokenization_allowlist_activation_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get allowlist activation status

        This operation retrieves the allowlist activation status of the token contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_tokenization_allowlist_activation_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetTokenizationAllowlistActivation200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_tokenization_allowlist_activation_serialize(
        self,
        token_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tokenization/tokens/{token_id}/allowlist/activation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_tokenization_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationTokenDetailInfo:
        """Get token details

        This operation retrieves the detailed information for a specific issued token by its ID. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_tokenization_info_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationTokenDetailInfo",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_tokenization_info_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationTokenDetailInfo]:
        """Get token details

        This operation retrieves the detailed information for a specific issued token by its ID. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_tokenization_info_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationTokenDetailInfo",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_tokenization_info_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get token details

        This operation retrieves the detailed information for a specific issued token by its ID. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_tokenization_info_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationTokenDetailInfo",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_tokenization_info_serialize(
        self,
        token_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tokenization/tokens/{token_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def issue_token(
        self,
        tokenization_issued_token_request: Annotated[TokenizationIssuedTokenRequest, Field(description="The request body to issue a new token.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationOperationResponse:
        """Issue token

        This operation issues a new token contract. It supports various blockchain platforms.  For EVM-based chains, this involves issuing a new smart contract from a template. 

        :param tokenization_issued_token_request: The request body to issue a new token. (required)
        :type tokenization_issued_token_request: TokenizationIssuedTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._issue_token_serialize(
            tokenization_issued_token_request=tokenization_issued_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def issue_token_with_http_info(
        self,
        tokenization_issued_token_request: Annotated[TokenizationIssuedTokenRequest, Field(description="The request body to issue a new token.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationOperationResponse]:
        """Issue token

        This operation issues a new token contract. It supports various blockchain platforms.  For EVM-based chains, this involves issuing a new smart contract from a template. 

        :param tokenization_issued_token_request: The request body to issue a new token. (required)
        :type tokenization_issued_token_request: TokenizationIssuedTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._issue_token_serialize(
            tokenization_issued_token_request=tokenization_issued_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def issue_token_without_preload_content(
        self,
        tokenization_issued_token_request: Annotated[TokenizationIssuedTokenRequest, Field(description="The request body to issue a new token.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Issue token

        This operation issues a new token contract. It supports various blockchain platforms.  For EVM-based chains, this involves issuing a new smart contract from a template. 

        :param tokenization_issued_token_request: The request body to issue a new token. (required)
        :type tokenization_issued_token_request: TokenizationIssuedTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._issue_token_serialize(
            tokenization_issued_token_request=tokenization_issued_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _issue_token_serialize(
        self,
        tokenization_issued_token_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tokenization_issued_token_request is not None:
            _body_params = tokenization_issued_token_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tokenization/tokens',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_issued_tokens(
        self,
        chain_id: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).")] = None,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).")] = None,
        token_standard: Annotated[Optional[TokenizationTokenStandard], Field(description="Filter by token standard.")] = None,
        status: Annotated[Optional[TokenizationStatus], Field(description="Filter by token status.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationListTokenInfoResponse:
        """List issued tokens

        This operation retrieves a list of tokens issued by the organization. Returns issued token information including total supply, holdings, and token status. 

        :param chain_id: The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).
        :type chain_id: str
        :param token_id: The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).
        :type token_id: str
        :param token_standard: Filter by token standard.
        :type token_standard: TokenizationTokenStandard
        :param status: Filter by token status.
        :type status: TokenizationStatus
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_issued_tokens_serialize(
            chain_id=chain_id,
            token_id=token_id,
            token_standard=token_standard,
            status=status,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListTokenInfoResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_issued_tokens_with_http_info(
        self,
        chain_id: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).")] = None,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).")] = None,
        token_standard: Annotated[Optional[TokenizationTokenStandard], Field(description="Filter by token standard.")] = None,
        status: Annotated[Optional[TokenizationStatus], Field(description="Filter by token status.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationListTokenInfoResponse]:
        """List issued tokens

        This operation retrieves a list of tokens issued by the organization. Returns issued token information including total supply, holdings, and token status. 

        :param chain_id: The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).
        :type chain_id: str
        :param token_id: The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).
        :type token_id: str
        :param token_standard: Filter by token standard.
        :type token_standard: TokenizationTokenStandard
        :param status: Filter by token status.
        :type status: TokenizationStatus
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_issued_tokens_serialize(
            chain_id=chain_id,
            token_id=token_id,
            token_standard=token_standard,
            status=status,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListTokenInfoResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_issued_tokens_without_preload_content(
        self,
        chain_id: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).")] = None,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).")] = None,
        token_standard: Annotated[Optional[TokenizationTokenStandard], Field(description="Filter by token standard.")] = None,
        status: Annotated[Optional[TokenizationStatus], Field(description="Filter by token status.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List issued tokens

        This operation retrieves a list of tokens issued by the organization. Returns issued token information including total supply, holdings, and token status. 

        :param chain_id: The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).
        :type chain_id: str
        :param token_id: The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).
        :type token_id: str
        :param token_standard: Filter by token standard.
        :type token_standard: TokenizationTokenStandard
        :param status: Filter by token status.
        :type status: TokenizationStatus
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_issued_tokens_serialize(
            chain_id=chain_id,
            token_id=token_id,
            token_standard=token_standard,
            status=status,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListTokenInfoResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_issued_tokens_serialize(
        self,
        chain_id,
        token_id,
        token_standard,
        status,
        limit,
        before,
        after,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if chain_id is not None:
            
            _query_params.append(('chain_id', chain_id))
            
        if token_id is not None:
            
            _query_params.append(('token_id', token_id))
            
        if token_standard is not None:
            
            _query_params.append(('token_standard', token_standard.value))
            
        if status is not None:
            
            _query_params.append(('status', status.value))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tokenization/tokens',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_tokenization_activities(
        self,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).")] = None,
        activity_type: Annotated[Optional[TokenizationOperationType], Field(description="Filter by tokenization activity type.")] = None,
        activity_status: Annotated[Optional[TokenizationActivityStatus], Field(description="Filter by tokenization activity status.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationListActivitiesResponse:
        """List tokenization activities

        This operation retrieves a list of tokenization activities. 

        :param token_id: The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).
        :type token_id: str
        :param activity_type: Filter by tokenization activity type.
        :type activity_type: TokenizationOperationType
        :param activity_status: Filter by tokenization activity status.
        :type activity_status: TokenizationActivityStatus
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_activities_serialize(
            token_id=token_id,
            activity_type=activity_type,
            activity_status=activity_status,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListActivitiesResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_tokenization_activities_with_http_info(
        self,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).")] = None,
        activity_type: Annotated[Optional[TokenizationOperationType], Field(description="Filter by tokenization activity type.")] = None,
        activity_status: Annotated[Optional[TokenizationActivityStatus], Field(description="Filter by tokenization activity status.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationListActivitiesResponse]:
        """List tokenization activities

        This operation retrieves a list of tokenization activities. 

        :param token_id: The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).
        :type token_id: str
        :param activity_type: Filter by tokenization activity type.
        :type activity_type: TokenizationOperationType
        :param activity_status: Filter by tokenization activity status.
        :type activity_status: TokenizationActivityStatus
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_activities_serialize(
            token_id=token_id,
            activity_type=activity_type,
            activity_status=activity_status,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListActivitiesResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_tokenization_activities_without_preload_content(
        self,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).")] = None,
        activity_type: Annotated[Optional[TokenizationOperationType], Field(description="Filter by tokenization activity type.")] = None,
        activity_status: Annotated[Optional[TokenizationActivityStatus], Field(description="Filter by tokenization activity status.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List tokenization activities

        This operation retrieves a list of tokenization activities. 

        :param token_id: The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).
        :type token_id: str
        :param activity_type: Filter by tokenization activity type.
        :type activity_type: TokenizationOperationType
        :param activity_status: Filter by tokenization activity status.
        :type activity_status: TokenizationActivityStatus
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_activities_serialize(
            token_id=token_id,
            activity_type=activity_type,
            activity_status=activity_status,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListActivitiesResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_tokenization_activities_serialize(
        self,
        token_id,
        activity_type,
        activity_status,
        limit,
        after,
        before,
        direction,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token_id is not None:
            
            _query_params.append(('token_id', token_id))
            
        if activity_type is not None:
            
            _query_params.append(('activity_type', activity_type.value))
            
        if activity_status is not None:
            
            _query_params.append(('activity_status', activity_status.value))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tokenization/activities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_tokenization_allowlist_addresses(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationAllowlistAddressesResponse:
        """List addresses on allowlist

        This operation lists addresses on the allowlist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_allowlist_addresses_serialize(
            token_id=token_id,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationAllowlistAddressesResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_tokenization_allowlist_addresses_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationAllowlistAddressesResponse]:
        """List addresses on allowlist

        This operation lists addresses on the allowlist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_allowlist_addresses_serialize(
            token_id=token_id,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationAllowlistAddressesResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_tokenization_allowlist_addresses_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List addresses on allowlist

        This operation lists addresses on the allowlist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_allowlist_addresses_serialize(
            token_id=token_id,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationAllowlistAddressesResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_tokenization_allowlist_addresses_serialize(
        self,
        token_id,
        limit,
        after,
        before,
        direction,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tokenization/tokens/{token_id}/allowlist/addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_tokenization_blocklist_addresses(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListTokenizationBlocklistAddresses200Response:
        """List addresses on blocklist

        This operation lists addresses on the blocklist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_blocklist_addresses_serialize(
            token_id=token_id,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTokenizationBlocklistAddresses200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_tokenization_blocklist_addresses_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListTokenizationBlocklistAddresses200Response]:
        """List addresses on blocklist

        This operation lists addresses on the blocklist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_blocklist_addresses_serialize(
            token_id=token_id,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTokenizationBlocklistAddresses200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_tokenization_blocklist_addresses_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List addresses on blocklist

        This operation lists addresses on the blocklist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_blocklist_addresses_serialize(
            token_id=token_id,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTokenizationBlocklistAddresses200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_tokenization_blocklist_addresses_serialize(
        self,
        token_id,
        limit,
        after,
        before,
        direction,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tokenization/tokens/{token_id}/blocklist/addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_tokenization_holdings(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationListHoldingsResponse:
        """Get token holdings information

        This operation retrieves the holdings information for a specific issued token, showing which wallets hold the token and their respective balances. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_holdings_serialize(
            token_id=token_id,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListHoldingsResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_tokenization_holdings_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationListHoldingsResponse]:
        """Get token holdings information

        This operation retrieves the holdings information for a specific issued token, showing which wallets hold the token and their respective balances. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_holdings_serialize(
            token_id=token_id,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListHoldingsResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_tokenization_holdings_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get token holdings information

        This operation retrieves the holdings information for a specific issued token, showing which wallets hold the token and their respective balances. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_holdings_serialize(
            token_id=token_id,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListHoldingsResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_tokenization_holdings_serialize(
        self,
        token_id,
        limit,
        before,
        after,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tokenization/tokens/{token_id}/holdings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_tokenization_permissions(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        address: Annotated[Optional[StrictStr], Field(description="The address to query permissions for. If not provided, returns all addresses with permissions.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationListPermissionsResponse:
        """List token permissions

        This operation retrieves the permission settings for a tokenization contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param address: The address to query permissions for. If not provided, returns all addresses with permissions.
        :type address: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_permissions_serialize(
            token_id=token_id,
            address=address,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListPermissionsResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_tokenization_permissions_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        address: Annotated[Optional[StrictStr], Field(description="The address to query permissions for. If not provided, returns all addresses with permissions.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationListPermissionsResponse]:
        """List token permissions

        This operation retrieves the permission settings for a tokenization contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param address: The address to query permissions for. If not provided, returns all addresses with permissions.
        :type address: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_permissions_serialize(
            token_id=token_id,
            address=address,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListPermissionsResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_tokenization_permissions_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        address: Annotated[Optional[StrictStr], Field(description="The address to query permissions for. If not provided, returns all addresses with permissions.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List token permissions

        This operation retrieves the permission settings for a tokenization contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param address: The address to query permissions for. If not provided, returns all addresses with permissions.
        :type address: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param direction: The sort direction. Possible values include:   - `ASC`: Sort the results in ascending order.   - `DESC`: Sort the results in descending order. 
        :type direction: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_permissions_serialize(
            token_id=token_id,
            address=address,
            limit=limit,
            after=after,
            before=before,
            direction=direction,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListPermissionsResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_tokenization_permissions_serialize(
        self,
        token_id,
        address,
        limit,
        after,
        before,
        direction,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        if address is not None:
            
            _query_params.append(('address', address))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tokenization/tokens/{token_id}/permissions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_tokenization_supported_chains(
        self,
        token_standard: Annotated[Optional[TokenizationTokenStandard], Field(description="Filter by token standard.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationListEnabledChainsResponse:
        """List supported chains for tokenization

        This operation retrieves a list of tokenization supported chains. 

        :param token_standard: Filter by token standard.
        :type token_standard: TokenizationTokenStandard
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_supported_chains_serialize(
            token_standard=token_standard,
            limit=limit,
            after=after,
            before=before,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListEnabledChainsResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_tokenization_supported_chains_with_http_info(
        self,
        token_standard: Annotated[Optional[TokenizationTokenStandard], Field(description="Filter by token standard.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationListEnabledChainsResponse]:
        """List supported chains for tokenization

        This operation retrieves a list of tokenization supported chains. 

        :param token_standard: Filter by token standard.
        :type token_standard: TokenizationTokenStandard
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_supported_chains_serialize(
            token_standard=token_standard,
            limit=limit,
            after=after,
            before=before,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListEnabledChainsResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_tokenization_supported_chains_without_preload_content(
        self,
        token_standard: Annotated[Optional[TokenizationTokenStandard], Field(description="Filter by token standard.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List supported chains for tokenization

        This operation retrieves a list of tokenization supported chains. 

        :param token_standard: Filter by token standard.
        :type token_standard: TokenizationTokenStandard
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_tokenization_supported_chains_serialize(
            token_standard=token_standard,
            limit=limit,
            after=after,
            before=before,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TokenizationListEnabledChainsResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_tokenization_supported_chains_serialize(
        self,
        token_standard,
        limit,
        after,
        before,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token_standard is not None:
            
            _query_params.append(('token_standard', token_standard.value))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/tokenization/enabled_chains',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def mint_tokenization(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_mint_token_request: Annotated[TokenizationMintTokenRequest, Field(description="The request body for minting tokens.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationOperationResponse:
        """Mint tokens

        This operation mints new tokens to a specified address. Creates a mint transaction that will increase the token supply.  **Note**: This operation is not supported for CoboERC20Wrapper and SOLWrapper tokens. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_mint_token_request: The request body for minting tokens. (required)
        :type tokenization_mint_token_request: TokenizationMintTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._mint_tokenization_serialize(
            token_id=token_id,
            tokenization_mint_token_request=tokenization_mint_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def mint_tokenization_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_mint_token_request: Annotated[TokenizationMintTokenRequest, Field(description="The request body for minting tokens.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationOperationResponse]:
        """Mint tokens

        This operation mints new tokens to a specified address. Creates a mint transaction that will increase the token supply.  **Note**: This operation is not supported for CoboERC20Wrapper and SOLWrapper tokens. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_mint_token_request: The request body for minting tokens. (required)
        :type tokenization_mint_token_request: TokenizationMintTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._mint_tokenization_serialize(
            token_id=token_id,
            tokenization_mint_token_request=tokenization_mint_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def mint_tokenization_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_mint_token_request: Annotated[TokenizationMintTokenRequest, Field(description="The request body for minting tokens.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Mint tokens

        This operation mints new tokens to a specified address. Creates a mint transaction that will increase the token supply.  **Note**: This operation is not supported for CoboERC20Wrapper and SOLWrapper tokens. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_mint_token_request: The request body for minting tokens. (required)
        :type tokenization_mint_token_request: TokenizationMintTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._mint_tokenization_serialize(
            token_id=token_id,
            tokenization_mint_token_request=tokenization_mint_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _mint_tokenization_serialize(
        self,
        token_id,
        tokenization_mint_token_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tokenization_mint_token_request is not None:
            _body_params = tokenization_mint_token_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tokenization/tokens/{token_id}/mint',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def pause_tokenization(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_pause_token_request: Annotated[Optional[TokenizationPauseTokenRequest], Field(description="The request body for pausing tokens.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationOperationResponse:
        """Pause token contract

        This operation pauses the token contract, temporarily halting token operations and transfers. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_pause_token_request: The request body for pausing tokens.
        :type tokenization_pause_token_request: TokenizationPauseTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._pause_tokenization_serialize(
            token_id=token_id,
            tokenization_pause_token_request=tokenization_pause_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def pause_tokenization_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_pause_token_request: Annotated[Optional[TokenizationPauseTokenRequest], Field(description="The request body for pausing tokens.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationOperationResponse]:
        """Pause token contract

        This operation pauses the token contract, temporarily halting token operations and transfers. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_pause_token_request: The request body for pausing tokens.
        :type tokenization_pause_token_request: TokenizationPauseTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._pause_tokenization_serialize(
            token_id=token_id,
            tokenization_pause_token_request=tokenization_pause_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def pause_tokenization_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_pause_token_request: Annotated[Optional[TokenizationPauseTokenRequest], Field(description="The request body for pausing tokens.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Pause token contract

        This operation pauses the token contract, temporarily halting token operations and transfers. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_pause_token_request: The request body for pausing tokens.
        :type tokenization_pause_token_request: TokenizationPauseTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._pause_tokenization_serialize(
            token_id=token_id,
            tokenization_pause_token_request=tokenization_pause_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _pause_tokenization_serialize(
        self,
        token_id,
        tokenization_pause_token_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tokenization_pause_token_request is not None:
            _body_params = tokenization_pause_token_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tokenization/tokens/{token_id}/pause',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def tokenization_contract_call(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_contract_call_request: Annotated[Optional[TokenizationContractCallRequest], Field(description="The request body for contract call.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationOperationResponse:
        """Call token contract

        This operation performs a contract call on the token contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_contract_call_request: The request body for contract call.
        :type tokenization_contract_call_request: TokenizationContractCallRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tokenization_contract_call_serialize(
            token_id=token_id,
            tokenization_contract_call_request=tokenization_contract_call_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def tokenization_contract_call_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_contract_call_request: Annotated[Optional[TokenizationContractCallRequest], Field(description="The request body for contract call.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationOperationResponse]:
        """Call token contract

        This operation performs a contract call on the token contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_contract_call_request: The request body for contract call.
        :type tokenization_contract_call_request: TokenizationContractCallRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tokenization_contract_call_serialize(
            token_id=token_id,
            tokenization_contract_call_request=tokenization_contract_call_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def tokenization_contract_call_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_contract_call_request: Annotated[Optional[TokenizationContractCallRequest], Field(description="The request body for contract call.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Call token contract

        This operation performs a contract call on the token contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_contract_call_request: The request body for contract call.
        :type tokenization_contract_call_request: TokenizationContractCallRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._tokenization_contract_call_serialize(
            token_id=token_id,
            tokenization_contract_call_request=tokenization_contract_call_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _tokenization_contract_call_serialize(
        self,
        token_id,
        tokenization_contract_call_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tokenization_contract_call_request is not None:
            _body_params = tokenization_contract_call_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tokenization/tokens/{token_id}/contract_call',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def unpause_tokenization(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_unpause_token_request: Annotated[Optional[TokenizationUnpauseTokenRequest], Field(description="The request body for unpausing tokens.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationOperationResponse:
        """Unpause token contract

        This operation unpauses the token contract, resuming token operations and transfers. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_unpause_token_request: The request body for unpausing tokens.
        :type tokenization_unpause_token_request: TokenizationUnpauseTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._unpause_tokenization_serialize(
            token_id=token_id,
            tokenization_unpause_token_request=tokenization_unpause_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def unpause_tokenization_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_unpause_token_request: Annotated[Optional[TokenizationUnpauseTokenRequest], Field(description="The request body for unpausing tokens.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationOperationResponse]:
        """Unpause token contract

        This operation unpauses the token contract, resuming token operations and transfers. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_unpause_token_request: The request body for unpausing tokens.
        :type tokenization_unpause_token_request: TokenizationUnpauseTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._unpause_tokenization_serialize(
            token_id=token_id,
            tokenization_unpause_token_request=tokenization_unpause_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def unpause_tokenization_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_unpause_token_request: Annotated[Optional[TokenizationUnpauseTokenRequest], Field(description="The request body for unpausing tokens.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Unpause token contract

        This operation unpauses the token contract, resuming token operations and transfers. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_unpause_token_request: The request body for unpausing tokens.
        :type tokenization_unpause_token_request: TokenizationUnpauseTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._unpause_tokenization_serialize(
            token_id=token_id,
            tokenization_unpause_token_request=tokenization_unpause_token_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _unpause_tokenization_serialize(
        self,
        token_id,
        tokenization_unpause_token_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tokenization_unpause_token_request is not None:
            _body_params = tokenization_unpause_token_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tokenization/tokens/{token_id}/unpause',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_tokenization_allowlist_activation(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_allowlist_activation_request: Annotated[Optional[TokenizationAllowlistActivationRequest], Field(description="The request body for activating or deactivating the allowlist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationOperationResponse:
        """Activate or deactivate allowlist

        This operation activates or deactivates the allowlist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_allowlist_activation_request: The request body for activating or deactivating the allowlist.
        :type tokenization_allowlist_activation_request: TokenizationAllowlistActivationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_allowlist_activation_serialize(
            token_id=token_id,
            tokenization_allowlist_activation_request=tokenization_allowlist_activation_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_tokenization_allowlist_activation_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_allowlist_activation_request: Annotated[Optional[TokenizationAllowlistActivationRequest], Field(description="The request body for activating or deactivating the allowlist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationOperationResponse]:
        """Activate or deactivate allowlist

        This operation activates or deactivates the allowlist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_allowlist_activation_request: The request body for activating or deactivating the allowlist.
        :type tokenization_allowlist_activation_request: TokenizationAllowlistActivationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_allowlist_activation_serialize(
            token_id=token_id,
            tokenization_allowlist_activation_request=tokenization_allowlist_activation_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_tokenization_allowlist_activation_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_allowlist_activation_request: Annotated[Optional[TokenizationAllowlistActivationRequest], Field(description="The request body for activating or deactivating the allowlist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Activate or deactivate allowlist

        This operation activates or deactivates the allowlist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_allowlist_activation_request: The request body for activating or deactivating the allowlist.
        :type tokenization_allowlist_activation_request: TokenizationAllowlistActivationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_allowlist_activation_serialize(
            token_id=token_id,
            tokenization_allowlist_activation_request=tokenization_allowlist_activation_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_tokenization_allowlist_activation_serialize(
        self,
        token_id,
        tokenization_allowlist_activation_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tokenization_allowlist_activation_request is not None:
            _body_params = tokenization_allowlist_activation_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tokenization/tokens/{token_id}/allowlist/activation',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_tokenization_allowlist_addresses(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_update_allowlist_addresses_request: Annotated[Optional[TokenizationUpdateAllowlistAddressesRequest], Field(description="The request body for adding or removing multiple addresses on the allowlist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationOperationResponse:
        """Update addresses on allowlist

        This operation updates addresses on the allowlist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_update_allowlist_addresses_request: The request body for adding or removing multiple addresses on the allowlist.
        :type tokenization_update_allowlist_addresses_request: TokenizationUpdateAllowlistAddressesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_allowlist_addresses_serialize(
            token_id=token_id,
            tokenization_update_allowlist_addresses_request=tokenization_update_allowlist_addresses_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_tokenization_allowlist_addresses_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_update_allowlist_addresses_request: Annotated[Optional[TokenizationUpdateAllowlistAddressesRequest], Field(description="The request body for adding or removing multiple addresses on the allowlist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationOperationResponse]:
        """Update addresses on allowlist

        This operation updates addresses on the allowlist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_update_allowlist_addresses_request: The request body for adding or removing multiple addresses on the allowlist.
        :type tokenization_update_allowlist_addresses_request: TokenizationUpdateAllowlistAddressesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_allowlist_addresses_serialize(
            token_id=token_id,
            tokenization_update_allowlist_addresses_request=tokenization_update_allowlist_addresses_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_tokenization_allowlist_addresses_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_update_allowlist_addresses_request: Annotated[Optional[TokenizationUpdateAllowlistAddressesRequest], Field(description="The request body for adding or removing multiple addresses on the allowlist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update addresses on allowlist

        This operation updates addresses on the allowlist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_update_allowlist_addresses_request: The request body for adding or removing multiple addresses on the allowlist.
        :type tokenization_update_allowlist_addresses_request: TokenizationUpdateAllowlistAddressesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_allowlist_addresses_serialize(
            token_id=token_id,
            tokenization_update_allowlist_addresses_request=tokenization_update_allowlist_addresses_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_tokenization_allowlist_addresses_serialize(
        self,
        token_id,
        tokenization_update_allowlist_addresses_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tokenization_update_allowlist_addresses_request is not None:
            _body_params = tokenization_update_allowlist_addresses_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tokenization/tokens/{token_id}/allowlist/addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_tokenization_blocklist_addresses(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_update_blocklist_addresses_request: Annotated[Optional[TokenizationUpdateBlocklistAddressesRequest], Field(description="The request body for adding or removing multiple addresses on the blocklist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationOperationResponse:
        """Update addresses on blocklist

        This operation updates addresses on the blocklist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_update_blocklist_addresses_request: The request body for adding or removing multiple addresses on the blocklist.
        :type tokenization_update_blocklist_addresses_request: TokenizationUpdateBlocklistAddressesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_blocklist_addresses_serialize(
            token_id=token_id,
            tokenization_update_blocklist_addresses_request=tokenization_update_blocklist_addresses_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_tokenization_blocklist_addresses_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_update_blocklist_addresses_request: Annotated[Optional[TokenizationUpdateBlocklistAddressesRequest], Field(description="The request body for adding or removing multiple addresses on the blocklist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationOperationResponse]:
        """Update addresses on blocklist

        This operation updates addresses on the blocklist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_update_blocklist_addresses_request: The request body for adding or removing multiple addresses on the blocklist.
        :type tokenization_update_blocklist_addresses_request: TokenizationUpdateBlocklistAddressesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_blocklist_addresses_serialize(
            token_id=token_id,
            tokenization_update_blocklist_addresses_request=tokenization_update_blocklist_addresses_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_tokenization_blocklist_addresses_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_update_blocklist_addresses_request: Annotated[Optional[TokenizationUpdateBlocklistAddressesRequest], Field(description="The request body for adding or removing multiple addresses on the blocklist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update addresses on blocklist

        This operation updates addresses on the blocklist. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_update_blocklist_addresses_request: The request body for adding or removing multiple addresses on the blocklist.
        :type tokenization_update_blocklist_addresses_request: TokenizationUpdateBlocklistAddressesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_blocklist_addresses_serialize(
            token_id=token_id,
            tokenization_update_blocklist_addresses_request=tokenization_update_blocklist_addresses_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_tokenization_blocklist_addresses_serialize(
        self,
        token_id,
        tokenization_update_blocklist_addresses_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tokenization_update_blocklist_addresses_request is not None:
            _body_params = tokenization_update_blocklist_addresses_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tokenization/tokens/{token_id}/blocklist/addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_tokenization_permissions(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_update_permissions_request: Annotated[TokenizationUpdatePermissionsRequest, Field(description="The request body for managing permissions.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TokenizationOperationResponse:
        """Update token permissions

        This operation updates permission settings for a tokenization contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_update_permissions_request: The request body for managing permissions. (required)
        :type tokenization_update_permissions_request: TokenizationUpdatePermissionsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_permissions_serialize(
            token_id=token_id,
            tokenization_update_permissions_request=tokenization_update_permissions_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_tokenization_permissions_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_update_permissions_request: Annotated[TokenizationUpdatePermissionsRequest, Field(description="The request body for managing permissions.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TokenizationOperationResponse]:
        """Update token permissions

        This operation updates permission settings for a tokenization contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_update_permissions_request: The request body for managing permissions. (required)
        :type tokenization_update_permissions_request: TokenizationUpdatePermissionsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_permissions_serialize(
            token_id=token_id,
            tokenization_update_permissions_request=tokenization_update_permissions_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_tokenization_permissions_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is the unique identifier of a token.")],
        tokenization_update_permissions_request: Annotated[TokenizationUpdatePermissionsRequest, Field(description="The request body for managing permissions.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update token permissions

        This operation updates permission settings for a tokenization contract. 

        :param token_id: The token ID, which is the unique identifier of a token. (required)
        :type token_id: str
        :param tokenization_update_permissions_request: The request body for managing permissions. (required)
        :type tokenization_update_permissions_request: TokenizationUpdatePermissionsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_tokenization_permissions_serialize(
            token_id=token_id,
            tokenization_update_permissions_request=tokenization_update_permissions_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "TokenizationOperationResponse",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_tokenization_permissions_serialize(
        self,
        token_id,
        tokenization_update_permissions_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if tokenization_update_permissions_request is not None:
            _body_params = tokenization_update_permissions_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/tokenization/tokens/{token_id}/permissions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )
