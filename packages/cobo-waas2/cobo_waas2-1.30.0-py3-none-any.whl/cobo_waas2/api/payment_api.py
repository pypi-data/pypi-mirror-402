# coding: utf-8

"""
    Cobo Wallet as a Service 2.0

    Contact: help@cobo.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from cobo_waas2.models.acquiring_type import AcquiringType
from cobo_waas2.models.bank_account import BankAccount
from cobo_waas2.models.bank_account_status import BankAccountStatus
from cobo_waas2.models.batch_allocation import BatchAllocation
from cobo_waas2.models.batch_allocation_detail import BatchAllocationDetail
from cobo_waas2.models.counterparty import Counterparty
from cobo_waas2.models.counterparty_detail import CounterpartyDetail
from cobo_waas2.models.counterparty_type import CounterpartyType
from cobo_waas2.models.create_batch_allocation_request import CreateBatchAllocationRequest
from cobo_waas2.models.create_bulk_send_request import CreateBulkSendRequest
from cobo_waas2.models.create_counterparty_entry201_response import CreateCounterpartyEntry201Response
from cobo_waas2.models.create_counterparty_entry_request import CreateCounterpartyEntryRequest
from cobo_waas2.models.create_counterparty_request import CreateCounterpartyRequest
from cobo_waas2.models.create_counterparty_wallet_address_request import CreateCounterpartyWalletAddressRequest
from cobo_waas2.models.create_crypto_address_request import CreateCryptoAddressRequest
from cobo_waas2.models.create_destination_bank_account_request import CreateDestinationBankAccountRequest
from cobo_waas2.models.create_destination_entry201_response import CreateDestinationEntry201Response
from cobo_waas2.models.create_destination_entry_request import CreateDestinationEntryRequest
from cobo_waas2.models.create_destination_request import CreateDestinationRequest
from cobo_waas2.models.create_destination_wallet_address_request import CreateDestinationWalletAddressRequest
from cobo_waas2.models.create_merchant_request import CreateMerchantRequest
from cobo_waas2.models.create_order_link_request import CreateOrderLinkRequest
from cobo_waas2.models.create_payment_order_request import CreatePaymentOrderRequest
from cobo_waas2.models.create_payout_request import CreatePayoutRequest
from cobo_waas2.models.create_refund_link_request import CreateRefundLinkRequest
from cobo_waas2.models.create_refund_request import CreateRefundRequest
from cobo_waas2.models.create_report_request import CreateReportRequest
from cobo_waas2.models.create_settlement_request_request import CreateSettlementRequestRequest
from cobo_waas2.models.create_top_up_addresses import CreateTopUpAddresses
from cobo_waas2.models.create_top_up_addresses201_response import CreateTopUpAddresses201Response
from cobo_waas2.models.crypto_address import CryptoAddress
from cobo_waas2.models.delete_counterparty200_response import DeleteCounterparty200Response
from cobo_waas2.models.delete_counterparty_by_id200_response import DeleteCounterpartyById200Response
from cobo_waas2.models.delete_counterparty_entry200_response import DeleteCounterpartyEntry200Response
from cobo_waas2.models.delete_counterparty_wallet_address200_response import DeleteCounterpartyWalletAddress200Response
from cobo_waas2.models.delete_crypto_address201_response import DeleteCryptoAddress201Response
from cobo_waas2.models.delete_destination200_response import DeleteDestination200Response
from cobo_waas2.models.delete_destination_bank_account200_response import DeleteDestinationBankAccount200Response
from cobo_waas2.models.delete_destination_by_id200_response import DeleteDestinationById200Response
from cobo_waas2.models.delete_destination_entry200_response import DeleteDestinationEntry200Response
from cobo_waas2.models.delete_destination_wallet_address200_response import DeleteDestinationWalletAddress200Response
from cobo_waas2.models.destination import Destination
from cobo_waas2.models.destination_bank_account import DestinationBankAccount
from cobo_waas2.models.destination_bank_account_detail import DestinationBankAccountDetail
from cobo_waas2.models.destination_detail import DestinationDetail
from cobo_waas2.models.destination_type import DestinationType
from cobo_waas2.models.enable_destination_whitelist_request import EnableDestinationWhitelistRequest
from cobo_waas2.models.entry_type import EntryType
from cobo_waas2.models.exchange_rate import ExchangeRate
from cobo_waas2.models.forced_sweep import ForcedSweep
from cobo_waas2.models.forced_sweep_request import ForcedSweepRequest
from cobo_waas2.models.get_counterparty_entry200_response import GetCounterpartyEntry200Response
from cobo_waas2.models.get_destination_entry200_response import GetDestinationEntry200Response
from cobo_waas2.models.get_exchange_rate200_response import GetExchangeRate200Response
from cobo_waas2.models.get_refunds200_response import GetRefunds200Response
from cobo_waas2.models.get_reports200_response import GetReports200Response
from cobo_waas2.models.get_settlement_info_by_ids200_response import GetSettlementInfoByIds200Response
from cobo_waas2.models.link import Link
from cobo_waas2.models.list_allocation_items200_response import ListAllocationItems200Response
from cobo_waas2.models.list_batch_allocations200_response import ListBatchAllocations200Response
from cobo_waas2.models.list_bulk_send_items200_response import ListBulkSendItems200Response
from cobo_waas2.models.list_counterparties200_response import ListCounterparties200Response
from cobo_waas2.models.list_counterparty_entries200_response import ListCounterpartyEntries200Response
from cobo_waas2.models.list_counterparty_wallet_address200_response import ListCounterpartyWalletAddress200Response
from cobo_waas2.models.list_destination_bank_accounts200_response import ListDestinationBankAccounts200Response
from cobo_waas2.models.list_destination_entries200_response import ListDestinationEntries200Response
from cobo_waas2.models.list_destination_wallet_addresses200_response import ListDestinationWalletAddresses200Response
from cobo_waas2.models.list_destinations200_response import ListDestinations200Response
from cobo_waas2.models.list_forced_sweep_requests200_response import ListForcedSweepRequests200Response
from cobo_waas2.models.list_merchant_balances200_response import ListMerchantBalances200Response
from cobo_waas2.models.list_merchants200_response import ListMerchants200Response
from cobo_waas2.models.list_payment_orders200_response import ListPaymentOrders200Response
from cobo_waas2.models.list_payment_wallet_balances200_response import ListPaymentWalletBalances200Response
from cobo_waas2.models.list_payouts200_response import ListPayouts200Response
from cobo_waas2.models.list_settlement_details200_response import ListSettlementDetails200Response
from cobo_waas2.models.list_settlement_requests200_response import ListSettlementRequests200Response
from cobo_waas2.models.list_top_up_payer_accounts200_response import ListTopUpPayerAccounts200Response
from cobo_waas2.models.list_top_up_payers200_response import ListTopUpPayers200Response
from cobo_waas2.models.merchant import Merchant
from cobo_waas2.models.order import Order
from cobo_waas2.models.payment_allocation_amount import PaymentAllocationAmount
from cobo_waas2.models.payment_bulk_send import PaymentBulkSend
from cobo_waas2.models.payment_estimate_fee201_response import PaymentEstimateFee201Response
from cobo_waas2.models.payment_estimate_fee_request import PaymentEstimateFeeRequest
from cobo_waas2.models.payment_payout import PaymentPayout
from cobo_waas2.models.payment_payout_detail import PaymentPayoutDetail
from cobo_waas2.models.psp_balance import PspBalance
from cobo_waas2.models.query_destination_whitelist_enabled200_response import QueryDestinationWhitelistEnabled200Response
from cobo_waas2.models.refund import Refund
from cobo_waas2.models.report import Report
from cobo_waas2.models.report_status import ReportStatus
from cobo_waas2.models.report_type import ReportType
from cobo_waas2.models.settlement import Settlement
from cobo_waas2.models.supported_token import SupportedToken
from cobo_waas2.models.top_up_address import TopUpAddress
from cobo_waas2.models.update_bank_account_by_id_request import UpdateBankAccountByIdRequest
from cobo_waas2.models.update_counterparty_by_id_request import UpdateCounterpartyByIdRequest
from cobo_waas2.models.update_counterparty_request import UpdateCounterpartyRequest
from cobo_waas2.models.update_destination_bank_account import UpdateDestinationBankAccount
from cobo_waas2.models.update_destination_by_id_request import UpdateDestinationByIdRequest
from cobo_waas2.models.update_destination_entry200_response import UpdateDestinationEntry200Response
from cobo_waas2.models.update_destination_entry_request import UpdateDestinationEntryRequest
from cobo_waas2.models.update_destination_request import UpdateDestinationRequest
from cobo_waas2.models.update_merchant_by_id_request import UpdateMerchantByIdRequest
from cobo_waas2.models.update_payment_order_request import UpdatePaymentOrderRequest
from cobo_waas2.models.update_refund_by_id_request import UpdateRefundByIdRequest
from cobo_waas2.models.update_top_up_address import UpdateTopUpAddress
from cobo_waas2.models.wallet_address import WalletAddress
from cobo_waas2.models.wallet_setup import WalletSetup

from cobo_waas2.api_client import ApiClient, RequestSerialized
from cobo_waas2.api_response import ApiResponse
from cobo_waas2.rest import RESTResponseType


class PaymentApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: ApiClient = None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def batch_get_exchange_rates(
        self,
        token_ids: Annotated[StrictStr, Field(description=" A list of token IDs, separated by comma. Supported values include:          - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        currencies: Annotated[StrictStr, Field(description="A list of fiat currencies, separated by comma. Currently, only `USD` is supported. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> List[ExchangeRate]:
        """Batch get exchange rates

        This operation retrieves the current exchange rates between multiple fiat currencies and cryptocurrencies. 

        :param token_ids:  A list of token IDs, separated by comma. Supported values include:          - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_ids: str
        :param currencies: A list of fiat currencies, separated by comma. Currently, only `USD` is supported.  (required)
        :type currencies: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._batch_get_exchange_rates_serialize(
            token_ids=token_ids,
            currencies=currencies,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExchangeRate]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def batch_get_exchange_rates_with_http_info(
        self,
        token_ids: Annotated[StrictStr, Field(description=" A list of token IDs, separated by comma. Supported values include:          - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        currencies: Annotated[StrictStr, Field(description="A list of fiat currencies, separated by comma. Currently, only `USD` is supported. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[List[ExchangeRate]]:
        """Batch get exchange rates

        This operation retrieves the current exchange rates between multiple fiat currencies and cryptocurrencies. 

        :param token_ids:  A list of token IDs, separated by comma. Supported values include:          - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_ids: str
        :param currencies: A list of fiat currencies, separated by comma. Currently, only `USD` is supported.  (required)
        :type currencies: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._batch_get_exchange_rates_serialize(
            token_ids=token_ids,
            currencies=currencies,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExchangeRate]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def batch_get_exchange_rates_without_preload_content(
        self,
        token_ids: Annotated[StrictStr, Field(description=" A list of token IDs, separated by comma. Supported values include:          - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        currencies: Annotated[StrictStr, Field(description="A list of fiat currencies, separated by comma. Currently, only `USD` is supported. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Batch get exchange rates

        This operation retrieves the current exchange rates between multiple fiat currencies and cryptocurrencies. 

        :param token_ids:  A list of token IDs, separated by comma. Supported values include:          - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_ids: str
        :param currencies: A list of fiat currencies, separated by comma. Currently, only `USD` is supported.  (required)
        :type currencies: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._batch_get_exchange_rates_serialize(
            token_ids=token_ids,
            currencies=currencies,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ExchangeRate]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _batch_get_exchange_rates_serialize(
        self,
        token_ids,
        currencies,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token_ids is not None:
            
            _query_params.append(('token_ids', token_ids))
            
        if currencies is not None:
            
            _query_params.append(('currencies', currencies))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/exchange_rates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def cancel_refund_by_id(
        self,
        refund_id: Annotated[StrictStr, Field(description="The refund order ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Refund:
        """Cancel refund order

        This operation cancels a specified refund order. You can only cancel refund orders that have not been processed yet. 

        :param refund_id: The refund order ID. (required)
        :type refund_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._cancel_refund_by_id_serialize(
            refund_id=refund_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def cancel_refund_by_id_with_http_info(
        self,
        refund_id: Annotated[StrictStr, Field(description="The refund order ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Refund]:
        """Cancel refund order

        This operation cancels a specified refund order. You can only cancel refund orders that have not been processed yet. 

        :param refund_id: The refund order ID. (required)
        :type refund_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._cancel_refund_by_id_serialize(
            refund_id=refund_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def cancel_refund_by_id_without_preload_content(
        self,
        refund_id: Annotated[StrictStr, Field(description="The refund order ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Cancel refund order

        This operation cancels a specified refund order. You can only cancel refund orders that have not been processed yet. 

        :param refund_id: The refund order ID. (required)
        :type refund_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._cancel_refund_by_id_serialize(
            refund_id=refund_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _cancel_refund_by_id_serialize(
        self,
        refund_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if refund_id is not None:
            _path_params['refund_id'] = refund_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/refunds/{refund_id}/cancel',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_batch_allocation(
        self,
        create_batch_allocation_request: Annotated[Optional[CreateBatchAllocationRequest], Field(description="The request body to create a batch allocation request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> BatchAllocation:
        """Create batch allocation

        This operation allocates funds between multiple accounts in one batch request. 

        :param create_batch_allocation_request: The request body to create a batch allocation request.
        :type create_batch_allocation_request: CreateBatchAllocationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_batch_allocation_serialize(
            create_batch_allocation_request=create_batch_allocation_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "BatchAllocation",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_batch_allocation_with_http_info(
        self,
        create_batch_allocation_request: Annotated[Optional[CreateBatchAllocationRequest], Field(description="The request body to create a batch allocation request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[BatchAllocation]:
        """Create batch allocation

        This operation allocates funds between multiple accounts in one batch request. 

        :param create_batch_allocation_request: The request body to create a batch allocation request.
        :type create_batch_allocation_request: CreateBatchAllocationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_batch_allocation_serialize(
            create_batch_allocation_request=create_batch_allocation_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "BatchAllocation",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_batch_allocation_without_preload_content(
        self,
        create_batch_allocation_request: Annotated[Optional[CreateBatchAllocationRequest], Field(description="The request body to create a batch allocation request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create batch allocation

        This operation allocates funds between multiple accounts in one batch request. 

        :param create_batch_allocation_request: The request body to create a batch allocation request.
        :type create_batch_allocation_request: CreateBatchAllocationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_batch_allocation_serialize(
            create_batch_allocation_request=create_batch_allocation_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "BatchAllocation",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_batch_allocation_serialize(
        self,
        create_batch_allocation_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_batch_allocation_request is not None:
            _body_params = create_batch_allocation_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/batch_allocations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_bulk_send(
        self,
        create_bulk_send_request: Annotated[Optional[CreateBulkSendRequest], Field(description="The request body to create a bulk send.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> PaymentBulkSend:
        """Create bulk send

        This operation creates a bulk send to transfer funds to multiple recipients in a single request. 

        :param create_bulk_send_request: The request body to create a bulk send.
        :type create_bulk_send_request: CreateBulkSendRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_bulk_send_serialize(
            create_bulk_send_request=create_bulk_send_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "PaymentBulkSend",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_bulk_send_with_http_info(
        self,
        create_bulk_send_request: Annotated[Optional[CreateBulkSendRequest], Field(description="The request body to create a bulk send.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[PaymentBulkSend]:
        """Create bulk send

        This operation creates a bulk send to transfer funds to multiple recipients in a single request. 

        :param create_bulk_send_request: The request body to create a bulk send.
        :type create_bulk_send_request: CreateBulkSendRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_bulk_send_serialize(
            create_bulk_send_request=create_bulk_send_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "PaymentBulkSend",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_bulk_send_without_preload_content(
        self,
        create_bulk_send_request: Annotated[Optional[CreateBulkSendRequest], Field(description="The request body to create a bulk send.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create bulk send

        This operation creates a bulk send to transfer funds to multiple recipients in a single request. 

        :param create_bulk_send_request: The request body to create a bulk send.
        :type create_bulk_send_request: CreateBulkSendRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_bulk_send_serialize(
            create_bulk_send_request=create_bulk_send_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "PaymentBulkSend",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_bulk_send_serialize(
        self,
        create_bulk_send_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_bulk_send_request is not None:
            _body_params = create_bulk_send_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/bulk_sends',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_counterparty(
        self,
        create_counterparty_request: Annotated[Optional[CreateCounterpartyRequest], Field(description="The request body to create a counterparty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> CounterpartyDetail:
        """Create counterparty

        This operation creates a [counterparty](https://www.cobo.com/payments/en/guides/counterparties). 

        :param create_counterparty_request: The request body to create a counterparty.
        :type create_counterparty_request: CreateCounterpartyRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_counterparty_serialize(
            create_counterparty_request=create_counterparty_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CounterpartyDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_counterparty_with_http_info(
        self,
        create_counterparty_request: Annotated[Optional[CreateCounterpartyRequest], Field(description="The request body to create a counterparty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[CounterpartyDetail]:
        """Create counterparty

        This operation creates a [counterparty](https://www.cobo.com/payments/en/guides/counterparties). 

        :param create_counterparty_request: The request body to create a counterparty.
        :type create_counterparty_request: CreateCounterpartyRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_counterparty_serialize(
            create_counterparty_request=create_counterparty_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CounterpartyDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_counterparty_without_preload_content(
        self,
        create_counterparty_request: Annotated[Optional[CreateCounterpartyRequest], Field(description="The request body to create a counterparty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create counterparty

        This operation creates a [counterparty](https://www.cobo.com/payments/en/guides/counterparties). 

        :param create_counterparty_request: The request body to create a counterparty.
        :type create_counterparty_request: CreateCounterpartyRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_counterparty_serialize(
            create_counterparty_request=create_counterparty_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CounterpartyDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_counterparty_serialize(
        self,
        create_counterparty_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_counterparty_request is not None:
            _body_params = create_counterparty_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/counterparty',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_counterparty_entry(
        self,
        create_counterparty_entry_request: Annotated[Optional[CreateCounterpartyEntryRequest], Field(description="The request body to create counterparty entries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> CreateCounterpartyEntry201Response:
        """Create counterparty entry

        This operation creates one or more entries for a counterparty.   A counterparty entry is a record of a counterparty's wallet address. 

        :param create_counterparty_entry_request: The request body to create counterparty entries.
        :type create_counterparty_entry_request: CreateCounterpartyEntryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_counterparty_entry_serialize(
            create_counterparty_entry_request=create_counterparty_entry_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateCounterpartyEntry201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_counterparty_entry_with_http_info(
        self,
        create_counterparty_entry_request: Annotated[Optional[CreateCounterpartyEntryRequest], Field(description="The request body to create counterparty entries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[CreateCounterpartyEntry201Response]:
        """Create counterparty entry

        This operation creates one or more entries for a counterparty.   A counterparty entry is a record of a counterparty's wallet address. 

        :param create_counterparty_entry_request: The request body to create counterparty entries.
        :type create_counterparty_entry_request: CreateCounterpartyEntryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_counterparty_entry_serialize(
            create_counterparty_entry_request=create_counterparty_entry_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateCounterpartyEntry201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_counterparty_entry_without_preload_content(
        self,
        create_counterparty_entry_request: Annotated[Optional[CreateCounterpartyEntryRequest], Field(description="The request body to create counterparty entries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create counterparty entry

        This operation creates one or more entries for a counterparty.   A counterparty entry is a record of a counterparty's wallet address. 

        :param create_counterparty_entry_request: The request body to create counterparty entries.
        :type create_counterparty_entry_request: CreateCounterpartyEntryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_counterparty_entry_serialize(
            create_counterparty_entry_request=create_counterparty_entry_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateCounterpartyEntry201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_counterparty_entry_serialize(
        self,
        create_counterparty_entry_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_counterparty_entry_request is not None:
            _body_params = create_counterparty_entry_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/counterparty_entry',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_counterparty_wallet_address(
        self,
        create_counterparty_wallet_address_request: Annotated[Optional[CreateCounterpartyWalletAddressRequest], Field(description="The request body to create a counterparty wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> WalletAddress:
        """Create counterparty wallet address

        This operation creates a counterparty wallet address. 

        :param create_counterparty_wallet_address_request: The request body to create a counterparty wallet address.
        :type create_counterparty_wallet_address_request: CreateCounterpartyWalletAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_counterparty_wallet_address_serialize(
            create_counterparty_wallet_address_request=create_counterparty_wallet_address_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "WalletAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_counterparty_wallet_address_with_http_info(
        self,
        create_counterparty_wallet_address_request: Annotated[Optional[CreateCounterpartyWalletAddressRequest], Field(description="The request body to create a counterparty wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[WalletAddress]:
        """Create counterparty wallet address

        This operation creates a counterparty wallet address. 

        :param create_counterparty_wallet_address_request: The request body to create a counterparty wallet address.
        :type create_counterparty_wallet_address_request: CreateCounterpartyWalletAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_counterparty_wallet_address_serialize(
            create_counterparty_wallet_address_request=create_counterparty_wallet_address_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "WalletAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_counterparty_wallet_address_without_preload_content(
        self,
        create_counterparty_wallet_address_request: Annotated[Optional[CreateCounterpartyWalletAddressRequest], Field(description="The request body to create a counterparty wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create counterparty wallet address

        This operation creates a counterparty wallet address. 

        :param create_counterparty_wallet_address_request: The request body to create a counterparty wallet address.
        :type create_counterparty_wallet_address_request: CreateCounterpartyWalletAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_counterparty_wallet_address_serialize(
            create_counterparty_wallet_address_request=create_counterparty_wallet_address_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "WalletAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_counterparty_wallet_address_serialize(
        self,
        create_counterparty_wallet_address_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_counterparty_wallet_address_request is not None:
            _body_params = create_counterparty_wallet_address_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/counterparty/wallet_address',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_crypto_address(
        self,
        create_crypto_address_request: Annotated[Optional[CreateCryptoAddressRequest], Field(description="The request body to register a crypto address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> CryptoAddress:
        """Create crypto address

        This operation registers a crypto address for crypto payouts.  The registered address can later be referenced by its ID when creating settlement requests. 

        :param create_crypto_address_request: The request body to register a crypto address.
        :type create_crypto_address_request: CreateCryptoAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_crypto_address_serialize(
            create_crypto_address_request=create_crypto_address_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CryptoAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_crypto_address_with_http_info(
        self,
        create_crypto_address_request: Annotated[Optional[CreateCryptoAddressRequest], Field(description="The request body to register a crypto address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[CryptoAddress]:
        """Create crypto address

        This operation registers a crypto address for crypto payouts.  The registered address can later be referenced by its ID when creating settlement requests. 

        :param create_crypto_address_request: The request body to register a crypto address.
        :type create_crypto_address_request: CreateCryptoAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_crypto_address_serialize(
            create_crypto_address_request=create_crypto_address_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CryptoAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_crypto_address_without_preload_content(
        self,
        create_crypto_address_request: Annotated[Optional[CreateCryptoAddressRequest], Field(description="The request body to register a crypto address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create crypto address

        This operation registers a crypto address for crypto payouts.  The registered address can later be referenced by its ID when creating settlement requests. 

        :param create_crypto_address_request: The request body to register a crypto address.
        :type create_crypto_address_request: CreateCryptoAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_crypto_address_serialize(
            create_crypto_address_request=create_crypto_address_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CryptoAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_crypto_address_serialize(
        self,
        create_crypto_address_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_crypto_address_request is not None:
            _body_params = create_crypto_address_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/crypto_addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_destination(
        self,
        create_destination_request: Annotated[Optional[CreateDestinationRequest], Field(description="The request body to create a destination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DestinationDetail:
        """Create destination

        This operation creates a [destination](https://www.cobo.com/payments/en/guides/destinations). 

        :param create_destination_request: The request body to create a destination.
        :type create_destination_request: CreateDestinationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_serialize(
            create_destination_request=create_destination_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DestinationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_destination_with_http_info(
        self,
        create_destination_request: Annotated[Optional[CreateDestinationRequest], Field(description="The request body to create a destination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DestinationDetail]:
        """Create destination

        This operation creates a [destination](https://www.cobo.com/payments/en/guides/destinations). 

        :param create_destination_request: The request body to create a destination.
        :type create_destination_request: CreateDestinationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_serialize(
            create_destination_request=create_destination_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DestinationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_destination_without_preload_content(
        self,
        create_destination_request: Annotated[Optional[CreateDestinationRequest], Field(description="The request body to create a destination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create destination

        This operation creates a [destination](https://www.cobo.com/payments/en/guides/destinations). 

        :param create_destination_request: The request body to create a destination.
        :type create_destination_request: CreateDestinationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_serialize(
            create_destination_request=create_destination_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DestinationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_destination_serialize(
        self,
        create_destination_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_destination_request is not None:
            _body_params = create_destination_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/destination',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_destination_bank_account(
        self,
        create_destination_bank_account_request: Annotated[Optional[CreateDestinationBankAccountRequest], Field(description="The request body to create a destination bank account.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DestinationBankAccount:
        """Create destination bank account

        This operation creates a destination bank account. 

        :param create_destination_bank_account_request: The request body to create a destination bank account.
        :type create_destination_bank_account_request: CreateDestinationBankAccountRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_bank_account_serialize(
            create_destination_bank_account_request=create_destination_bank_account_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DestinationBankAccount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_destination_bank_account_with_http_info(
        self,
        create_destination_bank_account_request: Annotated[Optional[CreateDestinationBankAccountRequest], Field(description="The request body to create a destination bank account.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DestinationBankAccount]:
        """Create destination bank account

        This operation creates a destination bank account. 

        :param create_destination_bank_account_request: The request body to create a destination bank account.
        :type create_destination_bank_account_request: CreateDestinationBankAccountRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_bank_account_serialize(
            create_destination_bank_account_request=create_destination_bank_account_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DestinationBankAccount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_destination_bank_account_without_preload_content(
        self,
        create_destination_bank_account_request: Annotated[Optional[CreateDestinationBankAccountRequest], Field(description="The request body to create a destination bank account.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create destination bank account

        This operation creates a destination bank account. 

        :param create_destination_bank_account_request: The request body to create a destination bank account.
        :type create_destination_bank_account_request: CreateDestinationBankAccountRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_bank_account_serialize(
            create_destination_bank_account_request=create_destination_bank_account_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DestinationBankAccount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_destination_bank_account_serialize(
        self,
        create_destination_bank_account_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_destination_bank_account_request is not None:
            _body_params = create_destination_bank_account_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/destination/bank_account',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_destination_entry(
        self,
        create_destination_entry_request: Annotated[Optional[CreateDestinationEntryRequest], Field(description="The request body to create destination entries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> CreateDestinationEntry201Response:
        """Create destination entry

        This operation creates one or more entries for a destination. A destination entry is a record of a destination's wallet addresses or bank accounts. 

        :param create_destination_entry_request: The request body to create destination entries.
        :type create_destination_entry_request: CreateDestinationEntryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_entry_serialize(
            create_destination_entry_request=create_destination_entry_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateDestinationEntry201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_destination_entry_with_http_info(
        self,
        create_destination_entry_request: Annotated[Optional[CreateDestinationEntryRequest], Field(description="The request body to create destination entries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[CreateDestinationEntry201Response]:
        """Create destination entry

        This operation creates one or more entries for a destination. A destination entry is a record of a destination's wallet addresses or bank accounts. 

        :param create_destination_entry_request: The request body to create destination entries.
        :type create_destination_entry_request: CreateDestinationEntryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_entry_serialize(
            create_destination_entry_request=create_destination_entry_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateDestinationEntry201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_destination_entry_without_preload_content(
        self,
        create_destination_entry_request: Annotated[Optional[CreateDestinationEntryRequest], Field(description="The request body to create destination entries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create destination entry

        This operation creates one or more entries for a destination. A destination entry is a record of a destination's wallet addresses or bank accounts. 

        :param create_destination_entry_request: The request body to create destination entries.
        :type create_destination_entry_request: CreateDestinationEntryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_entry_serialize(
            create_destination_entry_request=create_destination_entry_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateDestinationEntry201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_destination_entry_serialize(
        self,
        create_destination_entry_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_destination_entry_request is not None:
            _body_params = create_destination_entry_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/destination_entry',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_destination_wallet_address(
        self,
        create_destination_wallet_address_request: Annotated[Optional[CreateDestinationWalletAddressRequest], Field(description="The request body to create a destination wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> WalletAddress:
        """Create destination wallet address

        This operation creates a destination wallet address. 

        :param create_destination_wallet_address_request: The request body to create a destination wallet address.
        :type create_destination_wallet_address_request: CreateDestinationWalletAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_wallet_address_serialize(
            create_destination_wallet_address_request=create_destination_wallet_address_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "WalletAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_destination_wallet_address_with_http_info(
        self,
        create_destination_wallet_address_request: Annotated[Optional[CreateDestinationWalletAddressRequest], Field(description="The request body to create a destination wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[WalletAddress]:
        """Create destination wallet address

        This operation creates a destination wallet address. 

        :param create_destination_wallet_address_request: The request body to create a destination wallet address.
        :type create_destination_wallet_address_request: CreateDestinationWalletAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_wallet_address_serialize(
            create_destination_wallet_address_request=create_destination_wallet_address_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "WalletAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_destination_wallet_address_without_preload_content(
        self,
        create_destination_wallet_address_request: Annotated[Optional[CreateDestinationWalletAddressRequest], Field(description="The request body to create a destination wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create destination wallet address

        This operation creates a destination wallet address. 

        :param create_destination_wallet_address_request: The request body to create a destination wallet address.
        :type create_destination_wallet_address_request: CreateDestinationWalletAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_destination_wallet_address_serialize(
            create_destination_wallet_address_request=create_destination_wallet_address_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "WalletAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_destination_wallet_address_serialize(
        self,
        create_destination_wallet_address_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_destination_wallet_address_request is not None:
            _body_params = create_destination_wallet_address_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/destination/wallet_address',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_forced_sweep_request(
        self,
        forced_sweep_request: Annotated[Optional[ForcedSweepRequest], Field(description="The request body for forced sweep.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ForcedSweep:
        """Create forced sweep

        <Warning>This operation has been deprecated.</Warning> This operation creates a forced sweep to transfer funds from addresses within a specified wallet to its designated sweep-to address. 

        :param forced_sweep_request: The request body for forced sweep.
        :type forced_sweep_request: ForcedSweepRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_forced_sweep_request_serialize(
            forced_sweep_request=forced_sweep_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ForcedSweep",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_forced_sweep_request_with_http_info(
        self,
        forced_sweep_request: Annotated[Optional[ForcedSweepRequest], Field(description="The request body for forced sweep.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ForcedSweep]:
        """Create forced sweep

        <Warning>This operation has been deprecated.</Warning> This operation creates a forced sweep to transfer funds from addresses within a specified wallet to its designated sweep-to address. 

        :param forced_sweep_request: The request body for forced sweep.
        :type forced_sweep_request: ForcedSweepRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_forced_sweep_request_serialize(
            forced_sweep_request=forced_sweep_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ForcedSweep",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_forced_sweep_request_without_preload_content(
        self,
        forced_sweep_request: Annotated[Optional[ForcedSweepRequest], Field(description="The request body for forced sweep.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create forced sweep

        <Warning>This operation has been deprecated.</Warning> This operation creates a forced sweep to transfer funds from addresses within a specified wallet to its designated sweep-to address. 

        :param forced_sweep_request: The request body for forced sweep.
        :type forced_sweep_request: ForcedSweepRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_forced_sweep_request_serialize(
            forced_sweep_request=forced_sweep_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ForcedSweep",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_forced_sweep_request_serialize(
        self,
        forced_sweep_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if forced_sweep_request is not None:
            _body_params = forced_sweep_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/force_sweep_requests',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_merchant(
        self,
        create_merchant_request: Annotated[Optional[CreateMerchantRequest], Field(description="The request body to create a merchant.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Merchant:
        """Create merchant

        This operation creates a merchant. Upon successful creation, a merchant ID is generated and returned along with the merchant's information. For more information on merchant creation, please refer to [Preparation](https://www.cobo.com/payments/en/guides/preparation#create-merchant). 

        :param create_merchant_request: The request body to create a merchant.
        :type create_merchant_request: CreateMerchantRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_merchant_serialize(
            create_merchant_request=create_merchant_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Merchant",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_merchant_with_http_info(
        self,
        create_merchant_request: Annotated[Optional[CreateMerchantRequest], Field(description="The request body to create a merchant.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Merchant]:
        """Create merchant

        This operation creates a merchant. Upon successful creation, a merchant ID is generated and returned along with the merchant's information. For more information on merchant creation, please refer to [Preparation](https://www.cobo.com/payments/en/guides/preparation#create-merchant). 

        :param create_merchant_request: The request body to create a merchant.
        :type create_merchant_request: CreateMerchantRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_merchant_serialize(
            create_merchant_request=create_merchant_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Merchant",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_merchant_without_preload_content(
        self,
        create_merchant_request: Annotated[Optional[CreateMerchantRequest], Field(description="The request body to create a merchant.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create merchant

        This operation creates a merchant. Upon successful creation, a merchant ID is generated and returned along with the merchant's information. For more information on merchant creation, please refer to [Preparation](https://www.cobo.com/payments/en/guides/preparation#create-merchant). 

        :param create_merchant_request: The request body to create a merchant.
        :type create_merchant_request: CreateMerchantRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_merchant_serialize(
            create_merchant_request=create_merchant_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Merchant",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_merchant_serialize(
        self,
        create_merchant_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_merchant_request is not None:
            _body_params = create_merchant_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/merchants',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_order_link(
        self,
        create_order_link_request: Annotated[Optional[CreateOrderLinkRequest], Field(description="The request body to create a payment link for a pay-in order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Link:
        """Create order link

        This operation generates a payment link for a pay-in order. The link directs users to a hosted payment page where they can complete their payment for the order. You can share the link directly with users or embed the payment page in your website or application using an iframe.  For more details, see [Payment Link](https://www.cobo.com/payments/en/guides/payment-link). 

        :param create_order_link_request: The request body to create a payment link for a pay-in order.
        :type create_order_link_request: CreateOrderLinkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_order_link_serialize(
            create_order_link_request=create_order_link_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Link",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_order_link_with_http_info(
        self,
        create_order_link_request: Annotated[Optional[CreateOrderLinkRequest], Field(description="The request body to create a payment link for a pay-in order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Link]:
        """Create order link

        This operation generates a payment link for a pay-in order. The link directs users to a hosted payment page where they can complete their payment for the order. You can share the link directly with users or embed the payment page in your website or application using an iframe.  For more details, see [Payment Link](https://www.cobo.com/payments/en/guides/payment-link). 

        :param create_order_link_request: The request body to create a payment link for a pay-in order.
        :type create_order_link_request: CreateOrderLinkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_order_link_serialize(
            create_order_link_request=create_order_link_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Link",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_order_link_without_preload_content(
        self,
        create_order_link_request: Annotated[Optional[CreateOrderLinkRequest], Field(description="The request body to create a payment link for a pay-in order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create order link

        This operation generates a payment link for a pay-in order. The link directs users to a hosted payment page where they can complete their payment for the order. You can share the link directly with users or embed the payment page in your website or application using an iframe.  For more details, see [Payment Link](https://www.cobo.com/payments/en/guides/payment-link). 

        :param create_order_link_request: The request body to create a payment link for a pay-in order.
        :type create_order_link_request: CreateOrderLinkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_order_link_serialize(
            create_order_link_request=create_order_link_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Link",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_order_link_serialize(
        self,
        create_order_link_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_order_link_request is not None:
            _body_params = create_order_link_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/links/orders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_payment_order(
        self,
        create_payment_order_request: Annotated[Optional[CreatePaymentOrderRequest], Field(description="The request body to create a pay-in order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Order:
        """Create pay-in order

        This operation creates a pay-in order. 

        :param create_payment_order_request: The request body to create a pay-in order.
        :type create_payment_order_request: CreatePaymentOrderRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_payment_order_serialize(
            create_payment_order_request=create_payment_order_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Order",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_payment_order_with_http_info(
        self,
        create_payment_order_request: Annotated[Optional[CreatePaymentOrderRequest], Field(description="The request body to create a pay-in order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Order]:
        """Create pay-in order

        This operation creates a pay-in order. 

        :param create_payment_order_request: The request body to create a pay-in order.
        :type create_payment_order_request: CreatePaymentOrderRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_payment_order_serialize(
            create_payment_order_request=create_payment_order_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Order",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_payment_order_without_preload_content(
        self,
        create_payment_order_request: Annotated[Optional[CreatePaymentOrderRequest], Field(description="The request body to create a pay-in order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create pay-in order

        This operation creates a pay-in order. 

        :param create_payment_order_request: The request body to create a pay-in order.
        :type create_payment_order_request: CreatePaymentOrderRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_payment_order_serialize(
            create_payment_order_request=create_payment_order_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Order",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_payment_order_serialize(
        self,
        create_payment_order_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_payment_order_request is not None:
            _body_params = create_payment_order_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/orders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_payout(
        self,
        create_payout_request: Annotated[Optional[CreatePayoutRequest], Field(description="The request body to create a payout.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> PaymentPayout:
        """Create payout

        This operation creates a payout to withdraw available balances. 

        :param create_payout_request: The request body to create a payout.
        :type create_payout_request: CreatePayoutRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_payout_serialize(
            create_payout_request=create_payout_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "PaymentPayout",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_payout_with_http_info(
        self,
        create_payout_request: Annotated[Optional[CreatePayoutRequest], Field(description="The request body to create a payout.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[PaymentPayout]:
        """Create payout

        This operation creates a payout to withdraw available balances. 

        :param create_payout_request: The request body to create a payout.
        :type create_payout_request: CreatePayoutRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_payout_serialize(
            create_payout_request=create_payout_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "PaymentPayout",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_payout_without_preload_content(
        self,
        create_payout_request: Annotated[Optional[CreatePayoutRequest], Field(description="The request body to create a payout.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create payout

        This operation creates a payout to withdraw available balances. 

        :param create_payout_request: The request body to create a payout.
        :type create_payout_request: CreatePayoutRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_payout_serialize(
            create_payout_request=create_payout_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "PaymentPayout",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_payout_serialize(
        self,
        create_payout_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_payout_request is not None:
            _body_params = create_payout_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/payouts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_refund(
        self,
        create_refund_request: Annotated[Optional[CreateRefundRequest], Field(description="The request body to create a refund order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Refund:
        """Create refund order

        This operation creates a refund order to return cryptocurrency to a specified address.   When creating a refund order, you can optionally link it to an existing pay-in order for tracking and reconciliation purposes. 

        :param create_refund_request: The request body to create a refund order.
        :type create_refund_request: CreateRefundRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_refund_serialize(
            create_refund_request=create_refund_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_refund_with_http_info(
        self,
        create_refund_request: Annotated[Optional[CreateRefundRequest], Field(description="The request body to create a refund order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Refund]:
        """Create refund order

        This operation creates a refund order to return cryptocurrency to a specified address.   When creating a refund order, you can optionally link it to an existing pay-in order for tracking and reconciliation purposes. 

        :param create_refund_request: The request body to create a refund order.
        :type create_refund_request: CreateRefundRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_refund_serialize(
            create_refund_request=create_refund_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_refund_without_preload_content(
        self,
        create_refund_request: Annotated[Optional[CreateRefundRequest], Field(description="The request body to create a refund order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create refund order

        This operation creates a refund order to return cryptocurrency to a specified address.   When creating a refund order, you can optionally link it to an existing pay-in order for tracking and reconciliation purposes. 

        :param create_refund_request: The request body to create a refund order.
        :type create_refund_request: CreateRefundRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_refund_serialize(
            create_refund_request=create_refund_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_refund_serialize(
        self,
        create_refund_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_refund_request is not None:
            _body_params = create_refund_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/refunds',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_refund_link(
        self,
        create_refund_link_request: Annotated[Optional[CreateRefundLinkRequest], Field(description="The request body to create a refund link.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Link:
        """Create refund link

        This operation creates a link that points to a Cobo-hosted refund page. The user can submit their desired refund address on the page.  Once the address is submitted, Cobo will automatically create a refund order and initiate the refund process according to your configuration.  For details, see [Create refund link](https://www.cobo.com/payments/en/guides/create-refund-link). 

        :param create_refund_link_request: The request body to create a refund link.
        :type create_refund_link_request: CreateRefundLinkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_refund_link_serialize(
            create_refund_link_request=create_refund_link_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Link",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_refund_link_with_http_info(
        self,
        create_refund_link_request: Annotated[Optional[CreateRefundLinkRequest], Field(description="The request body to create a refund link.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Link]:
        """Create refund link

        This operation creates a link that points to a Cobo-hosted refund page. The user can submit their desired refund address on the page.  Once the address is submitted, Cobo will automatically create a refund order and initiate the refund process according to your configuration.  For details, see [Create refund link](https://www.cobo.com/payments/en/guides/create-refund-link). 

        :param create_refund_link_request: The request body to create a refund link.
        :type create_refund_link_request: CreateRefundLinkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_refund_link_serialize(
            create_refund_link_request=create_refund_link_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Link",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_refund_link_without_preload_content(
        self,
        create_refund_link_request: Annotated[Optional[CreateRefundLinkRequest], Field(description="The request body to create a refund link.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create refund link

        This operation creates a link that points to a Cobo-hosted refund page. The user can submit their desired refund address on the page.  Once the address is submitted, Cobo will automatically create a refund order and initiate the refund process according to your configuration.  For details, see [Create refund link](https://www.cobo.com/payments/en/guides/create-refund-link). 

        :param create_refund_link_request: The request body to create a refund link.
        :type create_refund_link_request: CreateRefundLinkRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_refund_link_serialize(
            create_refund_link_request=create_refund_link_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Link",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_refund_link_serialize(
        self,
        create_refund_link_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_refund_link_request is not None:
            _body_params = create_refund_link_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/links/refunds',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_report(
        self,
        create_report_request: Annotated[Optional[CreateReportRequest], Field(description="The request body to create payment reports.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Report:
        """Generate reports

         This operation generates reports for a variety of payment activities, including pay-ins, payouts, and commission fees. 

        :param create_report_request: The request body to create payment reports.
        :type create_report_request: CreateReportRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_report_serialize(
            create_report_request=create_report_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Report",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_report_with_http_info(
        self,
        create_report_request: Annotated[Optional[CreateReportRequest], Field(description="The request body to create payment reports.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Report]:
        """Generate reports

         This operation generates reports for a variety of payment activities, including pay-ins, payouts, and commission fees. 

        :param create_report_request: The request body to create payment reports.
        :type create_report_request: CreateReportRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_report_serialize(
            create_report_request=create_report_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Report",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_report_without_preload_content(
        self,
        create_report_request: Annotated[Optional[CreateReportRequest], Field(description="The request body to create payment reports.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Generate reports

         This operation generates reports for a variety of payment activities, including pay-ins, payouts, and commission fees. 

        :param create_report_request: The request body to create payment reports.
        :type create_report_request: CreateReportRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_report_serialize(
            create_report_request=create_report_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Report",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_report_serialize(
        self,
        create_report_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_report_request is not None:
            _body_params = create_report_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/reports',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_settlement_request(
        self,
        create_settlement_request_request: Annotated[Optional[CreateSettlementRequestRequest], Field(description="The request body to create a settlement request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Settlement:
        """Create settlement request

        <Note>This operation has been deprecated. Please use [Create payout](https://www.cobo.com/payments/en/api-references/payment/create-payout) instead.</Note>  You can include multiple merchants and cryptocurrencies in a single settlement request. 

        :param create_settlement_request_request: The request body to create a settlement request.
        :type create_settlement_request_request: CreateSettlementRequestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_settlement_request_serialize(
            create_settlement_request_request=create_settlement_request_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Settlement",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_settlement_request_with_http_info(
        self,
        create_settlement_request_request: Annotated[Optional[CreateSettlementRequestRequest], Field(description="The request body to create a settlement request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Settlement]:
        """Create settlement request

        <Note>This operation has been deprecated. Please use [Create payout](https://www.cobo.com/payments/en/api-references/payment/create-payout) instead.</Note>  You can include multiple merchants and cryptocurrencies in a single settlement request. 

        :param create_settlement_request_request: The request body to create a settlement request.
        :type create_settlement_request_request: CreateSettlementRequestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_settlement_request_serialize(
            create_settlement_request_request=create_settlement_request_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Settlement",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_settlement_request_without_preload_content(
        self,
        create_settlement_request_request: Annotated[Optional[CreateSettlementRequestRequest], Field(description="The request body to create a settlement request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create settlement request

        <Note>This operation has been deprecated. Please use [Create payout](https://www.cobo.com/payments/en/api-references/payment/create-payout) instead.</Note>  You can include multiple merchants and cryptocurrencies in a single settlement request. 

        :param create_settlement_request_request: The request body to create a settlement request.
        :type create_settlement_request_request: CreateSettlementRequestRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_settlement_request_serialize(
            create_settlement_request_request=create_settlement_request_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "Settlement",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_settlement_request_serialize(
        self,
        create_settlement_request_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_settlement_request_request is not None:
            _body_params = create_settlement_request_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/settlement_requests',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def create_top_up_addresses(
        self,
        create_top_up_addresses: Annotated[Optional[CreateTopUpAddresses], Field(description="The request body of the create top-up addresses operation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> CreateTopUpAddresses201Response:
        """Batch create top-up addresses

        This operation creates top-up addresses for multiple payers under a specific merchant and token in a single request.  <Note>This operation supports batch processing of up to 50 payers per request.</Note> 

        :param create_top_up_addresses: The request body of the create top-up addresses operation.
        :type create_top_up_addresses: CreateTopUpAddresses
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_top_up_addresses_serialize(
            create_top_up_addresses=create_top_up_addresses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateTopUpAddresses201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_top_up_addresses_with_http_info(
        self,
        create_top_up_addresses: Annotated[Optional[CreateTopUpAddresses], Field(description="The request body of the create top-up addresses operation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[CreateTopUpAddresses201Response]:
        """Batch create top-up addresses

        This operation creates top-up addresses for multiple payers under a specific merchant and token in a single request.  <Note>This operation supports batch processing of up to 50 payers per request.</Note> 

        :param create_top_up_addresses: The request body of the create top-up addresses operation.
        :type create_top_up_addresses: CreateTopUpAddresses
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_top_up_addresses_serialize(
            create_top_up_addresses=create_top_up_addresses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateTopUpAddresses201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_top_up_addresses_without_preload_content(
        self,
        create_top_up_addresses: Annotated[Optional[CreateTopUpAddresses], Field(description="The request body of the create top-up addresses operation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Batch create top-up addresses

        This operation creates top-up addresses for multiple payers under a specific merchant and token in a single request.  <Note>This operation supports batch processing of up to 50 payers per request.</Note> 

        :param create_top_up_addresses: The request body of the create top-up addresses operation.
        :type create_top_up_addresses: CreateTopUpAddresses
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._create_top_up_addresses_serialize(
            create_top_up_addresses=create_top_up_addresses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "CreateTopUpAddresses201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _create_top_up_addresses_serialize(
        self,
        create_top_up_addresses,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_top_up_addresses is not None:
            _body_params = create_top_up_addresses

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/topup/address',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def delete_counterparty(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DeleteCounterparty200Response:
        """Delete counterparty (Deprecated)

        This operation deletes a counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterparty200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_counterparty_with_http_info(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DeleteCounterparty200Response]:
        """Delete counterparty (Deprecated)

        This operation deletes a counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterparty200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_counterparty_without_preload_content(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Delete counterparty (Deprecated)

        This operation deletes a counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterparty200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_counterparty_serialize(
        self,
        counterparty_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if counterparty_id is not None:
            _path_params['counterparty_id'] = counterparty_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/counterparty/{counterparty_id}/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def delete_counterparty_by_id(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DeleteCounterpartyById200Response:
        """Delete counterparty

        This operation deletes a counterparty. Note that this operation will delete all entries under the counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_by_id_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterpartyById200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_counterparty_by_id_with_http_info(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DeleteCounterpartyById200Response]:
        """Delete counterparty

        This operation deletes a counterparty. Note that this operation will delete all entries under the counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_by_id_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterpartyById200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_counterparty_by_id_without_preload_content(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Delete counterparty

        This operation deletes a counterparty. Note that this operation will delete all entries under the counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_by_id_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterpartyById200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_counterparty_by_id_serialize(
        self,
        counterparty_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if counterparty_id is not None:
            _path_params['counterparty_id'] = counterparty_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/payments/counterparty/{counterparty_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def delete_counterparty_entry(
        self,
        counterparty_entry_id: Annotated[StrictStr, Field(description="The counterparty entry ID. For example, the wallet address ID.")],
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        entry_type: Annotated[Optional[EntryType], Field(description="The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DeleteCounterpartyEntry200Response:
        """Delete counterparty entry

        This operation deletes a counterparty entry. 

        :param counterparty_entry_id: The counterparty entry ID. For example, the wallet address ID. (required)
        :type counterparty_entry_id: str
        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param entry_type: The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. 
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_entry_serialize(
            counterparty_entry_id=counterparty_entry_id,
            counterparty_id=counterparty_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterpartyEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_counterparty_entry_with_http_info(
        self,
        counterparty_entry_id: Annotated[StrictStr, Field(description="The counterparty entry ID. For example, the wallet address ID.")],
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        entry_type: Annotated[Optional[EntryType], Field(description="The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DeleteCounterpartyEntry200Response]:
        """Delete counterparty entry

        This operation deletes a counterparty entry. 

        :param counterparty_entry_id: The counterparty entry ID. For example, the wallet address ID. (required)
        :type counterparty_entry_id: str
        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param entry_type: The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. 
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_entry_serialize(
            counterparty_entry_id=counterparty_entry_id,
            counterparty_id=counterparty_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterpartyEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_counterparty_entry_without_preload_content(
        self,
        counterparty_entry_id: Annotated[StrictStr, Field(description="The counterparty entry ID. For example, the wallet address ID.")],
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        entry_type: Annotated[Optional[EntryType], Field(description="The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Delete counterparty entry

        This operation deletes a counterparty entry. 

        :param counterparty_entry_id: The counterparty entry ID. For example, the wallet address ID. (required)
        :type counterparty_entry_id: str
        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param entry_type: The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. 
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_entry_serialize(
            counterparty_entry_id=counterparty_entry_id,
            counterparty_id=counterparty_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterpartyEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_counterparty_entry_serialize(
        self,
        counterparty_entry_id,
        counterparty_id,
        entry_type,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if counterparty_entry_id is not None:
            _path_params['counterparty_entry_id'] = counterparty_entry_id
        # process the query parameters
        if counterparty_id is not None:
            
            _query_params.append(('counterparty_id', counterparty_id))
            
        if entry_type is not None:
            
            _query_params.append(('entry_type', entry_type.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/payments/counterparty_entry/{counterparty_entry_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def delete_counterparty_wallet_address(
        self,
        wallet_address_id: Annotated[StrictStr, Field(description="The wallet address ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DeleteCounterpartyWalletAddress200Response:
        """Delete counterparty wallet address

        This operation deletes a counterparty wallet address. 

        :param wallet_address_id: The wallet address ID. (required)
        :type wallet_address_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_wallet_address_serialize(
            wallet_address_id=wallet_address_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterpartyWalletAddress200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_counterparty_wallet_address_with_http_info(
        self,
        wallet_address_id: Annotated[StrictStr, Field(description="The wallet address ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DeleteCounterpartyWalletAddress200Response]:
        """Delete counterparty wallet address

        This operation deletes a counterparty wallet address. 

        :param wallet_address_id: The wallet address ID. (required)
        :type wallet_address_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_wallet_address_serialize(
            wallet_address_id=wallet_address_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterpartyWalletAddress200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_counterparty_wallet_address_without_preload_content(
        self,
        wallet_address_id: Annotated[StrictStr, Field(description="The wallet address ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Delete counterparty wallet address

        This operation deletes a counterparty wallet address. 

        :param wallet_address_id: The wallet address ID. (required)
        :type wallet_address_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_counterparty_wallet_address_serialize(
            wallet_address_id=wallet_address_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteCounterpartyWalletAddress200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_counterparty_wallet_address_serialize(
        self,
        wallet_address_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wallet_address_id is not None:
            _path_params['wallet_address_id'] = wallet_address_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/counterparty/wallet_address/{wallet_address_id}/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def delete_crypto_address(
        self,
        crypto_address_id: Annotated[StrictStr, Field(description="The crypto address ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DeleteCryptoAddress201Response:
        """Delete crypto address

        This operation unregisters a crypto address from being used for crypto payouts. 

        :param crypto_address_id: The crypto address ID. (required)
        :type crypto_address_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_crypto_address_serialize(
            crypto_address_id=crypto_address_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DeleteCryptoAddress201Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_crypto_address_with_http_info(
        self,
        crypto_address_id: Annotated[StrictStr, Field(description="The crypto address ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DeleteCryptoAddress201Response]:
        """Delete crypto address

        This operation unregisters a crypto address from being used for crypto payouts. 

        :param crypto_address_id: The crypto address ID. (required)
        :type crypto_address_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_crypto_address_serialize(
            crypto_address_id=crypto_address_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DeleteCryptoAddress201Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_crypto_address_without_preload_content(
        self,
        crypto_address_id: Annotated[StrictStr, Field(description="The crypto address ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Delete crypto address

        This operation unregisters a crypto address from being used for crypto payouts. 

        :param crypto_address_id: The crypto address ID. (required)
        :type crypto_address_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_crypto_address_serialize(
            crypto_address_id=crypto_address_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "DeleteCryptoAddress201Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_crypto_address_serialize(
        self,
        crypto_address_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if crypto_address_id is not None:
            _path_params['crypto_address_id'] = crypto_address_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/crypto_addresses/{crypto_address_id}/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def delete_destination(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DeleteDestination200Response:
        """Delete destination (Deprecated)

        This operation deletes a destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestination200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_destination_with_http_info(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DeleteDestination200Response]:
        """Delete destination (Deprecated)

        This operation deletes a destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestination200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_destination_without_preload_content(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Delete destination (Deprecated)

        This operation deletes a destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestination200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_destination_serialize(
        self,
        destination_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if destination_id is not None:
            _path_params['destination_id'] = destination_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/destination/{destination_id}/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def delete_destination_bank_account(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DeleteDestinationBankAccount200Response:
        """Delete destination bank account

        This operation deletes a destination bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_bank_account_serialize(
            bank_account_id=bank_account_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationBankAccount200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_destination_bank_account_with_http_info(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DeleteDestinationBankAccount200Response]:
        """Delete destination bank account

        This operation deletes a destination bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_bank_account_serialize(
            bank_account_id=bank_account_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationBankAccount200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_destination_bank_account_without_preload_content(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Delete destination bank account

        This operation deletes a destination bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_bank_account_serialize(
            bank_account_id=bank_account_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationBankAccount200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_destination_bank_account_serialize(
        self,
        bank_account_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bank_account_id is not None:
            _path_params['bank_account_id'] = bank_account_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/destination/bank_account/{bank_account_id}/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def delete_destination_by_id(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DeleteDestinationById200Response:
        """Delete destination

        This operation deletes a destination. Note that this operation will delete all entries under the destination, including bank accounts and addresses. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_by_id_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationById200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_destination_by_id_with_http_info(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DeleteDestinationById200Response]:
        """Delete destination

        This operation deletes a destination. Note that this operation will delete all entries under the destination, including bank accounts and addresses. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_by_id_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationById200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_destination_by_id_without_preload_content(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Delete destination

        This operation deletes a destination. Note that this operation will delete all entries under the destination, including bank accounts and addresses. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_by_id_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationById200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_destination_by_id_serialize(
        self,
        destination_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if destination_id is not None:
            _path_params['destination_id'] = destination_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/payments/destination/{destination_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def delete_destination_entry(
        self,
        destination_entry_id: Annotated[StrictStr, Field(description="The destination entry ID. For example, the wallet address ID or the bank account ID.")],
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        entry_type: Annotated[EntryType, Field(description="EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DeleteDestinationEntry200Response:
        """Delete destination entry

        This operation deletes a destination entry. 

        :param destination_entry_id: The destination entry ID. For example, the wallet address ID or the bank account ID. (required)
        :type destination_entry_id: str
        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param entry_type: EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account.  (required)
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_entry_serialize(
            destination_entry_id=destination_entry_id,
            destination_id=destination_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_destination_entry_with_http_info(
        self,
        destination_entry_id: Annotated[StrictStr, Field(description="The destination entry ID. For example, the wallet address ID or the bank account ID.")],
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        entry_type: Annotated[EntryType, Field(description="EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DeleteDestinationEntry200Response]:
        """Delete destination entry

        This operation deletes a destination entry. 

        :param destination_entry_id: The destination entry ID. For example, the wallet address ID or the bank account ID. (required)
        :type destination_entry_id: str
        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param entry_type: EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account.  (required)
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_entry_serialize(
            destination_entry_id=destination_entry_id,
            destination_id=destination_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_destination_entry_without_preload_content(
        self,
        destination_entry_id: Annotated[StrictStr, Field(description="The destination entry ID. For example, the wallet address ID or the bank account ID.")],
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        entry_type: Annotated[EntryType, Field(description="EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Delete destination entry

        This operation deletes a destination entry. 

        :param destination_entry_id: The destination entry ID. For example, the wallet address ID or the bank account ID. (required)
        :type destination_entry_id: str
        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param entry_type: EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account.  (required)
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_entry_serialize(
            destination_entry_id=destination_entry_id,
            destination_id=destination_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_destination_entry_serialize(
        self,
        destination_entry_id,
        destination_id,
        entry_type,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if destination_entry_id is not None:
            _path_params['destination_entry_id'] = destination_entry_id
        # process the query parameters
        if destination_id is not None:
            
            _query_params.append(('destination_id', destination_id))
            
        if entry_type is not None:
            
            _query_params.append(('entry_type', entry_type.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/payments/destination_entry/{destination_entry_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def delete_destination_wallet_address(
        self,
        wallet_address_id: Annotated[StrictStr, Field(description="The wallet address ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DeleteDestinationWalletAddress200Response:
        """Delete destination wallet address

        This operation deletes a destination wallet address. 

        :param wallet_address_id: The wallet address ID. (required)
        :type wallet_address_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_wallet_address_serialize(
            wallet_address_id=wallet_address_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationWalletAddress200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_destination_wallet_address_with_http_info(
        self,
        wallet_address_id: Annotated[StrictStr, Field(description="The wallet address ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DeleteDestinationWalletAddress200Response]:
        """Delete destination wallet address

        This operation deletes a destination wallet address. 

        :param wallet_address_id: The wallet address ID. (required)
        :type wallet_address_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_wallet_address_serialize(
            wallet_address_id=wallet_address_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationWalletAddress200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_destination_wallet_address_without_preload_content(
        self,
        wallet_address_id: Annotated[StrictStr, Field(description="The wallet address ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Delete destination wallet address

        This operation deletes a destination wallet address. 

        :param wallet_address_id: The wallet address ID. (required)
        :type wallet_address_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._delete_destination_wallet_address_serialize(
            wallet_address_id=wallet_address_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteDestinationWalletAddress200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _delete_destination_wallet_address_serialize(
        self,
        wallet_address_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if wallet_address_id is not None:
            _path_params['wallet_address_id'] = wallet_address_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/destination/wallet_address/{wallet_address_id}/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def enable_destination_whitelist(
        self,
        enable_destination_whitelist_request: Annotated[Optional[EnableDestinationWhitelistRequest], Field(description="The request body to enable or disable the destination whitelist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> QueryDestinationWhitelistEnabled200Response:
        """Enable or disable destination whitelist

        This operation enables or disables the whitelist for a destination. 

        :param enable_destination_whitelist_request: The request body to enable or disable the destination whitelist.
        :type enable_destination_whitelist_request: EnableDestinationWhitelistRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._enable_destination_whitelist_serialize(
            enable_destination_whitelist_request=enable_destination_whitelist_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "QueryDestinationWhitelistEnabled200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def enable_destination_whitelist_with_http_info(
        self,
        enable_destination_whitelist_request: Annotated[Optional[EnableDestinationWhitelistRequest], Field(description="The request body to enable or disable the destination whitelist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[QueryDestinationWhitelistEnabled200Response]:
        """Enable or disable destination whitelist

        This operation enables or disables the whitelist for a destination. 

        :param enable_destination_whitelist_request: The request body to enable or disable the destination whitelist.
        :type enable_destination_whitelist_request: EnableDestinationWhitelistRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._enable_destination_whitelist_serialize(
            enable_destination_whitelist_request=enable_destination_whitelist_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "QueryDestinationWhitelistEnabled200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def enable_destination_whitelist_without_preload_content(
        self,
        enable_destination_whitelist_request: Annotated[Optional[EnableDestinationWhitelistRequest], Field(description="The request body to enable or disable the destination whitelist.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Enable or disable destination whitelist

        This operation enables or disables the whitelist for a destination. 

        :param enable_destination_whitelist_request: The request body to enable or disable the destination whitelist.
        :type enable_destination_whitelist_request: EnableDestinationWhitelistRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._enable_destination_whitelist_serialize(
            enable_destination_whitelist_request=enable_destination_whitelist_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "QueryDestinationWhitelistEnabled200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _enable_destination_whitelist_serialize(
        self,
        enable_destination_whitelist_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if enable_destination_whitelist_request is not None:
            _body_params = enable_destination_whitelist_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/destination/enable_whitelist',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_available_allocation_amount(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        source_account: Annotated[StrictStr, Field(description="The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`. ")],
        destination_account: Annotated[StrictStr, Field(description="The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> PaymentAllocationAmount:
        """Get available allocation amount

        This operation retrieves the available amount that can be allocated from a source account to a destination account. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param source_account: The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`.  (required)
        :type source_account: str
        :param destination_account: The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`.  (required)
        :type destination_account: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_available_allocation_amount_serialize(
            token_id=token_id,
            source_account=source_account,
            destination_account=destination_account,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentAllocationAmount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_available_allocation_amount_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        source_account: Annotated[StrictStr, Field(description="The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`. ")],
        destination_account: Annotated[StrictStr, Field(description="The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[PaymentAllocationAmount]:
        """Get available allocation amount

        This operation retrieves the available amount that can be allocated from a source account to a destination account. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param source_account: The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`.  (required)
        :type source_account: str
        :param destination_account: The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`.  (required)
        :type destination_account: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_available_allocation_amount_serialize(
            token_id=token_id,
            source_account=source_account,
            destination_account=destination_account,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentAllocationAmount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_available_allocation_amount_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        source_account: Annotated[StrictStr, Field(description="The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`. ")],
        destination_account: Annotated[StrictStr, Field(description="The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get available allocation amount

        This operation retrieves the available amount that can be allocated from a source account to a destination account. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param source_account: The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`.  (required)
        :type source_account: str
        :param destination_account: The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`.  (required)
        :type destination_account: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_available_allocation_amount_serialize(
            token_id=token_id,
            source_account=source_account,
            destination_account=destination_account,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentAllocationAmount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_available_allocation_amount_serialize(
        self,
        token_id,
        source_account,
        destination_account,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token_id is not None:
            
            _query_params.append(('token_id', token_id))
            
        if source_account is not None:
            
            _query_params.append(('source_account', source_account))
            
        if destination_account is not None:
            
            _query_params.append(('destination_account', destination_account))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/allocation_amount',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_batch_allocation_by_id(
        self,
        batch_allocation_id: Annotated[StrictStr, Field(description="The batch allocation ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> BatchAllocationDetail:
        """Get batch allocation information

        This operation retrieves the information of a batch allocation. 

        :param batch_allocation_id: The batch allocation ID. (required)
        :type batch_allocation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_batch_allocation_by_id_serialize(
            batch_allocation_id=batch_allocation_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BatchAllocationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_batch_allocation_by_id_with_http_info(
        self,
        batch_allocation_id: Annotated[StrictStr, Field(description="The batch allocation ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[BatchAllocationDetail]:
        """Get batch allocation information

        This operation retrieves the information of a batch allocation. 

        :param batch_allocation_id: The batch allocation ID. (required)
        :type batch_allocation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_batch_allocation_by_id_serialize(
            batch_allocation_id=batch_allocation_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BatchAllocationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_batch_allocation_by_id_without_preload_content(
        self,
        batch_allocation_id: Annotated[StrictStr, Field(description="The batch allocation ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get batch allocation information

        This operation retrieves the information of a batch allocation. 

        :param batch_allocation_id: The batch allocation ID. (required)
        :type batch_allocation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_batch_allocation_by_id_serialize(
            batch_allocation_id=batch_allocation_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BatchAllocationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_batch_allocation_by_id_serialize(
        self,
        batch_allocation_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if batch_allocation_id is not None:
            _path_params['batch_allocation_id'] = batch_allocation_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/batch_allocations/{batch_allocation_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_bulk_send_by_id(
        self,
        bulk_send_id: Annotated[StrictStr, Field(description="The bulk send ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> PaymentBulkSend:
        """Get bulk send information

        This operation retrieves the information of a specific bulk send. 

        :param bulk_send_id: The bulk send ID. (required)
        :type bulk_send_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_bulk_send_by_id_serialize(
            bulk_send_id=bulk_send_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentBulkSend",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_bulk_send_by_id_with_http_info(
        self,
        bulk_send_id: Annotated[StrictStr, Field(description="The bulk send ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[PaymentBulkSend]:
        """Get bulk send information

        This operation retrieves the information of a specific bulk send. 

        :param bulk_send_id: The bulk send ID. (required)
        :type bulk_send_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_bulk_send_by_id_serialize(
            bulk_send_id=bulk_send_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentBulkSend",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_bulk_send_by_id_without_preload_content(
        self,
        bulk_send_id: Annotated[StrictStr, Field(description="The bulk send ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get bulk send information

        This operation retrieves the information of a specific bulk send. 

        :param bulk_send_id: The bulk send ID. (required)
        :type bulk_send_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_bulk_send_by_id_serialize(
            bulk_send_id=bulk_send_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentBulkSend",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_bulk_send_by_id_serialize(
        self,
        bulk_send_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bulk_send_id is not None:
            _path_params['bulk_send_id'] = bulk_send_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/bulk_sends/{bulk_send_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_counterparty(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> CounterpartyDetail:
        """Get counterparty information

        This operation retrieves the detailed information about a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_counterparty_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CounterpartyDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_counterparty_with_http_info(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[CounterpartyDetail]:
        """Get counterparty information

        This operation retrieves the detailed information about a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_counterparty_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CounterpartyDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_counterparty_without_preload_content(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get counterparty information

        This operation retrieves the detailed information about a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_counterparty_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CounterpartyDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_counterparty_serialize(
        self,
        counterparty_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if counterparty_id is not None:
            _path_params['counterparty_id'] = counterparty_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/counterparty/{counterparty_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_counterparty_detail_by_id(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> CounterpartyDetail:
        """Get counterparty information (Deprecated)

        This operation retrieves the detailed information about a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_counterparty_detail_by_id_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CounterpartyDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_counterparty_detail_by_id_with_http_info(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[CounterpartyDetail]:
        """Get counterparty information (Deprecated)

        This operation retrieves the detailed information about a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_counterparty_detail_by_id_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CounterpartyDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_counterparty_detail_by_id_without_preload_content(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get counterparty information (Deprecated)

        This operation retrieves the detailed information about a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_counterparty_detail_by_id_serialize(
            counterparty_id=counterparty_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CounterpartyDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_counterparty_detail_by_id_serialize(
        self,
        counterparty_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if counterparty_id is not None:
            _path_params['counterparty_id'] = counterparty_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/counterparty/{counterparty_id}/detail',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_counterparty_entry(
        self,
        counterparty_entry_id: Annotated[StrictStr, Field(description="The counterparty entry ID. For example, the wallet address ID.")],
        entry_type: Annotated[Optional[EntryType], Field(description="The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> GetCounterpartyEntry200Response:
        """Get counterparty entry information

        This operation retrieves the detailed information about a specified counterparty entry. 

        :param counterparty_entry_id: The counterparty entry ID. For example, the wallet address ID. (required)
        :type counterparty_entry_id: str
        :param entry_type: The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. 
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_counterparty_entry_serialize(
            counterparty_entry_id=counterparty_entry_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCounterpartyEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_counterparty_entry_with_http_info(
        self,
        counterparty_entry_id: Annotated[StrictStr, Field(description="The counterparty entry ID. For example, the wallet address ID.")],
        entry_type: Annotated[Optional[EntryType], Field(description="The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[GetCounterpartyEntry200Response]:
        """Get counterparty entry information

        This operation retrieves the detailed information about a specified counterparty entry. 

        :param counterparty_entry_id: The counterparty entry ID. For example, the wallet address ID. (required)
        :type counterparty_entry_id: str
        :param entry_type: The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. 
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_counterparty_entry_serialize(
            counterparty_entry_id=counterparty_entry_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCounterpartyEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_counterparty_entry_without_preload_content(
        self,
        counterparty_entry_id: Annotated[StrictStr, Field(description="The counterparty entry ID. For example, the wallet address ID.")],
        entry_type: Annotated[Optional[EntryType], Field(description="The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get counterparty entry information

        This operation retrieves the detailed information about a specified counterparty entry. 

        :param counterparty_entry_id: The counterparty entry ID. For example, the wallet address ID. (required)
        :type counterparty_entry_id: str
        :param entry_type: The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. 
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_counterparty_entry_serialize(
            counterparty_entry_id=counterparty_entry_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetCounterpartyEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_counterparty_entry_serialize(
        self,
        counterparty_entry_id,
        entry_type,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if counterparty_entry_id is not None:
            _path_params['counterparty_entry_id'] = counterparty_entry_id
        # process the query parameters
        if entry_type is not None:
            
            _query_params.append(('entry_type', entry_type.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/counterparty_entry/{counterparty_entry_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_destination(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DestinationDetail:
        """Get destination information

        This operation retrieves the detailed information about a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_destination_with_http_info(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DestinationDetail]:
        """Get destination information

        This operation retrieves the detailed information about a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_destination_without_preload_content(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get destination information

        This operation retrieves the detailed information about a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_destination_serialize(
        self,
        destination_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if destination_id is not None:
            _path_params['destination_id'] = destination_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/destination/{destination_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_destination_bank_account_detail_by_id(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DestinationBankAccountDetail:
        """Get destination bank account information

        This operation retrieves the detailed information about a specified destination bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_bank_account_detail_by_id_serialize(
            bank_account_id=bank_account_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationBankAccountDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_destination_bank_account_detail_by_id_with_http_info(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DestinationBankAccountDetail]:
        """Get destination bank account information

        This operation retrieves the detailed information about a specified destination bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_bank_account_detail_by_id_serialize(
            bank_account_id=bank_account_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationBankAccountDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_destination_bank_account_detail_by_id_without_preload_content(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get destination bank account information

        This operation retrieves the detailed information about a specified destination bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_bank_account_detail_by_id_serialize(
            bank_account_id=bank_account_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationBankAccountDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_destination_bank_account_detail_by_id_serialize(
        self,
        bank_account_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bank_account_id is not None:
            _path_params['bank_account_id'] = bank_account_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/destination/bank_account/{bank_account_id}/detail',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_destination_detail_by_id(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DestinationDetail:
        """Get destination information (Deprecated)

        This operation retrieves the detailed information about a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_detail_by_id_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_destination_detail_by_id_with_http_info(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DestinationDetail]:
        """Get destination information (Deprecated)

        This operation retrieves the detailed information about a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_detail_by_id_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_destination_detail_by_id_without_preload_content(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get destination information (Deprecated)

        This operation retrieves the detailed information about a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_detail_by_id_serialize(
            destination_id=destination_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_destination_detail_by_id_serialize(
        self,
        destination_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if destination_id is not None:
            _path_params['destination_id'] = destination_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/destination/{destination_id}/detail',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_destination_entry(
        self,
        destination_entry_id: Annotated[StrictStr, Field(description="The destination entry ID. For example, the wallet address ID or the bank account ID.")],
        entry_type: Annotated[EntryType, Field(description="EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> GetDestinationEntry200Response:
        """Get destination entry information

        This operation retrieves the detailed information about a specified destination entry. 

        :param destination_entry_id: The destination entry ID. For example, the wallet address ID or the bank account ID. (required)
        :type destination_entry_id: str
        :param entry_type: EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account.  (required)
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_entry_serialize(
            destination_entry_id=destination_entry_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDestinationEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_destination_entry_with_http_info(
        self,
        destination_entry_id: Annotated[StrictStr, Field(description="The destination entry ID. For example, the wallet address ID or the bank account ID.")],
        entry_type: Annotated[EntryType, Field(description="EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[GetDestinationEntry200Response]:
        """Get destination entry information

        This operation retrieves the detailed information about a specified destination entry. 

        :param destination_entry_id: The destination entry ID. For example, the wallet address ID or the bank account ID. (required)
        :type destination_entry_id: str
        :param entry_type: EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account.  (required)
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_entry_serialize(
            destination_entry_id=destination_entry_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDestinationEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_destination_entry_without_preload_content(
        self,
        destination_entry_id: Annotated[StrictStr, Field(description="The destination entry ID. For example, the wallet address ID or the bank account ID.")],
        entry_type: Annotated[EntryType, Field(description="EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get destination entry information

        This operation retrieves the detailed information about a specified destination entry. 

        :param destination_entry_id: The destination entry ID. For example, the wallet address ID or the bank account ID. (required)
        :type destination_entry_id: str
        :param entry_type: EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account.  (required)
        :type entry_type: EntryType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_destination_entry_serialize(
            destination_entry_id=destination_entry_id,
            entry_type=entry_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDestinationEntry200Response",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_destination_entry_serialize(
        self,
        destination_entry_id,
        entry_type,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if destination_entry_id is not None:
            _path_params['destination_entry_id'] = destination_entry_id
        # process the query parameters
        if entry_type is not None:
            
            _query_params.append(('entry_type', entry_type.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/destination_entry/{destination_entry_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_exchange_rate(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        currency: Annotated[StrictStr, Field(description="The fiat currency. Currently, only `USD` is supported.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> GetExchangeRate200Response:
        """Get exchange rate

        This operation retrieves the current exchange rate between a specified currency pair. The exchange rate is updated approximately every 10 minutes.  <Note>This operation returns the exchange rate for reference only. The actual exchange rate may vary due to market fluctuations and other factors.</Note> 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param currency: The fiat currency. Currently, only `USD` is supported. (required)
        :type currency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_exchange_rate_serialize(
            token_id=token_id,
            currency=currency,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetExchangeRate200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_exchange_rate_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        currency: Annotated[StrictStr, Field(description="The fiat currency. Currently, only `USD` is supported.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[GetExchangeRate200Response]:
        """Get exchange rate

        This operation retrieves the current exchange rate between a specified currency pair. The exchange rate is updated approximately every 10 minutes.  <Note>This operation returns the exchange rate for reference only. The actual exchange rate may vary due to market fluctuations and other factors.</Note> 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param currency: The fiat currency. Currently, only `USD` is supported. (required)
        :type currency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_exchange_rate_serialize(
            token_id=token_id,
            currency=currency,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetExchangeRate200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_exchange_rate_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        currency: Annotated[StrictStr, Field(description="The fiat currency. Currently, only `USD` is supported.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get exchange rate

        This operation retrieves the current exchange rate between a specified currency pair. The exchange rate is updated approximately every 10 minutes.  <Note>This operation returns the exchange rate for reference only. The actual exchange rate may vary due to market fluctuations and other factors.</Note> 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param currency: The fiat currency. Currently, only `USD` is supported. (required)
        :type currency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_exchange_rate_serialize(
            token_id=token_id,
            currency=currency,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetExchangeRate200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_exchange_rate_serialize(
        self,
        token_id,
        currency,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if token_id is not None:
            _path_params['token_id'] = token_id
        if currency is not None:
            _path_params['currency'] = currency
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/exchange_rates/{token_id}/{currency}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_payment_order_detail_by_id(
        self,
        order_id: Annotated[StrictStr, Field(description="The pay-in order ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Order:
        """Get pay-in order information

        This operation retrieves details of a specific pay-in order. 

        :param order_id: The pay-in order ID. (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_payment_order_detail_by_id_serialize(
            order_id=order_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Order",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_payment_order_detail_by_id_with_http_info(
        self,
        order_id: Annotated[StrictStr, Field(description="The pay-in order ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Order]:
        """Get pay-in order information

        This operation retrieves details of a specific pay-in order. 

        :param order_id: The pay-in order ID. (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_payment_order_detail_by_id_serialize(
            order_id=order_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Order",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_payment_order_detail_by_id_without_preload_content(
        self,
        order_id: Annotated[StrictStr, Field(description="The pay-in order ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get pay-in order information

        This operation retrieves details of a specific pay-in order. 

        :param order_id: The pay-in order ID. (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_payment_order_detail_by_id_serialize(
            order_id=order_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Order",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_payment_order_detail_by_id_serialize(
        self,
        order_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if order_id is not None:
            _path_params['order_id'] = order_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/orders/{order_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_payout_by_id(
        self,
        payout_id: Annotated[StrictStr, Field(description="The payout ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> PaymentPayoutDetail:
        """Get payout information

        This operation retrieves the information of a specific payout. 

        :param payout_id: The payout ID. (required)
        :type payout_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_payout_by_id_serialize(
            payout_id=payout_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentPayoutDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_payout_by_id_with_http_info(
        self,
        payout_id: Annotated[StrictStr, Field(description="The payout ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[PaymentPayoutDetail]:
        """Get payout information

        This operation retrieves the information of a specific payout. 

        :param payout_id: The payout ID. (required)
        :type payout_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_payout_by_id_serialize(
            payout_id=payout_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentPayoutDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_payout_by_id_without_preload_content(
        self,
        payout_id: Annotated[StrictStr, Field(description="The payout ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get payout information

        This operation retrieves the information of a specific payout. 

        :param payout_id: The payout ID. (required)
        :type payout_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_payout_by_id_serialize(
            payout_id=payout_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentPayoutDetail",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_payout_by_id_serialize(
        self,
        payout_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if payout_id is not None:
            _path_params['payout_id'] = payout_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/payouts/{payout_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_psp_balance(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> PspBalance:
        """Get developer balance

        This operation retrieves the balance information for you as the developer. The balance information is grouped by token.  For more information, please refer to [Accounts and fund allocation](https://www.cobo.com/payments/en/guides/amounts-and-balances). 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_psp_balance_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PspBalance",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_psp_balance_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[PspBalance]:
        """Get developer balance

        This operation retrieves the balance information for you as the developer. The balance information is grouped by token.  For more information, please refer to [Accounts and fund allocation](https://www.cobo.com/payments/en/guides/amounts-and-balances). 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_psp_balance_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PspBalance",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_psp_balance_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get developer balance

        This operation retrieves the balance information for you as the developer. The balance information is grouped by token.  For more information, please refer to [Accounts and fund allocation](https://www.cobo.com/payments/en/guides/amounts-and-balances). 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_psp_balance_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PspBalance",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_psp_balance_serialize(
        self,
        token_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token_id is not None:
            
            _query_params.append(('token_id', token_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/balance/psp',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_refund_detail_by_id(
        self,
        refund_id: Annotated[StrictStr, Field(description="The refund order ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Refund:
        """Get refund order information

        This operation retrieves the detailed information about a specified refund order. 

        :param refund_id: The refund order ID. (required)
        :type refund_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_refund_detail_by_id_serialize(
            refund_id=refund_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_refund_detail_by_id_with_http_info(
        self,
        refund_id: Annotated[StrictStr, Field(description="The refund order ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Refund]:
        """Get refund order information

        This operation retrieves the detailed information about a specified refund order. 

        :param refund_id: The refund order ID. (required)
        :type refund_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_refund_detail_by_id_serialize(
            refund_id=refund_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_refund_detail_by_id_without_preload_content(
        self,
        refund_id: Annotated[StrictStr, Field(description="The refund order ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get refund order information

        This operation retrieves the detailed information about a specified refund order. 

        :param refund_id: The refund order ID. (required)
        :type refund_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_refund_detail_by_id_serialize(
            refund_id=refund_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_refund_detail_by_id_serialize(
        self,
        refund_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if refund_id is not None:
            _path_params['refund_id'] = refund_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/refunds/{refund_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_refunds(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> GetRefunds200Response:
        """List all refund orders

        This operation retrieves the information of all refund orders. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param request_id: The request ID.
        :type request_id: str
        :param statuses: A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) 
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_refunds_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            request_id=request_id,
            statuses=statuses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetRefunds200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_refunds_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[GetRefunds200Response]:
        """List all refund orders

        This operation retrieves the information of all refund orders. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param request_id: The request ID.
        :type request_id: str
        :param statuses: A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) 
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_refunds_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            request_id=request_id,
            statuses=statuses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetRefunds200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_refunds_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all refund orders

        This operation retrieves the information of all refund orders. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param request_id: The request ID.
        :type request_id: str
        :param statuses: A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) 
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_refunds_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            request_id=request_id,
            statuses=statuses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetRefunds200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_refunds_serialize(
        self,
        limit,
        before,
        after,
        merchant_id,
        request_id,
        statuses,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if merchant_id is not None:
            
            _query_params.append(('merchant_id', merchant_id))
            
        if request_id is not None:
            
            _query_params.append(('request_id', request_id))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/refunds',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_reports(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        report_type: Annotated[Optional[ReportType], Field(description="The type of the report. - `Order`: Summary of all pay-in orders. - `OrderTransaction`: Summary of all pay-in order transactions. - `TopUpTransaction`: Summary of all top-up transactions. - `PayinWeeklyStatement`: Weekly report of all pay-ins (including order mode and top-up mode). - `PayinDailyStatement`: Daily report of all pay-ins (including order mode and top-up mode). - `CryptoPayout`: Summary of all crypto payout transactions. - `OffRamp`: Summary of all fiat off-ramp transactions. - `Refund`: Summary of all refund transactions. - `PayoutWeeklyStatement`: Weekly report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayoutDailyStatement`: Daily report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayinCommissionFee`: Summary of all commission fees for pay-ins. - `PayoutCommissionFee`: Summary of all commission fees for payouts. - `BalanceChange`: Summary of balance changes for all accounts. - `Summary`: Summary of all pay-ins, payouts, and commission fees. ")] = None,
        report_status: Annotated[Optional[ReportStatus], Field(description="The status of the report. - `Completed`: The report has been generated successfully. - `Failed`: The report could not be generated. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> GetReports200Response:
        """List all reports

        This operation retrieves the information of all reports. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param report_type: The type of the report. - `Order`: Summary of all pay-in orders. - `OrderTransaction`: Summary of all pay-in order transactions. - `TopUpTransaction`: Summary of all top-up transactions. - `PayinWeeklyStatement`: Weekly report of all pay-ins (including order mode and top-up mode). - `PayinDailyStatement`: Daily report of all pay-ins (including order mode and top-up mode). - `CryptoPayout`: Summary of all crypto payout transactions. - `OffRamp`: Summary of all fiat off-ramp transactions. - `Refund`: Summary of all refund transactions. - `PayoutWeeklyStatement`: Weekly report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayoutDailyStatement`: Daily report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayinCommissionFee`: Summary of all commission fees for pay-ins. - `PayoutCommissionFee`: Summary of all commission fees for payouts. - `BalanceChange`: Summary of balance changes for all accounts. - `Summary`: Summary of all pay-ins, payouts, and commission fees. 
        :type report_type: ReportType
        :param report_status: The status of the report. - `Completed`: The report has been generated successfully. - `Failed`: The report could not be generated. 
        :type report_status: ReportStatus
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_reports_serialize(
            limit=limit,
            before=before,
            after=after,
            report_type=report_type,
            report_status=report_status,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReports200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_reports_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        report_type: Annotated[Optional[ReportType], Field(description="The type of the report. - `Order`: Summary of all pay-in orders. - `OrderTransaction`: Summary of all pay-in order transactions. - `TopUpTransaction`: Summary of all top-up transactions. - `PayinWeeklyStatement`: Weekly report of all pay-ins (including order mode and top-up mode). - `PayinDailyStatement`: Daily report of all pay-ins (including order mode and top-up mode). - `CryptoPayout`: Summary of all crypto payout transactions. - `OffRamp`: Summary of all fiat off-ramp transactions. - `Refund`: Summary of all refund transactions. - `PayoutWeeklyStatement`: Weekly report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayoutDailyStatement`: Daily report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayinCommissionFee`: Summary of all commission fees for pay-ins. - `PayoutCommissionFee`: Summary of all commission fees for payouts. - `BalanceChange`: Summary of balance changes for all accounts. - `Summary`: Summary of all pay-ins, payouts, and commission fees. ")] = None,
        report_status: Annotated[Optional[ReportStatus], Field(description="The status of the report. - `Completed`: The report has been generated successfully. - `Failed`: The report could not be generated. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[GetReports200Response]:
        """List all reports

        This operation retrieves the information of all reports. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param report_type: The type of the report. - `Order`: Summary of all pay-in orders. - `OrderTransaction`: Summary of all pay-in order transactions. - `TopUpTransaction`: Summary of all top-up transactions. - `PayinWeeklyStatement`: Weekly report of all pay-ins (including order mode and top-up mode). - `PayinDailyStatement`: Daily report of all pay-ins (including order mode and top-up mode). - `CryptoPayout`: Summary of all crypto payout transactions. - `OffRamp`: Summary of all fiat off-ramp transactions. - `Refund`: Summary of all refund transactions. - `PayoutWeeklyStatement`: Weekly report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayoutDailyStatement`: Daily report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayinCommissionFee`: Summary of all commission fees for pay-ins. - `PayoutCommissionFee`: Summary of all commission fees for payouts. - `BalanceChange`: Summary of balance changes for all accounts. - `Summary`: Summary of all pay-ins, payouts, and commission fees. 
        :type report_type: ReportType
        :param report_status: The status of the report. - `Completed`: The report has been generated successfully. - `Failed`: The report could not be generated. 
        :type report_status: ReportStatus
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_reports_serialize(
            limit=limit,
            before=before,
            after=after,
            report_type=report_type,
            report_status=report_status,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReports200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_reports_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        report_type: Annotated[Optional[ReportType], Field(description="The type of the report. - `Order`: Summary of all pay-in orders. - `OrderTransaction`: Summary of all pay-in order transactions. - `TopUpTransaction`: Summary of all top-up transactions. - `PayinWeeklyStatement`: Weekly report of all pay-ins (including order mode and top-up mode). - `PayinDailyStatement`: Daily report of all pay-ins (including order mode and top-up mode). - `CryptoPayout`: Summary of all crypto payout transactions. - `OffRamp`: Summary of all fiat off-ramp transactions. - `Refund`: Summary of all refund transactions. - `PayoutWeeklyStatement`: Weekly report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayoutDailyStatement`: Daily report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayinCommissionFee`: Summary of all commission fees for pay-ins. - `PayoutCommissionFee`: Summary of all commission fees for payouts. - `BalanceChange`: Summary of balance changes for all accounts. - `Summary`: Summary of all pay-ins, payouts, and commission fees. ")] = None,
        report_status: Annotated[Optional[ReportStatus], Field(description="The status of the report. - `Completed`: The report has been generated successfully. - `Failed`: The report could not be generated. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all reports

        This operation retrieves the information of all reports. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param report_type: The type of the report. - `Order`: Summary of all pay-in orders. - `OrderTransaction`: Summary of all pay-in order transactions. - `TopUpTransaction`: Summary of all top-up transactions. - `PayinWeeklyStatement`: Weekly report of all pay-ins (including order mode and top-up mode). - `PayinDailyStatement`: Daily report of all pay-ins (including order mode and top-up mode). - `CryptoPayout`: Summary of all crypto payout transactions. - `OffRamp`: Summary of all fiat off-ramp transactions. - `Refund`: Summary of all refund transactions. - `PayoutWeeklyStatement`: Weekly report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayoutDailyStatement`: Daily report of all payouts (including crypto payouts, fiat off-ramps, and refunds). - `PayinCommissionFee`: Summary of all commission fees for pay-ins. - `PayoutCommissionFee`: Summary of all commission fees for payouts. - `BalanceChange`: Summary of balance changes for all accounts. - `Summary`: Summary of all pay-ins, payouts, and commission fees. 
        :type report_type: ReportType
        :param report_status: The status of the report. - `Completed`: The report has been generated successfully. - `Failed`: The report could not be generated. 
        :type report_status: ReportStatus
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_reports_serialize(
            limit=limit,
            before=before,
            after=after,
            report_type=report_type,
            report_status=report_status,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetReports200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_reports_serialize(
        self,
        limit,
        before,
        after,
        report_type,
        report_status,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if report_type is not None:
            
            _query_params.append(('report_type', report_type.value))
            
        if report_status is not None:
            
            _query_params.append(('report_status', report_status.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/reports',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_settlement_by_id(
        self,
        settlement_request_id: Annotated[StrictStr, Field(description="The settlement request ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Settlement:
        """Get settlement request information

        <Note>This operation has been deprecated. Please use [Get payout information](https://www.cobo.com/payments/en/api-references/payment/get-payout-information) instead.</Note>  This operation retrieves the information of a specific settlement request. 

        :param settlement_request_id: The settlement request ID. (required)
        :type settlement_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_settlement_by_id_serialize(
            settlement_request_id=settlement_request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Settlement",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_settlement_by_id_with_http_info(
        self,
        settlement_request_id: Annotated[StrictStr, Field(description="The settlement request ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Settlement]:
        """Get settlement request information

        <Note>This operation has been deprecated. Please use [Get payout information](https://www.cobo.com/payments/en/api-references/payment/get-payout-information) instead.</Note>  This operation retrieves the information of a specific settlement request. 

        :param settlement_request_id: The settlement request ID. (required)
        :type settlement_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_settlement_by_id_serialize(
            settlement_request_id=settlement_request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Settlement",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_settlement_by_id_without_preload_content(
        self,
        settlement_request_id: Annotated[StrictStr, Field(description="The settlement request ID.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get settlement request information

        <Note>This operation has been deprecated. Please use [Get payout information](https://www.cobo.com/payments/en/api-references/payment/get-payout-information) instead.</Note>  This operation retrieves the information of a specific settlement request. 

        :param settlement_request_id: The settlement request ID. (required)
        :type settlement_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_settlement_by_id_serialize(
            settlement_request_id=settlement_request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Settlement",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_settlement_by_id_serialize(
        self,
        settlement_request_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if settlement_request_id is not None:
            _path_params['settlement_request_id'] = settlement_request_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/settlement_requests/{settlement_request_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_settlement_info_by_ids(
        self,
        merchant_ids: Annotated[Optional[StrictStr], Field(description="A list of merchant IDs to query.")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="The currency for the operation. Currently, only `USD` is supported.")] = None,
        acquiring_type: Annotated[Optional[AcquiringType], Field(description="This parameter has been deprecated")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> GetSettlementInfoByIds200Response:
        """Get withdrawable balances

        <Warning>This operation has been deprecated.</Warning> This operation retrieves the balances of specified merchants or the developer. 

        :param merchant_ids: A list of merchant IDs to query.
        :type merchant_ids: str
        :param currency: The currency for the operation. Currently, only `USD` is supported.
        :type currency: str
        :param acquiring_type: This parameter has been deprecated
        :type acquiring_type: AcquiringType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_settlement_info_by_ids_serialize(
            merchant_ids=merchant_ids,
            currency=currency,
            acquiring_type=acquiring_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetSettlementInfoByIds200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_settlement_info_by_ids_with_http_info(
        self,
        merchant_ids: Annotated[Optional[StrictStr], Field(description="A list of merchant IDs to query.")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="The currency for the operation. Currently, only `USD` is supported.")] = None,
        acquiring_type: Annotated[Optional[AcquiringType], Field(description="This parameter has been deprecated")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[GetSettlementInfoByIds200Response]:
        """Get withdrawable balances

        <Warning>This operation has been deprecated.</Warning> This operation retrieves the balances of specified merchants or the developer. 

        :param merchant_ids: A list of merchant IDs to query.
        :type merchant_ids: str
        :param currency: The currency for the operation. Currently, only `USD` is supported.
        :type currency: str
        :param acquiring_type: This parameter has been deprecated
        :type acquiring_type: AcquiringType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_settlement_info_by_ids_serialize(
            merchant_ids=merchant_ids,
            currency=currency,
            acquiring_type=acquiring_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetSettlementInfoByIds200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_settlement_info_by_ids_without_preload_content(
        self,
        merchant_ids: Annotated[Optional[StrictStr], Field(description="A list of merchant IDs to query.")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="The currency for the operation. Currently, only `USD` is supported.")] = None,
        acquiring_type: Annotated[Optional[AcquiringType], Field(description="This parameter has been deprecated")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Get withdrawable balances

        <Warning>This operation has been deprecated.</Warning> This operation retrieves the balances of specified merchants or the developer. 

        :param merchant_ids: A list of merchant IDs to query.
        :type merchant_ids: str
        :param currency: The currency for the operation. Currently, only `USD` is supported.
        :type currency: str
        :param acquiring_type: This parameter has been deprecated
        :type acquiring_type: AcquiringType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_settlement_info_by_ids_serialize(
            merchant_ids=merchant_ids,
            currency=currency,
            acquiring_type=acquiring_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetSettlementInfoByIds200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_settlement_info_by_ids_serialize(
        self,
        merchant_ids,
        currency,
        acquiring_type,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if merchant_ids is not None:
            
            _query_params.append(('merchant_ids', merchant_ids))
            
        if currency is not None:
            
            _query_params.append(('currency', currency))
            
        if acquiring_type is not None:
            
            _query_params.append(('acquiring_type', acquiring_type.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/settlement_info',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def get_top_up_address(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        custom_payer_id: Annotated[StrictStr, Field(description="A unique identifier to track and identify individual payers in your system.")],
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TopUpAddress:
        """Create/Get top-up address

        This operation creates or retrieves a unique top-up address for a payer.   In the request, you need to provide the `custom_payer_id` parameter to identify the payer in your system and link them to the top-up address.  - If no address exists for the payer on the specified chain, a new address will be created and returned. - If an address already exists for the payer on the specified chain, the existing address details will be returned.  You can also provide the `merchant_id` parameter to specify the merchant to which the payer belongs. If not provided, the default merchant will be used. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param custom_payer_id: A unique identifier to track and identify individual payers in your system. (required)
        :type custom_payer_id: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_top_up_address_serialize(
            token_id=token_id,
            custom_payer_id=custom_payer_id,
            merchant_id=merchant_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TopUpAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_top_up_address_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        custom_payer_id: Annotated[StrictStr, Field(description="A unique identifier to track and identify individual payers in your system.")],
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TopUpAddress]:
        """Create/Get top-up address

        This operation creates or retrieves a unique top-up address for a payer.   In the request, you need to provide the `custom_payer_id` parameter to identify the payer in your system and link them to the top-up address.  - If no address exists for the payer on the specified chain, a new address will be created and returned. - If an address already exists for the payer on the specified chain, the existing address details will be returned.  You can also provide the `merchant_id` parameter to specify the merchant to which the payer belongs. If not provided, the default merchant will be used. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param custom_payer_id: A unique identifier to track and identify individual payers in your system. (required)
        :type custom_payer_id: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_top_up_address_serialize(
            token_id=token_id,
            custom_payer_id=custom_payer_id,
            merchant_id=merchant_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TopUpAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_top_up_address_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        custom_payer_id: Annotated[StrictStr, Field(description="A unique identifier to track and identify individual payers in your system.")],
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Create/Get top-up address

        This operation creates or retrieves a unique top-up address for a payer.   In the request, you need to provide the `custom_payer_id` parameter to identify the payer in your system and link them to the top-up address.  - If no address exists for the payer on the specified chain, a new address will be created and returned. - If an address already exists for the payer on the specified chain, the existing address details will be returned.  You can also provide the `merchant_id` parameter to specify the merchant to which the payer belongs. If not provided, the default merchant will be used. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param custom_payer_id: A unique identifier to track and identify individual payers in your system. (required)
        :type custom_payer_id: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_top_up_address_serialize(
            token_id=token_id,
            custom_payer_id=custom_payer_id,
            merchant_id=merchant_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TopUpAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_top_up_address_serialize(
        self,
        token_id,
        custom_payer_id,
        merchant_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token_id is not None:
            
            _query_params.append(('token_id', token_id))
            
        if custom_payer_id is not None:
            
            _query_params.append(('custom_payer_id', custom_payer_id))
            
        if merchant_id is not None:
            
            _query_params.append(('merchant_id', merchant_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/topup/address',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_allocation_items(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        source_account: Annotated[Optional[StrictStr], Field(description="The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`. ")] = None,
        destination_account: Annotated[Optional[StrictStr], Field(description="The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`. ")] = None,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")] = None,
        batch_allocation_id: Annotated[Optional[StrictStr], Field(description="The batch allocation ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListAllocationItems200Response:
        """List all allocation items

        This operation retrieves the information of all allocations. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param source_account: The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`. 
        :type source_account: str
        :param destination_account: The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`. 
        :type destination_account: str
        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` 
        :type token_id: str
        :param batch_allocation_id: The batch allocation ID.
        :type batch_allocation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_allocation_items_serialize(
            limit=limit,
            before=before,
            after=after,
            source_account=source_account,
            destination_account=destination_account,
            token_id=token_id,
            batch_allocation_id=batch_allocation_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListAllocationItems200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_allocation_items_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        source_account: Annotated[Optional[StrictStr], Field(description="The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`. ")] = None,
        destination_account: Annotated[Optional[StrictStr], Field(description="The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`. ")] = None,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")] = None,
        batch_allocation_id: Annotated[Optional[StrictStr], Field(description="The batch allocation ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListAllocationItems200Response]:
        """List all allocation items

        This operation retrieves the information of all allocations. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param source_account: The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`. 
        :type source_account: str
        :param destination_account: The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`. 
        :type destination_account: str
        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` 
        :type token_id: str
        :param batch_allocation_id: The batch allocation ID.
        :type batch_allocation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_allocation_items_serialize(
            limit=limit,
            before=before,
            after=after,
            source_account=source_account,
            destination_account=destination_account,
            token_id=token_id,
            batch_allocation_id=batch_allocation_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListAllocationItems200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_allocation_items_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        source_account: Annotated[Optional[StrictStr], Field(description="The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`. ")] = None,
        destination_account: Annotated[Optional[StrictStr], Field(description="The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`. ")] = None,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")] = None,
        batch_allocation_id: Annotated[Optional[StrictStr], Field(description="The batch allocation ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all allocation items

        This operation retrieves the information of all allocations. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param source_account: The source account.  - If the source account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the source account is the developer account, use the string `\"developer\"`. 
        :type source_account: str
        :param destination_account: The destination account.  - If the destination account is a merchant account, provide the merchant's ID (e.g., \"M1001\"). - If the destination account is the developer account, use the string `\"developer\"`. 
        :type destination_account: str
        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` 
        :type token_id: str
        :param batch_allocation_id: The batch allocation ID.
        :type batch_allocation_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_allocation_items_serialize(
            limit=limit,
            before=before,
            after=after,
            source_account=source_account,
            destination_account=destination_account,
            token_id=token_id,
            batch_allocation_id=batch_allocation_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListAllocationItems200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_allocation_items_serialize(
        self,
        limit,
        before,
        after,
        source_account,
        destination_account,
        token_id,
        batch_allocation_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if source_account is not None:
            
            _query_params.append(('source_account', source_account))
            
        if destination_account is not None:
            
            _query_params.append(('destination_account', destination_account))
            
        if token_id is not None:
            
            _query_params.append(('token_id', token_id))
            
        if batch_allocation_id is not None:
            
            _query_params.append(('batch_allocation_id', batch_allocation_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/allocation_items',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_bank_accounts(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> List[BankAccount]:
        """List all bank accounts

        <Note>This operation has been deprecated. Please use [List counterparty entries](https://www.cobo.com/payments/en/api-references/payment/list-counterparty-entries) instead.</Note> This operation retrieves the information of all bank accounts registered. 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_bank_accounts_serialize(
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BankAccount]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_bank_accounts_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[List[BankAccount]]:
        """List all bank accounts

        <Note>This operation has been deprecated. Please use [List counterparty entries](https://www.cobo.com/payments/en/api-references/payment/list-counterparty-entries) instead.</Note> This operation retrieves the information of all bank accounts registered. 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_bank_accounts_serialize(
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BankAccount]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_bank_accounts_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all bank accounts

        <Note>This operation has been deprecated. Please use [List counterparty entries](https://www.cobo.com/payments/en/api-references/payment/list-counterparty-entries) instead.</Note> This operation retrieves the information of all bank accounts registered. 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_bank_accounts_serialize(
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BankAccount]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_bank_accounts_serialize(
        self,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/bank_accounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_batch_allocations(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListBatchAllocations200Response:
        """List all batch allocations

        This operation retrieves the information of all batch allocations. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_batch_allocations_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListBatchAllocations200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_batch_allocations_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListBatchAllocations200Response]:
        """List all batch allocations

        This operation retrieves the information of all batch allocations. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_batch_allocations_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListBatchAllocations200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_batch_allocations_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all batch allocations

        This operation retrieves the information of all batch allocations. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_batch_allocations_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListBatchAllocations200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_batch_allocations_serialize(
        self,
        limit,
        before,
        after,
        request_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if request_id is not None:
            
            _query_params.append(('request_id', request_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/batch_allocations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_bulk_send_items(
        self,
        bulk_send_id: Annotated[StrictStr, Field(description="The bulk send ID.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListBulkSendItems200Response:
        """List bulk send items

        This operation retrieves the list of items for a specific bulk send. 

        :param bulk_send_id: The bulk send ID. (required)
        :type bulk_send_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_bulk_send_items_serialize(
            bulk_send_id=bulk_send_id,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListBulkSendItems200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_bulk_send_items_with_http_info(
        self,
        bulk_send_id: Annotated[StrictStr, Field(description="The bulk send ID.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListBulkSendItems200Response]:
        """List bulk send items

        This operation retrieves the list of items for a specific bulk send. 

        :param bulk_send_id: The bulk send ID. (required)
        :type bulk_send_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_bulk_send_items_serialize(
            bulk_send_id=bulk_send_id,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListBulkSendItems200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_bulk_send_items_without_preload_content(
        self,
        bulk_send_id: Annotated[StrictStr, Field(description="The bulk send ID.")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List bulk send items

        This operation retrieves the list of items for a specific bulk send. 

        :param bulk_send_id: The bulk send ID. (required)
        :type bulk_send_id: str
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_bulk_send_items_serialize(
            bulk_send_id=bulk_send_id,
            limit=limit,
            before=before,
            after=after,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListBulkSendItems200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_bulk_send_items_serialize(
        self,
        bulk_send_id,
        limit,
        before,
        after,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bulk_send_id is not None:
            _path_params['bulk_send_id'] = bulk_send_id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/bulk_sends/{bulk_send_id}/items',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_counterparties(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        counterparty_type: Annotated[Optional[CounterpartyType], Field(description="The type of the counterparty. - `Individual`: The counterparty is an individual. - `Organization`: The counterparty is an organization. ")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code, in ISO 3166-1 alpha-3 format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListCounterparties200Response:
        """List all counterparties

        This operation retrieves the information of all counterparties.   You can filter the results by using a keyword for fuzzy search on counterparty names. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param counterparty_type: The type of the counterparty. - `Individual`: The counterparty is an individual. - `Organization`: The counterparty is an organization. 
        :type counterparty_type: CounterpartyType
        :param country: Country code, in ISO 3166-1 alpha-3 format.
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_counterparties_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            counterparty_type=counterparty_type,
            country=country,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCounterparties200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_counterparties_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        counterparty_type: Annotated[Optional[CounterpartyType], Field(description="The type of the counterparty. - `Individual`: The counterparty is an individual. - `Organization`: The counterparty is an organization. ")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code, in ISO 3166-1 alpha-3 format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListCounterparties200Response]:
        """List all counterparties

        This operation retrieves the information of all counterparties.   You can filter the results by using a keyword for fuzzy search on counterparty names. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param counterparty_type: The type of the counterparty. - `Individual`: The counterparty is an individual. - `Organization`: The counterparty is an organization. 
        :type counterparty_type: CounterpartyType
        :param country: Country code, in ISO 3166-1 alpha-3 format.
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_counterparties_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            counterparty_type=counterparty_type,
            country=country,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCounterparties200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_counterparties_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        counterparty_type: Annotated[Optional[CounterpartyType], Field(description="The type of the counterparty. - `Individual`: The counterparty is an individual. - `Organization`: The counterparty is an organization. ")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code, in ISO 3166-1 alpha-3 format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all counterparties

        This operation retrieves the information of all counterparties.   You can filter the results by using a keyword for fuzzy search on counterparty names. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param counterparty_type: The type of the counterparty. - `Individual`: The counterparty is an individual. - `Organization`: The counterparty is an organization. 
        :type counterparty_type: CounterpartyType
        :param country: Country code, in ISO 3166-1 alpha-3 format.
        :type country: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_counterparties_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            counterparty_type=counterparty_type,
            country=country,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCounterparties200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_counterparties_serialize(
        self,
        limit,
        before,
        after,
        keyword,
        counterparty_type,
        country,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if counterparty_type is not None:
            
            _query_params.append(('counterparty_type', counterparty_type.value))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/counterparty',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_counterparty_entries(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        entry_type: Annotated[Optional[EntryType], Field(description="The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")] = None,
        counterparty_id: Annotated[Optional[StrictStr], Field(description="The counterparty ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListCounterpartyEntries200Response:
        """List counterparty entries

        This operation retrieves the information of counterparty entries. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param entry_type: The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. 
        :type entry_type: EntryType
        :param counterparty_id: The counterparty ID.
        :type counterparty_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_counterparty_entries_serialize(
            limit=limit,
            before=before,
            after=after,
            entry_type=entry_type,
            counterparty_id=counterparty_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCounterpartyEntries200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_counterparty_entries_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        entry_type: Annotated[Optional[EntryType], Field(description="The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")] = None,
        counterparty_id: Annotated[Optional[StrictStr], Field(description="The counterparty ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListCounterpartyEntries200Response]:
        """List counterparty entries

        This operation retrieves the information of counterparty entries. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param entry_type: The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. 
        :type entry_type: EntryType
        :param counterparty_id: The counterparty ID.
        :type counterparty_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_counterparty_entries_serialize(
            limit=limit,
            before=before,
            after=after,
            entry_type=entry_type,
            counterparty_id=counterparty_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCounterpartyEntries200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_counterparty_entries_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        entry_type: Annotated[Optional[EntryType], Field(description="The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")] = None,
        counterparty_id: Annotated[Optional[StrictStr], Field(description="The counterparty ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List counterparty entries

        This operation retrieves the information of counterparty entries. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param entry_type: The type of the counterparty entry. - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. 
        :type entry_type: EntryType
        :param counterparty_id: The counterparty ID.
        :type counterparty_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_counterparty_entries_serialize(
            limit=limit,
            before=before,
            after=after,
            entry_type=entry_type,
            counterparty_id=counterparty_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCounterpartyEntries200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_counterparty_entries_serialize(
        self,
        limit,
        before,
        after,
        entry_type,
        counterparty_id,
        chain_ids,
        wallet_address,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if entry_type is not None:
            
            _query_params.append(('entry_type', entry_type.value))
            
        if counterparty_id is not None:
            
            _query_params.append(('counterparty_id', counterparty_id))
            
        if chain_ids is not None:
            
            _query_params.append(('chain_ids', chain_ids))
            
        if wallet_address is not None:
            
            _query_params.append(('wallet_address', wallet_address))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/counterparty_entry',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_counterparty_wallet_address(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        counterparty_id: Annotated[Optional[StrictStr], Field(description="The counterparty ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListCounterpartyWalletAddress200Response:
        """List counterparty wallet addresses

        This operation retrieves the information of counterparty wallet addresses. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param counterparty_id: The counterparty ID.
        :type counterparty_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_counterparty_wallet_address_serialize(
            limit=limit,
            before=before,
            after=after,
            counterparty_id=counterparty_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCounterpartyWalletAddress200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_counterparty_wallet_address_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        counterparty_id: Annotated[Optional[StrictStr], Field(description="The counterparty ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListCounterpartyWalletAddress200Response]:
        """List counterparty wallet addresses

        This operation retrieves the information of counterparty wallet addresses. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param counterparty_id: The counterparty ID.
        :type counterparty_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_counterparty_wallet_address_serialize(
            limit=limit,
            before=before,
            after=after,
            counterparty_id=counterparty_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCounterpartyWalletAddress200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_counterparty_wallet_address_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        counterparty_id: Annotated[Optional[StrictStr], Field(description="The counterparty ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List counterparty wallet addresses

        This operation retrieves the information of counterparty wallet addresses. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param counterparty_id: The counterparty ID.
        :type counterparty_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_counterparty_wallet_address_serialize(
            limit=limit,
            before=before,
            after=after,
            counterparty_id=counterparty_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCounterpartyWalletAddress200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_counterparty_wallet_address_serialize(
        self,
        limit,
        before,
        after,
        counterparty_id,
        chain_ids,
        wallet_address,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if counterparty_id is not None:
            
            _query_params.append(('counterparty_id', counterparty_id))
            
        if chain_ids is not None:
            
            _query_params.append(('chain_ids', chain_ids))
            
        if wallet_address is not None:
            
            _query_params.append(('wallet_address', wallet_address))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/counterparty/wallet_address',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_crypto_addresses(
        self,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> List[CryptoAddress]:
        """List crypto addresses

        This operation retrieves a list of crypto addresses registered for crypto payouts.   Contact our support team at [help@cobo.com](mailto:help@cobo.com) to register a new crypto address. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` 
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_crypto_addresses_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CryptoAddress]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_crypto_addresses_with_http_info(
        self,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[List[CryptoAddress]]:
        """List crypto addresses

        This operation retrieves a list of crypto addresses registered for crypto payouts.   Contact our support team at [help@cobo.com](mailto:help@cobo.com) to register a new crypto address. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` 
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_crypto_addresses_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CryptoAddress]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_crypto_addresses_without_preload_content(
        self,
        token_id: Annotated[Optional[StrictStr], Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List crypto addresses

        This operation retrieves a list of crypto addresses registered for crypto payouts.   Contact our support team at [help@cobo.com](mailto:help@cobo.com) to register a new crypto address. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` 
        :type token_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_crypto_addresses_serialize(
            token_id=token_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[CryptoAddress]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_crypto_addresses_serialize(
        self,
        token_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token_id is not None:
            
            _query_params.append(('token_id', token_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/crypto_addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_destination_bank_accounts(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        destination_id: Annotated[Optional[StrictStr], Field(description="The destination ID.")] = None,
        bank_account_status: Annotated[Optional[BankAccountStatus], Field(description="BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListDestinationBankAccounts200Response:
        """List destination bank accounts

        This operation retrieves the information of destination bank accounts. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param destination_id: The destination ID.
        :type destination_id: str
        :param bank_account_status: BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. 
        :type bank_account_status: BankAccountStatus
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destination_bank_accounts_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            destination_id=destination_id,
            bank_account_status=bank_account_status,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinationBankAccounts200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_destination_bank_accounts_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        destination_id: Annotated[Optional[StrictStr], Field(description="The destination ID.")] = None,
        bank_account_status: Annotated[Optional[BankAccountStatus], Field(description="BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListDestinationBankAccounts200Response]:
        """List destination bank accounts

        This operation retrieves the information of destination bank accounts. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param destination_id: The destination ID.
        :type destination_id: str
        :param bank_account_status: BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. 
        :type bank_account_status: BankAccountStatus
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destination_bank_accounts_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            destination_id=destination_id,
            bank_account_status=bank_account_status,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinationBankAccounts200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_destination_bank_accounts_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        destination_id: Annotated[Optional[StrictStr], Field(description="The destination ID.")] = None,
        bank_account_status: Annotated[Optional[BankAccountStatus], Field(description="BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List destination bank accounts

        This operation retrieves the information of destination bank accounts. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param destination_id: The destination ID.
        :type destination_id: str
        :param bank_account_status: BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. 
        :type bank_account_status: BankAccountStatus
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destination_bank_accounts_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            destination_id=destination_id,
            bank_account_status=bank_account_status,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinationBankAccounts200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_destination_bank_accounts_serialize(
        self,
        limit,
        before,
        after,
        keyword,
        destination_id,
        bank_account_status,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if destination_id is not None:
            
            _query_params.append(('destination_id', destination_id))
            
        if bank_account_status is not None:
            
            _query_params.append(('bank_account_status', bank_account_status.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/destination/bank_account',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_destination_entries(
        self,
        entry_type: Annotated[EntryType, Field(description="EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        destination_id: Annotated[Optional[StrictStr], Field(description="The destination ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        bank_account_status: Annotated[Optional[BankAccountStatus], Field(description="BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListDestinationEntries200Response:
        """List destination entries

        This operation retrieves the information of destination entries. 

        :param entry_type: EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account.  (required)
        :type entry_type: EntryType
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param destination_id: The destination ID.
        :type destination_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param bank_account_status: BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. 
        :type bank_account_status: BankAccountStatus
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destination_entries_serialize(
            entry_type=entry_type,
            limit=limit,
            before=before,
            after=after,
            destination_id=destination_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
            keyword=keyword,
            bank_account_status=bank_account_status,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinationEntries200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_destination_entries_with_http_info(
        self,
        entry_type: Annotated[EntryType, Field(description="EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        destination_id: Annotated[Optional[StrictStr], Field(description="The destination ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        bank_account_status: Annotated[Optional[BankAccountStatus], Field(description="BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListDestinationEntries200Response]:
        """List destination entries

        This operation retrieves the information of destination entries. 

        :param entry_type: EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account.  (required)
        :type entry_type: EntryType
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param destination_id: The destination ID.
        :type destination_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param bank_account_status: BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. 
        :type bank_account_status: BankAccountStatus
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destination_entries_serialize(
            entry_type=entry_type,
            limit=limit,
            before=before,
            after=after,
            destination_id=destination_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
            keyword=keyword,
            bank_account_status=bank_account_status,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinationEntries200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_destination_entries_without_preload_content(
        self,
        entry_type: Annotated[EntryType, Field(description="EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account. ")],
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        destination_id: Annotated[Optional[StrictStr], Field(description="The destination ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        bank_account_status: Annotated[Optional[BankAccountStatus], Field(description="BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List destination entries

        This operation retrieves the information of destination entries. 

        :param entry_type: EntryType defines the type of the counterparty entry: - `Address`: The counterparty entry is an address. - `BankAccount`: The counterparty entry is a bank account.  (required)
        :type entry_type: EntryType
        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param destination_id: The destination ID.
        :type destination_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param bank_account_status: BankAccountStatus defines the status of the bank account: - `Pending`: The bank account is pending verification by Cobo. - `Approved`: The bank account has been approved by Cobo. - `Rejected`: The bank account has been rejected by Cobo. 
        :type bank_account_status: BankAccountStatus
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destination_entries_serialize(
            entry_type=entry_type,
            limit=limit,
            before=before,
            after=after,
            destination_id=destination_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
            keyword=keyword,
            bank_account_status=bank_account_status,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinationEntries200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_destination_entries_serialize(
        self,
        entry_type,
        limit,
        before,
        after,
        destination_id,
        chain_ids,
        wallet_address,
        keyword,
        bank_account_status,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if entry_type is not None:
            
            _query_params.append(('entry_type', entry_type.value))
            
        if destination_id is not None:
            
            _query_params.append(('destination_id', destination_id))
            
        if chain_ids is not None:
            
            _query_params.append(('chain_ids', chain_ids))
            
        if wallet_address is not None:
            
            _query_params.append(('wallet_address', wallet_address))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if bank_account_status is not None:
            
            _query_params.append(('bank_account_status', bank_account_status.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/destination_entry',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_destination_wallet_addresses(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        destination_id: Annotated[Optional[StrictStr], Field(description="The destination ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListDestinationWalletAddresses200Response:
        """List destination wallet addresses

        This operation retrieves the information of destination wallet addresses. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param destination_id: The destination ID.
        :type destination_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destination_wallet_addresses_serialize(
            limit=limit,
            before=before,
            after=after,
            destination_id=destination_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinationWalletAddresses200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_destination_wallet_addresses_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        destination_id: Annotated[Optional[StrictStr], Field(description="The destination ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListDestinationWalletAddresses200Response]:
        """List destination wallet addresses

        This operation retrieves the information of destination wallet addresses. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param destination_id: The destination ID.
        :type destination_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destination_wallet_addresses_serialize(
            limit=limit,
            before=before,
            after=after,
            destination_id=destination_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinationWalletAddresses200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_destination_wallet_addresses_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        destination_id: Annotated[Optional[StrictStr], Field(description="The destination ID.")] = None,
        chain_ids: Annotated[Optional[StrictStr], Field(description="The chain ID, which is the unique identifier of a blockchain.")] = None,
        wallet_address: Annotated[Optional[StrictStr], Field(description="The wallet address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List destination wallet addresses

        This operation retrieves the information of destination wallet addresses. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param destination_id: The destination ID.
        :type destination_id: str
        :param chain_ids: The chain ID, which is the unique identifier of a blockchain.
        :type chain_ids: str
        :param wallet_address: The wallet address.
        :type wallet_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destination_wallet_addresses_serialize(
            limit=limit,
            before=before,
            after=after,
            destination_id=destination_id,
            chain_ids=chain_ids,
            wallet_address=wallet_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinationWalletAddresses200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_destination_wallet_addresses_serialize(
        self,
        limit,
        before,
        after,
        destination_id,
        chain_ids,
        wallet_address,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if destination_id is not None:
            
            _query_params.append(('destination_id', destination_id))
            
        if chain_ids is not None:
            
            _query_params.append(('chain_ids', chain_ids))
            
        if wallet_address is not None:
            
            _query_params.append(('wallet_address', wallet_address))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/destination/wallet_address',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_destinations(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        destination_type: Annotated[Optional[DestinationType], Field(description="DestinationType defines the type of the destination: - `Individual`: The destination is an individual. - `Organization`: The destination is an organization. ")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code, in ISO 3166-1 alpha-3 format.")] = None,
        merchant_ids: Annotated[Optional[StrictStr], Field(description="A list of merchant IDs to query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListDestinations200Response:
        """List all destinations

        This operation retrieves the information of all destinations.   You can filter the results by using a keyword for fuzzy search on destination names. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param destination_type: DestinationType defines the type of the destination: - `Individual`: The destination is an individual. - `Organization`: The destination is an organization. 
        :type destination_type: DestinationType
        :param country: Country code, in ISO 3166-1 alpha-3 format.
        :type country: str
        :param merchant_ids: A list of merchant IDs to query.
        :type merchant_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destinations_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            destination_type=destination_type,
            country=country,
            merchant_ids=merchant_ids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinations200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_destinations_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        destination_type: Annotated[Optional[DestinationType], Field(description="DestinationType defines the type of the destination: - `Individual`: The destination is an individual. - `Organization`: The destination is an organization. ")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code, in ISO 3166-1 alpha-3 format.")] = None,
        merchant_ids: Annotated[Optional[StrictStr], Field(description="A list of merchant IDs to query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListDestinations200Response]:
        """List all destinations

        This operation retrieves the information of all destinations.   You can filter the results by using a keyword for fuzzy search on destination names. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param destination_type: DestinationType defines the type of the destination: - `Individual`: The destination is an individual. - `Organization`: The destination is an organization. 
        :type destination_type: DestinationType
        :param country: Country code, in ISO 3166-1 alpha-3 format.
        :type country: str
        :param merchant_ids: A list of merchant IDs to query.
        :type merchant_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destinations_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            destination_type=destination_type,
            country=country,
            merchant_ids=merchant_ids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinations200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_destinations_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        destination_type: Annotated[Optional[DestinationType], Field(description="DestinationType defines the type of the destination: - `Individual`: The destination is an individual. - `Organization`: The destination is an organization. ")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country code, in ISO 3166-1 alpha-3 format.")] = None,
        merchant_ids: Annotated[Optional[StrictStr], Field(description="A list of merchant IDs to query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all destinations

        This operation retrieves the information of all destinations.   You can filter the results by using a keyword for fuzzy search on destination names. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param destination_type: DestinationType defines the type of the destination: - `Individual`: The destination is an individual. - `Organization`: The destination is an organization. 
        :type destination_type: DestinationType
        :param country: Country code, in ISO 3166-1 alpha-3 format.
        :type country: str
        :param merchant_ids: A list of merchant IDs to query.
        :type merchant_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_destinations_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            destination_type=destination_type,
            country=country,
            merchant_ids=merchant_ids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListDestinations200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_destinations_serialize(
        self,
        limit,
        before,
        after,
        keyword,
        destination_type,
        country,
        merchant_ids,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if destination_type is not None:
            
            _query_params.append(('destination_type', destination_type.value))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if merchant_ids is not None:
            
            _query_params.append(('merchant_ids', merchant_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/destination',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_forced_sweep_requests(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListForcedSweepRequests200Response:
        """List forced sweeps

        <Warning>This operation has been deprecated.</Warning> This operation retrieves the information of all forced sweeps. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_forced_sweep_requests_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListForcedSweepRequests200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_forced_sweep_requests_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListForcedSweepRequests200Response]:
        """List forced sweeps

        <Warning>This operation has been deprecated.</Warning> This operation retrieves the information of all forced sweeps. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_forced_sweep_requests_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListForcedSweepRequests200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_forced_sweep_requests_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List forced sweeps

        <Warning>This operation has been deprecated.</Warning> This operation retrieves the information of all forced sweeps. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_forced_sweep_requests_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListForcedSweepRequests200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_forced_sweep_requests_serialize(
        self,
        limit,
        before,
        after,
        request_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if request_id is not None:
            
            _query_params.append(('request_id', request_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/force_sweep_requests',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_merchant_balances(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        merchant_ids: Annotated[Optional[StrictStr], Field(description="A list of merchant IDs to query.")] = None,
        acquiring_type: Annotated[Optional[AcquiringType], Field(description="This parameter has been deprecated")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListMerchantBalances200Response:
        """List merchant balances

         This operation retrieves the balance information for specified merchants.   The balance information is grouped by token and acquiring type. If you do not specify the `merchant_ids` parameter, the balance information for all merchants will be returned.  For more information, please refer to [Accounts and fund allocation](https://www.cobo.com/payments/en/guides/amounts-and-balances). 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param merchant_ids: A list of merchant IDs to query.
        :type merchant_ids: str
        :param acquiring_type: This parameter has been deprecated
        :type acquiring_type: AcquiringType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_merchant_balances_serialize(
            token_id=token_id,
            merchant_ids=merchant_ids,
            acquiring_type=acquiring_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListMerchantBalances200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_merchant_balances_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        merchant_ids: Annotated[Optional[StrictStr], Field(description="A list of merchant IDs to query.")] = None,
        acquiring_type: Annotated[Optional[AcquiringType], Field(description="This parameter has been deprecated")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListMerchantBalances200Response]:
        """List merchant balances

         This operation retrieves the balance information for specified merchants.   The balance information is grouped by token and acquiring type. If you do not specify the `merchant_ids` parameter, the balance information for all merchants will be returned.  For more information, please refer to [Accounts and fund allocation](https://www.cobo.com/payments/en/guides/amounts-and-balances). 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param merchant_ids: A list of merchant IDs to query.
        :type merchant_ids: str
        :param acquiring_type: This parameter has been deprecated
        :type acquiring_type: AcquiringType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_merchant_balances_serialize(
            token_id=token_id,
            merchant_ids=merchant_ids,
            acquiring_type=acquiring_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListMerchantBalances200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_merchant_balances_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        merchant_ids: Annotated[Optional[StrictStr], Field(description="A list of merchant IDs to query.")] = None,
        acquiring_type: Annotated[Optional[AcquiringType], Field(description="This parameter has been deprecated")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List merchant balances

         This operation retrieves the balance information for specified merchants.   The balance information is grouped by token and acquiring type. If you do not specify the `merchant_ids` parameter, the balance information for all merchants will be returned.  For more information, please refer to [Accounts and fund allocation](https://www.cobo.com/payments/en/guides/amounts-and-balances). 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param merchant_ids: A list of merchant IDs to query.
        :type merchant_ids: str
        :param acquiring_type: This parameter has been deprecated
        :type acquiring_type: AcquiringType
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_merchant_balances_serialize(
            token_id=token_id,
            merchant_ids=merchant_ids,
            acquiring_type=acquiring_type,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListMerchantBalances200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_merchant_balances_serialize(
        self,
        token_id,
        merchant_ids,
        acquiring_type,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if merchant_ids is not None:
            
            _query_params.append(('merchant_ids', merchant_ids))
            
        if token_id is not None:
            
            _query_params.append(('token_id', token_id))
            
        if acquiring_type is not None:
            
            _query_params.append(('acquiring_type', acquiring_type.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/balance/merchants',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_merchants(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        wallet_id: Annotated[Optional[StrictStr], Field(description="This parameter has been deprecated.")] = None,
        wallet_setup: Annotated[Optional[WalletSetup], Field(description="The type of wallet setup for the merchant. Each wallet contains multiple cryptocurrency addresses that serve as the merchants receiving addresses.  - `Shared`: Multiple merchants share the same wallet. The wallets addresses may be used to receive payments for multiple merchants simultaneously. - `Separate`: Create a dedicated wallet for the merchant to achieve complete fund isolation. All addresses in this wallet are only used to receive payments for this merchant. - `Default`: The default wallet automatically created by the system for the default merchant (the merchant that shares the same name as your organization). ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListMerchants200Response:
        """List all merchants

        This operation retrieves the information of all merchants.   You can filter the results by using a keyword for fuzzy search on merchant names or by specifying a wallet ID. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param wallet_id: This parameter has been deprecated.
        :type wallet_id: str
        :param wallet_setup: The type of wallet setup for the merchant. Each wallet contains multiple cryptocurrency addresses that serve as the merchants receiving addresses.  - `Shared`: Multiple merchants share the same wallet. The wallets addresses may be used to receive payments for multiple merchants simultaneously. - `Separate`: Create a dedicated wallet for the merchant to achieve complete fund isolation. All addresses in this wallet are only used to receive payments for this merchant. - `Default`: The default wallet automatically created by the system for the default merchant (the merchant that shares the same name as your organization). 
        :type wallet_setup: WalletSetup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_merchants_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            wallet_id=wallet_id,
            wallet_setup=wallet_setup,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListMerchants200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_merchants_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        wallet_id: Annotated[Optional[StrictStr], Field(description="This parameter has been deprecated.")] = None,
        wallet_setup: Annotated[Optional[WalletSetup], Field(description="The type of wallet setup for the merchant. Each wallet contains multiple cryptocurrency addresses that serve as the merchants receiving addresses.  - `Shared`: Multiple merchants share the same wallet. The wallets addresses may be used to receive payments for multiple merchants simultaneously. - `Separate`: Create a dedicated wallet for the merchant to achieve complete fund isolation. All addresses in this wallet are only used to receive payments for this merchant. - `Default`: The default wallet automatically created by the system for the default merchant (the merchant that shares the same name as your organization). ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListMerchants200Response]:
        """List all merchants

        This operation retrieves the information of all merchants.   You can filter the results by using a keyword for fuzzy search on merchant names or by specifying a wallet ID. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param wallet_id: This parameter has been deprecated.
        :type wallet_id: str
        :param wallet_setup: The type of wallet setup for the merchant. Each wallet contains multiple cryptocurrency addresses that serve as the merchants receiving addresses.  - `Shared`: Multiple merchants share the same wallet. The wallets addresses may be used to receive payments for multiple merchants simultaneously. - `Separate`: Create a dedicated wallet for the merchant to achieve complete fund isolation. All addresses in this wallet are only used to receive payments for this merchant. - `Default`: The default wallet automatically created by the system for the default merchant (the merchant that shares the same name as your organization). 
        :type wallet_setup: WalletSetup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_merchants_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            wallet_id=wallet_id,
            wallet_setup=wallet_setup,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListMerchants200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_merchants_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="A search term for performing fuzzy matches in the search query.")] = None,
        wallet_id: Annotated[Optional[StrictStr], Field(description="This parameter has been deprecated.")] = None,
        wallet_setup: Annotated[Optional[WalletSetup], Field(description="The type of wallet setup for the merchant. Each wallet contains multiple cryptocurrency addresses that serve as the merchants receiving addresses.  - `Shared`: Multiple merchants share the same wallet. The wallets addresses may be used to receive payments for multiple merchants simultaneously. - `Separate`: Create a dedicated wallet for the merchant to achieve complete fund isolation. All addresses in this wallet are only used to receive payments for this merchant. - `Default`: The default wallet automatically created by the system for the default merchant (the merchant that shares the same name as your organization). ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all merchants

        This operation retrieves the information of all merchants.   You can filter the results by using a keyword for fuzzy search on merchant names or by specifying a wallet ID. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param keyword: A search term for performing fuzzy matches in the search query.
        :type keyword: str
        :param wallet_id: This parameter has been deprecated.
        :type wallet_id: str
        :param wallet_setup: The type of wallet setup for the merchant. Each wallet contains multiple cryptocurrency addresses that serve as the merchants receiving addresses.  - `Shared`: Multiple merchants share the same wallet. The wallets addresses may be used to receive payments for multiple merchants simultaneously. - `Separate`: Create a dedicated wallet for the merchant to achieve complete fund isolation. All addresses in this wallet are only used to receive payments for this merchant. - `Default`: The default wallet automatically created by the system for the default merchant (the merchant that shares the same name as your organization). 
        :type wallet_setup: WalletSetup
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_merchants_serialize(
            limit=limit,
            before=before,
            after=after,
            keyword=keyword,
            wallet_id=wallet_id,
            wallet_setup=wallet_setup,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListMerchants200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_merchants_serialize(
        self,
        limit,
        before,
        after,
        keyword,
        wallet_id,
        wallet_setup,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if wallet_id is not None:
            
            _query_params.append(('wallet_id', wallet_id))
            
        if wallet_setup is not None:
            
            _query_params.append(('wallet_setup', wallet_setup.value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/merchants',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_payment_orders(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        psp_order_id: Annotated[Optional[StrictStr], Field(description="A unique reference code assigned by the developer to identify this order in their system.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListPaymentOrders200Response:
        """List all pay-in orders

        This operation retrieves the information of all pay-in orders. You can filter the result by merchant ID. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param psp_order_id: A unique reference code assigned by the developer to identify this order in their system.
        :type psp_order_id: str
        :param statuses: A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) 
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payment_orders_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            psp_order_id=psp_order_id,
            statuses=statuses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPaymentOrders200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_payment_orders_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        psp_order_id: Annotated[Optional[StrictStr], Field(description="A unique reference code assigned by the developer to identify this order in their system.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListPaymentOrders200Response]:
        """List all pay-in orders

        This operation retrieves the information of all pay-in orders. You can filter the result by merchant ID. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param psp_order_id: A unique reference code assigned by the developer to identify this order in their system.
        :type psp_order_id: str
        :param statuses: A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) 
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payment_orders_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            psp_order_id=psp_order_id,
            statuses=statuses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPaymentOrders200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_payment_orders_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        psp_order_id: Annotated[Optional[StrictStr], Field(description="A unique reference code assigned by the developer to identify this order in their system.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all pay-in orders

        This operation retrieves the information of all pay-in orders. You can filter the result by merchant ID. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param psp_order_id: A unique reference code assigned by the developer to identify this order in their system.
        :type psp_order_id: str
        :param statuses: A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) 
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payment_orders_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            psp_order_id=psp_order_id,
            statuses=statuses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPaymentOrders200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_payment_orders_serialize(
        self,
        limit,
        before,
        after,
        merchant_id,
        psp_order_id,
        statuses,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if merchant_id is not None:
            
            _query_params.append(('merchant_id', merchant_id))
            
        if psp_order_id is not None:
            
            _query_params.append(('psp_order_id', psp_order_id))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/orders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_payment_supported_tokens(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> List[SupportedToken]:
        """List all supported tokens

        This operation retrieves the information of all supported tokens. 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payment_supported_tokens_serialize(
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SupportedToken]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_payment_supported_tokens_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[List[SupportedToken]]:
        """List all supported tokens

        This operation retrieves the information of all supported tokens. 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payment_supported_tokens_serialize(
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SupportedToken]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_payment_supported_tokens_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all supported tokens

        This operation retrieves the information of all supported tokens. 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payment_supported_tokens_serialize(
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SupportedToken]",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_payment_supported_tokens_serialize(
        self,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/supported_tokens',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_payment_wallet_balances(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        wallet_ids: Annotated[Optional[StrictStr], Field(description="A list of wallet IDs to query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListPaymentWalletBalances200Response:
        """List payment wallet balances

        <Warning>This operation has been deprecated.</Warning> This operation retrieves the balance information for specified payment wallets. The balance information is grouped by token. If you do not specify the `wallet_ids` parameter, the balance information for all payment wallets will be returned. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param wallet_ids: A list of wallet IDs to query.
        :type wallet_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payment_wallet_balances_serialize(
            token_id=token_id,
            wallet_ids=wallet_ids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPaymentWalletBalances200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_payment_wallet_balances_with_http_info(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        wallet_ids: Annotated[Optional[StrictStr], Field(description="A list of wallet IDs to query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListPaymentWalletBalances200Response]:
        """List payment wallet balances

        <Warning>This operation has been deprecated.</Warning> This operation retrieves the balance information for specified payment wallets. The balance information is grouped by token. If you do not specify the `wallet_ids` parameter, the balance information for all payment wallets will be returned. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param wallet_ids: A list of wallet IDs to query.
        :type wallet_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payment_wallet_balances_serialize(
            token_id=token_id,
            wallet_ids=wallet_ids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPaymentWalletBalances200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_payment_wallet_balances_without_preload_content(
        self,
        token_id: Annotated[StrictStr, Field(description="The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")],
        wallet_ids: Annotated[Optional[StrictStr], Field(description="A list of wallet IDs to query.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List payment wallet balances

        <Warning>This operation has been deprecated.</Warning> This operation retrieves the balance information for specified payment wallets. The balance information is grouped by token. If you do not specify the `wallet_ids` parameter, the balance information for all payment wallets will be returned. 

        :param token_id: The token ID, which is a unique identifier that specifies both the blockchain network and cryptocurrency token in the format `{CHAIN}_{TOKEN}`. Supported values include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT`  (required)
        :type token_id: str
        :param wallet_ids: A list of wallet IDs to query.
        :type wallet_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payment_wallet_balances_serialize(
            token_id=token_id,
            wallet_ids=wallet_ids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPaymentWalletBalances200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_payment_wallet_balances_serialize(
        self,
        token_id,
        wallet_ids,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if wallet_ids is not None:
            
            _query_params.append(('wallet_ids', wallet_ids))
            
        if token_id is not None:
            
            _query_params.append(('token_id', token_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/balance/payment_wallets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_payouts(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListPayouts200Response:
        """List all payouts

        This operation retrieves the information of all payouts. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payouts_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPayouts200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_payouts_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListPayouts200Response]:
        """List all payouts

        This operation retrieves the information of all payouts. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payouts_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPayouts200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_payouts_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all payouts

        This operation retrieves the information of all payouts. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_payouts_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListPayouts200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_payouts_serialize(
        self,
        limit,
        before,
        after,
        request_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if request_id is not None:
            
            _query_params.append(('request_id', request_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/payouts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_settlement_details(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListSettlementDetails200Response:
        """List all settlement details

        <Note>This operation has been deprecated.</Note>  This operation retrieves the information of all settlement details. You can filter the result by merchant ID or status. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param statuses: A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) 
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_settlement_details_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            statuses=statuses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSettlementDetails200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_settlement_details_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListSettlementDetails200Response]:
        """List all settlement details

        <Note>This operation has been deprecated.</Note>  This operation retrieves the information of all settlement details. You can filter the result by merchant ID or status. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param statuses: A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) 
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_settlement_details_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            statuses=statuses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSettlementDetails200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_settlement_details_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all settlement details

        <Note>This operation has been deprecated.</Note>  This operation retrieves the information of all settlement details. You can filter the result by merchant ID or status. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param statuses: A list of order, refund or payout item statuses. You can refer to the following operations for the possible status values:  - [Get pay-in order information](https://www.cobo.com/payments/en/api-references/payment/get-pay-in-order-information)  - [Get refund order information](https://www.cobo.com/payments/en/api-references/payment/get-refund-order-information)  - [List all payout items](https://www.cobo.com/payments/en/api-references/payment/list-all-payout-items) 
        :type statuses: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_settlement_details_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            statuses=statuses,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSettlementDetails200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_settlement_details_serialize(
        self,
        limit,
        before,
        after,
        merchant_id,
        statuses,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if merchant_id is not None:
            
            _query_params.append(('merchant_id', merchant_id))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/settlement_details',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_settlement_requests(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListSettlementRequests200Response:
        """List all settlement requests

        <Note>This operation has been deprecated. Please use [List all payouts](https://www.cobo.com/payments/en/api-references/payment/list-all-payouts) instead.</Note>  This operation retrieves the information of all settlement requests. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_settlement_requests_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSettlementRequests200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_settlement_requests_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListSettlementRequests200Response]:
        """List all settlement requests

        <Note>This operation has been deprecated. Please use [List all payouts](https://www.cobo.com/payments/en/api-references/payment/list-all-payouts) instead.</Note>  This operation retrieves the information of all settlement requests. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_settlement_requests_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSettlementRequests200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_settlement_requests_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        request_id: Annotated[Optional[StrictStr], Field(description="The request ID.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List all settlement requests

        <Note>This operation has been deprecated. Please use [List all payouts](https://www.cobo.com/payments/en/api-references/payment/list-all-payouts) instead.</Note>  This operation retrieves the information of all settlement requests. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param request_id: The request ID.
        :type request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_settlement_requests_serialize(
            limit=limit,
            before=before,
            after=after,
            request_id=request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListSettlementRequests200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_settlement_requests_serialize(
        self,
        limit,
        before,
        after,
        request_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if request_id is not None:
            
            _query_params.append(('request_id', request_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/settlement_requests',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_top_up_payer_accounts(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        payer_id: Annotated[Optional[StrictStr], Field(description="A unique identifier assigned by Cobo to track and identify individual payers.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListTopUpPayerAccounts200Response:
        """List top-up payer accounts

        This operation retrieves the accounts of all payers. You can filter the result by merchant ID and payer_id. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param payer_id: A unique identifier assigned by Cobo to track and identify individual payers.
        :type payer_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_top_up_payer_accounts_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            payer_id=payer_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTopUpPayerAccounts200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_top_up_payer_accounts_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        payer_id: Annotated[Optional[StrictStr], Field(description="A unique identifier assigned by Cobo to track and identify individual payers.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListTopUpPayerAccounts200Response]:
        """List top-up payer accounts

        This operation retrieves the accounts of all payers. You can filter the result by merchant ID and payer_id. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param payer_id: A unique identifier assigned by Cobo to track and identify individual payers.
        :type payer_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_top_up_payer_accounts_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            payer_id=payer_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTopUpPayerAccounts200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_top_up_payer_accounts_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        payer_id: Annotated[Optional[StrictStr], Field(description="A unique identifier assigned by Cobo to track and identify individual payers.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List top-up payer accounts

        This operation retrieves the accounts of all payers. You can filter the result by merchant ID and payer_id. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param payer_id: A unique identifier assigned by Cobo to track and identify individual payers.
        :type payer_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_top_up_payer_accounts_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            payer_id=payer_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTopUpPayerAccounts200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_top_up_payer_accounts_serialize(
        self,
        limit,
        before,
        after,
        merchant_id,
        payer_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if merchant_id is not None:
            
            _query_params.append(('merchant_id', merchant_id))
            
        if payer_id is not None:
            
            _query_params.append(('payer_id', payer_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/topup/payer_accounts',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def list_top_up_payers(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        payer_id: Annotated[Optional[StrictStr], Field(description="A unique identifier assigned by Cobo to track and identify individual payers.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ListTopUpPayers200Response:
        """List payers

        This operation retrieves the information of all payers under a merchant.   You can filter the result by the payer ID. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param payer_id: A unique identifier assigned by Cobo to track and identify individual payers.
        :type payer_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_top_up_payers_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            payer_id=payer_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTopUpPayers200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_top_up_payers_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        payer_id: Annotated[Optional[StrictStr], Field(description="A unique identifier assigned by Cobo to track and identify individual payers.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[ListTopUpPayers200Response]:
        """List payers

        This operation retrieves the information of all payers under a merchant.   You can filter the result by the payer ID. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param payer_id: A unique identifier assigned by Cobo to track and identify individual payers.
        :type payer_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_top_up_payers_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            payer_id=payer_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTopUpPayers200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_top_up_payers_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to return. For most operations, the value range is [1, 50].")] = None,
        before: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. ")] = None,
        after: Annotated[Optional[StrictStr], Field(description="A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. ")] = None,
        merchant_id: Annotated[Optional[StrictStr], Field(description="The merchant ID.")] = None,
        payer_id: Annotated[Optional[StrictStr], Field(description="A unique identifier assigned by Cobo to track and identify individual payers.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """List payers

        This operation retrieves the information of all payers under a merchant.   You can filter the result by the payer ID. 

        :param limit: The maximum number of objects to return. For most operations, the value range is [1, 50].
        :type limit: int
        :param before: A cursor indicating the position before the current page. This value is generated by Cobo and returned in the response. If you are paginating forward from the beginning, you do not need to provide it on the first request. When paginating backward (to the previous page), you should pass the before value returned from the last response. 
        :type before: str
        :param after: A cursor indicating the position after the current page. This value is generated by Cobo and returned in the response. You do not need to provide it on the first request. When paginating forward (to the next page), you should pass the after value returned from the last response. 
        :type after: str
        :param merchant_id: The merchant ID.
        :type merchant_id: str
        :param payer_id: A unique identifier assigned by Cobo to track and identify individual payers.
        :type payer_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_top_up_payers_serialize(
            limit=limit,
            before=before,
            after=after,
            merchant_id=merchant_id,
            payer_id=payer_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListTopUpPayers200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_top_up_payers_serialize(
        self,
        limit,
        before,
        after,
        merchant_id,
        payer_id,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if before is not None:
            
            _query_params.append(('before', before))
            
        if after is not None:
            
            _query_params.append(('after', after))
            
        if merchant_id is not None:
            
            _query_params.append(('merchant_id', merchant_id))
            
        if payer_id is not None:
            
            _query_params.append(('payer_id', payer_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/topup/payers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def payment_estimate_fee(
        self,
        payment_estimate_fee_request: Annotated[Optional[PaymentEstimateFeeRequest], Field(description="The request body for fee estimation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> PaymentEstimateFee201Response:
        """Estimate fees

        This operation calculates fees for payment-related operations, including: - **Pay-in**: Fees for accepting payments - **Refunds**: Fees for refunding the payment - **Crypto payouts**: Fees for payouts in crypto - **Fiat off-ramp**: Fees for fiat currency transfers via off-ramp.    The returned fees represent the charges that would apply if the operation were executed immediately. Note that actual fees may vary over time based on your usage volume and applicable fee rates. 

        :param payment_estimate_fee_request: The request body for fee estimation.
        :type payment_estimate_fee_request: PaymentEstimateFeeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._payment_estimate_fee_serialize(
            payment_estimate_fee_request=payment_estimate_fee_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "PaymentEstimateFee201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def payment_estimate_fee_with_http_info(
        self,
        payment_estimate_fee_request: Annotated[Optional[PaymentEstimateFeeRequest], Field(description="The request body for fee estimation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[PaymentEstimateFee201Response]:
        """Estimate fees

        This operation calculates fees for payment-related operations, including: - **Pay-in**: Fees for accepting payments - **Refunds**: Fees for refunding the payment - **Crypto payouts**: Fees for payouts in crypto - **Fiat off-ramp**: Fees for fiat currency transfers via off-ramp.    The returned fees represent the charges that would apply if the operation were executed immediately. Note that actual fees may vary over time based on your usage volume and applicable fee rates. 

        :param payment_estimate_fee_request: The request body for fee estimation.
        :type payment_estimate_fee_request: PaymentEstimateFeeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._payment_estimate_fee_serialize(
            payment_estimate_fee_request=payment_estimate_fee_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "PaymentEstimateFee201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def payment_estimate_fee_without_preload_content(
        self,
        payment_estimate_fee_request: Annotated[Optional[PaymentEstimateFeeRequest], Field(description="The request body for fee estimation.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Estimate fees

        This operation calculates fees for payment-related operations, including: - **Pay-in**: Fees for accepting payments - **Refunds**: Fees for refunding the payment - **Crypto payouts**: Fees for payouts in crypto - **Fiat off-ramp**: Fees for fiat currency transfers via off-ramp.    The returned fees represent the charges that would apply if the operation were executed immediately. Note that actual fees may vary over time based on your usage volume and applicable fee rates. 

        :param payment_estimate_fee_request: The request body for fee estimation.
        :type payment_estimate_fee_request: PaymentEstimateFeeRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._payment_estimate_fee_serialize(
            payment_estimate_fee_request=payment_estimate_fee_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "PaymentEstimateFee201Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _payment_estimate_fee_serialize(
        self,
        payment_estimate_fee_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if payment_estimate_fee_request is not None:
            _body_params = payment_estimate_fee_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payments/estimate_fee',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def query_destination_whitelist_enabled(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> QueryDestinationWhitelistEnabled200Response:
        """Query destination whitelist enabled status

        This operation retrieves the information of whether the destination whitelist is enabled. 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_destination_whitelist_enabled_serialize(
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QueryDestinationWhitelistEnabled200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def query_destination_whitelist_enabled_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[QueryDestinationWhitelistEnabled200Response]:
        """Query destination whitelist enabled status

        This operation retrieves the information of whether the destination whitelist is enabled. 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_destination_whitelist_enabled_serialize(
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QueryDestinationWhitelistEnabled200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def query_destination_whitelist_enabled_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Query destination whitelist enabled status

        This operation retrieves the information of whether the destination whitelist is enabled. 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_destination_whitelist_enabled_serialize(
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "QueryDestinationWhitelistEnabled200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _query_destination_whitelist_enabled_serialize(
        self,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payments/destination/enable_whitelist',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_bank_account_by_id(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        update_bank_account_by_id_request: Annotated[Optional[UpdateBankAccountByIdRequest], Field(description="The request body for updating an existing bank account.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> BankAccount:
        """Update bank account

        This operation updates the information of an existing bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param update_bank_account_by_id_request: The request body for updating an existing bank account.
        :type update_bank_account_by_id_request: UpdateBankAccountByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_bank_account_by_id_serialize(
            bank_account_id=bank_account_id,
            update_bank_account_by_id_request=update_bank_account_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BankAccount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_bank_account_by_id_with_http_info(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        update_bank_account_by_id_request: Annotated[Optional[UpdateBankAccountByIdRequest], Field(description="The request body for updating an existing bank account.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[BankAccount]:
        """Update bank account

        This operation updates the information of an existing bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param update_bank_account_by_id_request: The request body for updating an existing bank account.
        :type update_bank_account_by_id_request: UpdateBankAccountByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_bank_account_by_id_serialize(
            bank_account_id=bank_account_id,
            update_bank_account_by_id_request=update_bank_account_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BankAccount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_bank_account_by_id_without_preload_content(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        update_bank_account_by_id_request: Annotated[Optional[UpdateBankAccountByIdRequest], Field(description="The request body for updating an existing bank account.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update bank account

        This operation updates the information of an existing bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param update_bank_account_by_id_request: The request body for updating an existing bank account.
        :type update_bank_account_by_id_request: UpdateBankAccountByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_bank_account_by_id_serialize(
            bank_account_id=bank_account_id,
            update_bank_account_by_id_request=update_bank_account_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BankAccount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_bank_account_by_id_serialize(
        self,
        bank_account_id,
        update_bank_account_by_id_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bank_account_id is not None:
            _path_params['bank_account_id'] = bank_account_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_bank_account_by_id_request is not None:
            _body_params = update_bank_account_by_id_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/bank_accounts/{bank_account_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_counterparty(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        update_counterparty_request: Annotated[Optional[UpdateCounterpartyRequest], Field(description="The request body to update a counterparty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Counterparty:
        """Update counterparty

        This operation updates the information of a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param update_counterparty_request: The request body to update a counterparty.
        :type update_counterparty_request: UpdateCounterpartyRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_counterparty_serialize(
            counterparty_id=counterparty_id,
            update_counterparty_request=update_counterparty_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Counterparty",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_counterparty_with_http_info(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        update_counterparty_request: Annotated[Optional[UpdateCounterpartyRequest], Field(description="The request body to update a counterparty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Counterparty]:
        """Update counterparty

        This operation updates the information of a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param update_counterparty_request: The request body to update a counterparty.
        :type update_counterparty_request: UpdateCounterpartyRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_counterparty_serialize(
            counterparty_id=counterparty_id,
            update_counterparty_request=update_counterparty_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Counterparty",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_counterparty_without_preload_content(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        update_counterparty_request: Annotated[Optional[UpdateCounterpartyRequest], Field(description="The request body to update a counterparty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update counterparty

        This operation updates the information of a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param update_counterparty_request: The request body to update a counterparty.
        :type update_counterparty_request: UpdateCounterpartyRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_counterparty_serialize(
            counterparty_id=counterparty_id,
            update_counterparty_request=update_counterparty_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Counterparty",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_counterparty_serialize(
        self,
        counterparty_id,
        update_counterparty_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if counterparty_id is not None:
            _path_params['counterparty_id'] = counterparty_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_counterparty_request is not None:
            _body_params = update_counterparty_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/counterparty/{counterparty_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_counterparty_by_id(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        update_counterparty_by_id_request: Annotated[Optional[UpdateCounterpartyByIdRequest], Field(description="The request body to update a counterparty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Counterparty:
        """Update counterparty (Deprecated)

        This operation updates the information of a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param update_counterparty_by_id_request: The request body to update a counterparty.
        :type update_counterparty_by_id_request: UpdateCounterpartyByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_counterparty_by_id_serialize(
            counterparty_id=counterparty_id,
            update_counterparty_by_id_request=update_counterparty_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Counterparty",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_counterparty_by_id_with_http_info(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        update_counterparty_by_id_request: Annotated[Optional[UpdateCounterpartyByIdRequest], Field(description="The request body to update a counterparty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Counterparty]:
        """Update counterparty (Deprecated)

        This operation updates the information of a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param update_counterparty_by_id_request: The request body to update a counterparty.
        :type update_counterparty_by_id_request: UpdateCounterpartyByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_counterparty_by_id_serialize(
            counterparty_id=counterparty_id,
            update_counterparty_by_id_request=update_counterparty_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Counterparty",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_counterparty_by_id_without_preload_content(
        self,
        counterparty_id: Annotated[StrictStr, Field(description="The counterparty ID.")],
        update_counterparty_by_id_request: Annotated[Optional[UpdateCounterpartyByIdRequest], Field(description="The request body to update a counterparty.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update counterparty (Deprecated)

        This operation updates the information of a specified counterparty. 

        :param counterparty_id: The counterparty ID. (required)
        :type counterparty_id: str
        :param update_counterparty_by_id_request: The request body to update a counterparty.
        :type update_counterparty_by_id_request: UpdateCounterpartyByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_counterparty_by_id_serialize(
            counterparty_id=counterparty_id,
            update_counterparty_by_id_request=update_counterparty_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Counterparty",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_counterparty_by_id_serialize(
        self,
        counterparty_id,
        update_counterparty_by_id_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if counterparty_id is not None:
            _path_params['counterparty_id'] = counterparty_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_counterparty_by_id_request is not None:
            _body_params = update_counterparty_by_id_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/counterparty/{counterparty_id}/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_destination(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        update_destination_request: Annotated[Optional[UpdateDestinationRequest], Field(description="The request body to update a destination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Destination:
        """Update destination

        This operation updates the information of a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param update_destination_request: The request body to update a destination.
        :type update_destination_request: UpdateDestinationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_serialize(
            destination_id=destination_id,
            update_destination_request=update_destination_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Destination",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_destination_with_http_info(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        update_destination_request: Annotated[Optional[UpdateDestinationRequest], Field(description="The request body to update a destination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Destination]:
        """Update destination

        This operation updates the information of a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param update_destination_request: The request body to update a destination.
        :type update_destination_request: UpdateDestinationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_serialize(
            destination_id=destination_id,
            update_destination_request=update_destination_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Destination",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_destination_without_preload_content(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        update_destination_request: Annotated[Optional[UpdateDestinationRequest], Field(description="The request body to update a destination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update destination

        This operation updates the information of a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param update_destination_request: The request body to update a destination.
        :type update_destination_request: UpdateDestinationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_serialize(
            destination_id=destination_id,
            update_destination_request=update_destination_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Destination",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_destination_serialize(
        self,
        destination_id,
        update_destination_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if destination_id is not None:
            _path_params['destination_id'] = destination_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_destination_request is not None:
            _body_params = update_destination_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/destination/{destination_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_destination_bank_account_by_id(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        update_destination_bank_account: Annotated[Optional[UpdateDestinationBankAccount], Field(description="The request body to update a destination bank account.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> DestinationBankAccount:
        """Update destination bank account

        This operation updates the information of a specified destination bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param update_destination_bank_account: The request body to update a destination bank account.
        :type update_destination_bank_account: UpdateDestinationBankAccount
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_bank_account_by_id_serialize(
            bank_account_id=bank_account_id,
            update_destination_bank_account=update_destination_bank_account,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationBankAccount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_destination_bank_account_by_id_with_http_info(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        update_destination_bank_account: Annotated[Optional[UpdateDestinationBankAccount], Field(description="The request body to update a destination bank account.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[DestinationBankAccount]:
        """Update destination bank account

        This operation updates the information of a specified destination bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param update_destination_bank_account: The request body to update a destination bank account.
        :type update_destination_bank_account: UpdateDestinationBankAccount
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_bank_account_by_id_serialize(
            bank_account_id=bank_account_id,
            update_destination_bank_account=update_destination_bank_account,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationBankAccount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_destination_bank_account_by_id_without_preload_content(
        self,
        bank_account_id: Annotated[StrictStr, Field(description="The bank account ID.")],
        update_destination_bank_account: Annotated[Optional[UpdateDestinationBankAccount], Field(description="The request body to update a destination bank account.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update destination bank account

        This operation updates the information of a specified destination bank account. 

        :param bank_account_id: The bank account ID. (required)
        :type bank_account_id: str
        :param update_destination_bank_account: The request body to update a destination bank account.
        :type update_destination_bank_account: UpdateDestinationBankAccount
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_bank_account_by_id_serialize(
            bank_account_id=bank_account_id,
            update_destination_bank_account=update_destination_bank_account,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DestinationBankAccount",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_destination_bank_account_by_id_serialize(
        self,
        bank_account_id,
        update_destination_bank_account,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if bank_account_id is not None:
            _path_params['bank_account_id'] = bank_account_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_destination_bank_account is not None:
            _body_params = update_destination_bank_account

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/destination/bank_account/{bank_account_id}/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_destination_by_id(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        update_destination_by_id_request: Annotated[Optional[UpdateDestinationByIdRequest], Field(description="The request body to update a destination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Destination:
        """Update destination (Deprecated)

        This operation updates the information of a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param update_destination_by_id_request: The request body to update a destination.
        :type update_destination_by_id_request: UpdateDestinationByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_by_id_serialize(
            destination_id=destination_id,
            update_destination_by_id_request=update_destination_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Destination",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_destination_by_id_with_http_info(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        update_destination_by_id_request: Annotated[Optional[UpdateDestinationByIdRequest], Field(description="The request body to update a destination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Destination]:
        """Update destination (Deprecated)

        This operation updates the information of a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param update_destination_by_id_request: The request body to update a destination.
        :type update_destination_by_id_request: UpdateDestinationByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_by_id_serialize(
            destination_id=destination_id,
            update_destination_by_id_request=update_destination_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Destination",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_destination_by_id_without_preload_content(
        self,
        destination_id: Annotated[StrictStr, Field(description="The destination ID.")],
        update_destination_by_id_request: Annotated[Optional[UpdateDestinationByIdRequest], Field(description="The request body to update a destination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update destination (Deprecated)

        This operation updates the information of a specified destination. 

        :param destination_id: The destination ID. (required)
        :type destination_id: str
        :param update_destination_by_id_request: The request body to update a destination.
        :type update_destination_by_id_request: UpdateDestinationByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_by_id_serialize(
            destination_id=destination_id,
            update_destination_by_id_request=update_destination_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Destination",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_destination_by_id_serialize(
        self,
        destination_id,
        update_destination_by_id_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if destination_id is not None:
            _path_params['destination_id'] = destination_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_destination_by_id_request is not None:
            _body_params = update_destination_by_id_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/destination/{destination_id}/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_destination_entry(
        self,
        destination_entry_id: Annotated[StrictStr, Field(description="The destination entry ID. For example, the wallet address ID or the bank account ID.")],
        update_destination_entry_request: Annotated[Optional[UpdateDestinationEntryRequest], Field(description="The request body to update a destination entry.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> UpdateDestinationEntry200Response:
        """Update destination entry

        This operation updates the information of a specified destination entry. 

        :param destination_entry_id: The destination entry ID. For example, the wallet address ID or the bank account ID. (required)
        :type destination_entry_id: str
        :param update_destination_entry_request: The request body to update a destination entry.
        :type update_destination_entry_request: UpdateDestinationEntryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_entry_serialize(
            destination_entry_id=destination_entry_id,
            update_destination_entry_request=update_destination_entry_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateDestinationEntry200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_destination_entry_with_http_info(
        self,
        destination_entry_id: Annotated[StrictStr, Field(description="The destination entry ID. For example, the wallet address ID or the bank account ID.")],
        update_destination_entry_request: Annotated[Optional[UpdateDestinationEntryRequest], Field(description="The request body to update a destination entry.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[UpdateDestinationEntry200Response]:
        """Update destination entry

        This operation updates the information of a specified destination entry. 

        :param destination_entry_id: The destination entry ID. For example, the wallet address ID or the bank account ID. (required)
        :type destination_entry_id: str
        :param update_destination_entry_request: The request body to update a destination entry.
        :type update_destination_entry_request: UpdateDestinationEntryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_entry_serialize(
            destination_entry_id=destination_entry_id,
            update_destination_entry_request=update_destination_entry_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateDestinationEntry200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_destination_entry_without_preload_content(
        self,
        destination_entry_id: Annotated[StrictStr, Field(description="The destination entry ID. For example, the wallet address ID or the bank account ID.")],
        update_destination_entry_request: Annotated[Optional[UpdateDestinationEntryRequest], Field(description="The request body to update a destination entry.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update destination entry

        This operation updates the information of a specified destination entry. 

        :param destination_entry_id: The destination entry ID. For example, the wallet address ID or the bank account ID. (required)
        :type destination_entry_id: str
        :param update_destination_entry_request: The request body to update a destination entry.
        :type update_destination_entry_request: UpdateDestinationEntryRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_destination_entry_serialize(
            destination_entry_id=destination_entry_id,
            update_destination_entry_request=update_destination_entry_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateDestinationEntry200Response",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_destination_entry_serialize(
        self,
        destination_entry_id,
        update_destination_entry_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if destination_entry_id is not None:
            _path_params['destination_entry_id'] = destination_entry_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_destination_entry_request is not None:
            _body_params = update_destination_entry_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/destination_entry/{destination_entry_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_merchant_by_id(
        self,
        merchant_id: Annotated[StrictStr, Field(description="The merchant ID.")],
        update_merchant_by_id_request: Annotated[Optional[UpdateMerchantByIdRequest], Field(description="The request body to update a merchant.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Merchant:
        """Update merchant

        This operation updates the information of an existing merchant. 

        :param merchant_id: The merchant ID. (required)
        :type merchant_id: str
        :param update_merchant_by_id_request: The request body to update a merchant.
        :type update_merchant_by_id_request: UpdateMerchantByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_merchant_by_id_serialize(
            merchant_id=merchant_id,
            update_merchant_by_id_request=update_merchant_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Merchant",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_merchant_by_id_with_http_info(
        self,
        merchant_id: Annotated[StrictStr, Field(description="The merchant ID.")],
        update_merchant_by_id_request: Annotated[Optional[UpdateMerchantByIdRequest], Field(description="The request body to update a merchant.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Merchant]:
        """Update merchant

        This operation updates the information of an existing merchant. 

        :param merchant_id: The merchant ID. (required)
        :type merchant_id: str
        :param update_merchant_by_id_request: The request body to update a merchant.
        :type update_merchant_by_id_request: UpdateMerchantByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_merchant_by_id_serialize(
            merchant_id=merchant_id,
            update_merchant_by_id_request=update_merchant_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Merchant",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_merchant_by_id_without_preload_content(
        self,
        merchant_id: Annotated[StrictStr, Field(description="The merchant ID.")],
        update_merchant_by_id_request: Annotated[Optional[UpdateMerchantByIdRequest], Field(description="The request body to update a merchant.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update merchant

        This operation updates the information of an existing merchant. 

        :param merchant_id: The merchant ID. (required)
        :type merchant_id: str
        :param update_merchant_by_id_request: The request body to update a merchant.
        :type update_merchant_by_id_request: UpdateMerchantByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_merchant_by_id_serialize(
            merchant_id=merchant_id,
            update_merchant_by_id_request=update_merchant_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Merchant",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_merchant_by_id_serialize(
        self,
        merchant_id,
        update_merchant_by_id_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if merchant_id is not None:
            _path_params['merchant_id'] = merchant_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_merchant_by_id_request is not None:
            _body_params = update_merchant_by_id_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/merchants/{merchant_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_payment_order(
        self,
        order_id: Annotated[StrictStr, Field(description="The pay-in order ID.")],
        update_payment_order_request: Annotated[Optional[UpdatePaymentOrderRequest], Field(description="The request body to update a pay-in order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Order:
        """Update pay-in order

        This operation updates a pay-in order. Use this operation to expire a pay-in order that is no longer needed. 

        :param order_id: The pay-in order ID. (required)
        :type order_id: str
        :param update_payment_order_request: The request body to update a pay-in order.
        :type update_payment_order_request: UpdatePaymentOrderRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_payment_order_serialize(
            order_id=order_id,
            update_payment_order_request=update_payment_order_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Order",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_payment_order_with_http_info(
        self,
        order_id: Annotated[StrictStr, Field(description="The pay-in order ID.")],
        update_payment_order_request: Annotated[Optional[UpdatePaymentOrderRequest], Field(description="The request body to update a pay-in order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Order]:
        """Update pay-in order

        This operation updates a pay-in order. Use this operation to expire a pay-in order that is no longer needed. 

        :param order_id: The pay-in order ID. (required)
        :type order_id: str
        :param update_payment_order_request: The request body to update a pay-in order.
        :type update_payment_order_request: UpdatePaymentOrderRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_payment_order_serialize(
            order_id=order_id,
            update_payment_order_request=update_payment_order_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Order",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_payment_order_without_preload_content(
        self,
        order_id: Annotated[StrictStr, Field(description="The pay-in order ID.")],
        update_payment_order_request: Annotated[Optional[UpdatePaymentOrderRequest], Field(description="The request body to update a pay-in order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update pay-in order

        This operation updates a pay-in order. Use this operation to expire a pay-in order that is no longer needed. 

        :param order_id: The pay-in order ID. (required)
        :type order_id: str
        :param update_payment_order_request: The request body to update a pay-in order.
        :type update_payment_order_request: UpdatePaymentOrderRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_payment_order_serialize(
            order_id=order_id,
            update_payment_order_request=update_payment_order_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Order",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_payment_order_serialize(
        self,
        order_id,
        update_payment_order_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if order_id is not None:
            _path_params['order_id'] = order_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_payment_order_request is not None:
            _body_params = update_payment_order_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/orders/{order_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_refund_by_id(
        self,
        refund_id: Annotated[StrictStr, Field(description="The refund order ID.")],
        update_refund_by_id_request: Annotated[Optional[UpdateRefundByIdRequest], Field(description="The request body to update a refund order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> Refund:
        """Update refund order

        This operation updates a specified refund order by modifying its recipient address. You can only update the recipient address for refund orders that have not been processed yet. 

        :param refund_id: The refund order ID. (required)
        :type refund_id: str
        :param update_refund_by_id_request: The request body to update a refund order.
        :type update_refund_by_id_request: UpdateRefundByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_refund_by_id_serialize(
            refund_id=refund_id,
            update_refund_by_id_request=update_refund_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_refund_by_id_with_http_info(
        self,
        refund_id: Annotated[StrictStr, Field(description="The refund order ID.")],
        update_refund_by_id_request: Annotated[Optional[UpdateRefundByIdRequest], Field(description="The request body to update a refund order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[Refund]:
        """Update refund order

        This operation updates a specified refund order by modifying its recipient address. You can only update the recipient address for refund orders that have not been processed yet. 

        :param refund_id: The refund order ID. (required)
        :type refund_id: str
        :param update_refund_by_id_request: The request body to update a refund order.
        :type update_refund_by_id_request: UpdateRefundByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_refund_by_id_serialize(
            refund_id=refund_id,
            update_refund_by_id_request=update_refund_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_refund_by_id_without_preload_content(
        self,
        refund_id: Annotated[StrictStr, Field(description="The refund order ID.")],
        update_refund_by_id_request: Annotated[Optional[UpdateRefundByIdRequest], Field(description="The request body to update a refund order.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update refund order

        This operation updates a specified refund order by modifying its recipient address. You can only update the recipient address for refund orders that have not been processed yet. 

        :param refund_id: The refund order ID. (required)
        :type refund_id: str
        :param update_refund_by_id_request: The request body to update a refund order.
        :type update_refund_by_id_request: UpdateRefundByIdRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_refund_by_id_serialize(
            refund_id=refund_id,
            update_refund_by_id_request=update_refund_by_id_request,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Refund",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_refund_by_id_serialize(
        self,
        refund_id,
        update_refund_by_id_request,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if refund_id is not None:
            _path_params['refund_id'] = refund_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_refund_by_id_request is not None:
            _body_params = update_refund_by_id_request

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/refunds/{refund_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )

    @validate_call
    def update_top_up_address(
        self,
        update_top_up_address: Annotated[Optional[UpdateTopUpAddress], Field(description="The request body to update top-up address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> TopUpAddress:
        """Update top-up address

        This operation updates the dedicated top-up address assigned to a specific payer under a merchant on a specified chain.  <Note>   You can update the top-up address for a given payer a maximum of 10 times. If you exceed this limit, the API request will return an error. </Note> 

        :param update_top_up_address: The request body to update top-up address.
        :type update_top_up_address: UpdateTopUpAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_top_up_address_serialize(
            update_top_up_address=update_top_up_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TopUpAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_top_up_address_with_http_info(
        self,
        update_top_up_address: Annotated[Optional[UpdateTopUpAddress], Field(description="The request body to update top-up address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> ApiResponse[TopUpAddress]:
        """Update top-up address

        This operation updates the dedicated top-up address assigned to a specific payer under a merchant on a specified chain.  <Note>   You can update the top-up address for a given payer a maximum of 10 times. If you exceed this limit, the API request will return an error. </Note> 

        :param update_top_up_address: The request body to update top-up address.
        :type update_top_up_address: UpdateTopUpAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_top_up_address_serialize(
            update_top_up_address=update_top_up_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TopUpAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_top_up_address_without_preload_content(
        self,
        update_top_up_address: Annotated[Optional[UpdateTopUpAddress], Field(description="The request body to update top-up address.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> RESTResponseType:
        """Update top-up address

        This operation updates the dedicated top-up address assigned to a specific payer under a merchant on a specified chain.  <Note>   You can update the top-up address for a given payer a maximum of 10 times. If you exceed this limit, the API request will return an error. </Note> 

        :param update_top_up_address: The request body to update top-up address.
        :type update_top_up_address: UpdateTopUpAddress
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_top_up_address_serialize(
            update_top_up_address=update_top_up_address,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TopUpAddress",
            '4XX': "ErrorResponse",
            '5XX': "ErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_top_up_address_serialize(
        self,
        update_top_up_address,
    ) -> RequestSerialized:
        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if update_top_up_address is not None:
            _body_params = update_top_up_address

        # set the HTTP header `Accept`
        _header_params = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/payments/topup/address',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
        )
