import numpy as np
from ._ir import IRArbWaveform, IRBase, IREnvelope, IRFrame
from _typeshed import Incomplete
from typing import Iterable, TypeVar

__all__ = ['Frame', 'Envelope', 'Int', 'Var', 'set_judge', 'Reg', 'ArbWave', 'receive', 'send', 'init_arbwave', 'play_arb', 'wait_for_trigger', 'ins_envelope', 'init_frame', 'evlp_gaussian', 'evlp_square', 'evlp_cospulse', 'inc_phase', 'inc_frequency', 'reset_frame', 'play_wave', 'wait', 'capture']

Frame = TypeVar('Frame', bound=IRFrame)
Reg = TypeVar('Reg')
Envelope = TypeVar('Envelope', bound=IREnvelope)
ArbWave = TypeVar('ArbWave', bound=IRArbWaveform)
Placeholder = TypeVar('Placeholder', bound=IRBase)
Var = TypeVar('Var')
Int = TypeVar('Int')
Uint = TypeVar('Uint')
Float = TypeVar('Float')

def init_frame(freq: float, phase: float, *, idx: int = None) -> IRFrame: ...
def ins_envelope(envelope: np.ndarray | complex) -> IREnvelope: ...
def init_arbwave(wlist: dict[str, np.ndarray], arb_name: str) -> IRArbWaveform: ...
def evlp_gaussian(width: float, srate: float = 8000000000.0, amp: int = 1) -> IREnvelope: ...
def evlp_cospulse(width: float, srate: float = 8000000000.0, amp: int = 1) -> IREnvelope: ...
def evlp_square(width: float, srate: float = 8000000000.0, amp: int = 1) -> IREnvelope: ...
def reset_frame() -> Placeholder: ...
def wait_for_trigger() -> Placeholder: ...
def inc_phase(phase: float) -> Placeholder: ...
def inc_frequency(frame_list: Iterable[Frame], freq: float) -> Placeholder: ...
def play_wave(envelope: IREnvelope, amp: int = 1, freq: int = 0, phase: int = 0) -> Placeholder: ...
def play_arb(wave: IRArbWaveform): ...
def wait(width) -> Placeholder: ...
def capture(acq_width: float, delay_width: float, play_width: float, freq_list: Incomplete | None = None) -> Int: ...
def set_judge(rotation: complex, threshold: int, freq_list: list = None) -> tuple[IRBase, IRBase]: ...
def send(judge_reg) -> IRBase: ...
def receive(feedback_rd_chnl: int = 0) -> IRBase: ...
