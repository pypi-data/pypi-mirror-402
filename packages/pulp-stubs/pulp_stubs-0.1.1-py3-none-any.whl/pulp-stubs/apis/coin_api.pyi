"""
This type stub file was generated by pyright.
"""

import os
from typing import TYPE_CHECKING
from .. import LpProblem
from .core import LpSolver, LpSolver_CMD, arch, operating_system

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
cbc_path = ...
if operating_system == "win":
    ...
coinMP_path = ...
if operating_system == "osx":
    arch = ...
pulp_cbc_path = ...
class COIN_CMD(LpSolver_CMD):
    """The COIN CLP/CBC LP solver
    now only uses cbc
    """
    name = ...
    def defaultPath(self):
        ...
    
    def __init__(self, mip=..., msg=..., timeLimit=..., gapRel=..., gapAbs=..., presolve=..., cuts=..., strong=..., options=..., warmStart=..., keepFiles=..., path=..., threads=..., logPath=..., timeMode=..., maxNodes=...) -> None:
        """
        :param bool mip: if False, assume LP even if integer variables
        :param bool msg: if False, no log is shown
        :param float timeLimit: maximum time for solver (in seconds)
        :param float gapRel: relative gap tolerance for the solver to stop (in fraction)
        :param float gapAbs: absolute gap tolerance for the solver to stop
        :param int threads: sets the maximum number of threads
        :param list options: list of additional options to pass to solver
        :param bool warmStart: if True, the solver will use the current value of variables as a start
        :param bool keepFiles: if True, files are saved in the current directory and not deleted after solving
        :param str path: path to the solver binary
        :param str logPath: path to the log file
        :param bool presolve: if True, adds presolve on, if False, adds presolve off
        :param bool cuts: if True, adds gomory on knapsack on probing on, if False adds cuts off
        :param int strong: number of variables to look at in strong branching (range is 0 to 2147483647)
        :param str timeMode: "elapsed": count wall-time to timeLimit; "cpu": count cpu-time
        :param int maxNodes: max number of nodes during branching. Stops the solving when reached.
        """
        ...
    
    def copy(self):
        """Make a copy of self"""
        ...
    
    def actualSolve(self, lp: LpProblem, **kwargs):
        """Solve a well formulated lp problem"""
        ...
    
    def available(self):
        """True if the solver is available"""
        ...
    
    def solve_CBC(self, lp: LpProblem, use_mps=...):
        """Solve a MIP problem using CBC"""
        ...
    
    def getOptions(self):
        ...
    
    def readsol_MPS(self, filename, lp, vs, variablesNames, constraintsNames, objectiveName=...):
        """
        Read a CBC solution file generated from an mps or lp file (possible different names)
        """
        ...
    
    def writesol(self, filename, lp, vs, variablesNames, constraintsNames):
        """
        Writes a CBC solution file generated from an mps / lp file (possible different names)
        returns True on success
        """
        ...
    
    def readsol_LP(self, filename, lp, vs):
        """
        Read a CBC solution file generated from an lp (good names)
        returns status, values, reducedCosts, shadowPrices, slacks, sol_status
        """
        ...
    
    def get_status(self, filename):
        ...
    


COIN = ...
class PULP_CBC_CMD(COIN_CMD):
    """
    This solver uses a precompiled version of cbc provided with the package
    """
    name = ...
    pulp_cbc_path = ...
    if os.name != "nt":
        ...


def COINMP_DLL_load_dll(path: list[str]):
    """
    function that loads the DLL useful for debugging installation problems
    path is a list of paths actually
    """
    ...

class COINMP_DLL(LpSolver):
    """
    The COIN_MP LP MIP solver (via a DLL or linux so)

    :param timeLimit: The number of seconds before forcing the solver to exit
    :param epgap: The fractional mip tolerance
    """
    name = ...
    lib = ...


if COINMP_DLL.available():
    COIN = ...
yaposib = ...
class YAPOSIB(LpSolver):
    """
    COIN OSI (via its python interface)

    Copyright Christophe-Marie Duquesne 2012

    The yaposib variables are available (after a solve) in var.solverVar
    The yaposib constraints are available in constraint.solverConstraint
    The Model is in prob.solverModel
    """
    name = ...


cy = ...
class CYLP(LpSolver):
    name = ...


