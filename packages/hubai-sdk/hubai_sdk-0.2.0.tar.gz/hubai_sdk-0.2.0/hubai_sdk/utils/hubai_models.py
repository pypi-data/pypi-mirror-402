# generated by datamodel-codegen:
#   filename:  hubai_openapi_fixed.json
#   timestamp: 2026-01-13T07:34:33+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union
from uuid import UUID

from pydantic import (
    NaiveDatetime,
    BaseModel,
    ConfigDict,
    Field,
    PositiveInt,
    RootModel,
    confloat,
    conint,
    constr,
)


class BodyDownloadApiV1ModelsDownloadGet(BaseModel):
    tags: Optional[List[str]] = Field(None, title="Tags")
    snpe_version: Optional[List[str]] = Field(None, title="Snpe Version")


class BodyUploadModelInstanceFileApiV1ModelInstancesModelInstanceIdUploadPost(
    BaseModel
):
    files: List[bytes] = Field(..., title="Files")


class DataType(Enum):
    int4 = "int4"
    int8 = "int8"
    int16 = "int16"
    int32 = "int32"
    int64 = "int64"
    uint4 = "uint4"
    uint8 = "uint8"
    uint16 = "uint16"
    uint32 = "uint32"
    uint64 = "uint64"
    float16 = "float16"
    float32 = "float32"
    float64 = "float64"
    boolean = "boolean"
    string = "string"


class EnumChannelEncoding(Enum):
    RGB = "RGB"
    BGR = "BGR"
    GRAY = "GRAY"
    NONE = "NONE"


class EnumDomain(Enum):
    GENERAL = "GENERAL"


class EnumHailoVersion(Enum):
    field_2024_07 = "2024.07"
    field_2024_10 = "2024.10"


class EnumIRVersion(Enum):
    field_2021_4_0 = "2021.4.0"
    field_2022_3_0 = "2022.3.0"


class EnumJobStatusType(Enum):
    QUEUED = "QUEUED"
    RUNNING = "RUNNING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"


class EnumLicenseType(Enum):
    undefined = "undefined"
    MIT = "MIT"
    GNU_General_Public_License_v3_0 = "GNU General Public License v3.0"
    GNU_Affero_General_Public_License_v3_0 = "GNU Affero General Public License v3.0"
    Apache_2_0 = "Apache 2.0"
    NTU_S_Lab_1_0 = "NTU S-Lab 1.0"
    Ultralytics_Enterprise = "Ultralytics Enterprise"
    CreativeML_Open_RAIL_M = "CreativeML Open RAIL-M"
    BSD_3_Clause = "BSD 3-Clause"


class EnumModelClass(Enum):
    BASE = "BASE"
    EXPORTED = "EXPORTED"


class EnumModelInstanceStatus(Enum):
    available = "available"
    unavailable = "unavailable"


class EnumModelPrecisionType(Enum):
    INT8 = "INT8"
    FP16 = "FP16"
    INT8_INT16 = "INT8_INT16"
    FP32 = "FP32"


class EnumModelType(Enum):
    ONNX = "ONNX"
    IR = "IR"
    PYTORCH = "PYTORCH"
    TFLITE = "TFLITE"
    RVC2 = "RVC2"
    RVC3 = "RVC3"
    RVC4 = "RVC4"
    HAILO = "HAILO"
    RVC2_LEGACY = "RVC2_LEGACY"


class EnumPotTargetDevice(Enum):
    VPU = "VPU"
    ANY = "ANY"


class EnumQuantizationDataType(Enum):
    DRIVING = "DRIVING"
    FOOD = "FOOD"
    GENERAL = "GENERAL"
    INDOORS = "INDOORS"
    RANDOM = "RANDOM"
    WAREHOUSE = "WAREHOUSE"
    CLIP = "CLIP"
    UNKNOWN = "UNKNOWN"


class EnumQuantizationMode(Enum):
    INT8_STANDARD = "INT8_STANDARD"
    INT8_ACCURACY_FOCUSED = "INT8_ACCURACY_FOCUSED"
    INT8_INT16_MIXED = "INT8_INT16_MIXED"
    FP16_STANDARD = "FP16_STANDARD"
    FP32_STANDARD = "FP32_STANDARD"


class EnumSortOrder(Enum):
    asc = "asc"
    desc = "desc"


class EnumTaskType(Enum):
    CLASSIFICATION = "CLASSIFICATION"
    OBJECT_DETECTION = "OBJECT_DETECTION"
    SEGMENTATION = "SEGMENTATION"
    KEYPOINT_DETECTION = "KEYPOINT_DETECTION"
    OPTICAL_CHARACTER_RECOGNITION = "OPTICAL_CHARACTER_RECOGNITION"
    DEPTH_ESTIMATION = "DEPTH_ESTIMATION"
    LINE_DETECTION = "LINE_DETECTION"
    FEATURE_DETECTION = "FEATURE_DETECTION"
    DENOISING = "DENOISING"
    LOW_LIGHT_ENHANCEMENT = "LOW_LIGHT_ENHANCEMENT"
    SUPER_RESOLUTION = "SUPER_RESOLUTION"
    REGRESSION = "REGRESSION"
    INSTANCE_SEGMENTATION = "INSTANCE_SEGMENTATION"
    IMAGE_EMBEDDING = "IMAGE_EMBEDDING"
    SPEECH_RECOGNITION = "SPEECH_RECOGNITION"


class EnumYoloVersion(Enum):
    yolov5 = "yolov5"
    yolov6r1 = "yolov6r1"
    yolov6r3 = "yolov6r3"
    yolov6r4 = "yolov6r4"
    yolov7 = "yolov7"
    yolov8 = "yolov8"
    yolov9 = "yolov9"
    yolov10 = "yolov10"
    yolov11 = "yolov11"
    yolov12 = "yolov12"
    goldyolo = "goldyolo"


class GCSUploadPolicyFields(BaseModel):
    key: str = Field(..., title="Key")
    policy: str = Field(..., title="Policy")
    success_action_status: str = Field(..., title="Success Action Status")
    x_goog_algorithm: str = Field(
        ..., alias="x-goog-algorithm", title="X-Goog-Algorithm"
    )
    x_goog_credential: str = Field(
        ..., alias="x-goog-credential", title="X-Goog-Credential"
    )
    x_goog_date: str = Field(..., alias="x-goog-date", title="X-Goog-Date")
    x_goog_signature: str = Field(
        ..., alias="x-goog-signature", title="X-Goog-Signature"
    )


class GCSUploadPolicyResponse(BaseModel):
    url: str = Field(..., title="Url")
    fields: GCSUploadPolicyFields


class GetFromSlugsRequestItem(BaseModel):
    identifier: int = Field(
        ..., description="Identifier of the information.", title="Identifier"
    )
    slug: str = Field(..., description="Slug to get.", title="Slug")


class HeadClassificationMetadata(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    postprocessor_path: Optional[str] = Field(
        None, description="Path to the postprocessor.", title="Postprocessor Path"
    )
    classes: List[str] = Field(
        ...,
        description="Names of object classes recognized by the model.",
        title="Classes",
    )
    n_classes: int = Field(
        ...,
        description="Number of object classes recognized by the model.",
        title="N Classes",
    )
    is_softmax: bool = Field(
        ..., description="True, if output is already softmaxed.", title="Is Softmax"
    )


class HeadMetadata(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    postprocessor_path: Optional[str] = Field(
        None, description="Path to the postprocessor.", title="Postprocessor Path"
    )


class HeadObjectDetectionMetadata(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    postprocessor_path: Optional[str] = Field(
        None, description="Path to the postprocessor.", title="Postprocessor Path"
    )
    classes: List[str] = Field(
        ...,
        description="Names of object classes recognized by the model.",
        title="Classes",
    )
    n_classes: int = Field(
        ...,
        description="Number of object classes recognized by the model.",
        title="N Classes",
    )
    iou_threshold: float = Field(
        ...,
        description="Non-max supression threshold limiting boxes intersection.",
        title="Iou Threshold",
    )
    conf_threshold: float = Field(
        ...,
        description="Confidence score threshold above which a detected object is considered valid.",
        title="Conf Threshold",
    )
    max_det: int = Field(
        ..., description="Maximum detections per image.", title="Max Det"
    )
    anchors: Optional[List[List[List[float]]]] = Field(
        None,
        description="Predefined bounding boxes of different sizes and aspect ratios. The innermost lists are length 2 tuples of box sizes. The middle lists are anchors for each output. The outmost lists go from smallest to largest output.",
        title="Anchors",
    )


class HeadObjectDetectionSSDMetadata(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    postprocessor_path: Optional[str] = Field(
        None, description="Path to the postprocessor.", title="Postprocessor Path"
    )
    classes: List[str] = Field(
        ...,
        description="Names of object classes recognized by the model.",
        title="Classes",
    )
    n_classes: int = Field(
        ...,
        description="Number of object classes recognized by the model.",
        title="N Classes",
    )
    iou_threshold: float = Field(
        ...,
        description="Non-max supression threshold limiting boxes intersection.",
        title="Iou Threshold",
    )
    conf_threshold: float = Field(
        ...,
        description="Confidence score threshold above which a detected object is considered valid.",
        title="Conf Threshold",
    )
    max_det: int = Field(
        ..., description="Maximum detections per image.", title="Max Det"
    )
    anchors: Optional[List[List[List[float]]]] = Field(
        None,
        description="Predefined bounding boxes of different sizes and aspect ratios. The innermost lists are length 2 tuples of box sizes. The middle lists are anchors for each output. The outmost lists go from smallest to largest output.",
        title="Anchors",
    )
    boxes_outputs: str = Field(
        ...,
        description="Output name corresponding to predicted bounding box coordinates.",
        title="Boxes Outputs",
    )
    scores_outputs: str = Field(
        ...,
        description="Output name corresponding to predicted bounding box confidence scores.",
        title="Scores Outputs",
    )


class HeadSegmentationMetadata(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    postprocessor_path: Optional[str] = Field(
        None, description="Path to the postprocessor.", title="Postprocessor Path"
    )
    classes: List[str] = Field(
        ...,
        description="Names of object classes recognized by the model.",
        title="Classes",
    )
    n_classes: int = Field(
        ...,
        description="Number of object classes recognized by the model.",
        title="N Classes",
    )
    is_softmax: bool = Field(
        ..., description="True, if output is already softmaxed.", title="Is Softmax"
    )


class HeadYOLOMetadata(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    postprocessor_path: Optional[str] = Field(
        None, description="Path to the postprocessor.", title="Postprocessor Path"
    )
    classes: List[str] = Field(
        ...,
        description="Names of object classes recognized by the model.",
        title="Classes",
    )
    n_classes: int = Field(
        ...,
        description="Number of object classes recognized by the model.",
        title="N Classes",
    )
    is_softmax: Optional[bool] = Field(
        None,
        description="True, if output is already softmaxed in YOLO instance segmentation.",
        title="Is Softmax",
    )
    iou_threshold: float = Field(
        ...,
        description="Non-max supression threshold limiting boxes intersection.",
        title="Iou Threshold",
    )
    conf_threshold: float = Field(
        ...,
        description="Confidence score threshold above which a detected object is considered valid.",
        title="Conf Threshold",
    )
    max_det: int = Field(
        ..., description="Maximum detections per image.", title="Max Det"
    )
    anchors: Optional[List[List[List[float]]]] = Field(
        None,
        description="Predefined bounding boxes of different sizes and aspect ratios. The innermost lists are length 2 tuples of box sizes. The middle lists are anchors for each output. The outmost lists go from smallest to largest output.",
        title="Anchors",
    )
    yolo_outputs: List[str] = Field(
        ...,
        description="A list of output names for each of the different YOLO grid sizes.",
        title="Yolo Outputs",
    )
    mask_outputs: Optional[List[str]] = Field(
        None,
        description="A list of output names for each mask output.",
        title="Mask Outputs",
    )
    protos_outputs: Optional[str] = Field(
        None, description="Output name for the protos.", title="Protos Outputs"
    )
    keypoints_outputs: Optional[List[str]] = Field(
        None,
        description="A list of output names for the keypoints.",
        title="Keypoints Outputs",
    )
    angles_outputs: Optional[List[str]] = Field(
        None,
        description="A list of output names for the angles.",
        title="Angles Outputs",
    )
    subtype: str = Field(
        ...,
        description="YOLO family decoding subtype (e.g. yolov5, yolov6, yolov7 etc.).",
        title="Subtype",
    )
    n_prototypes: Optional[int] = Field(
        None,
        description="Number of prototypes per bbox in YOLO instance segmnetation.",
        title="N Prototypes",
    )
    n_keypoints: Optional[int] = Field(
        None,
        description="Number of keypoints per bbox in YOLO keypoint detection.",
        title="N Keypoints",
    )


class ShapeItem(RootModel[PositiveInt]):
    root: PositiveInt


class InputParametersOnnxIr(BaseModel):
    input_name: Optional[constr(max_length=255)] = Field(
        None,
        description="The name of the input on the file level (e.g. name of input in the ONNX). Required for multi-input but inferrable otherwise.",
        title="Input Name",
    )
    scale_values: Optional[List[float]] = Field(
        None,
        description="A list of scale values to be used for each channel.",
        title="Scale Values",
    )
    mean_values: Optional[List[float]] = Field(
        None,
        description="A list of mean values to be used for each channel.",
        title="Mean Values",
    )
    encoding_from: Optional[EnumChannelEncoding] = Field(
        "RGB", description="The encoding of the input image."
    )
    encoding_to: Optional[EnumChannelEncoding] = Field(
        "BGR", description="The desired encoding of converted model's input image."
    )
    reverse_input_channels: Optional[bool] = Field(
        False,
        description="DEPRECATED. If true, switched the input channels order from RGB to BGR.",
        title="Reverse Input Channels",
    )
    layout: Optional[str] = Field(
        None,
        description="The layout of the input which the NN accepts.",
        title="Layout",
    )
    shape: Optional[List[ShapeItem]] = Field(
        [], description="The shape of the input which the NN accepts.", title="Shape"
    )


class InputType(Enum):
    raw = "raw"
    image = "image"


class JobEventMessageResponse(BaseModel):
    id: str = Field(..., title="Id")
    queued_at: Optional[NaiveDatetime] = Field(None, title="Queued At")
    started_at: Optional[NaiveDatetime] = Field(None, title="Started At")
    finished_at: Optional[NaiveDatetime] = Field(None, title="Finished At")
    arguments: Dict[str, Any] = Field(..., title="Arguments")
    extra: Dict[str, Any] = Field(..., title="Extra")
    name: str = Field(..., title="Name")
    status: EnumJobStatusType
    correlation_id: Optional[UUID] = Field(None, title="Correlation Id")
    exception: Optional[str] = Field(
        None, description="Exception message if any", title="Exception"
    )
    is_publishable: Optional[bool] = Field(
        False,
        description="Whether message should be published to Hub or not.",
        title="Is Publishable",
    )


class Metadata(BaseModel):
    name: str = Field(..., description="Name of the model.", title="Name")
    path: str = Field(
        ..., description="Relative path to the model executable.", title="Path"
    )
    precision: Optional[DataType] = Field(
        "float32", description="Precision of the model weights."
    )


class ModelDownloadResponse(BaseModel):
    model_id: str = Field(..., description="The ID of the model.", title="Model Id")
    model_version_id: str = Field(
        ..., description="The ID of the model version.", title="Model Version Id"
    )
    model_instance_id: str = Field(
        ..., description="The ID of the model instance.", title="Model Instance Id"
    )
    hash: str = Field(
        ..., description="The MD5 hash of the model instance.", title="Hash"
    )
    download_links: List[str] = Field(
        ...,
        description="List of download links for the model instance.",
        title="Download Links",
    )


class ModelInstanceDetailsRequest(BaseModel):
    model_instance_ids: List[UUID] = Field(
        ...,
        description="List of IDs of the associated Model Instances.",
        title="Model Instance Ids",
    )


class ModelInstanceFileResponse(BaseModel):
    model_instance_id: str = Field(
        ...,
        description="ID of the associated ModelInstance.",
        title="Model Instance Id",
    )
    filepath: str = Field(
        ..., description="Relative path to the file.", title="Filepath"
    )
    id: str = Field(..., description="Unique identifier.", title="Id")
    created: NaiveDatetime = Field(
        ..., description="Creation timestamp.", title="Created"
    )
    updated: NaiveDatetime = Field(
        ..., description="Last update timestamp.", title="Updated"
    )
    file_size_bytes: int = Field(
        ..., description="The size of the file in bytes.", title="File Size Bytes"
    )


class ModelInstancePatchRequest(BaseModel):
    model_version_id: Optional[UUID] = Field(
        None, description="ID of the associated Model.", title="Model Version Id"
    )
    parent_id: Optional[UUID] = Field(
        None,
        description="Unique identifier of the parent ModelInstance.",
        title="Parent Id",
    )
    model_type: Optional[EnumModelType] = Field(
        None, description="Type of the ModelInstance."
    )
    name: Optional[constr(max_length=255)] = Field(
        None, description="Name of the ModelInstance.", title="Name"
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description="Changelog of the ModelInstance.", title="Description"
    )
    tags: Optional[List[str]] = Field(
        None, description="List of tags associated with the Model.", title="Tags"
    )
    dag_run_id: Optional[UUID] = Field(
        None,
        description="ID of the DagRun associated with an exported Model.",
        title="Dag Run Id",
    )
    hardware_parameters: Optional[Dict[str, Any]] = Field(
        None,
        description="Hardware parameters of the Model.",
        title="Hardware Parameters",
    )
    input_shape: Optional[List[List[PositiveInt]]] = Field(
        None, description="The input shape of the ModelInstance.", title="Input Shape"
    )
    quantization_data: Optional[Union[EnumQuantizationDataType, UUID]] = Field(
        None,
        description="The data used to quantize this ModelInstance. It could be a Dataset or a pre-defined domain.",
        title="Quantization Data",
    )
    yolo_version: Optional[EnumYoloVersion] = Field(
        None,
        description="If the model instance is PYTORCH and YOLO, the YOLO version of this instance.",
    )
    quantization_mode: Optional[EnumQuantizationMode] = Field(
        None, description="Type of the precision of the ModelInstance."
    )
    is_deployable: Optional[bool] = Field(
        None,
        description="Configure whether a ModelInstance is deployable or not.",
        title="Is Deployable",
    )


class ModelInstancePayloadParameters(BaseModel):
    model_version_id: UUID = Field(
        ..., description="ID of the associated Model Version.", title="Model Version Id"
    )


class ModelInstanceRequest(BaseModel):
    model_version_id: UUID = Field(
        ..., description="ID of the associated Model Version.", title="Model Version Id"
    )
    parent_id: Optional[UUID] = Field(
        None,
        description="Unique identifier of the parent ModelInstance.",
        title="Parent Id",
    )
    model_type: EnumModelType = Field(..., description="Type of the ModelInstance.")
    name: constr(max_length=255) = Field(
        ..., description="Name of the ModelInstance.", title="Name"
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description="Changelog of the ModelInstance.", title="Description"
    )
    tags: Optional[List[str]] = Field(
        None, description="List of tags associated with the Model.", title="Tags"
    )
    dag_run_id: Optional[UUID] = Field(
        None,
        description="ID of the DagRun associated with an exported Model.",
        title="Dag Run Id",
    )
    hardware_parameters: Optional[Dict[str, Any]] = Field(
        None,
        description="Hardware parameters of the Model.",
        title="Hardware Parameters",
    )
    input_shape: Optional[List[List[PositiveInt]]] = Field(
        None, description="The input shape of the ModelInstance.", title="Input Shape"
    )
    quantization_data: Optional[Union[EnumQuantizationDataType, UUID]] = Field(
        None,
        description="The data used to quantize this ModelInstance. It could be a Dataset or a pre-defined domain.",
        title="Quantization Data",
    )
    yolo_version: Optional[EnumYoloVersion] = Field(
        None,
        description="If the model instance is PYTORCH and YOLO, the YOLO version of this instance.",
    )
    quantization_mode: Optional[EnumQuantizationMode] = Field(
        None, description="Type of the precision of the ModelInstance."
    )
    is_deployable: Optional[bool] = Field(
        None,
        description="Configure whether a ModelInstance is deployable or not.",
        title="Is Deployable",
    )


class ModelInstanceResponse(BaseModel):
    model_version_id: str = Field(
        ..., description="ID of the associated Model Version.", title="Model Version Id"
    )
    parent_id: Optional[str] = Field(
        None,
        description="Unique identifier of the parent ModelInstance.",
        title="Parent Id",
    )
    model_type: EnumModelType = Field(..., description="Type of the ModelInstance.")
    name: constr(max_length=255) = Field(
        ..., description="Name of the ModelInstance.", title="Name"
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description="Changelog of the ModelInstance.", title="Description"
    )
    tags: Optional[List[str]] = Field(
        None, description="List of tags associated with the Model.", title="Tags"
    )
    dag_run_id: Optional[str] = Field(
        None,
        description="ID of the DagRun associated with an exported Model.",
        title="Dag Run Id",
    )
    hardware_parameters: Optional[Dict[str, Any]] = Field(
        None,
        description="Hardware parameters of the Model.",
        title="Hardware Parameters",
    )
    input_shape: Optional[List[List[PositiveInt]]] = Field(
        None, description="The input shape of the ModelInstance.", title="Input Shape"
    )
    quantization_data: Optional[Union[EnumQuantizationDataType, str]] = Field(
        None,
        description="The data used to quantize this ModelInstance. It could be a Dataset or a pre-defined domain.",
        title="Quantization Data",
    )
    yolo_version: Optional[EnumYoloVersion] = Field(
        None,
        description="If the model instance is PYTORCH and YOLO, the YOLO version of this instance.",
    )
    id: str = Field(..., description="Unique identifier.", title="Id")
    created: NaiveDatetime = Field(
        ..., description="Creation timestamp.", title="Created"
    )
    updated: NaiveDatetime = Field(
        ..., description="Last update timestamp.", title="Updated"
    )
    slug: constr(max_length=255) = Field(
        ..., description="Slug for the ModelInstance.", title="Slug"
    )
    is_nn_archive: bool = Field(
        ..., description="If NN archive is used to store files.", title="Is Nn Archive"
    )
    model_class: Optional[EnumModelClass] = Field(
        None,
        description="DEPRECATED: Specifies whether the ModelVersion is a root, base, or exported model.",
    )
    model_id: Optional[str] = Field(
        None, description="ID of the associated Model.", title="Model Id"
    )
    exportable_to: Optional[List[EnumModelType]] = Field(
        [],
        description="The platforms that a ModelInstance can be exported to.",
        title="Exportable To",
    )
    is_public: Optional[bool] = Field(
        False,
        description="Whether a ModelInstance belongs to a public model.",
        title="Is Public",
    )
    model_precision_type: Optional[EnumModelPrecisionType] = Field(
        None, description="Type of the precision of the ModelInstance."
    )
    status: Optional[EnumModelInstanceStatus] = Field(
        "unavailable",
        description="Whether this model is successfully exported or uploaded and available for deployment to device.",
    )
    platforms: Optional[List[EnumModelType]] = Field(
        [], description="List of supported platforms.", title="Platforms"
    )
    hash: Optional[constr(max_length=255)] = Field(
        None, description="The MD5 hash of the ModelInstance.", title="Hash"
    )
    hash_short: Optional[constr(max_length=7)] = Field(
        None, description="The first 7 characters of the MD5 hash.", title="Hash Short"
    )
    model_version_name: Optional[str] = Field(
        None,
        description="Name of the associated Model Version.",
        title="Model Version Name",
    )
    training_run_name: Optional[constr(max_length=255)] = Field(
        None,
        description="Name of the training run that created this ModelInstance.",
        title="Training Run Name",
    )


class ModelInstanceUploadResponse(BaseModel):
    job: JobEventMessageResponse
    policy: GCSUploadPolicyResponse


class ModelLinkBase(BaseModel):
    name: str = Field(
        ..., description="Name of the link, e.g. github or huggingface.", title="Name"
    )
    link: str = Field(..., description="URL value of the link.", title="Link")


class ModelLinkResponse(BaseModel):
    name: str = Field(
        ..., description="Name of the link, e.g. github or huggingface.", title="Name"
    )
    link: str = Field(..., description="URL value of the link.", title="Link")


class ModelPatchRequest(BaseModel):
    name: Optional[constr(max_length=255)] = Field(
        None, description="Name of the Model.", title="Name"
    )
    license_type: Optional[EnumLicenseType] = Field(
        None, description="Type of license."
    )
    is_public: Optional[bool] = Field(
        None, description="Flag indicating if the Model is public.", title="Is Public"
    )
    description_short: Optional[constr(max_length=255)] = Field(
        None, description="Short description of the Model.", title="Description Short"
    )
    description: Optional[constr(max_length=10000)] = Field(
        None, description="Description of the model.", title="Description"
    )
    architecture_id: Optional[UUID] = Field(
        None,
        description="Architecture ID specifying a trainable architecture.",
        title="Architecture Id",
    )
    tasks: Optional[List[EnumTaskType]] = Field(
        [], description="Array of types of tasks.", title="Tasks"
    )
    links: Optional[List[ModelLinkBase]] = Field(
        [], description="Links to official Model pages.", title="Links"
    )
    is_yolo: Optional[bool] = Field(
        None, description="Whether the model is a YOLO model.", title="Is Yolo"
    )
    project_id: Optional[UUID] = Field(
        None, description="ID of the associated Project.", title="Project Id"
    )


class ModelResponse(BaseModel):
    name: constr(max_length=255) = Field(
        ..., description="Name of the Model.", title="Name"
    )
    license_type: EnumLicenseType = Field(..., description="Type of license.")
    is_public: bool = Field(
        ..., description="Flag indicating if the Model is public.", title="Is Public"
    )
    description_short: Optional[constr(max_length=255)] = Field(
        None, description="Short description of the Model.", title="Description Short"
    )
    description: Optional[constr(max_length=10000)] = Field(
        None, description="Description of the model.", title="Description"
    )
    architecture_id: Optional[str] = Field(
        None,
        description="Architecture ID specifying a trainable architecture.",
        title="Architecture Id",
    )
    tasks: Optional[List[EnumTaskType]] = Field(
        [], description="Array of types of tasks.", title="Tasks"
    )
    links: Optional[List[ModelLinkResponse]] = Field(
        [], description="Links to official Model pages.", title="Links"
    )
    is_yolo: Optional[bool] = Field(
        False, description="Whether the model is a YOLO model.", title="Is Yolo"
    )
    id: str = Field(..., description="Unique identifier.", title="Id")
    team_name: Optional[str] = Field(
        None, description="Hub team name.", title="Team Name"
    )
    team_slug: Optional[str] = Field(
        None, description="Hub team slug.", title="Team Slug"
    )
    created: NaiveDatetime = Field(
        ..., description="Creation timestamp.", title="Created"
    )
    updated: NaiveDatetime = Field(
        ..., description="Last update timestamp.", title="Updated"
    )
    slug: str = Field(..., description="Slug for the Model.", title="Slug")
    likes: Optional[int] = Field(0, description="Number of likes.", title="Likes")
    downloads: int = Field(..., description="Number of downloads.", title="Downloads")
    versions: Optional[int] = Field(
        0, description="Number of versions.", title="Versions"
    )
    last_version_added: Any = Field(
        None,
        description="Timestamp of the latest base model.",
        title="Last Version Added",
    )
    platforms: Optional[List[EnumModelType]] = Field(
        [], description="List of supported platforms.", title="Platforms"
    )
    exportable_to: Optional[List[EnumModelType]] = Field(
        [],
        description="The platforms that a ModelVersion can be exported to.",
        title="Exportable To",
    )
    project_id: Optional[str] = Field(
        None, description="Project ID associated with this model.", title="Project Id"
    )
    is_commercial: Optional[bool] = Field(
        None, description="Is the model's license commercial.", title="Is Commercial"
    )
    is_official: Optional[bool] = Field(
        False, description="Is the model created by Luxonis.", title="Is Official"
    )
    is_liked_by_user: Optional[bool] = Field(
        None,
        description="True if the model is liked by the user.",
        title="Is Liked By User",
    )
    model_image_link: Optional[str] = Field(
        None,
        description="The CDN link to upload/download model images.",
        title="Model Image Link",
    )
    exportable_types: Optional[List[EnumModelType]] = Field(
        [],
        description="The types of models that can be exported to a target platform. Previously called base model types.",
        title="Exportable Types",
    )


class ModelVersionDownloadResponse(BaseModel):
    model_instance_name: str = Field(
        ...,
        description="Name of the ModelInstance for the download link.",
        title="Model Instance Name",
    )
    download_link: str = Field(
        ...,
        description="Presigned URL to download a file belonging to this instance.",
        title="Download Link",
    )


class ModelVersionPatchRequest(BaseModel):
    model_id: Optional[UUID] = Field(
        None, description="ID of the associated Model.", title="Model Id"
    )
    name: Optional[constr(max_length=255)] = Field(
        None, description="Name of the ModelVersion.", title="Name"
    )
    version: Optional[constr(max_length=255)] = Field(
        None,
        description="Semantic version of this ModelVersion (for use with model variants). It should be in the format X.Y or X.Y.Z",
        title="Version",
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description="Changelog of the ModelVersion.", title="Description"
    )
    repository_url: Optional[constr(max_length=255)] = Field(
        None, description="URL of the model's repository.", title="Repository Url"
    )
    commit_hash: Optional[constr(max_length=255)] = Field(
        None, description="Commit hash of the model in repository.", title="Commit Hash"
    )
    domain: Optional[EnumDomain] = Field(
        None, description="Domain type.", examples=["GENERAL"]
    )
    training_run_id: Optional[UUID] = Field(
        None,
        description="ID of the training run that created this ModelVersion.",
        title="Training Run Id",
    )
    training_run_name: Optional[constr(max_length=255)] = Field(
        None,
        description="Name of the training run that created this ModelVersion.",
        title="Training Run Name",
    )
    tags: Optional[List[str]] = Field(
        None, description="List of tags associated with the ModelVersion.", title="Tags"
    )


class ModelVersionPayloadParameters(BaseModel):
    model_id: UUID = Field(
        ..., description="ID of the associated Model.", title="Model Id"
    )
    width: int = Field(..., description="Width of the ModelVersion.", title="Width")
    height: int = Field(..., description="Height of the ModelVersion.", title="Height")


class ModelVersionRequest(BaseModel):
    model_id: UUID = Field(
        ..., description="ID of the associated Model.", title="Model Id"
    )
    name: constr(max_length=255) = Field(
        ..., description="Name of the ModelVersion.", title="Name"
    )
    version: constr(max_length=255) = Field(
        ...,
        description="Semantic version of this ModelVersion (for use with model variants). It should be in the format X.Y or X.Y.Z",
        title="Version",
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description="Changelog of the ModelVersion.", title="Description"
    )
    repository_url: Optional[constr(max_length=255)] = Field(
        None, description="URL of the model's repository.", title="Repository Url"
    )
    commit_hash: Optional[constr(max_length=255)] = Field(
        None, description="Commit hash of the model in repository.", title="Commit Hash"
    )
    domain: Optional[EnumDomain] = Field(
        None, description="Domain type.", examples=["GENERAL"]
    )
    training_run_id: Optional[UUID] = Field(
        None,
        description="ID of the training run that created this ModelVersion.",
        title="Training Run Id",
    )
    training_run_name: Optional[constr(max_length=255)] = Field(
        None,
        description="Name of the training run that created this ModelVersion.",
        title="Training Run Name",
    )
    tags: Optional[List[str]] = Field(
        None, description="List of tags associated with the ModelVersion.", title="Tags"
    )


class Output(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str = Field(..., description="Name of the output layer.", title="Name")
    dtype: DataType = Field(
        ..., description="Data type of the output data (e.g., 'float32')."
    )
    shape: Optional[List[int]] = Field(
        None,
        description="Shape of the output as a list of integers (e.g. [1, 1000]).",
        title="Shape",
    )
    layout: Optional[str] = Field(
        None,
        description="List of letters describing the output layout (e.g. 'NC').",
        title="Layout",
    )


class PerformanceRating(BaseModel):
    accuracy_rating: Optional[int] = Field(
        ...,
        description="Accuracy rating of the architecture on a scale of 1-10.",
        title="Accuracy Rating",
    )
    speed_rating: Optional[int] = Field(
        ...,
        description="Speed rating of the architecture on a scale of 1-10.",
        title="Speed Rating",
    )
    fps_rating: Optional[confloat(ge=0.0)] = Field(
        ..., description="FPS rating of the architecture.", title="Fps Rating"
    )


class PerformanceRatings(BaseModel):
    rvc2_ratings: PerformanceRating = Field(
        ..., description="Speed and accuracy rating for RVC2."
    )
    rvc3_ratings: PerformanceRating = Field(
        ..., description="Speed and accuracy rating for RVC3."
    )
    rvc4_ratings: PerformanceRating = Field(
        ..., description="Speed and accuracy rating for RVC4."
    )
    hailo_ratings: PerformanceRating = Field(
        ..., description="Speed and accuracy rating for Hailo."
    )


class PreprocessingBlock(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    mean: Optional[List[float]] = Field(
        None,
        description="Mean values in channel order. Order depends on the order in which the model was trained on.",
        title="Mean",
    )
    scale: Optional[List[float]] = Field(
        None,
        description="Standardization values in channel order. Order depends on the order in which the model was trained on.",
        title="Scale",
    )
    reverse_channels: Optional[bool] = Field(
        None,
        description="If True input to the model is RGB else BGR.",
        title="Reverse Channels",
    )
    interleaved_to_planar: Optional[bool] = Field(
        None,
        description="If True input to the model is interleaved (NHWC) else planar (NCHW).",
        title="Interleaved To Planar",
    )
    dai_type: Optional[str] = Field(
        None,
        description="DepthAI input type which is read by DepthAI to automatically setup the pipeline.",
        title="Dai Type",
    )


class NumberOfShaves(Enum):
    integer_1 = 1
    integer_2 = 2
    integer_3 = 3
    integer_4 = 4
    integer_5 = 5
    integer_6 = 6
    integer_7 = 7
    integer_8 = 8
    integer_9 = 9
    integer_10 = 10
    integer_11 = 11
    integer_12 = 12
    integer_13 = 13
    integer_14 = 14
    integer_15 = 15
    integer_16 = 16


class RVC2ExportParametersOnnxIrPresetResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(max_length=255) = Field(
        ..., description="Name of the exported model.", title="Name"
    )
    quantization_data: Optional[Union[EnumQuantizationDataType, str]] = Field(
        None,
        description="Either the domain name of the predefined quantization data or a UUID specifying a custom dataset.",
        title="Quantization Data",
    )
    disable_onnx_simplification: Optional[bool] = Field(
        False,
        description="If true, disable the onnx simplification.",
        title="Disable Onnx Simplification",
    )
    disable_onnx_optimization: Optional[bool] = Field(
        False,
        description="If true, disable the onnx optimization.",
        title="Disable Onnx Optimization",
    )
    max_quantization_images: Optional[conint(ge=1)] = Field(
        None,
        description="The maximum number of images to use for quantization.",
        title="Max Quantization Images",
    )
    inputs: Optional[List[InputParametersOnnxIr]] = Field(
        [], description="The config defining the inputs of the model.", title="Inputs"
    )
    mo_args: Optional[List[str]] = Field(
        [],
        description="Additional OpenVINO model optimizer args to be used for RVC2.",
        title="Mo Args",
    )
    compile_tool_args: Optional[List[str]] = Field(
        [],
        description="Additional args to pass to compile_tool for RVC2.",
        title="Compile Tool Args",
    )
    number_of_shaves: Optional[NumberOfShaves] = Field(
        None,
        description="Number of shaves to use for legacy RVC2.",
        title="Number Of Shaves",
    )
    ir_version: Optional[EnumIRVersion] = Field(
        "2022.3.0", description="Modelconverter image version to be used for export."
    )


class RVC3ExportParametersOnnxIr(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(max_length=255) = Field(
        ..., description="Name of the exported model.", title="Name"
    )
    quantization_data: Optional[Union[EnumQuantizationDataType, str]] = Field(
        None,
        description="Either the domain name of the predefined quantization data or a UUID specifying a custom dataset.",
        title="Quantization Data",
    )
    disable_onnx_simplification: Optional[bool] = Field(
        False,
        description="If true, disable the onnx simplification.",
        title="Disable Onnx Simplification",
    )
    disable_onnx_optimization: Optional[bool] = Field(
        False,
        description="If true, disable the onnx optimization.",
        title="Disable Onnx Optimization",
    )
    max_quantization_images: Optional[conint(ge=1)] = Field(
        None,
        description="The maximum number of images to use for quantization.",
        title="Max Quantization Images",
    )
    inputs: Optional[List[InputParametersOnnxIr]] = Field(
        [], description="The config defining the inputs of the model.", title="Inputs"
    )
    pot_target_device: Optional[EnumPotTargetDevice] = Field(
        "VPU", description="Target device for POT for RVC3."
    )
    mo_args: Optional[List[str]] = Field(
        [],
        description="Additional OpenVINO model optimizer args to be used for RVC3.",
        title="Mo Args",
    )
    compile_tool_args: Optional[List[str]] = Field(
        [],
        description="Additional args to pass to compile_tool for RVC3.",
        title="Compile Tool Args",
    )
    ir_version: Literal["2022.3.0"] = Field(
        "2022.3.0",
        description="Modelconverter image version to be used for export.",
        title="Ir Version",
    )


class SnpeVersion(Enum):
    field_2_32_6 = "2.32.6"
    field_2_23_0 = "2.23.0"


class RVC4ExportParametersOnnxIr(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(max_length=255) = Field(
        ..., description="Name of the exported model.", title="Name"
    )
    quantization_data: Optional[Union[EnumQuantizationDataType, str]] = Field(
        None,
        description="Either the domain name of the predefined quantization data or a UUID specifying a custom dataset.",
        title="Quantization Data",
    )
    disable_onnx_simplification: Optional[bool] = Field(
        False,
        description="If true, disable the onnx simplification.",
        title="Disable Onnx Simplification",
    )
    disable_onnx_optimization: Optional[bool] = Field(
        False,
        description="If true, disable the onnx optimization.",
        title="Disable Onnx Optimization",
    )
    max_quantization_images: Optional[conint(ge=1)] = Field(
        None,
        description="The maximum number of images to use for quantization.",
        title="Max Quantization Images",
    )
    inputs: Optional[List[InputParametersOnnxIr]] = Field(
        [], description="The config defining the inputs of the model.", title="Inputs"
    )
    target_precision: Optional[EnumQuantizationMode] = Field(
        None, description="Target precision for RVC4."
    )
    snpe_onnx_to_dlc_args: Optional[List[str]] = Field(
        [],
        description="Additional args to pass to SNPE onnx-to-dlc for RVC4.",
        title="Snpe Onnx To Dlc Args",
    )
    snpe_dlc_quant_args: Optional[List[str]] = Field(
        [],
        description="Additional args to pass to snpe-dlc-quant for RVC4.",
        title="Snpe Dlc Quant Args",
    )
    snpe_dlc_graph_prepare_args: Optional[List[str]] = Field(
        [],
        description="Additional args to pass to snpe-dlc-graph-prepare for RVC4.",
        title="Snpe Dlc Graph Prepare Args",
    )
    snpe_version: Optional[SnpeVersion] = Field(
        "2.32.6",
        description="SNPE version to be used for export.",
        title="Snpe Version",
    )


class ValidationError(BaseModel):
    loc: List[Union[str, int]] = Field(..., title="Location")
    msg: str = Field(..., title="Message")
    type: str = Field(..., title="Error Type")


class ArchitecturePatchRequest(BaseModel):
    name: Optional[constr(max_length=255)] = Field(
        None, description="Name of the Architecture.", title="Name"
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description="Description of the architecture.", title="Description"
    )
    license_type: Optional[EnumLicenseType] = Field(
        None, description="Type of license."
    )
    is_public: Optional[bool] = Field(
        None,
        description="Flag indicating if the Architecture is public.",
        title="Is Public",
    )
    tasks: Optional[List[EnumTaskType]] = Field(
        None, description="Array of types of tasks.", title="Tasks"
    )
    training_image: Optional[str] = Field(
        None,
        description="The internal training image used in this architecture.",
        title="Training Image",
    )
    training_model_config: Optional[Dict[str, Any]] = Field(
        None,
        description="The `model` configuration block parsed by the training image.",
        title="Training Model Config",
    )
    training_hyperparameter_config: Optional[Dict[str, Any]] = Field(
        None,
        description="The `training` configuration block parsed by the training image.",
        title="Training Hyperparameter Config",
    )
    performance_ratings: Optional[PerformanceRatings] = Field(
        None,
        description="The speed and accuracy ratings for each HW with this architecture.",
    )


class ArchitectureRequest(BaseModel):
    name: constr(max_length=255) = Field(
        ..., description="Name of the Architecture.", title="Name"
    )
    description: constr(max_length=255) = Field(
        ..., description="Description of the architecture.", title="Description"
    )
    license_type: EnumLicenseType = Field(..., description="Type of license.")
    is_public: bool = Field(
        ...,
        description="Flag indicating if the Architecture is public.",
        title="Is Public",
    )
    tasks: List[EnumTaskType] = Field(
        ..., description="Array of types of tasks.", title="Tasks"
    )
    training_image: str = Field(
        ...,
        description="The internal training image used in this architecture.",
        title="Training Image",
    )
    training_model_config: Dict[str, Any] = Field(
        ...,
        description="The `model` configuration block parsed by the training image.",
        title="Training Model Config",
    )
    training_hyperparameter_config: Dict[str, Any] = Field(
        ...,
        description="The `training` configuration block parsed by the training image.",
        title="Training Hyperparameter Config",
    )
    performance_ratings: PerformanceRatings = Field(
        ...,
        description="The speed and accuracy ratings for each HW with this architecture.",
    )


class ArchitectureResponse(BaseModel):
    name: constr(max_length=255) = Field(
        ..., description="Name of the Architecture.", title="Name"
    )
    description: constr(max_length=255) = Field(
        ..., description="Description of the architecture.", title="Description"
    )
    license_type: EnumLicenseType = Field(..., description="Type of license.")
    is_public: bool = Field(
        ...,
        description="Flag indicating if the Architecture is public.",
        title="Is Public",
    )
    tasks: List[EnumTaskType] = Field(
        ..., description="Array of types of tasks.", title="Tasks"
    )
    training_image: str = Field(
        ...,
        description="The internal training image used in this architecture.",
        title="Training Image",
    )
    training_model_config: Dict[str, Any] = Field(
        ...,
        description="The `model` configuration block parsed by the training image.",
        title="Training Model Config",
    )
    training_hyperparameter_config: Dict[str, Any] = Field(
        ...,
        description="The `training` configuration block parsed by the training image.",
        title="Training Hyperparameter Config",
    )
    performance_ratings: PerformanceRatings = Field(
        ...,
        description="The speed and accuracy ratings for each HW with this architecture.",
    )
    id: str = Field(..., description="Unique identifier.", title="Id")
    created: NaiveDatetime = Field(
        ..., description="Creation timestamp.", title="Created"
    )
    updated: NaiveDatetime = Field(
        ..., description="Last update timestamp.", title="Updated"
    )
    slug: constr(max_length=255) = Field(
        ..., description="Slug for the Architecture.", title="Slug"
    )


class AvailableForModel(BaseModel):
    id: str = Field(..., description="ID of the associated ModelInstance.", title="Id")
    platform: EnumModelType = Field(
        ..., description="The target platform of the ModelInstance."
    )


class BodyReadAllModelInstancesApiV1ModelInstancesGet(BaseModel):
    tags: Optional[List[str]] = Field(None, title="Tags")
    input_shape: Optional[List[str]] = Field(None, title="Input Shape")
    platforms: Optional[List[EnumModelType]] = Field(None, title="Platforms")
    snpe_version: Optional[List[str]] = Field(None, title="Snpe Version")
    multiple_model_version_ids: Optional[List[UUID]] = Field(
        None, title="Multiple Model Version Ids"
    )


class GetFromSlugsRequest(BaseModel):
    team_slugs: Optional[List[str]] = Field(None, title="Team Slugs")
    model_slugs: Optional[List[str]] = Field(None, title="Model Slugs")
    variant_slugs: Optional[List[str]] = Field(None, title="Variant Slugs")
    items: List[GetFromSlugsRequestItem] = Field(
        ..., description="List of slugs to get models from.", title="Items"
    )


class HTTPValidationError(BaseModel):
    detail: Optional[List[ValidationError]] = Field(None, title="Detail")


class HailoExportParametersOnnxIr(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: constr(max_length=255) = Field(
        ..., description="Name of the exported model.", title="Name"
    )
    quantization_data: Optional[Union[EnumQuantizationDataType, str]] = Field(
        "RANDOM",
        description="Either the domain name of the predefined quantization data or a UUID specifying a custom dataset.",
        title="Quantization Data",
    )
    disable_onnx_simplification: Optional[bool] = Field(
        False,
        description="If true, disable the onnx simplification.",
        title="Disable Onnx Simplification",
    )
    disable_onnx_optimization: Optional[bool] = Field(
        False,
        description="If true, disable the onnx optimization.",
        title="Disable Onnx Optimization",
    )
    max_quantization_images: Optional[conint(ge=1)] = Field(
        None,
        description="The maximum number of images to use for quantization.",
        title="Max Quantization Images",
    )
    inputs: Optional[List[InputParametersOnnxIr]] = Field(
        [], description="The config defining the inputs of the model.", title="Inputs"
    )
    optimization_level: Optional[conint(ge=0, le=4)] = Field(
        2, description="Optimization level for Hailo.", title="Optimization Level"
    )
    compression_level: Optional[conint(ge=0, le=5)] = Field(
        2, description="Compression level for Hailo.", title="Compression Level"
    )
    batch_size: Optional[conint(ge=0, le=128)] = Field(
        8, description="Batch size for Hailo.", title="Batch Size"
    )
    disable_calibration: Optional[bool] = Field(
        False, description="Early stop for Hailo.", title="Disable Calibration"
    )
    disable_compilation: Optional[bool] = Field(
        False,
        description="Disable compilation for Hailo to output a .har file instead.",
        title="Disable Compilation",
    )
    alls: Optional[List[str]] = Field(
        None,
        description="Text representation of the Hailo alls file. Each element in the list is a line of the alls file.",
        title="Alls",
    )
    hailo_version: Optional[EnumHailoVersion] = Field(
        "2024.10", description="Hailo version to be used for export."
    )


class Head(BaseModel):
    name: Optional[str] = Field(
        None, description="Optional name of the head.", title="Name"
    )
    parser: str = Field(
        ...,
        description="Name of the parser responsible for processing the models output.",
        title="Parser",
    )
    metadata: Union[
        HeadObjectDetectionMetadata,
        HeadClassificationMetadata,
        HeadObjectDetectionSSDMetadata,
        HeadSegmentationMetadata,
        HeadYOLOMetadata,
        HeadMetadata,
    ] = Field(..., description="Metadata of the parser.", title="Metadata")
    outputs: Optional[List[str]] = Field(
        None,
        description="Specify which outputs are fed into the parser. If None, all outputs are fed.",
        title="Outputs",
    )


class Input(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str = Field(..., description="Name of the input layer.", title="Name")
    dtype: DataType = Field(
        ..., description="Data type of the input data (e.g., 'float32')."
    )
    input_type: InputType = Field(
        ..., description="Type of input data (e.g., 'image')."
    )
    shape: List[int] = Field(
        ...,
        description="Shape of the input data as a list of integers (e.g. [H,W], [H,W,C], [N,H,W,C], ...).",
        min_length=1,
        title="Shape",
    )
    layout: Optional[constr(min_length=1)] = Field(
        "NCHW",
        description="Lettercode interpretation of the input data dimensions (e.g., 'NCHW')",
        title="Layout",
    )
    preprocessing: PreprocessingBlock = Field(
        ..., description="Preprocessing steps applied to the input data."
    )


class ModelInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    metadata: Metadata = Field(
        ..., description="Metadata object defining the model metadata."
    )
    inputs: List[Input] = Field(
        ...,
        description="List of Input objects defining the model inputs.",
        title="Inputs",
    )
    outputs: List[Output] = Field(
        ...,
        description="List of Output objects defining the model outputs.",
        title="Outputs",
    )
    heads: Optional[List[Head]] = Field(
        ...,
        description="List of Head objects defining the model heads. If not defined, we assume a raw output.",
        title="Heads",
    )


class ModelOutput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    metadata: Metadata = Field(
        ..., description="Metadata object defining the model metadata."
    )
    inputs: List[Input] = Field(
        ...,
        description="List of Input objects defining the model inputs.",
        title="Inputs",
    )
    outputs: List[Output] = Field(
        ...,
        description="List of Output objects defining the model outputs.",
        title="Outputs",
    )
    heads: Optional[List[Head]] = Field(
        ...,
        description="List of Head objects defining the model heads. If not defined, we assume a raw output.",
        title="Heads",
    )


class ModelCreateRequest(BaseModel):
    name: constr(max_length=255) = Field(
        ..., description="Name of the Model.", title="Name"
    )
    license_type: EnumLicenseType = Field(..., description="Type of license.")
    is_public: bool = Field(
        ..., description="Flag indicating if the Model is public.", title="Is Public"
    )
    description_short: Optional[constr(max_length=255)] = Field(
        None, description="Short description of the Model.", title="Description Short"
    )
    description: Optional[constr(max_length=10000)] = Field(
        None, description="Description of the model.", title="Description"
    )
    architecture_id: Optional[UUID] = Field(
        None,
        description="Architecture ID specifying a trainable architecture.",
        title="Architecture Id",
    )
    tasks: Optional[List[EnumTaskType]] = Field(
        [], description="Array of types of tasks.", title="Tasks"
    )
    links: Optional[List[ModelLinkBase]] = Field(
        [], description="Links to official Model pages.", title="Links"
    )
    is_yolo: Optional[bool] = Field(
        False, description="Whether the model is a YOLO model.", title="Is Yolo"
    )


class ModelVersionResponse(BaseModel):
    model_id: str = Field(
        ..., description="ID of the associated Model.", title="Model Id"
    )
    name: constr(max_length=255) = Field(
        ..., description="Name of the ModelVersion.", title="Name"
    )
    version: constr(max_length=255) = Field(
        ...,
        description="Semantic version of this ModelVersion (for use with model variants). It should be in the format X.Y or X.Y.Z",
        title="Version",
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description="Changelog of the ModelVersion.", title="Description"
    )
    repository_url: Optional[constr(max_length=255)] = Field(
        None, description="URL of the model's repository.", title="Repository Url"
    )
    commit_hash: Optional[constr(max_length=255)] = Field(
        None, description="Commit hash of the model in repository.", title="Commit Hash"
    )
    domain: Optional[EnumDomain] = Field(
        None, description="Domain type.", examples=["GENERAL"]
    )
    training_run_id: Optional[str] = Field(
        None,
        description="ID of the training run that created this ModelVersion.",
        title="Training Run Id",
    )
    training_run_name: Optional[constr(max_length=255)] = Field(
        None,
        description="Name of the training run that created this ModelVersion.",
        title="Training Run Name",
    )
    tags: Optional[List[str]] = Field(
        None, description="List of tags associated with the ModelVersion.", title="Tags"
    )
    id: str = Field(..., description="Unique identifier.", title="Id")
    created: NaiveDatetime = Field(
        ..., description="Creation timestamp.", title="Created"
    )
    updated: NaiveDatetime = Field(
        ..., description="Last update timestamp.", title="Updated"
    )
    slug: str = Field(..., description="Slug for the ModelVersion.", title="Slug")
    variant_slug: constr(max_length=255) = Field(
        ...,
        description="Slug of the variant of this ModelVersion.",
        title="Variant Slug",
    )
    platforms: Optional[List[EnumModelType]] = Field(
        [], description="List of supported platforms.", title="Platforms"
    )
    number_base_files: Optional[int] = Field(
        0,
        description="Number of base files under the ModelVersion.",
        title="Number Base Files",
    )
    is_public: Optional[bool] = Field(
        False,
        description="Whether a ModelVersion belongs to a public model.",
        title="Is Public",
    )
    exportable_to: Optional[List[EnumModelType]] = Field(
        [],
        description="The platforms that a ModelVersion can be exported to.",
        title="Exportable To",
    )
    available_for: Optional[List[AvailableForModel]] = Field(
        [],
        description="A list of available target platforms along with the best matching model instance ID for download.",
        title="Available For",
    )
    exportable_types: Optional[List[EnumModelType]] = Field(
        [],
        description="The types of models that can be exported to a target platform. Previously called base model types.",
        title="Exportable Types",
    )
    has_base_nn_archive: Optional[bool] = Field(
        False,
        description="Whether the ModelVersion has a base model with a NN archive.",
        title="Has Base Nn Archive",
    )


class ArchiveConfigurationRequest(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    config_version: Optional[str] = Field(
        "1.0",
        description="String representing config schema version in format 'x.y' where x is major version and y is minor version.",
        title="Config Version",
    )
    model: ModelInput = Field(
        ...,
        description="A Model object representing the neural network used in the archive.",
    )


class ArchiveConfigurationResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    config_version: Optional[str] = Field(
        "1.0",
        description="String representing config schema version in format 'x.y' where x is major version and y is minor version.",
        title="Config Version",
    )
    model: ModelOutput = Field(
        ...,
        description="A Model object representing the neural network used in the archive.",
    )


class GetFromSlugsResponseItem(BaseModel):
    identifier: int = Field(
        ..., description="Identifier of the information.", title="Identifier"
    )
    model: ModelResponse = Field(..., description="Model resource.")
    model_version: ModelVersionResponse = Field(
        ..., description="Model version/variant resource."
    )


class ModelInstanceDetailsResponse(BaseModel):
    model_instance: ModelInstanceResponse = Field(
        ..., description="Model Instance details."
    )
    model_version: ModelVersionResponse = Field(
        ..., description="Model Version details."
    )
    model: ModelResponse = Field(..., description="Model details.")


class GetFromSlugsResponse(BaseModel):
    items: List[GetFromSlugsResponseItem] = Field(
        ...,
        description="List of model and variant information corresponding to slugs.",
        title="Items",
    )
