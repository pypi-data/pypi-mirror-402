# coding: utf-8

"""
    Sifflet Backend API

    Requirements: <br>    - [Create your access token through the UI](https://docs.siffletdata.com/docs/generate-an-api-token#create-an-api-token) <br>    - Get your tenant name: if you access to Sifflet with `https://abcdef.siffletdata.com`, then your tenant would be `abcdef`

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from typing import Any, ClassVar, Dict, List, Optional, Set

from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    StrictBool,
    StrictInt,
    StrictStr,
    field_validator,
)
from sifflet_sdk.client.models.asset_data_product_dto import AssetDataProductDto
from sifflet_sdk.client.models.asset_domain_dto import AssetDomainDto
from sifflet_sdk.client.models.asset_usage_dto import AssetUsageDto
from sifflet_sdk.client.models.declared_asset_details_dto_all_of_created_by import (
    DeclaredAssetDetailsDtoAllOfCreatedBy,
)
from sifflet_sdk.client.models.declared_asset_details_dto_all_of_last_modified_by import (
    DeclaredAssetDetailsDtoAllOfLastModifiedBy,
)
from sifflet_sdk.client.models.description_dto import DescriptionDto
from sifflet_sdk.client.models.description_prediction_dto import (
    DescriptionPredictionDto,
)
from sifflet_sdk.client.models.entity_custom_metadata_dto import EntityCustomMetadataDto
from sifflet_sdk.client.models.orchestrator_details_dto import OrchestratorDetailsDto
from sifflet_sdk.client.models.tag_dto import TagDto
from sifflet_sdk.client.models.user_dto import UserDto
from typing_extensions import Self


class DeclaredAssetDetailsDto(BaseModel):
    """
    DeclaredAssetDetailsDto
    """  # noqa: E501

    actionable: StrictBool
    custom_metadata: Optional[List[EntityCustomMetadataDto]] = Field(default=None, alias="customMetadata")
    data_products: List[AssetDataProductDto] = Field(alias="dataProducts")
    datasource_id: StrictStr = Field(alias="datasourceId")
    datasource_name: StrictStr = Field(alias="datasourceName")
    description: Optional[StrictStr] = None
    description_prediction: Optional[DescriptionPredictionDto] = Field(default=None, alias="descriptionPrediction")
    domains: List[AssetDomainDto]
    external_descriptions: Optional[List[DescriptionDto]] = Field(default=None, alias="externalDescriptions")
    external_terms: Optional[List[TagDto]] = Field(default=None, alias="externalTerms")
    has_preview: StrictBool = Field(alias="hasPreview")
    integration_id: Optional[StrictStr] = Field(default=None, alias="integrationId")
    integration_name: Optional[StrictStr] = Field(default=None, alias="integrationName")
    last_refresh: Optional[StrictInt] = Field(default=None, alias="lastRefresh")
    lineage_platform: StrictStr = Field(alias="lineagePlatform")
    next_refresh: Optional[StrictInt] = Field(default=None, alias="nextRefresh")
    orchestrators_details: Optional[List[OrchestratorDetailsDto]] = Field(default=None, alias="orchestratorsDetails")
    owners: Optional[List[UserDto]] = None
    platform: Optional[StrictStr] = None
    source_creation_type: StrictStr = Field(alias="sourceCreationType")
    source_uri: Optional[StrictStr] = Field(default=None, alias="sourceUri")
    tags: Optional[List[TagDto]] = None
    terms: Optional[List[TagDto]] = None
    usage: Optional[AssetUsageDto] = None
    created_by: Optional[DeclaredAssetDetailsDtoAllOfCreatedBy] = Field(default=None, alias="createdBy")
    creation_date: Optional[StrictInt] = Field(default=None, alias="creationDate")
    descriptions: Optional[List[StrictStr]] = None
    last_modified_by: Optional[DeclaredAssetDetailsDtoAllOfLastModifiedBy] = Field(default=None, alias="lastModifiedBy")
    last_modified_date: Optional[StrictInt] = Field(default=None, alias="lastModifiedDate")
    __properties: ClassVar[List[str]] = [
        "actionable",
        "customMetadata",
        "dataProducts",
        "datasourceId",
        "datasourceName",
        "description",
        "descriptionPrediction",
        "domains",
        "externalDescriptions",
        "externalTerms",
        "hasPreview",
        "integrationId",
        "integrationName",
        "lastRefresh",
        "lineagePlatform",
        "nextRefresh",
        "orchestratorsDetails",
        "owners",
        "platform",
        "sourceCreationType",
        "sourceUri",
        "tags",
        "terms",
        "usage",
        "createdBy",
        "creationDate",
        "descriptions",
        "lastModifiedBy",
        "lastModifiedDate",
    ]

    @field_validator("lineage_platform")
    def lineage_platform_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(
            [
                "ATHENA",
                "BIGQUERY",
                "FIREBOLT",
                "PRESTO",
                "REDSHIFT",
                "SNOWFLAKE",
                "DATABRICKS",
                "DATABRICKS_JOBS",
                "ADF",
                "MSSQL",
                "MYSQL",
                "SYNAPSE",
                "POSTGRES",
                "H2",
                "ORACLE",
                "LIGHTDASH",
                "LOOKER",
                "METABASE",
                "MICROSTRATEGY",
                "TABLEAU",
                "POWER_BI",
                "QLIK",
                "QUICKSIGHT",
                "STITCH",
                "AIRBYTE",
                "AIRFLOW",
                "COMPOSER",
                "DAGSTER",
                "DBT",
                "DBTCLOUD",
                "FIVETRAN",
                "MWAA",
                "PREFECT",
                "TALEND",
                "HUBSPOT",
                "INFORMATICA",
                "MULESOFT",
                "SALESFORCE",
                "SEGMENT",
                "SLACK",
                "CENSUS",
                "HIGH_TOUCH",
                "AMAZON_SAGEMAKER",
                "DATAIKU",
                "MICROSOFT_AZURE_ML",
                "GOOGLE_ANALYTICS",
                "SIGMA",
                "UNKNOWN",
                "AZURE",
                "CATALOG_GENERIC",
                "GOOGLE_DRIVE",
                "GOOGLE_SHEETS",
                "GOOGLE_CLOUD_STORAGE",
                "S3",
                "EXCEL",
                "GITHUB",
                "SIXSENSE",
                "FIFTEENFIVE",
                "THREESIXTYLEARNING",
                "ACCELDATA",
                "ACRYL_DATA",
                "ACTIAN_VECTOR",
                "ACTIVE_CAMPAIGN",
                "ADA",
                "ADJUST",
                "ADOBE",
                "ADP_WFN",
                "ADROLL",
                "AFFINITY",
                "AIRCALL",
                "AIRTABLE",
                "ALATION",
                "ALCHEMER",
                "ALVIN_AI",
                "AMAZON",
                "AMAZON_CLOUDFRONT",
                "AMAZON_DOCUMENTDB",
                "AMAZON_DYNAMODB",
                "AMAZON_FIREHOSE",
                "AMAZON_SELLING_PARTNER",
                "AMPLITUDE",
                "ANAPLAN",
                "ANOMALO",
                "APACHE_KAFKA",
                "APACHE_SPARK",
                "APPCUES",
                "APPFIGURES",
                "APPLE",
                "APPLE_APP_STORE",
                "APPSFLYER",
                "ASANA",
                "ASSEMBLED",
                "ATLAN",
                "ATLASSIAN_CONFLUENCE",
                "ATLASSIAN_JIRA",
                "ATLASSIAN_OPSGENIE",
                "AUTH0",
                "AUTODESK_BIM_360",
                "AWIN",
                "AWS_CLOUDTRAIL",
                "AWS_COST_EXPLORER",
                "AWS_INVENTORY",
                "AWS_LAMBDA",
                "BALLOT_READY",
                "BAMBOOHR",
                "BIGCOMMERCE",
                "BIGEYE",
                "BILLINGPLATFORM",
                "BIRDEYE",
                "BLACKBOARD",
                "BOX",
                "BRAINTREE",
                "BRAZE",
                "BREX",
                "BUILDKITE",
                "BUZZSPROUT",
                "CALENDLY",
                "CAMPAIGN_MONITOR",
                "CANNY",
                "CANVAS",
                "CAPTERRA",
                "CASTOR_DOC",
                "CERTINIA",
                "CHAMELEON",
                "CHANNEL_ADVISOR",
                "CHARGEBEE",
                "CHARGEDESK",
                "CHARTMOGUL",
                "CHORUS_AI",
                "CHURNKEY",
                "CHURNZERO",
                "CIMIS",
                "CIN7",
                "CIRCLE_CI",
                "CLARI",
                "CLICKUP",
                "CLIFF_AI",
                "CLOSE",
                "COLLIBRA",
                "COMMERCETOOLS",
                "CONFLUENT_CLOUD",
                "CONTRAST_SECURITY",
                "COUPA",
                "CRITEO",
                "CROSSBEAM",
                "CRUNCHBASE",
                "CUSTOMER_IO",
                "D2L_BRIGHTSPACE",
                "DATA_WORLD",
                "DATABAND",
                "DATADOG",
                "DATAEDO",
                "DATAFOLD",
                "DATAGALAXY",
                "DATAHUB",
                "DB2",
                "DCL_LOGISTICS",
                "DEAR",
                "DECUBE",
                "DELIGHTED",
                "DEPUTY",
                "DESTINI",
                "DIXA",
                "DOCEBO",
                "DRATA",
                "DRIFT",
                "DRIP",
                "DROPBOX",
                "DUOPLANE",
                "E_CONOMIC",
                "EASY_POST",
                "ELASTICSEARCH",
                "ELEMENTARY",
                "ELLUCIAN",
                "ELOQUA",
                "EMAIL",
                "EMPLOYMENT_HERO",
                "EPICOR_PROPHET_21",
                "EVENTBRITE",
                "EVERHOUR",
                "EXPENSIFY",
                "FACEBOOK",
                "FIGMA",
                "FIREBASE",
                "FLEXPORT",
                "FORJ",
                "FOUNTAIN",
                "FREIGHTVIEW",
                "FRESHBOOKS",
                "FRESHCHAT",
                "FRESHDESK",
                "FRESHDESK_CONTACT_CENTER",
                "FRESHSERVICE",
                "FRESHSUCCESS",
                "FRESHTEAM",
                "FRIENDBUY",
                "FRONT",
                "FTP",
                "FULLSTORY",
                "G2",
                "GAINSIGHT",
                "GEM",
                "GIT",
                "GITLAB",
                "GLADLY",
                "GOCARDLESS",
                "GONG",
                "GOOGLE",
                "GOOGLE_AD_MANAGER",
                "GOOGLE_ADS",
                "GOOGLE_CALENDAR",
                "GOOGLE_CAMPAIGN_MANAGER",
                "GOOGLE_CHROME",
                "GOOGLE_CLOUD",
                "GOOGLE_DISPLAY",
                "GOOGLE_PLAY",
                "GOOGLE_SEARCH_ADS_360",
                "GOOGLE_SEARCH_CONSOLE",
                "GOOGLE_TASKS",
                "GORGIAS",
                "GREENHOUSE",
                "GREENPLUM",
                "GREEN_POWER_MONITOR",
                "GREPSR",
                "GRIN",
                "GURU",
                "HARVEST",
                "HDFS",
                "HEAP",
                "HEIGHT",
                "HELP_SCOUT",
                "HELPSHIFT",
                "HEROKU_KAFKA",
                "HEX",
                "HIBOB",
                "HOPIN",
                "IMPACT",
                "INCIDENT_IO",
                "INFOBIP",
                "INSIGHTLY",
                "INSTAGRAM",
                "INTERCOM",
                "INVESTOPEDIA",
                "IRONCLAD",
                "IRONSOURCE",
                "ITERABLE",
                "JAVA",
                "JENKINS",
                "JUSTCALL",
                "KANDJI",
                "KENSU",
                "KHOROS_CARE",
                "KISSMETRICS",
                "KLAVIYO",
                "KNOWBE4",
                "KONNECT_INSIGHTS",
                "KUSTOMER",
                "LARIAT_DATA",
                "LATTICE",
                "LAUNCH_DARKLY",
                "LEARN_UPON",
                "LESSONLY",
                "LEVER",
                "LIFTOFF",
                "LIGHTSPEED",
                "LIGHTSUP",
                "LINEAR",
                "LINKEDIN",
                "LIVECHAT",
                "LOADED_COMMERCE",
                "LOB",
                "LOOP",
                "LOOPIO",
                "LUMA",
                "MAGENTO",
                "MAILCHIMP",
                "MAILGUN",
                "MANDRILL",
                "MANTA",
                "MARIADB",
                "MARIN_SOFTWARE",
                "MARKETO",
                "MATILLION",
                "MATTERMOST",
                "MAVENLINK",
                "MAXIO",
                "MEDALLIA",
                "META",
                "METAPHOR",
                "METAPLANE",
                "MICROSOFT",
                "MICROSOFT_AZURE_BLOB_STORAGE",
                "MICROSOFT_DYNAMICS",
                "MICROSOFT_ONEDRIVE",
                "MICROSOFT_PURVIEW",
                "MICROSOFT_TEAMS",
                "MIXMAX",
                "MIXPANEL",
                "MONDAY_COM",
                "MONGODB",
                "MONTE_CARLO",
                "MOUNTAIN",
                "MUX",
                "NAMELY",
                "NCINO",
                "NETSUITE_ANALYTICS",
                "NEW_RELIC",
                "NOTION",
                "NYLAS",
                "OBSERVE",
                "OCTOPAI",
                "OKTA",
                "OPEN_DATA_DC",
                "OPEN_EXCHANGES_RATES",
                "OPEN_AI",
                "OPEN_SEARCH",
                "OPTIMIZELY",
                "ORBIT_COMMUNITY_PLATFORM",
                "ORDWAY",
                "ORTTO",
                "OS_COMMERCE",
                "OUTBRAIN",
                "OUTREACH",
                "OVALEDGE",
                "PAGERDUTY",
                "PAGERSHIFT",
                "PAYPAL",
                "PENDO",
                "PINGDOM",
                "PINTEREST",
                "PIPE17",
                "PIPEDRIVE",
                "PIVOTAL_TRACKER",
                "PLAYVOX",
                "POSTHOG",
                "POWERSCHOOL",
                "PRESTASHOP",
                "PRODUCTBOARD",
                "PYTHON",
                "QUALAROO",
                "QUALTRICS",
                "QUICKBOOKS",
                "RAMP",
                "RARIBLE",
                "RECHARGE",
                "RECURLY",
                "REDDIT",
                "RELTIO",
                "REPLY_IO",
                "RETAILNEXT",
                "RETENTLY",
                "REVEL_SYSTEMS",
                "RINGCENTRAL",
                "RIPPLING",
                "ROLLBAR",
                "ROOTLY",
                "SAGE_HR",
                "SAGE_INTACCT",
                "SAILTHRU",
                "SALESLOFT",
                "SALSIFY",
                "SAMSARA",
                "SAP",
                "SAP_CONCUR",
                "SCORM",
                "SECODA",
                "SECURITY_JOURNEY",
                "SELECT_STAR",
                "SENDGRID",
                "BREVO",
                "SERVICE_NOW",
                "SFTP",
                "SHAREPOINT",
                "SHARETRIBE",
                "SHIPHERO",
                "SHIPSTATION",
                "SHOPIFY",
                "SHOPWARE",
                "SHORT_IO",
                "SIFFLET",
                "SIMPLECAST",
                "SIMPLESAT",
                "SINGLESTORE",
                "SISENSE",
                "SKILLJAR",
                "SKUVAULT",
                "SLAB",
                "SMADEX",
                "SNAPCHAT",
                "SNOWPLOW",
                "SODA",
                "SONARQUBE",
                "SPLIT_IO",
                "SPLUNK",
                "SPOTIFY",
                "SPREE_COMMERCE",
                "SPROUT_SOCIAL",
                "SQUARE",
                "SQUARESPACE",
                "SSIS",
                "STACK_ADAPT",
                "STATSIG",
                "STRIPE",
                "STYLIGHT",
                "SUBSCRIPT",
                "TABOOLA",
                "TALKDESK",
                "TALKWALKER",
                "TEAMWORK_COM",
                "TEMPO_IO",
                "TERADATA",
                "TERRAFORM",
                "THE_TRADE_DESK",
                "THOUGHT_SPOT",
                "TIKTOK",
                "TOGGL",
                "TRANSCEND",
                "TRELLO",
                "TRISOLUTE",
                "TWILIO",
                "TYPEFORM",
                "UPLAND",
                "USERVOICE",
                "VALIDIO",
                "VEEVA",
                "VERIZON_MEDIA",
                "VITALLY",
                "VONAGE",
                "VUETIFY",
                "WEB_SCRAPER",
                "WEBHOOKS",
                "WHEN_I_WORK",
                "WHEREFOUR",
                "WIKIPEDIA",
                "WOOCOMMERCE",
                "WORDPRESS",
                "WORKABLE",
                "WORKDAY",
                "WORKFLOW_MAX",
                "WRIKE",
                "X",
                "XERO",
                "XRAY",
                "YAHOO",
                "YOTPO",
                "YOUTUBE",
                "ZEENEA",
                "ZEN_CART",
                "ZENDESK_CHAT",
                "ZENDESK_SELL",
                "ZENDESK_SUNSHINE",
                "ZENDESK_SUPPORT",
                "TRINET",
                "ZINGTREE",
                "ZOHO_BOOKS",
                "ZOHO_CAMPAIGNS",
                "ZOHO_CRM",
                "ZOOM",
                "ZUORA",
            ]
        ):
            raise ValueError(
                "must be one of enum values ('ATHENA', 'BIGQUERY', 'FIREBOLT', 'PRESTO', 'REDSHIFT', 'SNOWFLAKE', 'DATABRICKS', 'DATABRICKS_JOBS', 'ADF', 'MSSQL', 'MYSQL', 'SYNAPSE', 'POSTGRES', 'H2', 'ORACLE', 'LIGHTDASH', 'LOOKER', 'METABASE', 'MICROSTRATEGY', 'TABLEAU', 'POWER_BI', 'QLIK', 'QUICKSIGHT', 'STITCH', 'AIRBYTE', 'AIRFLOW', 'COMPOSER', 'DAGSTER', 'DBT', 'DBTCLOUD', 'FIVETRAN', 'MWAA', 'PREFECT', 'TALEND', 'HUBSPOT', 'INFORMATICA', 'MULESOFT', 'SALESFORCE', 'SEGMENT', 'SLACK', 'CENSUS', 'HIGH_TOUCH', 'AMAZON_SAGEMAKER', 'DATAIKU', 'MICROSOFT_AZURE_ML', 'GOOGLE_ANALYTICS', 'SIGMA', 'UNKNOWN', 'AZURE', 'CATALOG_GENERIC', 'GOOGLE_DRIVE', 'GOOGLE_SHEETS', 'GOOGLE_CLOUD_STORAGE', 'S3', 'EXCEL', 'GITHUB', 'SIXSENSE', 'FIFTEENFIVE', 'THREESIXTYLEARNING', 'ACCELDATA', 'ACRYL_DATA', 'ACTIAN_VECTOR', 'ACTIVE_CAMPAIGN', 'ADA', 'ADJUST', 'ADOBE', 'ADP_WFN', 'ADROLL', 'AFFINITY', 'AIRCALL', 'AIRTABLE', 'ALATION', 'ALCHEMER', 'ALVIN_AI', 'AMAZON', 'AMAZON_CLOUDFRONT', 'AMAZON_DOCUMENTDB', 'AMAZON_DYNAMODB', 'AMAZON_FIREHOSE', 'AMAZON_SELLING_PARTNER', 'AMPLITUDE', 'ANAPLAN', 'ANOMALO', 'APACHE_KAFKA', 'APACHE_SPARK', 'APPCUES', 'APPFIGURES', 'APPLE', 'APPLE_APP_STORE', 'APPSFLYER', 'ASANA', 'ASSEMBLED', 'ATLAN', 'ATLASSIAN_CONFLUENCE', 'ATLASSIAN_JIRA', 'ATLASSIAN_OPSGENIE', 'AUTH0', 'AUTODESK_BIM_360', 'AWIN', 'AWS_CLOUDTRAIL', 'AWS_COST_EXPLORER', 'AWS_INVENTORY', 'AWS_LAMBDA', 'BALLOT_READY', 'BAMBOOHR', 'BIGCOMMERCE', 'BIGEYE', 'BILLINGPLATFORM', 'BIRDEYE', 'BLACKBOARD', 'BOX', 'BRAINTREE', 'BRAZE', 'BREX', 'BUILDKITE', 'BUZZSPROUT', 'CALENDLY', 'CAMPAIGN_MONITOR', 'CANNY', 'CANVAS', 'CAPTERRA', 'CASTOR_DOC', 'CERTINIA', 'CHAMELEON', 'CHANNEL_ADVISOR', 'CHARGEBEE', 'CHARGEDESK', 'CHARTMOGUL', 'CHORUS_AI', 'CHURNKEY', 'CHURNZERO', 'CIMIS', 'CIN7', 'CIRCLE_CI', 'CLARI', 'CLICKUP', 'CLIFF_AI', 'CLOSE', 'COLLIBRA', 'COMMERCETOOLS', 'CONFLUENT_CLOUD', 'CONTRAST_SECURITY', 'COUPA', 'CRITEO', 'CROSSBEAM', 'CRUNCHBASE', 'CUSTOMER_IO', 'D2L_BRIGHTSPACE', 'DATA_WORLD', 'DATABAND', 'DATADOG', 'DATAEDO', 'DATAFOLD', 'DATAGALAXY', 'DATAHUB', 'DB2', 'DCL_LOGISTICS', 'DEAR', 'DECUBE', 'DELIGHTED', 'DEPUTY', 'DESTINI', 'DIXA', 'DOCEBO', 'DRATA', 'DRIFT', 'DRIP', 'DROPBOX', 'DUOPLANE', 'E_CONOMIC', 'EASY_POST', 'ELASTICSEARCH', 'ELEMENTARY', 'ELLUCIAN', 'ELOQUA', 'EMAIL', 'EMPLOYMENT_HERO', 'EPICOR_PROPHET_21', 'EVENTBRITE', 'EVERHOUR', 'EXPENSIFY', 'FACEBOOK', 'FIGMA', 'FIREBASE', 'FLEXPORT', 'FORJ', 'FOUNTAIN', 'FREIGHTVIEW', 'FRESHBOOKS', 'FRESHCHAT', 'FRESHDESK', 'FRESHDESK_CONTACT_CENTER', 'FRESHSERVICE', 'FRESHSUCCESS', 'FRESHTEAM', 'FRIENDBUY', 'FRONT', 'FTP', 'FULLSTORY', 'G2', 'GAINSIGHT', 'GEM', 'GIT', 'GITLAB', 'GLADLY', 'GOCARDLESS', 'GONG', 'GOOGLE', 'GOOGLE_AD_MANAGER', 'GOOGLE_ADS', 'GOOGLE_CALENDAR', 'GOOGLE_CAMPAIGN_MANAGER', 'GOOGLE_CHROME', 'GOOGLE_CLOUD', 'GOOGLE_DISPLAY', 'GOOGLE_PLAY', 'GOOGLE_SEARCH_ADS_360', 'GOOGLE_SEARCH_CONSOLE', 'GOOGLE_TASKS', 'GORGIAS', 'GREENHOUSE', 'GREENPLUM', 'GREEN_POWER_MONITOR', 'GREPSR', 'GRIN', 'GURU', 'HARVEST', 'HDFS', 'HEAP', 'HEIGHT', 'HELP_SCOUT', 'HELPSHIFT', 'HEROKU_KAFKA', 'HEX', 'HIBOB', 'HOPIN', 'IMPACT', 'INCIDENT_IO', 'INFOBIP', 'INSIGHTLY', 'INSTAGRAM', 'INTERCOM', 'INVESTOPEDIA', 'IRONCLAD', 'IRONSOURCE', 'ITERABLE', 'JAVA', 'JENKINS', 'JUSTCALL', 'KANDJI', 'KENSU', 'KHOROS_CARE', 'KISSMETRICS', 'KLAVIYO', 'KNOWBE4', 'KONNECT_INSIGHTS', 'KUSTOMER', 'LARIAT_DATA', 'LATTICE', 'LAUNCH_DARKLY', 'LEARN_UPON', 'LESSONLY', 'LEVER', 'LIFTOFF', 'LIGHTSPEED', 'LIGHTSUP', 'LINEAR', 'LINKEDIN', 'LIVECHAT', 'LOADED_COMMERCE', 'LOB', 'LOOP', 'LOOPIO', 'LUMA', 'MAGENTO', 'MAILCHIMP', 'MAILGUN', 'MANDRILL', 'MANTA', 'MARIADB', 'MARIN_SOFTWARE', 'MARKETO', 'MATILLION', 'MATTERMOST', 'MAVENLINK', 'MAXIO', 'MEDALLIA', 'META', 'METAPHOR', 'METAPLANE', 'MICROSOFT', 'MICROSOFT_AZURE_BLOB_STORAGE', 'MICROSOFT_DYNAMICS', 'MICROSOFT_ONEDRIVE', 'MICROSOFT_PURVIEW', 'MICROSOFT_TEAMS', 'MIXMAX', 'MIXPANEL', 'MONDAY_COM', 'MONGODB', 'MONTE_CARLO', 'MOUNTAIN', 'MUX', 'NAMELY', 'NCINO', 'NETSUITE_ANALYTICS', 'NEW_RELIC', 'NOTION', 'NYLAS', 'OBSERVE', 'OCTOPAI', 'OKTA', 'OPEN_DATA_DC', 'OPEN_EXCHANGES_RATES', 'OPEN_AI', 'OPEN_SEARCH', 'OPTIMIZELY', 'ORBIT_COMMUNITY_PLATFORM', 'ORDWAY', 'ORTTO', 'OS_COMMERCE', 'OUTBRAIN', 'OUTREACH', 'OVALEDGE', 'PAGERDUTY', 'PAGERSHIFT', 'PAYPAL', 'PENDO', 'PINGDOM', 'PINTEREST', 'PIPE17', 'PIPEDRIVE', 'PIVOTAL_TRACKER', 'PLAYVOX', 'POSTHOG', 'POWERSCHOOL', 'PRESTASHOP', 'PRODUCTBOARD', 'PYTHON', 'QUALAROO', 'QUALTRICS', 'QUICKBOOKS', 'RAMP', 'RARIBLE', 'RECHARGE', 'RECURLY', 'REDDIT', 'RELTIO', 'REPLY_IO', 'RETAILNEXT', 'RETENTLY', 'REVEL_SYSTEMS', 'RINGCENTRAL', 'RIPPLING', 'ROLLBAR', 'ROOTLY', 'SAGE_HR', 'SAGE_INTACCT', 'SAILTHRU', 'SALESLOFT', 'SALSIFY', 'SAMSARA', 'SAP', 'SAP_CONCUR', 'SCORM', 'SECODA', 'SECURITY_JOURNEY', 'SELECT_STAR', 'SENDGRID', 'BREVO', 'SERVICE_NOW', 'SFTP', 'SHAREPOINT', 'SHARETRIBE', 'SHIPHERO', 'SHIPSTATION', 'SHOPIFY', 'SHOPWARE', 'SHORT_IO', 'SIFFLET', 'SIMPLECAST', 'SIMPLESAT', 'SINGLESTORE', 'SISENSE', 'SKILLJAR', 'SKUVAULT', 'SLAB', 'SMADEX', 'SNAPCHAT', 'SNOWPLOW', 'SODA', 'SONARQUBE', 'SPLIT_IO', 'SPLUNK', 'SPOTIFY', 'SPREE_COMMERCE', 'SPROUT_SOCIAL', 'SQUARE', 'SQUARESPACE', 'SSIS', 'STACK_ADAPT', 'STATSIG', 'STRIPE', 'STYLIGHT', 'SUBSCRIPT', 'TABOOLA', 'TALKDESK', 'TALKWALKER', 'TEAMWORK_COM', 'TEMPO_IO', 'TERADATA', 'TERRAFORM', 'THE_TRADE_DESK', 'THOUGHT_SPOT', 'TIKTOK', 'TOGGL', 'TRANSCEND', 'TRELLO', 'TRISOLUTE', 'TWILIO', 'TYPEFORM', 'UPLAND', 'USERVOICE', 'VALIDIO', 'VEEVA', 'VERIZON_MEDIA', 'VITALLY', 'VONAGE', 'VUETIFY', 'WEB_SCRAPER', 'WEBHOOKS', 'WHEN_I_WORK', 'WHEREFOUR', 'WIKIPEDIA', 'WOOCOMMERCE', 'WORDPRESS', 'WORKABLE', 'WORKDAY', 'WORKFLOW_MAX', 'WRIKE', 'X', 'XERO', 'XRAY', 'YAHOO', 'YOTPO', 'YOUTUBE', 'ZEENEA', 'ZEN_CART', 'ZENDESK_CHAT', 'ZENDESK_SELL', 'ZENDESK_SUNSHINE', 'ZENDESK_SUPPORT', 'TRINET', 'ZINGTREE', 'ZOHO_BOOKS', 'ZOHO_CAMPAIGNS', 'ZOHO_CRM', 'ZOOM', 'ZUORA')"
            )
        return value

    @field_validator("source_creation_type")
    def source_creation_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(["DECLARED", "CONNECTED"]):
            raise ValueError("must be one of enum values ('DECLARED', 'CONNECTED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DeclaredAssetDetailsDto from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in custom_metadata (list)
        _items = []
        if self.custom_metadata:
            for _item_custom_metadata in self.custom_metadata:
                if _item_custom_metadata:
                    _items.append(_item_custom_metadata.to_dict())
            _dict["customMetadata"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in data_products (list)
        _items = []
        if self.data_products:
            for _item_data_products in self.data_products:
                if _item_data_products:
                    _items.append(_item_data_products.to_dict())
            _dict["dataProducts"] = _items
        # override the default output from pydantic by calling `to_dict()` of description_prediction
        if self.description_prediction:
            _dict["descriptionPrediction"] = self.description_prediction.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in domains (list)
        _items = []
        if self.domains:
            for _item_domains in self.domains:
                if _item_domains:
                    _items.append(_item_domains.to_dict())
            _dict["domains"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in external_descriptions (list)
        _items = []
        if self.external_descriptions:
            for _item_external_descriptions in self.external_descriptions:
                if _item_external_descriptions:
                    _items.append(_item_external_descriptions.to_dict())
            _dict["externalDescriptions"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in external_terms (list)
        _items = []
        if self.external_terms:
            for _item_external_terms in self.external_terms:
                if _item_external_terms:
                    _items.append(_item_external_terms.to_dict())
            _dict["externalTerms"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in orchestrators_details (list)
        _items = []
        if self.orchestrators_details:
            for _item_orchestrators_details in self.orchestrators_details:
                if _item_orchestrators_details:
                    _items.append(_item_orchestrators_details.to_dict())
            _dict["orchestratorsDetails"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in owners (list)
        _items = []
        if self.owners:
            for _item_owners in self.owners:
                if _item_owners:
                    _items.append(_item_owners.to_dict())
            _dict["owners"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in tags (list)
        _items = []
        if self.tags:
            for _item_tags in self.tags:
                if _item_tags:
                    _items.append(_item_tags.to_dict())
            _dict["tags"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in terms (list)
        _items = []
        if self.terms:
            for _item_terms in self.terms:
                if _item_terms:
                    _items.append(_item_terms.to_dict())
            _dict["terms"] = _items
        # override the default output from pydantic by calling `to_dict()` of usage
        if self.usage:
            _dict["usage"] = self.usage.to_dict()
        # override the default output from pydantic by calling `to_dict()` of created_by
        if self.created_by:
            _dict["createdBy"] = self.created_by.to_dict()
        # override the default output from pydantic by calling `to_dict()` of last_modified_by
        if self.last_modified_by:
            _dict["lastModifiedBy"] = self.last_modified_by.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DeclaredAssetDetailsDto from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "actionable": obj.get("actionable"),
                "customMetadata": (
                    [EntityCustomMetadataDto.from_dict(_item) for _item in obj["customMetadata"]]
                    if obj.get("customMetadata") is not None
                    else None
                ),
                "dataProducts": (
                    [AssetDataProductDto.from_dict(_item) for _item in obj["dataProducts"]]
                    if obj.get("dataProducts") is not None
                    else None
                ),
                "datasourceId": obj.get("datasourceId"),
                "datasourceName": obj.get("datasourceName"),
                "description": obj.get("description"),
                "descriptionPrediction": (
                    DescriptionPredictionDto.from_dict(obj["descriptionPrediction"])
                    if obj.get("descriptionPrediction") is not None
                    else None
                ),
                "domains": (
                    [AssetDomainDto.from_dict(_item) for _item in obj["domains"]]
                    if obj.get("domains") is not None
                    else None
                ),
                "externalDescriptions": (
                    [DescriptionDto.from_dict(_item) for _item in obj["externalDescriptions"]]
                    if obj.get("externalDescriptions") is not None
                    else None
                ),
                "externalTerms": (
                    [TagDto.from_dict(_item) for _item in obj["externalTerms"]]
                    if obj.get("externalTerms") is not None
                    else None
                ),
                "hasPreview": obj.get("hasPreview"),
                "integrationId": obj.get("integrationId"),
                "integrationName": obj.get("integrationName"),
                "lastRefresh": obj.get("lastRefresh"),
                "lineagePlatform": obj.get("lineagePlatform"),
                "nextRefresh": obj.get("nextRefresh"),
                "orchestratorsDetails": (
                    [OrchestratorDetailsDto.from_dict(_item) for _item in obj["orchestratorsDetails"]]
                    if obj.get("orchestratorsDetails") is not None
                    else None
                ),
                "owners": (
                    [UserDto.from_dict(_item) for _item in obj["owners"]] if obj.get("owners") is not None else None
                ),
                "platform": obj.get("platform"),
                "sourceCreationType": obj.get("sourceCreationType"),
                "sourceUri": obj.get("sourceUri"),
                "tags": [TagDto.from_dict(_item) for _item in obj["tags"]] if obj.get("tags") is not None else None,
                "terms": [TagDto.from_dict(_item) for _item in obj["terms"]] if obj.get("terms") is not None else None,
                "usage": AssetUsageDto.from_dict(obj["usage"]) if obj.get("usage") is not None else None,
                "createdBy": (
                    DeclaredAssetDetailsDtoAllOfCreatedBy.from_dict(obj["createdBy"])
                    if obj.get("createdBy") is not None
                    else None
                ),
                "creationDate": obj.get("creationDate"),
                "descriptions": obj.get("descriptions"),
                "lastModifiedBy": (
                    DeclaredAssetDetailsDtoAllOfLastModifiedBy.from_dict(obj["lastModifiedBy"])
                    if obj.get("lastModifiedBy") is not None
                    else None
                ),
                "lastModifiedDate": obj.get("lastModifiedDate"),
            }
        )
        return _obj
