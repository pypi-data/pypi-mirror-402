from __future__ import annotations

from typing import List, Optional, Type, TypeAlias
from typing import Literal as _Literal

from pydantic import BaseModel, Field, create_model
from flujo.domain.base_model import BaseModel as FlujoBaseModel


JsonSchema: TypeAlias = dict[str, object]
JsonAnnotation: TypeAlias = object


def _python_type_for_json_schema(schema: JsonSchema, *, name_hint: str = "Value") -> JsonAnnotation:
    t_raw = schema.get("type")
    t: Optional[str] = t_raw if isinstance(t_raw, str) else None
    if t is None:
        # Fall back to permissive object when type is not specified
        return object

    if t == "string":
        enums = schema.get("enum")
        if isinstance(enums, list) and enums:
            try:
                return _Literal[tuple(enums)]
            except Exception:
                return str
        return str
    if t == "integer":
        enums = schema.get("enum")
        if isinstance(enums, list) and enums:
            try:
                coerced = [int(e) for e in enums]
                return _Literal[tuple(coerced)]
            except Exception:
                return int
        return int
    if t == "number":
        enums = schema.get("enum")
        if isinstance(enums, list) and enums:
            try:
                coerced = [float(e) for e in enums]
                return _Literal[tuple(coerced)]
            except Exception:
                return float
        return float
    if t == "boolean":
        # Booleans with enum are odd; fall back to bool
        return bool
    if t == "array":
        # Keep item typing permissive for runtime compatibility
        return list[object]
    if t == "object":
        # Nested object without explicit properties -> generic dict
        if not isinstance(schema.get("properties"), dict):
            return dict[str, object]
        # For objects with properties, a model will be generated by caller
        return dict[str, object]

    # Fallback
    return object


def generate_model_from_schema(name: str, schema: JsonSchema) -> Type[BaseModel]:
    """Generate a Pydantic BaseModel from a JSON Schema dictionary.

    The generator supports core JSON Schema features used by Flujo blueprints:
    - type: string, integer, number, boolean, object, array
    - properties, required
    - enum on primitives (via typing.Literal)
    - description propagated to Field

    For non-object primitives, a wrapper model with a single field 'value' is returned.
    """
    model_name = (
        "".join(part.capitalize() for part in name.replace("-", "_").split("_")) or "DynamicModel"
    )

    schema_type = schema.get("type")

    # Primitive wrappers
    if schema_type != "object":
        annotation = _python_type_for_json_schema(schema, name_hint="Value")
        primitive_fields: dict[str, object] = {
            "value": (annotation, ...),
        }
        # Carry field description if any
        desc = schema.get("description")
        if desc:
            primitive_fields["value"] = (annotation, Field(..., description=str(desc)))
        primitive_model: Type[BaseModel] = create_model(  # type: ignore[call-overload]
            model_name, __base__=FlujoBaseModel, **primitive_fields
        )
        return primitive_model

    # Object handling
    raw_properties = schema.get("properties")
    properties: dict[str, JsonSchema] = (
        dict(raw_properties) if isinstance(raw_properties, dict) else {}
    )
    raw_required = schema.get("required")
    required: List[str] = [str(r) for r in raw_required] if isinstance(raw_required, list) else []

    fields: dict[str, object] = {}
    for prop_name, prop_schema in properties.items():
        prop_type: JsonAnnotation
        if prop_schema.get("type") == "array":
            items_schema = prop_schema.get("items")
            if isinstance(items_schema, dict) and items_schema.get("type") == "object":
                # Array of objects, create a sub-model for the items
                item_model_name = f"{model_name}{prop_name.capitalize()}Item"
                item_type = generate_model_from_schema(item_model_name, dict(items_schema))
                prop_type = list[item_type]
            elif isinstance(items_schema, dict):
                # Primitive or enum-typed array items
                item_py = _python_type_for_json_schema(
                    dict(items_schema), name_hint=f"{prop_name}_item"
                )
                prop_type = list[item_py]
            else:
                # Unspecified items
                prop_type = list[object]
        elif prop_schema.get("type") == "object" and isinstance(
            prop_schema.get("properties"), dict
        ):
            # Nested object, create a sub-model
            sub_name = f"{model_name}{''.join(part.capitalize() for part in prop_name.split('_'))}"
            prop_type = generate_model_from_schema(sub_name, dict(prop_schema))
        else:
            # Primitive type
            prop_type = _python_type_for_json_schema(prop_schema, name_hint=prop_name)

        is_required = prop_name in required
        default = ... if is_required else None

        # Optionality is expressed by default=None for pydantic models
        if "description" in prop_schema:
            fields[prop_name] = (
                prop_type,
                Field(default, description=str(prop_schema["description"])),
            )
        else:
            fields[prop_name] = (prop_type, default)

    if not fields:
        # Empty object schema -> allow arbitrary mapping
        fields["data"] = (dict[str, object], Field(default_factory=dict))

    obj_model: Type[BaseModel] = create_model(  # type: ignore[call-overload]
        model_name, __base__=FlujoBaseModel, **fields
    )
    return obj_model


__all__ = ["generate_model_from_schema"]
