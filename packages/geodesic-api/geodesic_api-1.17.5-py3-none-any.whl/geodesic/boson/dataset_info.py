from geodesic.bases import _APIObject
from geodesic.descriptors import (
    _StringDescr,
    _IntDescr,
    _ListDescr,
    _DictDescr,
    _TypeConstrainedDescr,
)
from geodesic.boson import BosonConfig
from geodesic.stac import Extent
from geodesic.utils.display import (
    _convert_geometry_types_to_rows,
    _convert_raster_assets_to_rows,
    _convert_extent_to_rows,
    _convert_asset_bands_to_rows,
    render_table_str,
    render_table_html,
    format_grouped_data,
    format_grouped_data_html,
    _create_table,
)

import prettytable


class DatasetInfo(_APIObject):
    """Metadata about a boson dataset.

    This is obtained by calling the dataset-info endpoint in Boson. While there is some
    field overlap, this is usually dynamically generated by Boson and is not necessarily
    the same as the metadata set by the user. Especially in cases where a creator of a
    Dataset opted to not provide much metadata, Boson attempts to generate update to date
    information, depending on the provider used.

    This is particularly useful to inspect things like valid raster assets, min/max zoom,
    available fields for querying, and STAC collections.
    """

    def __init__(self, data=None, **kwargs):
        """Initialize DatasetInfo with data dict or keyword arguments."""
        if data is not None:
            if not isinstance(data, dict):
                raise TypeError(f"DatasetInfo data must be a dict, got {type(data)}")
            if kwargs:
                raise ValueError("Cannot specify both 'data' and keyword arguments")
            # Backward compatibility: data dict passed as positional arg
            super().__init__()
            if data:
                for key, value in data.items():
                    self[key] = value  # This triggers descriptor validation
        else:
            # New style: keyword arguments (from **json_data)
            super().__init__(**kwargs)

    # Simple string fields
    name = _StringDescr(doc="name of this Dataset")
    alias = _StringDescr(doc="alias - human readable name of this Dataset")
    description = _StringDescr(doc="description of this Dataset")

    # Integer fields
    min_zoom = _IntDescr(doc="Min Zoom (OSM Zoom Value) for this layer")
    max_zoom = _IntDescr(doc="Max Zoom (OSM Zoom Value) for this layer")

    # Extent - can be Extent object or dict, no coercion
    overall_extent = _TypeConstrainedDescr(
        (Extent, dict), coerce=False, optional=True, doc="spatiotemporal extent of this Dataset"
    )

    # Dictionary fields - store raw dicts
    raster_assets = _DictDescr(doc="dictionary of raster-assets for this Dataset")
    queryables = _DictDescr(doc="dictionary of queryables for each collection")
    fields = _DictDescr(doc="dictionary of fields for each collection")
    geometry_types = _DictDescr(doc="dictionary of geometry types for each collection")

    # List fields - store raw lists
    default_asset_bands = _ListDescr(item_type=dict, doc="default asset bands...")
    conforms_to = _ListDescr(item_type=str, doc="list of OGC/other standard conformances")
    links = _ListDescr(item_type=dict, doc="list of links for this Dataset")
    collections = _ListDescr(item_type=dict, doc="list of STAC/Features Collections")

    # Provider config - no coercion
    provider_config = _TypeConstrainedDescr(
        (BosonConfig, dict), coerce=False, optional=True, doc="Boson provider config"
    )

    def _get_field_display_order(self):
        """Get the order and display names for fields."""
        return [
            ("name", "Name"),
            ("alias", "Alias"),
            ("description", "Description"),
            ("overall_extent", "Overall Extent"),
            ("min_zoom", "Min Zoom"),
            ("max_zoom", "Max Zoom"),
            ("raster_assets", "Raster Assets"),
            ("default_asset_bands", "Default Asset Bands"),
            ("queryables", "Queryables"),
            ("fields", "Fields"),
            ("geometry_types", "Geometry Types"),
            ("conforms_to", "Conforms To"),
            ("collections", "Collections"),
            ("links", "Links"),
            ("provider_config", "Provider Config"),
        ]

    def _should_skip_field(self, value):
        """Check if a field should be skipped in display."""
        # Skip None or empty values
        if value is None:
            return True

        # Skip empty containers
        try:
            if hasattr(value, "__len__") and len(value) == 0:
                return True
        except Exception:
            pass

        return False

    def _format_overall_extent(self, value, html=False):
        extent_dict = dict(value) if isinstance(value, Extent) else value
        rows = _convert_extent_to_rows(extent_dict)
        if html:
            return render_table_html(["Extent", "Type", "Value"], rows)
        return render_table_str(["Extent", "Type", "Value"], rows)

    def _format_raster_assets(self, value, html=False):
        rows = _convert_raster_assets_to_rows(value)
        if html:
            return render_table_html(["Asset", "Band"], rows)
        return render_table_str(["Asset", "Band"], rows)

    def _format_default_asset_bands(self, value, html=False):
        rows = _convert_asset_bands_to_rows(value)
        if html:
            return render_table_html(["Asset", "Bands"], rows)
        return render_table_str(["Asset", "Bands"], rows)

    def _format_geometry_types(self, value, html=False):
        rows = _convert_geometry_types_to_rows(value)
        if html:
            return render_table_html(["Collection", "Geometry Type", "Count"], rows)
        return render_table_str(["Collection", "Geometry Type", "Count"], rows)

    def _format_conforms_to(self, value, html=False):
        rows = [{"URI": uri} for uri in value]
        if html:
            return render_table_html(["URI"], rows)
        return render_table_str(["URI"], rows)

    def _format_links(self, value, html=False):
        if html:
            return render_table_html(["rel", "type", "href"], value)
        return render_table_str(["rel", "type", "href"], value)

    def _format_collections(self, value, html=False):
        if html:
            return render_table_html(["id", "title", "stac_version"], value)
        return render_table_str(["id", "title", "stac_version"], value)

    def _format_queryables(self, value, html=False):
        def accessor(name, info):
            return {"Name": name, "Type": info.get("type", ""), "Title": info.get("title", "")}

        headers = ["Name", "Type", "Title"]
        if html:
            return format_grouped_data_html(value, headers, accessor, "h4")
        return format_grouped_data(value, headers, accessor)

    def _format_fields(self, value, html=False):
        def accessor(name, info):
            return {"Name": name, "Type": info.get("type", ""), "Title": info.get("title", "")}

        headers = ["Name", "Type", "Title"]
        if html:
            return format_grouped_data_html(value, headers, accessor, "h4")
        return format_grouped_data(value, headers, accessor)

    def _format_provider_config(self, value):
        # Convert to BosonConfig if it's a dict
        if isinstance(value, dict) and not isinstance(value, BosonConfig):
            value = BosonConfig(**value)
        return str(value)

    def _format_provider_config_html(self, value):
        # Convert to BosonConfig if it's a dict
        if isinstance(value, dict) and not isinstance(value, BosonConfig):
            value = BosonConfig(**value)
        # Let BosonConfig handle its own HTML display
        bundle = value._repr_mimebundle_()
        return bundle.get("text/html", "")

    def __str__(self):
        """Display formatted tables. DatasetInfo controls rendering of all fields."""
        output_parts = []

        # Fields that should NOT have section headers
        no_header_fields = {
            "name",
            "alias",
            "description",
            "overall_extent",
            "min_zoom",
            "max_zoom",
        }

        # Map fields to their formatters
        formatters = {
            "overall_extent": lambda v: self._format_overall_extent(v, html=False),
            "raster_assets": lambda v: self._format_raster_assets(v, html=False),
            "default_asset_bands": lambda v: self._format_default_asset_bands(v, html=False),
            "geometry_types": lambda v: self._format_geometry_types(v, html=False),
            "conforms_to": lambda v: self._format_conforms_to(v, html=False),
            "links": lambda v: self._format_links(v, html=False),
            "collections": lambda v: self._format_collections(v, html=False),
            "queryables": lambda v: self._format_queryables(v, html=False),
            "fields": lambda v: self._format_fields(v, html=False),
            "provider_config": self._format_provider_config,
        }

        for field_name, display_name in self._get_field_display_order():
            if field_name not in self:
                continue

            value = self[field_name]

            if self._should_skip_field(value):
                continue

            # Add blank line before each field for spacing
            output_parts.append("")

            try:
                # Check if we have a custom formatter
                if field_name in formatters:
                    formatted = formatters[field_name](value)
                    if formatted:
                        # Add section header for fields NOT in no_header_fields
                        if field_name not in no_header_fields:
                            output_parts.append(f"{display_name}:")
                        output_parts.append(formatted)
                else:
                    # Simple field - string, int, or dict/BosonConfig

                    table = _create_table(
                        [display_name], align_left=True, style=prettytable.MARKDOWN
                    )
                    table.add_row([str(value)])
                    output_parts.append(str(table))
            except Exception as e:
                # If there's an error formatting, show a simplified version
                output_parts.append(f"{display_name}:")
                output_parts.append(f"  <Error displaying {field_name}: {type(e).__name__}>")

        return "\n".join(output_parts)

    def __repr__(self):
        """Representation of DatasetInfo."""
        dict_repr = str(dict(self))

        if len(dict_repr) > 100:
            return f"DatasetInfo({dict_repr[:100]}...)"

        return f"DatasetInfo({dict_repr})"

    def _repr_mimebundle_(self, include=None, exclude=None):
        """Return HTML representation for Jupyter display. DatasetInfo controls rendering."""
        html_parts = []
        html_parts.append("<div style='margin: 10px;'>")
        html_parts.append("<h3>Dataset Info</h3>")

        # Fields that should NOT have section headers
        no_header_fields = {
            "name",
            "alias",
            "description",
            "min_zoom",
            "max_zoom",
        }

        # Map fields to their HTML formatters
        formatters_html = {
            "overall_extent": lambda v: self._format_overall_extent(v, html=True),
            "raster_assets": lambda v: self._format_raster_assets(v, html=True),
            "default_asset_bands": lambda v: self._format_default_asset_bands(v, html=True),
            "geometry_types": lambda v: self._format_geometry_types(v, html=True),
            "conforms_to": lambda v: self._format_conforms_to(v, html=True),
            "links": lambda v: self._format_links(v, html=True),
            "collections": lambda v: self._format_collections(v, html=True),
            "queryables": lambda v: self._format_queryables(v, html=True),
            "fields": lambda v: self._format_fields(v, html=True),
            "provider_config": self._format_provider_config_html,
        }
        first_field = True
        for field_name, display_name in self._get_field_display_order():
            if field_name not in self:
                continue

            value = self[field_name]

            if self._should_skip_field(value):
                continue

            # Add line break before each field (except the first one)
            if not first_field:
                html_parts.append("<br>")
            first_field = False

            try:
                # Check if we have a custom HTML formatter
                if field_name in formatters_html:
                    formatted = formatters_html[field_name](value)
                    if formatted:
                        # Add header if NOT in no_header_fields
                        if field_name not in no_header_fields:
                            html_parts.append(f"<h4>{display_name}</h4>")
                        html_parts.append(formatted)
                else:
                    # Simple field
                    from geodesic.utils.display import _create_table, _fix_html_alignment

                    table = _create_table([display_name])
                    table.add_row([str(value)])
                    html_parts.append(_fix_html_alignment(table.get_html_string(format=True)))
            except Exception:
                # If there's an error, display as text
                if field_name not in no_header_fields:
                    html_parts.append(f"<h4>{display_name}</h4>")
                html_parts.append(f"<pre>{value}</pre>")

        html_parts.append("</div>")
        return {"text/html": "\n".join(html_parts)}
