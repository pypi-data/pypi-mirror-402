"""
Command execution engine for GCP CLI.
"""

import os
import tempfile
import subprocess
import logging
from typing import Optional
from .ai_generator import AICommandGenerator
from .config import ConfigManager
from .credentials import CredentialManager
from .utils import print_code, print_success, print_error, confirm_action, save_command_history

logger = logging.getLogger(__name__)


class GCPCommandExecutor:
    """Executes GCP commands generated by AI."""
    
    def __init__(
        self,
        config: Optional[ConfigManager] = None,
        credentials: Optional[CredentialManager] = None,
        ai_generator: Optional[AICommandGenerator] = None
    ):
        """
        Initialize command executor.
        
        Args:
            config: Configuration manager
            credentials: Credential manager
            ai_generator: AI command generator
        """
        self.config = config or ConfigManager()
        self.credentials = credentials or CredentialManager()
        
        # Set up credentials in environment
        self.credentials.set_environment_credentials()
        
        # Initialize AI generator
        self.ai_generator = ai_generator or AICommandGenerator(
            config=self.config,
            credentials=self.credentials
        )
        
        logger.info("Initialized GCP command executor")
    
    def execute_natural_query(
        self,
        query: str,
        preview: Optional[bool] = None,
        dry_run: bool = False,
        additional_context: Optional[str] = None
    ) -> dict:
        """
        Execute a natural language query.
        
        Args:
            query: Natural language query (e.g., "list all compute instances")
            preview: Whether to preview code before execution (uses config default if None)
            dry_run: If True, only generate and display code without executing
            additional_context: Optional additional context for generation
            
        Returns:
            Dictionary with execution results
        """
        result = {
            'query': query,
            'code': None,
            'output': None,
            'error': None,
            'executed': False
        }
        
        try:
            # Generate command
            logger.info(f"Processing query: {query}")
            code = self.ai_generator.generate_command(
                query=query,
                credentials_path=self.credentials.credentials_path,
                additional_context=additional_context
            )
            
            result['code'] = code
            
            # Validate code
            if not self.ai_generator.validate_code(code):
                result['error'] = "Generated code has syntax errors"
                print_error("Generated code has syntax errors")
                return result
            
            # Preview code if enabled
            if preview is None:
                preview = self.config.get('preview_before_execute', True)
            
            if preview or dry_run:
                print_code(code, language="python", title="Generated GCP Command")
            
            # Dry run mode - don't execute
            if dry_run:
                logger.info("Dry run mode - skipping execution")
                return result
            
            # Ask for confirmation if preview is enabled
            if preview:
                if not confirm_action("Execute this command?", default=False):
                    logger.info("Execution cancelled by user")
                    result['error'] = "Execution cancelled by user"
                    return result
            
            # Execute the code
            output, error = self._execute_code(code)
            
            result['output'] = output
            result['error'] = error
            result['executed'] = True
            
            if error:
                print_error(f"Execution failed: {error}")
            else:
                print_success("Command executed successfully")
            
            # Save to history
            save_command_history(query)
            
            return result
            
        except Exception as e:
            logger.error(f"Failed to execute query: {e}")
            result['error'] = str(e)
            print_error(f"Error: {e}")
            return result
    
    def _execute_code(self, code: str) -> tuple:
        """
        Execute Python code in a temporary file.
        
        Args:
            code: Python code to execute
            
        Returns:
            Tuple of (output, error)
        """
        output = None
        error = None
        
        # Write code to temporary file
        with tempfile.NamedTemporaryFile(
            mode='w',
            delete=False,
            suffix='.py'
        ) as script_file:
            script_file.write(code)
            script_filename = script_file.name
        
        try:
            # Execute the script
            logger.info(f"Executing script: {script_filename}")
            
            result = subprocess.run(
                ['python3', script_filename],
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            output = result.stdout
            if result.stderr:
                error = result.stderr
            
            if result.returncode != 0:
                logger.error(f"Script execution failed with return code {result.returncode}")
                if not error:
                    error = f"Process exited with code {result.returncode}"
            
        except subprocess.TimeoutExpired:
            error = "Script execution timed out (5 minutes)"
            logger.error(error)
        except Exception as e:
            error = str(e)
            logger.error(f"Failed to execute script: {e}")
        finally:
            # Clean up temporary file
            try:
                os.remove(script_filename)
            except:
                pass
        
        return output, error
    
    def execute_script_file(self, script_path: str, preview: bool = True) -> dict:
        """
        Execute a Python script file.
        
        Args:
            script_path: Path to Python script
            preview: Whether to preview code before execution
            
        Returns:
            Dictionary with execution results
        """
        result = {
            'script_path': script_path,
            'code': None,
            'output': None,
            'error': None,
            'executed': False
        }
        
        try:
            # Read script
            with open(script_path, 'r') as f:
                code = f.read()
            
            result['code'] = code
            
            # Preview if enabled
            if preview:
                print_code(code, language="python", title=f"Script: {script_path}")
                if not confirm_action("Execute this script?", default=False):
                    result['error'] = "Execution cancelled by user"
                    return result
            
            # Execute
            output, error = self._execute_code(code)
            
            result['output'] = output
            result['error'] = error
            result['executed'] = True
            
            if error:
                print_error(f"Script execution failed: {error}")
            else:
                print_success("Script executed successfully")
            
            return result
            
        except Exception as e:
            logger.error(f"Failed to execute script: {e}")
            result['error'] = str(e)
            print_error(f"Error: {e}")
            return result
