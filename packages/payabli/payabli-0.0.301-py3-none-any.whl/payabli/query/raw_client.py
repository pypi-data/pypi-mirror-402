# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.bad_request_error import BadRequestError
from ..errors.internal_server_error import InternalServerError
from ..errors.service_unavailable_error import ServiceUnavailableError
from ..errors.unauthorized_error import UnauthorizedError
from ..query_types.types.limit_record import LimitRecord
from ..query_types.types.list_organizations_response import ListOrganizationsResponse
from ..query_types.types.query_batches_detail_response import QueryBatchesDetailResponse
from ..query_types.types.query_batches_response import QueryBatchesResponse
from ..query_types.types.query_transfer_detail_response import QueryTransferDetailResponse
from ..types.entry import Entry
from ..types.export_format import ExportFormat
from ..types.orgid import Orgid
from ..types.payabli_api_response import PayabliApiResponse
from ..types.query_batches_out_response import QueryBatchesOutResponse
from ..types.query_chargebacks_response import QueryChargebacksResponse
from ..types.query_customer_response import QueryCustomerResponse
from ..types.query_entrypoint_response import QueryEntrypointResponse
from ..types.query_payout_transaction import QueryPayoutTransaction
from ..types.query_response_notification_reports import QueryResponseNotificationReports
from ..types.query_response_notifications import QueryResponseNotifications
from ..types.query_response_settlements import QueryResponseSettlements
from ..types.query_response_transactions import QueryResponseTransactions
from ..types.query_response_vendors import QueryResponseVendors
from ..types.query_subscription_response import QuerySubscriptionResponse
from ..types.query_user_response import QueryUserResponse
from ..types.transfer_query_response import TransferQueryResponse
from ..types.v_card_query_response import VCardQueryResponse


class RawQueryClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_batch_details(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryBatchesDetailResponse]:
        """
        Retrieve a list of batches and their details, including settled and
        unsettled transactions for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `settlementDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `gatewayTransId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `settledAmount`  (gt, ge, lt, le, eq, ne)
            - `operation`    (in, nin, eq, ne)
            - `source`   (in, nin, eq, ne)
            - `batchNumber`  (ct, nct, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `isHold` (eq, ne)
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `batchId` (ct, nct, eq, neq)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**

            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `settledAmount(gt)=20` returns all records with a `settledAmount` greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryBatchesDetailResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/batchDetails/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryBatchesDetailResponse,
                    parse_obj_as(
                        type_=QueryBatchesDetailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_batch_details_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryResponseSettlements]:
        """
        Retrieve a list of batches and their details, including settled and unsettled transactions for an organization. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `settlementDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `gatewayTransId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `settledAmount`  (gt, ge, lt, le, eq, ne)
            - `operation`    (in, nin, eq, ne)
            - `source`   (in, nin, eq, ne)
            - `batchNumber`  (ct, nct, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `isHold` (eq, ne)
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `batchId` (ct, nct, eq, neq)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**

            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `settledAmount(gt)=20` returns all records with a `settledAmount` greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryResponseSettlements]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/batchDetails/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseSettlements,
                    parse_obj_as(
                        type_=QueryResponseSettlements,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_batches(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryBatchesResponse]:
        """
        Retrieve a list of batches for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `batchDate` (gt, ge, lt, le, eq, ne)
            - `batchNumber` (ne, eq)
            - `method` (in, nin, eq, ne)
            - `connectorName` (ne, eq, ct, nct)
            - `batchAmount` (gt, ge, lt, le, eq, ne)
            - `feeBatchAmount` (gt, ge, lt, le, eq, ne)
            - `netBatchAmount` (gt, ge, lt, le, eq, ne)
            - `releaseAmount` (gt, ge, lt, le, eq, ne)
            - `heldAmount` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `paypointId` (ne, eq)
            - `externalPaypointID` (ct, nct, eq, ne)
            - `expectedDepositDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `batchRecords` (gt, ge, lt, le, eq, ne)
            - `transferId` (ne, eq)
            - `transferDate` (gt, ge, lt, le, eq, ne)
            - `grossAmount` (gt, ge, lt, le, eq, ne)
            - `chargeBackAmount` (gt, ge, lt, le, eq, ne)
            - `returnedAmount` (gt, ge, lt, le, eq, ne)
            - `billingFeeAmount` (gt, ge, lt, le, eq, ne)
            - `thirdPartyPaidAmount` (gt, ge, lt, le, eq, ne)
            - `netFundedAmount` (gt, ge, lt, le, eq, ne)
            - `adjustmentAmount` (gt, ge, lt, le, eq, ne)
            - `processor` (ne, eq, ct, nct)
            - `transferStatus` (ne, eq, in, nin)

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `batchAmount(gt)=20` returns all records with a `batchAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryBatchesResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/batches/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryBatchesResponse,
                    parse_obj_as(
                        type_=QueryBatchesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_batches_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryBatchesResponse]:
        """
        Retrieve a list of batches for an org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `batchDate` (gt, ge, lt, le, eq, ne)
            - `batchNumber` (ne, eq)
            - `method` (in, nin, eq, ne)
            - `connectorName` (ne, eq, ct, nct)
            - `batchAmount` (gt, ge, lt, le, eq, ne)
            - `feeBatchAmount` (gt, ge, lt, le, eq, ne)
            - `netBatchAmount` (gt, ge, lt, le, eq, ne)
            - `releaseAmount` (gt, ge, lt, le, eq, ne)
            - `heldAmount` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `paypointId` (ne, eq)
            - `externalPaypointID` (ct, nct, eq, ne)
            - `expectedDepositDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `batchRecords` (gt, ge, lt, le, eq, ne)
            - `transferId` (ne, eq)
            - `transferDate` (gt, ge, lt, le, eq, ne)
            - `grossAmount` (gt, ge, lt, le, eq, ne)
            - `chargeBackAmount` (gt, ge, lt, le, eq, ne)
            - `returnedAmount` (gt, ge, lt, le, eq, ne)
            - `billingFeeAmount` (gt, ge, lt, le, eq, ne)
            - `thirdPartyPaidAmount` (gt, ge, lt, le, eq, ne)
            - `netFundedAmount` (gt, ge, lt, le, eq, ne)
            - `adjustmentAmount` (gt, ge, lt, le, eq, ne)
            - `processor` (ne, eq, ct, nct)
            - `transferStatus` (ne, eq, in, nin)

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `batchAmount(gt)=20` returns all records with a `batchAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryBatchesResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/batches/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryBatchesResponse,
                    parse_obj_as(
                        type_=QueryBatchesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_batches_out(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryBatchesOutResponse]:
        """
        Retrieve a list of MoneyOut batches for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query. See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted**:

            - `batchDate` (gt, ge, lt, le, eq, ne)
            - `batchNumber` (ne, eq)
            - `batchAmount` (gt, ge, lt, le, eq, ne)
            - `parentOrgId` (ne, eq, nin, in)
            - `status` (in, nin, eq, ne)
            - `orgId` (eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `paypointId` (ne, eq)
            - `externalPaypointID` (ct, nct, eq, ne)

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryBatchesOutResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/batchesOut/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryBatchesOutResponse,
                    parse_obj_as(
                        type_=QueryBatchesOutResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_batches_out_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryBatchesOutResponse]:
        """
        Retrieve a list of MoneyOut batches for an org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted**:

            - `batchDate` (gt, ge, lt, le, eq, ne)
            - `batchNumber` (ne, eq)
            - `batchAmount` (gt, ge, lt, le, eq, ne)
            - `parentOrgId` (ne, eq, nin, in)
            - `status` (in, nin, eq, ne)
            - `orgId` (eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `paypointId` (ne, eq)
            - `externalPaypointID` (ct, nct, eq, ne)

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryBatchesOutResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/batchesOut/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryBatchesOutResponse,
                    parse_obj_as(
                        type_=QueryBatchesOutResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_chargebacks(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryChargebacksResponse]:
        """
        Retrieves a list of chargebacks and returned transactions for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            **List of field names accepted:**
            - `chargebackDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `netAmount`  (gt, ge, lt, le, eq, ne)
            - `reasonCode`   (in, nin, eq, ne)
            - `reason`  (ct, nct, eq, ne)
            - `replyDate` (gt, ge, lt, le, eq, ne)
            - `caseNumber`  (ct, nct, eq, ne)
            - `status`   (in, nin, eq, ne)
            - `accountType`   (in, nin, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted - enclosed between parentheses:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryChargebacksResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/chargebacks/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryChargebacksResponse,
                    parse_obj_as(
                        type_=QueryChargebacksResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_chargebacks_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryChargebacksResponse]:
        """
        Retrieve a list of chargebacks and returned transactions for an org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.

            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info> See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            **List of field names accepted:**

            - `chargebackDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `netAmount`  (gt, ge, lt, le, eq, ne)
            - `reasonCode`   (in, nin, eq, ne)
            - `reason`  (ct, nct, eq, ne)
            - `replyDate` (gt, ge, lt, le, eq, ne)
            - `caseNumber`  (ct, nct, eq, ne)
            - `status`   (in, nin, eq, ne)
            - `accountType`   (in, nin, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted - enclosed between parentheses:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryChargebacksResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/chargebacks/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryChargebacksResponse,
                    parse_obj_as(
                        type_=QueryChargebacksResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_customers(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryCustomerResponse]:
        """
        Retrieves a list of customers for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more details.

            **List of Accepted Field Names:**

            - `createdDate` (gt, ge, lt, le, eq, ne)
            - `customernumber` (ne, eq, ct, nct)
            - `firstname` (ne, eq, ct, nct)
            - `lastname` (ne, eq, ct, nct)
            - `name` (ct, nct)
            - `address` (ne, eq, ct, nct)
            - `city` (ne, eq, ct, nct)
            - `country` (ne, eq, ct, nct)
            - `zip` (ne, eq, ct, nct)
            - `state` (ne, eq, ct, nct)
            - `shippingaddress` (ne, eq, ct, nct)
            - `shippingcity` (ne, eq, ct, nct)
            - `shippingcountry` (ne, eq, ct, nct)
            - `shippingzip` (ne, eq, ct, nct)
            - `shippingstate` (ne, eq, ct, nct)
            - `phone` (ne, eq, ct, nct)
            - `email` (ne, eq, ct, nct)
            - `company` (ne, eq, ct, nct)
            - `username` (ne, eq, ct, nct)
            - `balance` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name
            - `orgId` (eq) *mandatory when entry=org*
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)

            **List of Accepted Comparisons:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **Accepted Parameters:**
            - `limitRecord`: Max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: Initial record in query

            **Example Usage:**
            `balance(gt)=20` will return all records with a balance greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryCustomerResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/customers/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryCustomerResponse,
                    parse_obj_as(
                        type_=QueryCustomerResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_customers_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryCustomerResponse]:
        """
        Retrieves a list of customers for an org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more details.

            **List of Accepted Field Names:**

            - `createdDate` (gt, ge, lt, le, eq, ne)
            - `customernumber` (ne, eq, ct, nct)
            - `firstname` (ne, eq, ct, nct)
            - `lastname` (ne, eq, ct, nct)
            - `name` (ct, nct)
            - `address` (ne, eq, ct, nct)
            - `city` (ne, eq, ct, nct)
            - `country` (ne, eq, ct, nct)
            - `zip` (ne, eq, ct, nct)
            - `state` (ne, eq, ct, nct)
            - `shippingaddress` (ne, eq, ct, nct)
            - `shippingcity` (ne, eq, ct, nct)
            - `shippingcountry` (ne, eq, ct, nct)
            - `shippingzip` (ne, eq, ct, nct)
            - `shippingstate` (ne, eq, ct, nct)
            - `phone` (ne, eq, ct, nct)
            - `email` (ne, eq, ct, nct)
            - `company` (ne, eq, ct, nct)
            - `username` (ne, eq, ct, nct)
            - `balance` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name
            - `orgId` (eq) *mandatory when entry=org*
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)

            **List of Accepted Comparisons:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **Accepted Parameters:**
            - `limitRecord`: Max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: Initial record in query

            **Example Usage:**
            `balance(gt)=20` will return all records with a balance greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryCustomerResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/customers/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryCustomerResponse,
                    parse_obj_as(
                        type_=QueryCustomerResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_notification_reports(
        self,
        entry: Entry,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryResponseNotificationReports]:
        """
        Returns a list of all reports generated in the last 60 days for a single entrypoint. Use filters to limit results.

        Parameters
        ----------
        entry : Entry

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `reportName` (ct, nct, eq, ne)
            - `createdAt` (gt, ge, lt, le, eq, ne)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array
            - nin => not inside array

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: reportName(ct)=tr  return all records containing the string "tr"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryResponseNotificationReports]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/notificationReports/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseNotificationReports,
                    parse_obj_as(
                        type_=QueryResponseNotificationReports,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_notification_reports_org(
        self,
        org_id: int,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryResponseNotificationReports]:
        """
        Returns a list of all reports generated in the last 60 days for an organization. Use filters to limit results.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `reportName` (ct, nct, eq, ne)
            - `createdAt` (gt, ge, lt, le, eq, ne)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array
            - nin => not inside array

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: reportName(ct)=tr  return all records containing the string "tr"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryResponseNotificationReports]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/notificationReports/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseNotificationReports,
                    parse_obj_as(
                        type_=QueryResponseNotificationReports,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_notifications(
        self,
        entry: Entry,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryResponseNotifications]:
        """
        Returns a list of notifications for an entrypoint. Use filters to limit results.

        Parameters
        ----------
        entry : Entry

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `frequency` (in, nin,ne, eq)
            - `method` (in, nin, eq, ne)
            - `event` (in, nin, eq, ne)
            - `target` (ct, nct, eq, ne)
            - `status` (eq, ne)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array
            - nin => not inside array

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: totalAmount(gt)=20  return all records with totalAmount greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryResponseNotifications]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/notifications/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseNotifications,
                    parse_obj_as(
                        type_=QueryResponseNotifications,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_notifications_org(
        self,
        org_id: int,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryResponseNotifications]:
        """
        Return a list of notifications for an organization. Use filters to limit results.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `frequency` (in, nin,ne, eq)
            - `method` (in, nin, eq, ne)
            - `event` (in, nin, eq, ne)
            - `target` (ct, nct, eq, ne)
            - `status` (eq, ne)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array
            - nin => not inside array

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: totalAmount(gt)=20  return all records with totalAmount greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryResponseNotifications]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/notifications/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseNotifications,
                    parse_obj_as(
                        type_=QueryResponseNotifications,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_organizations(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListOrganizationsResponse]:
        """
        Retrieves a list of an organization's suborganizations and their full details such as orgId, users, and settings. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            **List of field names accepted:**

            - `createdAt` (gt, ge, lt, le, eq, ne)
            - `startDate` (gt, ge, lt, le, eq, ne)
            - `dbaname`  (ct, nct)
            - `legalname`  (ct, nct)
            - `ein`  (ct, nct)
            - `address`  (ct, nct)
            - `city`  (ct, nct)
            - `state`  (ct, nct)
            - `phone`  (ct, nct)
            - `mcc`  (ct, nct)
            - `owntype`  (ct, nct)
            - `ownerName`  (ct, nct)
            - `contactName`  (ct, nct)
            - `orgParentname`  (ct, nct)
            - `boardingId` (eq, ne)
            - `entryName`  (ct, nct)

            **List of comparison accepted - enclosed between parentheses:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array

            **List of parameters accepted:**

            - `limitRecord` : max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord` : initial record in query

            Example: `dbaname(ct)=hoa` returns all records with a `dbaname` containing "hoa"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListOrganizationsResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/organizations/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListOrganizationsResponse,
                    parse_obj_as(
                        type_=ListOrganizationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_payout(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryPayoutTransaction]:
        """
        Retrieves a list of money out transactions (payouts) for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            List of field names accepted:

              - `status` (in, nin, eq, ne)
              - `transactionDate` (gt, ge, lt, le, eq, ne)
              - `billNumber` (ct, nct)
              - `vendorNumber` (ct, nct, eq, ne)
              - `vendorName` (ct, nct, eq, ne)
              - `paymentMethod` (ct, nct, eq, ne, in, nin)
              - `paymentId` (ct, nct, eq, ne)
              - `parentOrgId` (ne, eq, nin, in)
              - `batchNumber` (ct, nct, eq, ne)
              - `totalAmount` (gt, ge, lt, le, eq, ne)
              - `paypointLegal` (ne, eq, ct, nct)
              - `paypointDba` (ne, eq, ct, nct)
              - `accountId` (ne, eq, ct, nct)
              - `orgName` (ne, eq, ct, nct)
              - `externalPaypointID` (ct, nct, eq, ne)
              - `paypointId` (eq, ne)
              - `vendorId` (eq, ne)
              - `vendorEIN` (ct, nct, eq, ne)
              - `vendorPhone` (ct, nct, eq, ne)
              - `vendorEmail` (ct, nct, eq, ne)
              - `vendorAddress` (ct, nct, eq, ne)
              - `vendorCity` (ct, nct, eq, ne)
              - `vendorState` (ct, nct, eq, ne)
              - `vendorCountry` (ct, nct, eq, ne)
              - `vendorZip` (ct, nct, eq, ne)
              - `vendorMCC` (ct, nct, eq, ne)
              - `vendorLocationCode` (ct, nct, eq, ne)
              - `vendorCustomField1` (ct, nct, eq, ne)
              - `vendorCustomField2` (ct, nct, eq, ne)
              - `comments` (ct, nct)
              - `payaccountCurrency` (ne, eq, in, nin)
              - `remitAddress` (ct, nct)
              - `source` (ct, nct, eq, ne)
              - `updatedOn` (gt, ge, lt, le, eq, ne)
              - `feeAmount` (gt, ge, lt, le, eq, ne)
              - `lotNumber` (ct, nct)
              - `customerVendorAccount` (ct, nct, eq, ne)
              - `batchId` (eq, ne)
              - `AchTraceNumber` (eq, ne)
              - `payoutProgram`(eq, ne) the options are `managed` or `odp`. For example, `payoutProgram(eq)=managed` returns all records with a `payoutProgram` equal to `managed`.

              List of comparison accepted - enclosed between parentheses:
              - eq or empty => equal
              - gt => greater than
              - ge => greater or equal
              - lt => less than
              - le => less or equal
              - ne => not equal
              - ct => contains
              - nct => not contains
              - in => inside array separated by \\"|\\"
              - nin => not inside array separated by \\"|\\"

              List of parameters accepted:

              - limitRecord : max number of records for query (default=\\"20\\", \\"0\\" or negative value for all)
              - fromRecord : initial record in query
              - sortBy : indicate field name and direction to sort the results

              Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

              Example: `sortBy=desc(netamount)` returns all records sorted by `netAmount` descending

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryPayoutTransaction]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/payouts/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryPayoutTransaction,
                    parse_obj_as(
                        type_=QueryPayoutTransaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_payout_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryPayoutTransaction]:
        """
        Retrieves a list of money out transactions (payouts) for an organization. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            List of field names accepted:

              - `status` (in, nin, eq, ne)
              - `transactionDate` (gt, ge, lt, le, eq, ne)
              - `billNumber` (ct, nct)
              - `vendorNumber` (ct, nct, eq, ne)
              - `vendorName` (ct, nct, eq, ne)
              - `parentOrgId` (ne, eq, nin, in)
              - `paymentMethod` (ct, nct, eq, ne, in, nin)
              - `paymentId` (ct, nct, eq, ne)
              - `batchNumber` (ct, nct, eq, ne)
              - `totalAmount` (gt, ge, lt, le, eq, ne)
              - `paypointLegal` (ne, eq, ct, nct)
              - `paypointDba` (ne, eq, ct, nct)
              - `accountId` (ne, eq, ct, nct)
              - `orgName` (ne, eq, ct, nct)
              - `externalPaypointID` (ct, nct, eq, ne)
              - `paypointId` (eq, ne)
              - `vendorId` (eq, ne)
              - `vendorEIN` (ct, nct, eq, ne)
              - `vendorPhone` (ct, nct, eq, ne)
              - `vendorEmail` (ct, nct, eq, ne)
              - `vendorAddress` (ct, nct, eq, ne)
              - `vendorCity` (ct, nct, eq, ne)
              - `vendorState` (ct, nct, eq, ne)
              - `vendorCountry` (ct, nct, eq, ne)
              - `vendorZip` (ct, nct, eq, ne)
              - `vendorMCC` (ct, nct, eq, ne)
              - `vendorLocationCode` (ct, nct, eq, ne)
              - `vendorCustomField1` (ct, nct, eq, ne)
              - `vendorCustomField2` (ct, nct, eq, ne)
              - `comments` (ct, nct)
              - `payaccountCurrency` (ne, eq, in, nin)
              - `remitAddress` (ct, nct)
              - `source` (ct, nct, eq, ne)
              - `updatedOn` (gt, ge, lt, le, eq, ne)
              - `feeAmount` (gt, ge, lt, le, eq, ne)
              - `lotNumber` (ct, nct)
              - `customerVendorAccount` (ct, nct, eq, ne)
              - `batchId` (eq, ne)
              - `AchTraceNumber` (eq, ne)
              - `payoutProgram`(eq, ne) the options are `managed` or `odp`. For example, `payoutProgram(eq)=managed` returns all records with a `payoutProgram` equal to `managed`.

              List of comparison accepted - enclosed between parentheses:
              - eq or empty => equal
              - gt => greater than
              - ge => greater or equal
              - lt => less than
              - le => less or equal
              - ne => not equal
              - ct => contains
              - nct => not contains
              - in => inside array separated by \\"|\\"
              - nin => not inside array separated by \\"|\\"

              List of parameters accepted:

              - limitRecord : max number of records for query (default=\\"20\\", \\"0\\" or negative value for all)
              - fromRecord : initial record in query
              - sortBy : indicate field name and direction to sort the results

              Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

              Example: `sortBy=desc(netamount)` returns all records sorted by `netAmount` descending

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryPayoutTransaction]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/payouts/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryPayoutTransaction,
                    parse_obj_as(
                        type_=QueryPayoutTransaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_paypoints(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryEntrypointResponse]:
        """
        Returns a list of paypoints in an organization. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            **List of field names accepted:**

            - `createdAt` (gt, ge, lt, le, eq, ne)
            - `lastModified` (gt, ge, lt, le, eq, ne)
            - `startDate` (gt, ge, lt, le, eq, ne)
            - `dbaname`  (ct, nct)
            - `status` (eq, ne)
            - `legalname`  (ct, nct)
            - `externalPaypointID` (ct, nct)
            - `ein`  (ct, nct)
            - `address`  (ct, nct)
            - `city`  (ct, nct)
            - `state`  (ct, nct)
            - `phone`  (ct, nct)
            - `mcc`  (ct, nct)
            - `owntype`  (ct, nct)
            - `ownerName`  (ct, nct)
            - `contactName`  (ct, nct)
            - `paypointId` (eq, ne)
            - `orgParentname`  (ct, nct, in, nin)
            - `boardingId` (eq, ne)
            - `entryName`  (ct, nct)
            - `externalOrgID` (ct, nct)

            **List of comparison accepted - enclosed between parentheses:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array

            **List of parameters accepted:**

            - `limitRecord` : max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord` : initial record in query

            Example: `dbaname(ct)=hoa` returns all records with a `dbaname` containing "hoa"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryEntrypointResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/paypoints/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryEntrypointResponse,
                    parse_obj_as(
                        type_=QueryEntrypointResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_settlements(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryResponseSettlements]:
        """
        Retrieve a list of settled transactions for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `settlementDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `gatewayTransId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `settledAmount`  (gt, ge, lt, le, eq, ne)
            - `operation`    (in, nin, eq, ne)
            - `source`   (in, nin, eq, ne)
            - `batchNumber`  (ct, nct, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `isHold` (eq, ne)
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `batchId` (ct, nct, eq, neq)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**

            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `settledAmount(gt)=20` returns all records with a `settledAmount` greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryResponseSettlements]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/settlements/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseSettlements,
                    parse_obj_as(
                        type_=QueryResponseSettlements,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_settlements_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryResponseSettlements]:
        """
        Retrieve a list of settled transactions for an organization. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `settlementDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `gatewayTransId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `settledAmount`  (gt, ge, lt, le, eq, ne)
            - `operation`    (in, nin, eq, ne)
            - `source`   (in, nin, eq, ne)
            - `batchNumber`  (ct, nct, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `isHold` (eq, ne)
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `batchId` (ct, nct, eq, neq)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**

            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `settledAmount(gt)=20` returns all records with a `settledAmount` greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryResponseSettlements]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/settlements/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseSettlements,
                    parse_obj_as(
                        type_=QueryResponseSettlements,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_subscriptions(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QuerySubscriptionResponse]:
        """
        Returns a list of subscriptions for a single paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `startDate` (gt, ge, lt, le, eq, ne)
            - `endDate` (gt, ge, lt, le, eq, ne)
            - `nextDate` (gt, ge, lt, le, eq, ne)
            - `frequency` (in, nin, ne, eq)
            - `method` (in, nin, eq, ne)
            - `totalAmount` (gt, ge, lt, le, eq, ne)
            - `netAmount` (gt, ge, lt, le, eq, ne)
            - `feeAmount` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `untilcancelled` (eq, ne)
            - `payaccountLastfour` (nct, ct)
            - `payaccountType` (ne, eq, in, nin)
            - `payaccountCurrency` (ne, eq, in, nin)
            - `customerFirstname` (ct, nct, eq, ne)
            - `customerLastname` (ct, nct, eq, ne)
            - `customerName` (ct, nct)
            - `customerId` (eq, ne)
            - `customerNumber` (ct, nct, eq, ne)
            - `customerCompanyname` (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity` (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity` (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId` (eq)
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `externalPaypointId` (ct, nct, ne, eq)
            - `subId` (eq, ne)
            - `orderDescription` (ct, nct)
            - `cycles` (eq, ne, gt, ge, lt, le)
            - `leftcycles` (eq, ne, gt, ge, lt, le)
            - `createdAt` (eq, ne, gt, ge, lt, le)
            - `updatedOn` (eq, ne, gt, ge, lt, le)
            - `invoiceNumber` (ct, nct)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison operators accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QuerySubscriptionResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/subscriptions/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QuerySubscriptionResponse,
                    parse_obj_as(
                        type_=QuerySubscriptionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_subscriptions_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QuerySubscriptionResponse]:
        """
        Returns a list of subscriptions for a single org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `startDate` (gt, ge, lt, le, eq, ne)
            - `endDate` (gt, ge, lt, le, eq, ne)
            - `nextDate` (gt, ge, lt, le, eq, ne)
            - `frequency` (in, nin, ne, eq)
            - `method` (in, nin, eq, ne)
            - `totalAmount` (gt, ge, lt, le, eq, ne)
            - `netAmount` (gt, ge, lt, le, eq, ne)
            - `feeAmount` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `untilcancelled` (eq, ne)
            - `payaccountLastfour` (nct, ct)
            - `payaccountType` (ne, eq, in, nin)
            - `payaccountCurrency` (ne, eq, in, nin)
            - `customerFirstname` (ct, nct, eq, ne)
            - `customerLastname` (ct, nct, eq, ne)
            - `customerName` (ct, nct)
            - `customerId` (eq, ne)
            - `customerNumber` (ct, nct, eq, ne)
            - `customerCompanyname` (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity` (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity` (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId` (eq)
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `externalPaypointId` (ct, nct, ne, eq)
            - `subId` (eq, ne)
            - `orderDescription` (ct, nct)
            - `cycles` (eq, ne, gt, ge, lt, le)
            - `leftcycles` (eq, ne, gt, ge, lt, le)
            - `createdAt` (eq, ne, gt, ge, lt, le)
            - `updatedOn` (eq, ne, gt, ge, lt, le)
            - `invoiceNumber` (ct, nct)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison operators accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QuerySubscriptionResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/subscriptions/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QuerySubscriptionResponse,
                    parse_obj_as(
                        type_=QuerySubscriptionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_transactions(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryResponseTransactions]:
        """
        Retrieve a list of transactions for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.
        By default, this endpoint returns only transactions from the last 60 days. To query transactions outside of this period, include `transactionDate` filters.
        For example, this request parameters filter for transactions between April 01, 2024 and April 09, 2024. 
        ``` curl --request GET \\
          --url https://sandbox.payabli.com/api/Query/transactions/org/1?limitRecord=20&fromRecord=0&transactionDate(ge)=2024-04-01T00:00:00&transactionDate(le)=2024-04-09T23:59:59\\
          --header 'requestToken: <api-key>'
        
          ```
        
        Parameters
        ----------
        entry : Entry
        
        export_format : typing.Optional[ExportFormat]
        
        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.
        
        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.
        
        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            
            Collection of field names, conditions, and values used to filter the query. 
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**
            
              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.
            
              For example:
            
              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20
            
              should become:
            
              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.
            
            **List of field names accepted:**
            
            - `transactionDate` (gt, ge, lt, le, eq, ne)
            - `transId` (ne, eq, ct, nct, in, nin)
            - `gatewayTransId` (ne, eq, ct, nct)
            - `orderId` (ne, eq)
            - `scheduleId` (ne, eq)
            - `returnId` (ne, eq)
            - `refundId` (ne, eq)
            - `idTrans` (ne, eq)
            - `orgId` (ne, eq)
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `externalPaypointId` (ct, nct, eq, ne)
            - `method` (in, nin, eq, ne)
            - `totalAmount` (gt, ge, lt, le, eq, ne)
            - `netAmount` (gt, ge, lt, le, eq, ne)
            - `feeAmount` (gt, ge, lt, le, eq, ne)
            - `operation` (in, nin, eq, ne)
            - `source` (in, nin, eq, ne, ct, nct)
            - `status` (in, nin, eq, ne)
            - `settlementStatus` (in, nin, eq, ne)
            - `batchNumber` (nct, ct)
            - `invoiceNumber` (ct, nct)
            - `ipAddress` (eq, ne)
            - `authCode` (ct, nct)
            - `orderDescription` (ct, nct)
            - `payaccountLastfour` (nct, ct)
            - `payaccountType` (ne, eq, in, nin)
            - `payaccountCurrency` (ne, eq, in, nin)
            - `customerFirstname` (ct, nct, eq, ne)
            - `customerLastname` (ct, nct, eq, ne)
            - `customerName` (ct, nct)
            - `customerId` (eq, ne)
            - `customerNumber` (ct, nct, eq, ne)
            - `customerCompanyname` (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity` (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity` (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `deviceId` (ct, nct, in, nin, eq, ne)
            - `AchSecCode` ( ct, nct, in, nin, eq, ne)
            - `AchHolderType` (ct, nct, in, nin, eq, and ne)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name related to customer data
            - 'invoiceAdditional-xxx' (ne, eq, ct, nct) where xxx is the additional field name related to invoice data
            
            **List of comparison operators accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array      
        
        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        HttpResponse[QueryResponseTransactions]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/transactions/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseTransactions,
                    parse_obj_as(
                        type_=QueryResponseTransactions,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_transactions_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryResponseTransactions]:
        """
        
        Retrieve a list of transactions for an organization. Use filters to
        limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.
        
        
        By default, this endpoint returns only transactions from the last 60 days. To query transactions outside of this period, include `transactionDate` filters.
        
        For example, this request parameters filter for transactions between April 01, 2024 and April 09, 2024. 
        
        ```
        curl --request GET \\
          --url https://sandbox.payabli.com/api/Query/transactions/org/1?limitRecord=20&fromRecord=0&transactionDate(ge)=2024-04-01T00:00:00&transactionDate(le)=2024-04-09T23:59:59\\
          --header 'requestToken: <api-key>'
        
          ```
        
        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.
        
        export_format : typing.Optional[ExportFormat]
        
        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.
        
        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.
        
        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            
            Collection of field names, conditions, and values used to filter the query. 
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**
            
              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.
            
              For example:
            
              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20
            
              should become:
            
              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.
            
            **List of field names accepted:**
            
            - `transactionDate` (gt, ge, lt, le, eq, ne)
            - `transId` (ne, eq, ct, nct, in, nin)
            - `gatewayTransId` (ne, eq, ct, nct)
            - `orderId` (ne, eq)
            - `scheduleId` (ne, eq)
            - `returnId` (ne, eq)
            - `refundId` (ne, eq)
            - `idTrans` (ne, eq)
            - `orgId` (ne, eq)
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `externalPaypointId` (ct, nct, eq, ne)
            - `method` (in, nin, eq, ne)
            - `totalAmount` (gt, ge, lt, le, eq, ne)
            - `netAmount` (gt, ge, lt, le, eq, ne)
            - `feeAmount` (gt, ge, lt, le, eq, ne)
            - `operation` (in, nin, eq, ne)
            - `source` (in, nin, eq, ne, ct, nct)
            - `status` (in, nin, eq, ne)
            - `settlementStatus` (in, nin, eq, ne)
            - `batchNumber` (nct, ct)
            - `invoiceNumber` (ct, nct)
            - `authCode` (ct, nct)
            - `orderDescription` (ct, nct)
            - `payaccountLastfour` (nct, ct)
            - `payaccountType` (ne, eq, in, nin)
            - `payaccountCurrency` (ne, eq, in, nin)
            - `customerFirstname` (ct, nct, eq, ne)
            - `customerLastname` (ct, nct, eq, ne)
            - `customerName` (ct, nct)
            - `customerId` (eq, ne)
            - `customerNumber` (ct, nct, eq, ne)
            - `customerCompanyname` (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity` (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity` (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `deviceId` (ct, nct, in, nin, eq, ne)
            - `AchSecCode` ( ct, nct, in, nin, eq, ne)
            - `AchHolderType`` (ct, nct, in, nin, eq, and ne)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name related to customer data
            - 'invoiceAdditional-xxx' (ne, eq, ct, nct) where xxx is the additional field name related to invoice data
            
            **List of comparison operators accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array
              
        
        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        HttpResponse[QueryResponseTransactions]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/transactions/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseTransactions,
                    parse_obj_as(
                        type_=QueryResponseTransactions,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_transfer_details(
        self,
        entry: Entry,
        transfer_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[LimitRecord] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryTransferDetailResponse]:
        """
        Retrieve a list of transfer details records for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        transfer_id : int
            The numeric identifier for the transfer, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[LimitRecord]

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter
            the query.

            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions
            Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference)
            for more information.


            **List of field names accepted:**

              - `grossAmount` (gt, ge, lt, le, eq, ne)
              - `chargeBackAmount` (gt, ge, lt, le, eq, ne)
              - `returnedAmount` (gt, ge, lt, le, eq, ne)
              - `billingFeeAmount` (gt, ge, lt, le, eq, ne)
              - `thirdPartyPaidAmount` (gt, ge, lt, le, eq, ne)
              - `netFundedAmount` (gt, ge, lt, le, eq, ne)
              - `adjustmentAmount` (gt, ge, lt, le, eq, ne)
              - `splitFundingAmount` (gt, ge, lt, le, eq, ne)
              - `operation` (in, nin, eq, ne)
              - `transactionId` (eq, ne, in, nin)
              - `category` (eq, ne, ct, nct)
              - `type` (eq, ne, in, nin)
              - `method` (eq, ne, in, nin)


        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryTransferDetailResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/transferDetails/{jsonable_encoder(entry)}/{jsonable_encoder(transfer_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryTransferDetailResponse,
                    parse_obj_as(
                        type_=QueryTransferDetailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_transfers(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TransferQueryResponse]:
        """
        Retrieve a list of transfers for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query. See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            List of field names accepted:

              - `transferDate` (gt, ge, lt, le, eq, ne)
              - `grossAmount` (gt, ge, lt, le, eq, ne)
              - `chargeBackAmount` (gt, ge, lt, le, eq, ne)
              - `returnedAmount` (gt, ge, lt, le, eq, ne)
              - `billingFeeAmount` (gt, ge, lt, le, eq, ne)
              - `thirdPartyPaidAmount` (gt, ge, lt, le, eq, ne)
              - `netFundedAmount` (gt, ge, lt, le, eq, ne)
              - `adjustmentAmount` (gt, ge, lt, le, eq, ne)
              - `processor` (ne, eq, ct, nct)
              - `transferStatus` (ne, eq, in, nin)
              - `batchNumber` (ne, eq, ct, nct)
              - `batchId` (ne, eq, in, nin)
              - `transferId` (in, nin, eq, ne)
              - `bankAccountNumber` (ct, nct, ne, eq)
              - `bankRoutingNumber` (ct, nct, ne, eq)
              - `batchCurrency` (in, nin, ne, eq)
              - `parentOrgName` (ct, nct, ne, eq)
              - `parentOrgId` (ct, nct, ne, eq)
              - `externalPaypointID` (ct, nct)

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TransferQueryResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/transfers/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransferQueryResponse,
                    parse_obj_as(
                        type_=TransferQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_transfers_org(
        self,
        org_id: Orgid,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TransferQueryResponse]:
        """
        Retrieve a list of transfers for an org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : Orgid

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query. See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            List of field names accepted:

              - `transferDate` (gt, ge, lt, le, eq, ne)
              - `grossAmount` (gt, ge, lt, le, eq, ne)
              - `chargeBackAmount` (gt, ge, lt, le, eq, ne)
              - `returnedAmount` (gt, ge, lt, le, eq, ne)
              - `billingFeeAmount` (gt, ge, lt, le, eq, ne)
              - `thirdPartyPaidAmount` (gt, ge, lt, le, eq, ne)
              - `netFundedAmount` (gt, ge, lt, le, eq, ne)
              - `adjustmentAmount` (gt, ge, lt, le, eq, ne)
              - `processor` (ne, eq, ct, nct)
              - `transferStatus` (ne, eq, in, nin)
              - `batchNumber` (ne, eq, ct, nct)
              - `batchId` (ne, eq, in, nin)
              - `transferId` (in, nin, eq, ne)
              - `bankAccountNumber` (ct, nct, ne, eq)
              - `bankRoutingNumber` (ct, nct, ne, eq)
              - `batchCurrency` (in, nin, ne, eq)

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TransferQueryResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/transfers/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransferQueryResponse,
                    parse_obj_as(
                        type_=TransferQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_users_org(
        self,
        org_id: int,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryUserResponse]:
        """
        Get list of users for an org. Use filters to limit results.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            **List of field names accepted:**

            - `createdDate` (gt, ge, lt, le, eq, ne)
            - `name`  (ne, eq, ct, nct)
            - `email`  (ne, eq, ct, nct)
            - `status`   (in, nin, eq, ne)
            - `role.xxx`  (ne, eq, ct, nct) where xxx is the role field: `roleLabel` or `roleValue`

            **List of comparison accepted - enclosed between parentheses:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `name(ct)=john`  return all records with name containing 'john'.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryUserResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/users/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryUserResponse,
                    parse_obj_as(
                        type_=QueryUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_users_paypoint(
        self,
        entry: str,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryUserResponse]:
        """
        Get list of users for a paypoint. Use filters to limit results.

        Parameters
        ----------
        entry : str
            The paypoint's entrypoint identifier. [Learn more](/api-reference/api-overview#entrypoint-vs-entry)

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            **List of field names accepted:**

            - `createdDate` (gt, ge, lt, le, eq, ne)
            - `name`  (ne, eq, ct, nct)
            - `email`  (ne, eq, ct, nct)
            - `status`   (in, nin, eq, ne)
            - `role.xxx`  (ne, eq, ct, nct) where xxx is the role field: `roleLabel` or `roleValue`

            **List of comparison accepted - enclosed between parentheses:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `name(ct)=john`  return all records with name containing 'john'

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryUserResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/users/point/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryUserResponse,
                    parse_obj_as(
                        type_=QueryUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_vendors(
        self,
        entry: str,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryResponseVendors]:
        """
        Retrieve a list of vendors for an entrypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : str
            The paypoint's entrypoint identifier. [Learn more](/api-reference/api-overview#entrypoint-vs-entry)

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `method` (in, nin, eq, ne)
            - `enrollmentStatus` (in,nin, eq, ne)
            - `status` (in, nin, eq, ne)
            - `vendorNumber` (ct, nct, eq, ne)
            - `name` (ct, nct, eq, ne)
            - `ein` (ct, nct, eq, ne)
            - `phone` (ct, nct, eq, ne)
            - `email` (ct, nct, eq, ne)
            - `address` (ct, nct, eq, ne)
            - `city` (ct, nct, eq, ne)
            - `state` (ct, nct, eq, ne)
            - `country` (ct, nct, eq, ne)
            - `zip` (ct, nct, eq, ne)
            - `mcc` (ct, nct, eq, ne)
            - `locationCode` (ct, nct, eq, ne)
            - `paypointLegal` (ne, eq, ct, nct)
            - `parentOrgId` (ne, eq, nin, in)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array separated by "|"
            - nin => not inside array separated by "|"

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryResponseVendors]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/vendors/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseVendors,
                    parse_obj_as(
                        type_=QueryResponseVendors,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_vendors_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[QueryResponseVendors]:
        """
        Retrieve a list of vendors for an organization. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `method` (in, nin, eq, ne)
            - `enrollmentStatus` (in,nin, eq, ne)
            - `status` (in, nin, eq, ne)
            - `vendorNumber` (ct, nct, eq, ne)
            - `name` (ct, nct, eq, ne)
            - `ein` (ct, nct, eq, ne)
            - `phone` (ct, nct, eq, ne)
            - `email` (ct, nct, eq, ne)
            - `address` (ct, nct, eq, ne)
            - `city` (ct, nct, eq, ne)
            - `state` (ct, nct, eq, ne)
            - `country` (ct, nct, eq, ne)
            - `zip` (ct, nct, eq, ne)
            - `mcc` (ct, nct, eq, ne)
            - `locationCode` (ct, nct, eq, ne)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `parentOrgId` (ne, eq, nin, in)
            - `orgName` (ne, eq, ct, nct)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array separated by "|"
            - nin => not inside array separated by "|"

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[QueryResponseVendors]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/vendors/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseVendors,
                    parse_obj_as(
                        type_=QueryResponseVendors,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_vcards(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[VCardQueryResponse]:
        """
        Retrieve a list of vcards (virtual credit cards) issued for an entrypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            List of field names accepted:

              - `status` (in, nin, eq, ne)
              - `createdAt` (gt, ge, lt, le, eq, ne)
              - `cardToken` (ct, nct, eq, ne)
              - `lastFour` (ct, nct, eq, ne)
              - `expirationDate` (ct, nct, eq, ne)
              - `payoutId` (ct, nct, eq, ne, in, nin)
              - `vendorId` (ct, nct, eq, ne, in, nin)
              - `miscData1` (ct, nct, eq, ne)
              - `miscData2` (ct, nct, eq, ne)
              - `currentUses` (gt, ge, lt, le, eq, ne)
              - `amount` (gt, ge, lt, le, eq, ne)
              - `balance` (gt, ge, lt, le, eq, ne)
              - `paypointLegal` (ne, eq, ct, nct)
              - `paypointDba` (ne, eq, ct, nct)
              - `orgName` (ne, eq, ct, nct)
              - `externalPaypointId` (ct, nct, eq, ne)
              - `paypointId` (in, nin, eq, ne)

            List of comparison accepted - enclosed between parentheses:

              - eq or empty => equal
              - gt => greater than
              - ge => greater or equal
              - lt => less than
              - le => less or equal
              - ne => not equal
              - ct => contains
              - nct => not contains
              - in => inside array separated by "|"
              - nin => not inside array separated by "|"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[VCardQueryResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/vcards/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    VCardQueryResponse,
                    parse_obj_as(
                        type_=VCardQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_vcards_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[VCardQueryResponse]:
        """
        Retrieve a list of vcards (virtual credit cards) issued for an organization. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            List of field names accepted:

              - `status` (in, nin, eq, ne)
              - `createdAt` (gt, ge, lt, le, eq, ne)
              - `cardToken` (ct, nct, eq, ne)
              - `lastFour` (ct, nct, eq, ne)
              - `expirationDate` (ct, nct, eq, ne)
              - `payoutId` (ct, nct, eq, ne, in, nin)
              - `vendorId` (ct, nct, eq, ne, in, nin)
              - `miscData1` (ct, nct, eq, ne)
              - `miscData2` (ct, nct, eq, ne)
              - `currentUses` (gt, ge, lt, le, eq, ne)
              - `amount` (gt, ge, lt, le, eq, ne)
              - `balance` (gt, ge, lt, le, eq, ne)
              - `paypointLegal` (ne, eq, ct, nct)
              - `paypointDba` (ne, eq, ct, nct)
              - `orgName` (ne, eq, ct, nct)
              - `externalPaypointId` (ct, nct, eq, ne)
              - `paypointId` (in, nin, eq, ne)

            List of comparison accepted - enclosed between parentheses:

              - eq or empty => equal
              - gt => greater than
              - ge => greater or equal
              - lt => less than
              - le => less or equal
              - ne => not equal
              - ct => contains
              - nct => not contains
              - in => inside array separated by "|"
              - nin => not inside array separated by "|"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[VCardQueryResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"Query/vcards/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    VCardQueryResponse,
                    parse_obj_as(
                        type_=VCardQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawQueryClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_batch_details(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryBatchesDetailResponse]:
        """
        Retrieve a list of batches and their details, including settled and
        unsettled transactions for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `settlementDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `gatewayTransId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `settledAmount`  (gt, ge, lt, le, eq, ne)
            - `operation`    (in, nin, eq, ne)
            - `source`   (in, nin, eq, ne)
            - `batchNumber`  (ct, nct, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `isHold` (eq, ne)
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `batchId` (ct, nct, eq, neq)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**

            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `settledAmount(gt)=20` returns all records with a `settledAmount` greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryBatchesDetailResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/batchDetails/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryBatchesDetailResponse,
                    parse_obj_as(
                        type_=QueryBatchesDetailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_batch_details_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryResponseSettlements]:
        """
        Retrieve a list of batches and their details, including settled and unsettled transactions for an organization. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `settlementDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `gatewayTransId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `settledAmount`  (gt, ge, lt, le, eq, ne)
            - `operation`    (in, nin, eq, ne)
            - `source`   (in, nin, eq, ne)
            - `batchNumber`  (ct, nct, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `isHold` (eq, ne)
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `batchId` (ct, nct, eq, neq)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**

            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `settledAmount(gt)=20` returns all records with a `settledAmount` greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryResponseSettlements]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/batchDetails/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseSettlements,
                    parse_obj_as(
                        type_=QueryResponseSettlements,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_batches(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryBatchesResponse]:
        """
        Retrieve a list of batches for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `batchDate` (gt, ge, lt, le, eq, ne)
            - `batchNumber` (ne, eq)
            - `method` (in, nin, eq, ne)
            - `connectorName` (ne, eq, ct, nct)
            - `batchAmount` (gt, ge, lt, le, eq, ne)
            - `feeBatchAmount` (gt, ge, lt, le, eq, ne)
            - `netBatchAmount` (gt, ge, lt, le, eq, ne)
            - `releaseAmount` (gt, ge, lt, le, eq, ne)
            - `heldAmount` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `paypointId` (ne, eq)
            - `externalPaypointID` (ct, nct, eq, ne)
            - `expectedDepositDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `batchRecords` (gt, ge, lt, le, eq, ne)
            - `transferId` (ne, eq)
            - `transferDate` (gt, ge, lt, le, eq, ne)
            - `grossAmount` (gt, ge, lt, le, eq, ne)
            - `chargeBackAmount` (gt, ge, lt, le, eq, ne)
            - `returnedAmount` (gt, ge, lt, le, eq, ne)
            - `billingFeeAmount` (gt, ge, lt, le, eq, ne)
            - `thirdPartyPaidAmount` (gt, ge, lt, le, eq, ne)
            - `netFundedAmount` (gt, ge, lt, le, eq, ne)
            - `adjustmentAmount` (gt, ge, lt, le, eq, ne)
            - `processor` (ne, eq, ct, nct)
            - `transferStatus` (ne, eq, in, nin)

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `batchAmount(gt)=20` returns all records with a `batchAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryBatchesResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/batches/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryBatchesResponse,
                    parse_obj_as(
                        type_=QueryBatchesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_batches_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryBatchesResponse]:
        """
        Retrieve a list of batches for an org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `batchDate` (gt, ge, lt, le, eq, ne)
            - `batchNumber` (ne, eq)
            - `method` (in, nin, eq, ne)
            - `connectorName` (ne, eq, ct, nct)
            - `batchAmount` (gt, ge, lt, le, eq, ne)
            - `feeBatchAmount` (gt, ge, lt, le, eq, ne)
            - `netBatchAmount` (gt, ge, lt, le, eq, ne)
            - `releaseAmount` (gt, ge, lt, le, eq, ne)
            - `heldAmount` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `paypointId` (ne, eq)
            - `externalPaypointID` (ct, nct, eq, ne)
            - `expectedDepositDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `batchRecords` (gt, ge, lt, le, eq, ne)
            - `transferId` (ne, eq)
            - `transferDate` (gt, ge, lt, le, eq, ne)
            - `grossAmount` (gt, ge, lt, le, eq, ne)
            - `chargeBackAmount` (gt, ge, lt, le, eq, ne)
            - `returnedAmount` (gt, ge, lt, le, eq, ne)
            - `billingFeeAmount` (gt, ge, lt, le, eq, ne)
            - `thirdPartyPaidAmount` (gt, ge, lt, le, eq, ne)
            - `netFundedAmount` (gt, ge, lt, le, eq, ne)
            - `adjustmentAmount` (gt, ge, lt, le, eq, ne)
            - `processor` (ne, eq, ct, nct)
            - `transferStatus` (ne, eq, in, nin)

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `batchAmount(gt)=20` returns all records with a `batchAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryBatchesResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/batches/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryBatchesResponse,
                    parse_obj_as(
                        type_=QueryBatchesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_batches_out(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryBatchesOutResponse]:
        """
        Retrieve a list of MoneyOut batches for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query. See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted**:

            - `batchDate` (gt, ge, lt, le, eq, ne)
            - `batchNumber` (ne, eq)
            - `batchAmount` (gt, ge, lt, le, eq, ne)
            - `parentOrgId` (ne, eq, nin, in)
            - `status` (in, nin, eq, ne)
            - `orgId` (eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `paypointId` (ne, eq)
            - `externalPaypointID` (ct, nct, eq, ne)

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryBatchesOutResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/batchesOut/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryBatchesOutResponse,
                    parse_obj_as(
                        type_=QueryBatchesOutResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_batches_out_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryBatchesOutResponse]:
        """
        Retrieve a list of MoneyOut batches for an org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted**:

            - `batchDate` (gt, ge, lt, le, eq, ne)
            - `batchNumber` (ne, eq)
            - `batchAmount` (gt, ge, lt, le, eq, ne)
            - `parentOrgId` (ne, eq, nin, in)
            - `status` (in, nin, eq, ne)
            - `orgId` (eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `paypointId` (ne, eq)
            - `externalPaypointID` (ct, nct, eq, ne)

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryBatchesOutResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/batchesOut/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryBatchesOutResponse,
                    parse_obj_as(
                        type_=QueryBatchesOutResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_chargebacks(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryChargebacksResponse]:
        """
        Retrieves a list of chargebacks and returned transactions for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            **List of field names accepted:**
            - `chargebackDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `netAmount`  (gt, ge, lt, le, eq, ne)
            - `reasonCode`   (in, nin, eq, ne)
            - `reason`  (ct, nct, eq, ne)
            - `replyDate` (gt, ge, lt, le, eq, ne)
            - `caseNumber`  (ct, nct, eq, ne)
            - `status`   (in, nin, eq, ne)
            - `accountType`   (in, nin, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted - enclosed between parentheses:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryChargebacksResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/chargebacks/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryChargebacksResponse,
                    parse_obj_as(
                        type_=QueryChargebacksResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_chargebacks_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryChargebacksResponse]:
        """
        Retrieve a list of chargebacks and returned transactions for an org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.

            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info> See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            **List of field names accepted:**

            - `chargebackDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `netAmount`  (gt, ge, lt, le, eq, ne)
            - `reasonCode`   (in, nin, eq, ne)
            - `reason`  (ct, nct, eq, ne)
            - `replyDate` (gt, ge, lt, le, eq, ne)
            - `caseNumber`  (ct, nct, eq, ne)
            - `status`   (in, nin, eq, ne)
            - `accountType`   (in, nin, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted - enclosed between parentheses:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryChargebacksResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/chargebacks/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryChargebacksResponse,
                    parse_obj_as(
                        type_=QueryChargebacksResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_customers(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryCustomerResponse]:
        """
        Retrieves a list of customers for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more details.

            **List of Accepted Field Names:**

            - `createdDate` (gt, ge, lt, le, eq, ne)
            - `customernumber` (ne, eq, ct, nct)
            - `firstname` (ne, eq, ct, nct)
            - `lastname` (ne, eq, ct, nct)
            - `name` (ct, nct)
            - `address` (ne, eq, ct, nct)
            - `city` (ne, eq, ct, nct)
            - `country` (ne, eq, ct, nct)
            - `zip` (ne, eq, ct, nct)
            - `state` (ne, eq, ct, nct)
            - `shippingaddress` (ne, eq, ct, nct)
            - `shippingcity` (ne, eq, ct, nct)
            - `shippingcountry` (ne, eq, ct, nct)
            - `shippingzip` (ne, eq, ct, nct)
            - `shippingstate` (ne, eq, ct, nct)
            - `phone` (ne, eq, ct, nct)
            - `email` (ne, eq, ct, nct)
            - `company` (ne, eq, ct, nct)
            - `username` (ne, eq, ct, nct)
            - `balance` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name
            - `orgId` (eq) *mandatory when entry=org*
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)

            **List of Accepted Comparisons:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **Accepted Parameters:**
            - `limitRecord`: Max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: Initial record in query

            **Example Usage:**
            `balance(gt)=20` will return all records with a balance greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryCustomerResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/customers/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryCustomerResponse,
                    parse_obj_as(
                        type_=QueryCustomerResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_customers_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryCustomerResponse]:
        """
        Retrieves a list of customers for an org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more details.

            **List of Accepted Field Names:**

            - `createdDate` (gt, ge, lt, le, eq, ne)
            - `customernumber` (ne, eq, ct, nct)
            - `firstname` (ne, eq, ct, nct)
            - `lastname` (ne, eq, ct, nct)
            - `name` (ct, nct)
            - `address` (ne, eq, ct, nct)
            - `city` (ne, eq, ct, nct)
            - `country` (ne, eq, ct, nct)
            - `zip` (ne, eq, ct, nct)
            - `state` (ne, eq, ct, nct)
            - `shippingaddress` (ne, eq, ct, nct)
            - `shippingcity` (ne, eq, ct, nct)
            - `shippingcountry` (ne, eq, ct, nct)
            - `shippingzip` (ne, eq, ct, nct)
            - `shippingstate` (ne, eq, ct, nct)
            - `phone` (ne, eq, ct, nct)
            - `email` (ne, eq, ct, nct)
            - `company` (ne, eq, ct, nct)
            - `username` (ne, eq, ct, nct)
            - `balance` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name
            - `orgId` (eq) *mandatory when entry=org*
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)

            **List of Accepted Comparisons:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **Accepted Parameters:**
            - `limitRecord`: Max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: Initial record in query

            **Example Usage:**
            `balance(gt)=20` will return all records with a balance greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryCustomerResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/customers/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryCustomerResponse,
                    parse_obj_as(
                        type_=QueryCustomerResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_notification_reports(
        self,
        entry: Entry,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryResponseNotificationReports]:
        """
        Returns a list of all reports generated in the last 60 days for a single entrypoint. Use filters to limit results.

        Parameters
        ----------
        entry : Entry

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `reportName` (ct, nct, eq, ne)
            - `createdAt` (gt, ge, lt, le, eq, ne)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array
            - nin => not inside array

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: reportName(ct)=tr  return all records containing the string "tr"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryResponseNotificationReports]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/notificationReports/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseNotificationReports,
                    parse_obj_as(
                        type_=QueryResponseNotificationReports,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_notification_reports_org(
        self,
        org_id: int,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryResponseNotificationReports]:
        """
        Returns a list of all reports generated in the last 60 days for an organization. Use filters to limit results.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `reportName` (ct, nct, eq, ne)
            - `createdAt` (gt, ge, lt, le, eq, ne)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array
            - nin => not inside array

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: reportName(ct)=tr  return all records containing the string "tr"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryResponseNotificationReports]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/notificationReports/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseNotificationReports,
                    parse_obj_as(
                        type_=QueryResponseNotificationReports,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_notifications(
        self,
        entry: Entry,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryResponseNotifications]:
        """
        Returns a list of notifications for an entrypoint. Use filters to limit results.

        Parameters
        ----------
        entry : Entry

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `frequency` (in, nin,ne, eq)
            - `method` (in, nin, eq, ne)
            - `event` (in, nin, eq, ne)
            - `target` (ct, nct, eq, ne)
            - `status` (eq, ne)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array
            - nin => not inside array

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: totalAmount(gt)=20  return all records with totalAmount greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryResponseNotifications]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/notifications/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseNotifications,
                    parse_obj_as(
                        type_=QueryResponseNotifications,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_notifications_org(
        self,
        org_id: int,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryResponseNotifications]:
        """
        Return a list of notifications for an organization. Use filters to limit results.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `frequency` (in, nin,ne, eq)
            - `method` (in, nin, eq, ne)
            - `event` (in, nin, eq, ne)
            - `target` (ct, nct, eq, ne)
            - `status` (eq, ne)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array
            - nin => not inside array

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: totalAmount(gt)=20  return all records with totalAmount greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryResponseNotifications]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/notifications/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseNotifications,
                    parse_obj_as(
                        type_=QueryResponseNotifications,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_organizations(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListOrganizationsResponse]:
        """
        Retrieves a list of an organization's suborganizations and their full details such as orgId, users, and settings. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            **List of field names accepted:**

            - `createdAt` (gt, ge, lt, le, eq, ne)
            - `startDate` (gt, ge, lt, le, eq, ne)
            - `dbaname`  (ct, nct)
            - `legalname`  (ct, nct)
            - `ein`  (ct, nct)
            - `address`  (ct, nct)
            - `city`  (ct, nct)
            - `state`  (ct, nct)
            - `phone`  (ct, nct)
            - `mcc`  (ct, nct)
            - `owntype`  (ct, nct)
            - `ownerName`  (ct, nct)
            - `contactName`  (ct, nct)
            - `orgParentname`  (ct, nct)
            - `boardingId` (eq, ne)
            - `entryName`  (ct, nct)

            **List of comparison accepted - enclosed between parentheses:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array

            **List of parameters accepted:**

            - `limitRecord` : max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord` : initial record in query

            Example: `dbaname(ct)=hoa` returns all records with a `dbaname` containing "hoa"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListOrganizationsResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/organizations/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListOrganizationsResponse,
                    parse_obj_as(
                        type_=ListOrganizationsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_payout(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryPayoutTransaction]:
        """
        Retrieves a list of money out transactions (payouts) for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            List of field names accepted:

              - `status` (in, nin, eq, ne)
              - `transactionDate` (gt, ge, lt, le, eq, ne)
              - `billNumber` (ct, nct)
              - `vendorNumber` (ct, nct, eq, ne)
              - `vendorName` (ct, nct, eq, ne)
              - `paymentMethod` (ct, nct, eq, ne, in, nin)
              - `paymentId` (ct, nct, eq, ne)
              - `parentOrgId` (ne, eq, nin, in)
              - `batchNumber` (ct, nct, eq, ne)
              - `totalAmount` (gt, ge, lt, le, eq, ne)
              - `paypointLegal` (ne, eq, ct, nct)
              - `paypointDba` (ne, eq, ct, nct)
              - `accountId` (ne, eq, ct, nct)
              - `orgName` (ne, eq, ct, nct)
              - `externalPaypointID` (ct, nct, eq, ne)
              - `paypointId` (eq, ne)
              - `vendorId` (eq, ne)
              - `vendorEIN` (ct, nct, eq, ne)
              - `vendorPhone` (ct, nct, eq, ne)
              - `vendorEmail` (ct, nct, eq, ne)
              - `vendorAddress` (ct, nct, eq, ne)
              - `vendorCity` (ct, nct, eq, ne)
              - `vendorState` (ct, nct, eq, ne)
              - `vendorCountry` (ct, nct, eq, ne)
              - `vendorZip` (ct, nct, eq, ne)
              - `vendorMCC` (ct, nct, eq, ne)
              - `vendorLocationCode` (ct, nct, eq, ne)
              - `vendorCustomField1` (ct, nct, eq, ne)
              - `vendorCustomField2` (ct, nct, eq, ne)
              - `comments` (ct, nct)
              - `payaccountCurrency` (ne, eq, in, nin)
              - `remitAddress` (ct, nct)
              - `source` (ct, nct, eq, ne)
              - `updatedOn` (gt, ge, lt, le, eq, ne)
              - `feeAmount` (gt, ge, lt, le, eq, ne)
              - `lotNumber` (ct, nct)
              - `customerVendorAccount` (ct, nct, eq, ne)
              - `batchId` (eq, ne)
              - `AchTraceNumber` (eq, ne)
              - `payoutProgram`(eq, ne) the options are `managed` or `odp`. For example, `payoutProgram(eq)=managed` returns all records with a `payoutProgram` equal to `managed`.

              List of comparison accepted - enclosed between parentheses:
              - eq or empty => equal
              - gt => greater than
              - ge => greater or equal
              - lt => less than
              - le => less or equal
              - ne => not equal
              - ct => contains
              - nct => not contains
              - in => inside array separated by \\"|\\"
              - nin => not inside array separated by \\"|\\"

              List of parameters accepted:

              - limitRecord : max number of records for query (default=\\"20\\", \\"0\\" or negative value for all)
              - fromRecord : initial record in query
              - sortBy : indicate field name and direction to sort the results

              Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

              Example: `sortBy=desc(netamount)` returns all records sorted by `netAmount` descending

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryPayoutTransaction]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/payouts/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryPayoutTransaction,
                    parse_obj_as(
                        type_=QueryPayoutTransaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_payout_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryPayoutTransaction]:
        """
        Retrieves a list of money out transactions (payouts) for an organization. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            List of field names accepted:

              - `status` (in, nin, eq, ne)
              - `transactionDate` (gt, ge, lt, le, eq, ne)
              - `billNumber` (ct, nct)
              - `vendorNumber` (ct, nct, eq, ne)
              - `vendorName` (ct, nct, eq, ne)
              - `parentOrgId` (ne, eq, nin, in)
              - `paymentMethod` (ct, nct, eq, ne, in, nin)
              - `paymentId` (ct, nct, eq, ne)
              - `batchNumber` (ct, nct, eq, ne)
              - `totalAmount` (gt, ge, lt, le, eq, ne)
              - `paypointLegal` (ne, eq, ct, nct)
              - `paypointDba` (ne, eq, ct, nct)
              - `accountId` (ne, eq, ct, nct)
              - `orgName` (ne, eq, ct, nct)
              - `externalPaypointID` (ct, nct, eq, ne)
              - `paypointId` (eq, ne)
              - `vendorId` (eq, ne)
              - `vendorEIN` (ct, nct, eq, ne)
              - `vendorPhone` (ct, nct, eq, ne)
              - `vendorEmail` (ct, nct, eq, ne)
              - `vendorAddress` (ct, nct, eq, ne)
              - `vendorCity` (ct, nct, eq, ne)
              - `vendorState` (ct, nct, eq, ne)
              - `vendorCountry` (ct, nct, eq, ne)
              - `vendorZip` (ct, nct, eq, ne)
              - `vendorMCC` (ct, nct, eq, ne)
              - `vendorLocationCode` (ct, nct, eq, ne)
              - `vendorCustomField1` (ct, nct, eq, ne)
              - `vendorCustomField2` (ct, nct, eq, ne)
              - `comments` (ct, nct)
              - `payaccountCurrency` (ne, eq, in, nin)
              - `remitAddress` (ct, nct)
              - `source` (ct, nct, eq, ne)
              - `updatedOn` (gt, ge, lt, le, eq, ne)
              - `feeAmount` (gt, ge, lt, le, eq, ne)
              - `lotNumber` (ct, nct)
              - `customerVendorAccount` (ct, nct, eq, ne)
              - `batchId` (eq, ne)
              - `AchTraceNumber` (eq, ne)
              - `payoutProgram`(eq, ne) the options are `managed` or `odp`. For example, `payoutProgram(eq)=managed` returns all records with a `payoutProgram` equal to `managed`.

              List of comparison accepted - enclosed between parentheses:
              - eq or empty => equal
              - gt => greater than
              - ge => greater or equal
              - lt => less than
              - le => less or equal
              - ne => not equal
              - ct => contains
              - nct => not contains
              - in => inside array separated by \\"|\\"
              - nin => not inside array separated by \\"|\\"

              List of parameters accepted:

              - limitRecord : max number of records for query (default=\\"20\\", \\"0\\" or negative value for all)
              - fromRecord : initial record in query
              - sortBy : indicate field name and direction to sort the results

              Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

              Example: `sortBy=desc(netamount)` returns all records sorted by `netAmount` descending

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryPayoutTransaction]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/payouts/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryPayoutTransaction,
                    parse_obj_as(
                        type_=QueryPayoutTransaction,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_paypoints(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryEntrypointResponse]:
        """
        Returns a list of paypoints in an organization. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            **List of field names accepted:**

            - `createdAt` (gt, ge, lt, le, eq, ne)
            - `lastModified` (gt, ge, lt, le, eq, ne)
            - `startDate` (gt, ge, lt, le, eq, ne)
            - `dbaname`  (ct, nct)
            - `status` (eq, ne)
            - `legalname`  (ct, nct)
            - `externalPaypointID` (ct, nct)
            - `ein`  (ct, nct)
            - `address`  (ct, nct)
            - `city`  (ct, nct)
            - `state`  (ct, nct)
            - `phone`  (ct, nct)
            - `mcc`  (ct, nct)
            - `owntype`  (ct, nct)
            - `ownerName`  (ct, nct)
            - `contactName`  (ct, nct)
            - `paypointId` (eq, ne)
            - `orgParentname`  (ct, nct, in, nin)
            - `boardingId` (eq, ne)
            - `entryName`  (ct, nct)
            - `externalOrgID` (ct, nct)

            **List of comparison accepted - enclosed between parentheses:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array

            **List of parameters accepted:**

            - `limitRecord` : max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord` : initial record in query

            Example: `dbaname(ct)=hoa` returns all records with a `dbaname` containing "hoa"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryEntrypointResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/paypoints/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryEntrypointResponse,
                    parse_obj_as(
                        type_=QueryEntrypointResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_settlements(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryResponseSettlements]:
        """
        Retrieve a list of settled transactions for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `settlementDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `gatewayTransId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `settledAmount`  (gt, ge, lt, le, eq, ne)
            - `operation`    (in, nin, eq, ne)
            - `source`   (in, nin, eq, ne)
            - `batchNumber`  (ct, nct, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `isHold` (eq, ne)
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `batchId` (ct, nct, eq, neq)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**

            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `settledAmount(gt)=20` returns all records with a `settledAmount` greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryResponseSettlements]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/settlements/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseSettlements,
                    parse_obj_as(
                        type_=QueryResponseSettlements,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_settlements_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryResponseSettlements]:
        """
        Retrieve a list of settled transactions for an organization. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `settlementDate` (gt, ge, lt, le, eq, ne)
            - `depositDate` (gt, ge, lt, le, eq, ne)
            - `transId`  (ne, eq, ct, nct)
            - `gatewayTransId`  (ne, eq, ct, nct)
            - `method`   (in, nin, eq, ne)
            - `settledAmount`  (gt, ge, lt, le, eq, ne)
            - `operation`    (in, nin, eq, ne)
            - `source`   (in, nin, eq, ne)
            - `batchNumber`  (ct, nct, eq, ne)
            - `payaccountLastfour`   (nct, ct)
            - `payaccountType`   (ne, eq, in, nin)
            - `customerFirstname`   (ct, nct, eq, ne)
            - `customerLastname`    (ct, nct, eq, ne)
            - `customerName`   (ct, nct)
            - `customerId`  (eq, ne)
            - `customerNumber`  (ct, nct, eq, ne)
            - `customerCompanyname`    (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity`    (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity`    (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId`  (eq) *mandatory when entry=org*
            - `isHold` (eq, ne)
            - `paypointId`  (ne, eq)
            - `paypointLegal`  (ne, eq, ct, nct)
            - `paypointDba`  (ne, eq, ct, nct)
            - `orgName`  (ne, eq, ct, nct)
            - `batchId` (ct, nct, eq, neq)
            - `additional-xxx`  (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**

            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `settledAmount(gt)=20` returns all records with a `settledAmount` greater than 20.00.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryResponseSettlements]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/settlements/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseSettlements,
                    parse_obj_as(
                        type_=QueryResponseSettlements,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_subscriptions(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QuerySubscriptionResponse]:
        """
        Returns a list of subscriptions for a single paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `startDate` (gt, ge, lt, le, eq, ne)
            - `endDate` (gt, ge, lt, le, eq, ne)
            - `nextDate` (gt, ge, lt, le, eq, ne)
            - `frequency` (in, nin, ne, eq)
            - `method` (in, nin, eq, ne)
            - `totalAmount` (gt, ge, lt, le, eq, ne)
            - `netAmount` (gt, ge, lt, le, eq, ne)
            - `feeAmount` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `untilcancelled` (eq, ne)
            - `payaccountLastfour` (nct, ct)
            - `payaccountType` (ne, eq, in, nin)
            - `payaccountCurrency` (ne, eq, in, nin)
            - `customerFirstname` (ct, nct, eq, ne)
            - `customerLastname` (ct, nct, eq, ne)
            - `customerName` (ct, nct)
            - `customerId` (eq, ne)
            - `customerNumber` (ct, nct, eq, ne)
            - `customerCompanyname` (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity` (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity` (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId` (eq)
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `externalPaypointId` (ct, nct, ne, eq)
            - `subId` (eq, ne)
            - `orderDescription` (ct, nct)
            - `cycles` (eq, ne, gt, ge, lt, le)
            - `leftcycles` (eq, ne, gt, ge, lt, le)
            - `createdAt` (eq, ne, gt, ge, lt, le)
            - `updatedOn` (eq, ne, gt, ge, lt, le)
            - `invoiceNumber` (ct, nct)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison operators accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QuerySubscriptionResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/subscriptions/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QuerySubscriptionResponse,
                    parse_obj_as(
                        type_=QuerySubscriptionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_subscriptions_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QuerySubscriptionResponse]:
        """
        Returns a list of subscriptions for a single org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.

            **List of field names accepted:**

            - `startDate` (gt, ge, lt, le, eq, ne)
            - `endDate` (gt, ge, lt, le, eq, ne)
            - `nextDate` (gt, ge, lt, le, eq, ne)
            - `frequency` (in, nin, ne, eq)
            - `method` (in, nin, eq, ne)
            - `totalAmount` (gt, ge, lt, le, eq, ne)
            - `netAmount` (gt, ge, lt, le, eq, ne)
            - `feeAmount` (gt, ge, lt, le, eq, ne)
            - `status` (in, nin, eq, ne)
            - `untilcancelled` (eq, ne)
            - `payaccountLastfour` (nct, ct)
            - `payaccountType` (ne, eq, in, nin)
            - `payaccountCurrency` (ne, eq, in, nin)
            - `customerFirstname` (ct, nct, eq, ne)
            - `customerLastname` (ct, nct, eq, ne)
            - `customerName` (ct, nct)
            - `customerId` (eq, ne)
            - `customerNumber` (ct, nct, eq, ne)
            - `customerCompanyname` (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity` (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity` (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `orgId` (eq)
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `externalPaypointId` (ct, nct, ne, eq)
            - `subId` (eq, ne)
            - `orderDescription` (ct, nct)
            - `cycles` (eq, ne, gt, ge, lt, le)
            - `leftcycles` (eq, ne, gt, ge, lt, le)
            - `createdAt` (eq, ne, gt, ge, lt, le)
            - `updatedOn` (eq, ne, gt, ge, lt, le)
            - `invoiceNumber` (ct, nct)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name

            **List of comparison operators accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QuerySubscriptionResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/subscriptions/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QuerySubscriptionResponse,
                    parse_obj_as(
                        type_=QuerySubscriptionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_transactions(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryResponseTransactions]:
        """
        Retrieve a list of transactions for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.
        By default, this endpoint returns only transactions from the last 60 days. To query transactions outside of this period, include `transactionDate` filters.
        For example, this request parameters filter for transactions between April 01, 2024 and April 09, 2024. 
        ``` curl --request GET \\
          --url https://sandbox.payabli.com/api/Query/transactions/org/1?limitRecord=20&fromRecord=0&transactionDate(ge)=2024-04-01T00:00:00&transactionDate(le)=2024-04-09T23:59:59\\
          --header 'requestToken: <api-key>'
        
          ```
        
        Parameters
        ----------
        entry : Entry
        
        export_format : typing.Optional[ExportFormat]
        
        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.
        
        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.
        
        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            
            Collection of field names, conditions, and values used to filter the query. 
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**
            
              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.
            
              For example:
            
              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20
            
              should become:
            
              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.
            
            **List of field names accepted:**
            
            - `transactionDate` (gt, ge, lt, le, eq, ne)
            - `transId` (ne, eq, ct, nct, in, nin)
            - `gatewayTransId` (ne, eq, ct, nct)
            - `orderId` (ne, eq)
            - `scheduleId` (ne, eq)
            - `returnId` (ne, eq)
            - `refundId` (ne, eq)
            - `idTrans` (ne, eq)
            - `orgId` (ne, eq)
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `externalPaypointId` (ct, nct, eq, ne)
            - `method` (in, nin, eq, ne)
            - `totalAmount` (gt, ge, lt, le, eq, ne)
            - `netAmount` (gt, ge, lt, le, eq, ne)
            - `feeAmount` (gt, ge, lt, le, eq, ne)
            - `operation` (in, nin, eq, ne)
            - `source` (in, nin, eq, ne, ct, nct)
            - `status` (in, nin, eq, ne)
            - `settlementStatus` (in, nin, eq, ne)
            - `batchNumber` (nct, ct)
            - `invoiceNumber` (ct, nct)
            - `ipAddress` (eq, ne)
            - `authCode` (ct, nct)
            - `orderDescription` (ct, nct)
            - `payaccountLastfour` (nct, ct)
            - `payaccountType` (ne, eq, in, nin)
            - `payaccountCurrency` (ne, eq, in, nin)
            - `customerFirstname` (ct, nct, eq, ne)
            - `customerLastname` (ct, nct, eq, ne)
            - `customerName` (ct, nct)
            - `customerId` (eq, ne)
            - `customerNumber` (ct, nct, eq, ne)
            - `customerCompanyname` (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity` (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity` (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `deviceId` (ct, nct, in, nin, eq, ne)
            - `AchSecCode` ( ct, nct, in, nin, eq, ne)
            - `AchHolderType` (ct, nct, in, nin, eq, and ne)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name related to customer data
            - 'invoiceAdditional-xxx' (ne, eq, ct, nct) where xxx is the additional field name related to invoice data
            
            **List of comparison operators accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array      
        
        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        AsyncHttpResponse[QueryResponseTransactions]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/transactions/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseTransactions,
                    parse_obj_as(
                        type_=QueryResponseTransactions,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_transactions_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryResponseTransactions]:
        """
        
        Retrieve a list of transactions for an organization. Use filters to
        limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.
        
        
        By default, this endpoint returns only transactions from the last 60 days. To query transactions outside of this period, include `transactionDate` filters.
        
        For example, this request parameters filter for transactions between April 01, 2024 and April 09, 2024. 
        
        ```
        curl --request GET \\
          --url https://sandbox.payabli.com/api/Query/transactions/org/1?limitRecord=20&fromRecord=0&transactionDate(ge)=2024-04-01T00:00:00&transactionDate(le)=2024-04-09T23:59:59\\
          --header 'requestToken: <api-key>'
        
          ```
        
        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.
        
        export_format : typing.Optional[ExportFormat]
        
        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.
        
        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.
        
        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            
            Collection of field names, conditions, and values used to filter the query. 
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**
            
              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.
            
              For example:
            
              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20
            
              should become:
            
              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.
            
            **List of field names accepted:**
            
            - `transactionDate` (gt, ge, lt, le, eq, ne)
            - `transId` (ne, eq, ct, nct, in, nin)
            - `gatewayTransId` (ne, eq, ct, nct)
            - `orderId` (ne, eq)
            - `scheduleId` (ne, eq)
            - `returnId` (ne, eq)
            - `refundId` (ne, eq)
            - `idTrans` (ne, eq)
            - `orgId` (ne, eq)
            - `paypointId` (ne, eq)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)
            - `externalPaypointId` (ct, nct, eq, ne)
            - `method` (in, nin, eq, ne)
            - `totalAmount` (gt, ge, lt, le, eq, ne)
            - `netAmount` (gt, ge, lt, le, eq, ne)
            - `feeAmount` (gt, ge, lt, le, eq, ne)
            - `operation` (in, nin, eq, ne)
            - `source` (in, nin, eq, ne, ct, nct)
            - `status` (in, nin, eq, ne)
            - `settlementStatus` (in, nin, eq, ne)
            - `batchNumber` (nct, ct)
            - `invoiceNumber` (ct, nct)
            - `authCode` (ct, nct)
            - `orderDescription` (ct, nct)
            - `payaccountLastfour` (nct, ct)
            - `payaccountType` (ne, eq, in, nin)
            - `payaccountCurrency` (ne, eq, in, nin)
            - `customerFirstname` (ct, nct, eq, ne)
            - `customerLastname` (ct, nct, eq, ne)
            - `customerName` (ct, nct)
            - `customerId` (eq, ne)
            - `customerNumber` (ct, nct, eq, ne)
            - `customerCompanyname` (ct, nct, eq, ne)
            - `customerAddress` (ct, nct, eq, ne)
            - `customerCity` (ct, nct, eq, ne)
            - `customerZip` (ct, nct, eq, ne)
            - `customerState` (ct, nct, eq, ne)
            - `customerCountry` (ct, nct, eq, ne)
            - `customerPhone` (ct, nct, eq, ne)
            - `customerEmail` (ct, nct, eq, ne)
            - `customerShippingAddress` (ct, nct, eq, ne)
            - `customerShippingCity` (ct, nct, eq, ne)
            - `customerShippingZip` (ct, nct, eq, ne)
            - `customerShippingState` (ct, nct, eq, ne)
            - `customerShippingCountry` (ct, nct, eq, ne)
            - `deviceId` (ct, nct, in, nin, eq, ne)
            - `AchSecCode` ( ct, nct, in, nin, eq, ne)
            - `AchHolderType`` (ct, nct, in, nin, eq, and ne)
            - `additional-xxx` (ne, eq, ct, nct) where xxx is the additional field name related to customer data
            - 'invoiceAdditional-xxx' (ne, eq, ct, nct) where xxx is the additional field name related to invoice data
            
            **List of comparison operators accepted:**
            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array
            - `nin` => not inside array
              
        
        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        AsyncHttpResponse[QueryResponseTransactions]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/transactions/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseTransactions,
                    parse_obj_as(
                        type_=QueryResponseTransactions,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_transfer_details(
        self,
        entry: Entry,
        transfer_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[LimitRecord] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryTransferDetailResponse]:
        """
        Retrieve a list of transfer details records for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        transfer_id : int
            The numeric identifier for the transfer, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[LimitRecord]

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]

            Collection of field names, conditions, and values used to filter
            the query.

            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>

            See [Filters and Conditions
            Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference)
            for more information.


            **List of field names accepted:**

              - `grossAmount` (gt, ge, lt, le, eq, ne)
              - `chargeBackAmount` (gt, ge, lt, le, eq, ne)
              - `returnedAmount` (gt, ge, lt, le, eq, ne)
              - `billingFeeAmount` (gt, ge, lt, le, eq, ne)
              - `thirdPartyPaidAmount` (gt, ge, lt, le, eq, ne)
              - `netFundedAmount` (gt, ge, lt, le, eq, ne)
              - `adjustmentAmount` (gt, ge, lt, le, eq, ne)
              - `splitFundingAmount` (gt, ge, lt, le, eq, ne)
              - `operation` (in, nin, eq, ne)
              - `transactionId` (eq, ne, in, nin)
              - `category` (eq, ne, ct, nct)
              - `type` (eq, ne, in, nin)
              - `method` (eq, ne, in, nin)


        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryTransferDetailResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/transferDetails/{jsonable_encoder(entry)}/{jsonable_encoder(transfer_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryTransferDetailResponse,
                    parse_obj_as(
                        type_=QueryTransferDetailResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_transfers(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TransferQueryResponse]:
        """
        Retrieve a list of transfers for a paypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query. See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            List of field names accepted:

              - `transferDate` (gt, ge, lt, le, eq, ne)
              - `grossAmount` (gt, ge, lt, le, eq, ne)
              - `chargeBackAmount` (gt, ge, lt, le, eq, ne)
              - `returnedAmount` (gt, ge, lt, le, eq, ne)
              - `billingFeeAmount` (gt, ge, lt, le, eq, ne)
              - `thirdPartyPaidAmount` (gt, ge, lt, le, eq, ne)
              - `netFundedAmount` (gt, ge, lt, le, eq, ne)
              - `adjustmentAmount` (gt, ge, lt, le, eq, ne)
              - `processor` (ne, eq, ct, nct)
              - `transferStatus` (ne, eq, in, nin)
              - `batchNumber` (ne, eq, ct, nct)
              - `batchId` (ne, eq, in, nin)
              - `transferId` (in, nin, eq, ne)
              - `bankAccountNumber` (ct, nct, ne, eq)
              - `bankRoutingNumber` (ct, nct, ne, eq)
              - `batchCurrency` (in, nin, ne, eq)
              - `parentOrgName` (ct, nct, ne, eq)
              - `parentOrgId` (ct, nct, ne, eq)
              - `externalPaypointID` (ct, nct)

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TransferQueryResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/transfers/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransferQueryResponse,
                    parse_obj_as(
                        type_=TransferQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_transfers_org(
        self,
        org_id: Orgid,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TransferQueryResponse]:
        """
        Retrieve a list of transfers for an org. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : Orgid

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query. See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for more information.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            List of field names accepted:

              - `transferDate` (gt, ge, lt, le, eq, ne)
              - `grossAmount` (gt, ge, lt, le, eq, ne)
              - `chargeBackAmount` (gt, ge, lt, le, eq, ne)
              - `returnedAmount` (gt, ge, lt, le, eq, ne)
              - `billingFeeAmount` (gt, ge, lt, le, eq, ne)
              - `thirdPartyPaidAmount` (gt, ge, lt, le, eq, ne)
              - `netFundedAmount` (gt, ge, lt, le, eq, ne)
              - `adjustmentAmount` (gt, ge, lt, le, eq, ne)
              - `processor` (ne, eq, ct, nct)
              - `transferStatus` (ne, eq, in, nin)
              - `batchNumber` (ne, eq, ct, nct)
              - `batchId` (ne, eq, in, nin)
              - `transferId` (in, nin, eq, ne)
              - `bankAccountNumber` (ct, nct, ne, eq)
              - `bankRoutingNumber` (ct, nct, ne, eq)
              - `batchCurrency` (in, nin, ne, eq)

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TransferQueryResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/transfers/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TransferQueryResponse,
                    parse_obj_as(
                        type_=TransferQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_users_org(
        self,
        org_id: int,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryUserResponse]:
        """
        Get list of users for an org. Use filters to limit results.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            **List of field names accepted:**

            - `createdDate` (gt, ge, lt, le, eq, ne)
            - `name`  (ne, eq, ct, nct)
            - `email`  (ne, eq, ct, nct)
            - `status`   (in, nin, eq, ne)
            - `role.xxx`  (ne, eq, ct, nct) where xxx is the role field: `roleLabel` or `roleValue`

            **List of comparison accepted - enclosed between parentheses:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `name(ct)=john`  return all records with name containing 'john'.

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryUserResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/users/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryUserResponse,
                    parse_obj_as(
                        type_=QueryUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_users_paypoint(
        self,
        entry: str,
        *,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryUserResponse]:
        """
        Get list of users for a paypoint. Use filters to limit results.

        Parameters
        ----------
        entry : str
            The paypoint's entrypoint identifier. [Learn more](/api-reference/api-overview#entrypoint-vs-entry)

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            **List of field names accepted:**

            - `createdDate` (gt, ge, lt, le, eq, ne)
            - `name`  (ne, eq, ct, nct)
            - `email`  (ne, eq, ct, nct)
            - `status`   (in, nin, eq, ne)
            - `role.xxx`  (ne, eq, ct, nct) where xxx is the role field: `roleLabel` or `roleValue`

            **List of comparison accepted - enclosed between parentheses:**

            - `eq` or empty => equal
            - `gt` => greater than
            - `ge` => greater or equal
            - `lt` => less than
            - `le` => less or equal
            - `ne` => not equal
            - `ct` => contains
            - `nct` => not contains
            - `in` => inside array separated by "|"
            - `nin` => not inside array separated by "|"

            **List of parameters accepted:**
            - `limitRecord`: max number of records for query (default="20", "0" or negative value for all)
            - `fromRecord`: initial record in query

            Example: `name(ct)=john`  return all records with name containing 'john'

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryUserResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/users/point/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryUserResponse,
                    parse_obj_as(
                        type_=QueryUserResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_vendors(
        self,
        entry: str,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryResponseVendors]:
        """
        Retrieve a list of vendors for an entrypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : str
            The paypoint's entrypoint identifier. [Learn more](/api-reference/api-overview#entrypoint-vs-entry)

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `method` (in, nin, eq, ne)
            - `enrollmentStatus` (in,nin, eq, ne)
            - `status` (in, nin, eq, ne)
            - `vendorNumber` (ct, nct, eq, ne)
            - `name` (ct, nct, eq, ne)
            - `ein` (ct, nct, eq, ne)
            - `phone` (ct, nct, eq, ne)
            - `email` (ct, nct, eq, ne)
            - `address` (ct, nct, eq, ne)
            - `city` (ct, nct, eq, ne)
            - `state` (ct, nct, eq, ne)
            - `country` (ct, nct, eq, ne)
            - `zip` (ct, nct, eq, ne)
            - `mcc` (ct, nct, eq, ne)
            - `locationCode` (ct, nct, eq, ne)
            - `paypointLegal` (ne, eq, ct, nct)
            - `parentOrgId` (ne, eq, nin, in)
            - `paypointDba` (ne, eq, ct, nct)
            - `orgName` (ne, eq, ct, nct)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array separated by "|"
            - nin => not inside array separated by "|"

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryResponseVendors]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/vendors/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseVendors,
                    parse_obj_as(
                        type_=QueryResponseVendors,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_vendors_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[QueryResponseVendors]:
        """
        Retrieve a list of vendors for an organization. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            See [Filters and Conditions Reference](/developers/developer-guides/pay-ops-reporting-engine-overview#filters-and-conditions-reference) for help.

            List of field names accepted:
            - `method` (in, nin, eq, ne)
            - `enrollmentStatus` (in,nin, eq, ne)
            - `status` (in, nin, eq, ne)
            - `vendorNumber` (ct, nct, eq, ne)
            - `name` (ct, nct, eq, ne)
            - `ein` (ct, nct, eq, ne)
            - `phone` (ct, nct, eq, ne)
            - `email` (ct, nct, eq, ne)
            - `address` (ct, nct, eq, ne)
            - `city` (ct, nct, eq, ne)
            - `state` (ct, nct, eq, ne)
            - `country` (ct, nct, eq, ne)
            - `zip` (ct, nct, eq, ne)
            - `mcc` (ct, nct, eq, ne)
            - `locationCode` (ct, nct, eq, ne)
            - `paypointLegal` (ne, eq, ct, nct)
            - `paypointDba` (ne, eq, ct, nct)
            - `parentOrgId` (ne, eq, nin, in)
            - `orgName` (ne, eq, ct, nct)

            List of comparison accepted - enclosed between parentheses:
            - eq or empty => equal
            - gt => greater than
            - ge => greater or equal
            - lt => less than
            - le => less or equal
            - ne => not equal
            - ct => contains
            - nct => not contains
            - in => inside array separated by "|"
            - nin => not inside array separated by "|"

            List of parameters accepted:
            - limitRecord : max number of records for query (default="20", "0" or negative value for all)
            - fromRecord : initial record in query

            Example: `netAmount(gt)=20` returns all records with a `netAmount` greater than 20.00

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[QueryResponseVendors]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/vendors/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    QueryResponseVendors,
                    parse_obj_as(
                        type_=QueryResponseVendors,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_vcards(
        self,
        entry: Entry,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[VCardQueryResponse]:
        """
        Retrieve a list of vcards (virtual credit cards) issued for an entrypoint. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        entry : Entry

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            List of field names accepted:

              - `status` (in, nin, eq, ne)
              - `createdAt` (gt, ge, lt, le, eq, ne)
              - `cardToken` (ct, nct, eq, ne)
              - `lastFour` (ct, nct, eq, ne)
              - `expirationDate` (ct, nct, eq, ne)
              - `payoutId` (ct, nct, eq, ne, in, nin)
              - `vendorId` (ct, nct, eq, ne, in, nin)
              - `miscData1` (ct, nct, eq, ne)
              - `miscData2` (ct, nct, eq, ne)
              - `currentUses` (gt, ge, lt, le, eq, ne)
              - `amount` (gt, ge, lt, le, eq, ne)
              - `balance` (gt, ge, lt, le, eq, ne)
              - `paypointLegal` (ne, eq, ct, nct)
              - `paypointDba` (ne, eq, ct, nct)
              - `orgName` (ne, eq, ct, nct)
              - `externalPaypointId` (ct, nct, eq, ne)
              - `paypointId` (in, nin, eq, ne)

            List of comparison accepted - enclosed between parentheses:

              - eq or empty => equal
              - gt => greater than
              - ge => greater or equal
              - lt => less than
              - le => less or equal
              - ne => not equal
              - ct => contains
              - nct => not contains
              - in => inside array separated by "|"
              - nin => not inside array separated by "|"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[VCardQueryResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/vcards/{jsonable_encoder(entry)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    VCardQueryResponse,
                    parse_obj_as(
                        type_=VCardQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        PayabliApiResponse,
                        parse_obj_as(
                            type_=PayabliApiResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_vcards_org(
        self,
        org_id: int,
        *,
        export_format: typing.Optional[ExportFormat] = None,
        from_record: typing.Optional[int] = None,
        limit_record: typing.Optional[int] = None,
        parameters: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        sort_by: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[VCardQueryResponse]:
        """
        Retrieve a list of vcards (virtual credit cards) issued for an organization. Use filters to limit results. Include the `exportFormat` query parameter to return the results as a file instead of a JSON response.

        Parameters
        ----------
        org_id : int
            The numeric identifier for organization, assigned by Payabli.

        export_format : typing.Optional[ExportFormat]

        from_record : typing.Optional[int]
            The number of records to skip before starting to collect the result set.

        limit_record : typing.Optional[int]
            Max number of records to return for the query. Use `0` or negative value to return all records.

        parameters : typing.Optional[typing.Dict[str, typing.Optional[str]]]
            Collection of field names, conditions, and values used to filter the query.
            <Info>
              **You must remove `parameters=` from the request before you send it, otherwise Payabli will ignore the filters.**

              Because of a technical limitation, you can't make a request that includes filters from the API console on this page. The response won't be filtered. Instead, copy the request, remove `parameters=` and run the request in a different client.

              For example:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?parameters=totalAmount(gt)=1000&limitRecord=20

              should become:

              --url https://api-sandbox.payabli.com/api/Query/transactions/org/236?totalAmount(gt)=1000&limitRecord=20
            </Info>
            List of field names accepted:

              - `status` (in, nin, eq, ne)
              - `createdAt` (gt, ge, lt, le, eq, ne)
              - `cardToken` (ct, nct, eq, ne)
              - `lastFour` (ct, nct, eq, ne)
              - `expirationDate` (ct, nct, eq, ne)
              - `payoutId` (ct, nct, eq, ne, in, nin)
              - `vendorId` (ct, nct, eq, ne, in, nin)
              - `miscData1` (ct, nct, eq, ne)
              - `miscData2` (ct, nct, eq, ne)
              - `currentUses` (gt, ge, lt, le, eq, ne)
              - `amount` (gt, ge, lt, le, eq, ne)
              - `balance` (gt, ge, lt, le, eq, ne)
              - `paypointLegal` (ne, eq, ct, nct)
              - `paypointDba` (ne, eq, ct, nct)
              - `orgName` (ne, eq, ct, nct)
              - `externalPaypointId` (ct, nct, eq, ne)
              - `paypointId` (in, nin, eq, ne)

            List of comparison accepted - enclosed between parentheses:

              - eq or empty => equal
              - gt => greater than
              - ge => greater or equal
              - lt => less than
              - le => less or equal
              - ne => not equal
              - ct => contains
              - nct => not contains
              - in => inside array separated by "|"
              - nin => not inside array separated by "|"

        sort_by : typing.Optional[str]
            The field name to use for sorting results. Use `desc(field_name)` to sort descending by `field_name`, and use `asc(field_name)` to sort ascending by `field_name`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[VCardQueryResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"Query/vcards/org/{jsonable_encoder(org_id)}",
            method="GET",
            params={
                "exportFormat": export_format,
                "fromRecord": from_record,
                "limitRecord": limit_record,
                "parameters": parameters,
                "sortBy": sort_by,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    VCardQueryResponse,
                    parse_obj_as(
                        type_=VCardQueryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
