"""
LunaEngine Image Conversion Tool

Function:
    Converts images to embedded Python code for use in the LunaEngine graphics engine,
    supporting resolution scaling and multiple encoding methods.

Description:
    Command-line tool for converting images into Python representations that can be
    embedded directly in source code. Offers resizing options, preview capabilities,
    and batch conversion support.

Location:
    lunaengine/tools/image_conversion_tool.py

Libraries Used:
    - os: Path and directory manipulation
    - sys: Argument handling and system control
    - argparse: Command-line argument processing
    - pathlib: Object-oriented path handling
    - pygame: Image processing and preview functionality
    - utils (internal module): ImageConverter and EmbeddedImage for conversion
"""

import os
import sys
import argparse
from pathlib import Path

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from utils import ImageConverter, EmbeddedImage
import pygame

def main():
    parser = argparse.ArgumentParser(description='LunaEngine Image Conversion Tool')
    parser.add_argument('input_image', help='Input image file path')
    parser.add_argument('--output', '-o', help='Output Python file path')
    parser.add_argument('--var-name', '-v', default='embedded_image', help='Variable name in output code')
    parser.add_argument('--max-width', type=int, help='Maximum width (maintains aspect ratio)')
    parser.add_argument('--max-height', type=int, help='Maximum height (maintains aspect ratio)')
    parser.add_argument('--width', type=int, help='Exact width (forces resize)')
    parser.add_argument('--height', type=int, help='Exact height (forces resize)')
    parser.add_argument('--method', '-m', choices=['pixel_array', 'base64', 'compressed'], 
                       default='compressed', help='Conversion method')
    parser.add_argument('--preview', '-p', action='store_true', help='Show preview of converted image')
    parser.add_argument('--quality', '-q', type=int, choices=range(1, 101), default=85,
                       help='Compression quality (1-100, higher=better)')
    
    args = parser.parse_args()
    
    # Initialize Pygame for preview if needed
    if args.preview:
        pygame.init()
    
    try:
        # Load and process the image
        input_path = Path(args.input_image)
        if not input_path.exists():
            print(f"âŒ Error: Input file '{args.input_image}' not found")
            return 1
        
        print(f"ðŸ–¼ï¸  Processing: {input_path.name}")
        
        # Determine output path
        if args.output:
            output_path = Path(args.output)
        else:
            output_path = input_path.with_suffix('.py')
        
        # Calculate target size
        target_size = None
        if args.max_width or args.max_height:
            target_size = (args.max_width, args.max_height)
        elif args.width or args.height:
            target_size = (args.width or 0, args.height or 0)
        
        # Convert the image
        python_code = ImageConverter.image_to_python_code(
            str(input_path),
            output_var_name=args.var_name,
            max_size=target_size,
            method=args.method
        )
        
        # Add header with conversion info
        header = [
            f'# Auto-generated by LunaEngine Image Conversion Tool',
            f'# Source: {input_path.name}',
            f'# Method: {args.method}',
            f'# Target size: {target_size}' if target_size else '# Original size preserved',
            f'# Generated on: {pygame.time.get_ticks()}',  # Simple timestamp
            ''
        ]
        
        full_code = '\n'.join(header) + python_code
        
        # Add usage example
        usage = [
            '',
            '# Usage example:',
            f'# from lunaengine.utils import EmbeddedImage',
            f'# image = EmbeddedImage({args.var_name})',
            f'# image.draw(renderer, x, y)',
            ''
        ]
        
        full_code += '\n'.join(usage)
        
        # Save the file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(full_code)
        
        print(f"âœ… Converted: {output_path}")
        
        # Show preview if requested
        if args.preview:
            show_preview(input_path, args.var_name, python_code, target_size)
        
        # Print statistics
        print_statistics(input_path, output_path, args.var_name, python_code)
        
        return 0
        
    except Exception as e:
        print(f"âŒ Error during conversion: {e}")
        return 1

def show_preview(original_path: Path, var_name: str, python_code: str, target_size: tuple):
    """Show a preview of the original and converted image"""
    try:
        # Extract image data from the generated code
        # This is a bit hacky but works for demonstration
        lines = python_code.split('\n')
        image_data = {}
        
        # Parse the generated dictionary
        for line in lines:
            if ':' in line and '"' in line or "'" in line:
                key, value = line.split(':', 1)
                key = key.strip().strip("'\" ")
                value = value.strip().strip(', ')
                
                if key in ['width', 'height']:
                    image_data[key] = int(value)
                elif key == 'data':
                    image_data[key] = value.strip("'\"")
                elif key == 'pixels':
                    # For pixel array method, we'll recreate the surface
                    pass
        
        # Create embedded image
        if 'data' in image_data or 'pixels' in image_data:
            embedded_image = EmbeddedImage(image_data)
            
            # Create preview window
            preview_width = 800
            preview_height = 600
            
            screen = pygame.display.set_mode((preview_width, preview_height))
            pygame.display.set_caption(f"Image Preview - {original_path.name}")
            
            # Load original image for comparison
            original_surface = pygame.image.load(str(original_path)).convert_alpha()
            
            # Create a surface for display
            display_surface = pygame.Surface((preview_width, preview_height))
            display_surface.fill((40, 40, 60))
            
            # Calculate layout
            original_width, original_height = original_surface.get_size()
            embedded_width, embedded_height = embedded_image.width, embedded_image.height
            
            # Scale images to fit preview
            max_display_width = 350
            max_display_height = 300
            
            # Scale original
            orig_ratio = min(max_display_width / original_width, max_display_height / original_height)
            orig_display_width = int(original_width * orig_ratio)
            orig_display_height = int(original_height * orig_ratio)
            orig_scaled = pygame.transform.smoothscale(original_surface, (orig_display_width, orig_display_height))
            
            # Scale embedded
            embed_ratio = min(max_display_width / embedded_width, max_display_height / embedded_height)
            embed_display_width = int(embedded_width * embed_ratio)
            embed_display_height = int(embedded_height * embed_ratio)
            embed_scaled = pygame.transform.smoothscale(embedded_image.surface, (embed_display_width, embed_display_height))
            
            # Draw images
            orig_x = 50
            orig_y = 100
            embed_x = 450
            embed_y = 100
            
            display_surface.blit(orig_scaled, (orig_x, orig_y))
            display_surface.blit(embed_scaled, (embed_x, embed_y))
            
            # Draw labels
            font = pygame.font.Font(None, 36)
            title_font = pygame.font.Font(None, 24)
            
            title = font.render("Image Conversion Preview", True, (255, 255, 255))
            original_label = title_font.render(f"Original: {original_width}x{original_height}", True, (255, 200, 100))
            embedded_label = title_font.render(f"Embedded: {embedded_width}x{embedded_height}", True, (100, 255, 100))
            instructions = title_font.render("Press any key to close preview", True, (200, 200, 255))
            
            display_surface.blit(title, (preview_width//2 - title.get_width()//2, 20))
            display_surface.blit(original_label, (orig_x, orig_y - 30))
            display_surface.blit(embedded_label, (embed_x, embed_y - 30))
            display_surface.blit(instructions, (preview_width//2 - instructions.get_width()//2, 500))
            
            # Display
            screen.blit(display_surface, (0, 0))
            pygame.display.flip()
            
            # Wait for user input
            waiting = True
            while waiting:
                for event in pygame.event.get():
                    if event.type in (pygame.QUIT, pygame.KEYDOWN, pygame.MOUSEBUTTONDOWN):
                        waiting = False
            
            pygame.quit()
            
    except Exception as e:
        print(f"âš ï¸  Preview failed: {e}")

def print_statistics(original_path: Path, output_path: Path, var_name: str, python_code: str):
    """Print conversion statistics"""
    original_size = original_path.stat().st_size
    output_size = output_path.stat().st_size
    
    # Count lines in generated code
    code_lines = python_code.count('\n') + 1
    
    print("\nðŸ“Š CONVERSION STATISTICS:")
    print("=" * 40)
    print(f"Original file size:  {original_size / 1024:.1f} KB")
    print(f"Generated code size: {output_size / 1024:.1f} KB")
    print(f"Lines of code:      {code_lines}")
    print(f"Size ratio:         {output_size / original_size:.2f}x")
    print(f"Variable name:      {var_name}")
    print("=" * 40)

def batch_convert():
    """Batch convert multiple images"""
    parser = argparse.ArgumentParser(description='Batch convert images')
    parser.add_argument('input_dir', help='Input directory containing images')
    parser.add_argument('--output-dir', help='Output directory for Python files')
    parser.add_argument('--max-width', type=int, default=512, help='Maximum width')
    parser.add_argument('--max-height', type=int, default=512, help='Maximum height')
    parser.add_argument('--method', choices=['pixel_array', 'base64', 'compressed'], 
                       default='compressed', help='Conversion method')
    
    args = parser.parse_args()
    
    input_dir = Path(args.input_dir)
    output_dir = Path(args.output_dir) if args.output_dir else input_dir / 'converted'
    output_dir.mkdir(exist_ok=True)
    
    # Supported image formats
    image_extensions = {'.png', '.jpg', '.jpeg', '.bmp', '.tga', '.tiff'}
    
    converted_count = 0
    total_size_reduction = 0
    
    for image_file in input_dir.iterdir():
        if image_file.suffix.lower() in image_extensions:
            try:
                output_file = output_dir / f"{image_file.stem}_embedded.py"
                var_name = f"{image_file.stem.lower().replace(' ', '_')}_image"
                
                python_code = ImageConverter.image_to_python_code(
                    str(image_file),
                    output_var_name=var_name,
                    max_size=(args.max_width, args.max_height),
                    method=args.method
                )
                
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(python_code)
                
                original_size = image_file.stat().st_size
                converted_size = output_file.stat().st_size
                size_ratio = converted_size / original_size
                total_size_reduction += size_ratio
                
                print(f"âœ… {image_file.name} -> {output_file.name} ({size_ratio:.2f}x)")
                converted_count += 1
                
            except Exception as e:
                print(f"âŒ Failed to convert {image_file.name}: {e}")
    
    if converted_count > 0:
        avg_ratio = total_size_reduction / converted_count
        print(f"\nðŸŽ‰ Batch conversion complete!")
        print(f"ðŸ“ Converted {converted_count} images")
        print(f"ðŸ“¦ Average size ratio: {avg_ratio:.2f}x")
        print(f"ðŸ’¾ Output directory: {output_dir}")

if __name__ == "__main__":
    # Check if we're doing batch conversion
    if len(sys.argv) > 1 and sys.argv[1] == 'batch':
        sys.argv.pop(1)  # Remove 'batch' from arguments
        batch_convert()
    else:
        sys.exit(main())