#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;
"""
C# SDK Interface Generator for struct-frame.

This module generates a high-level SDK interface class that provides
type-safe send and subscribe methods for each message type. The generated
interface wraps a StructFrameSdk instance and provides convenience methods
for each message in the package.
"""

from struct_frame import version, pascalCase
import time


def get_csharp_field_type(field, package_name):
    """Get the C# type for a field"""
    from struct_frame.csharp_gen import csharp_types
    
    type_name = field.fieldType
    
    # Handle basic type resolution
    if type_name in csharp_types:
        base_type = csharp_types[type_name]
    else:
        # Use the package where the type is defined
        type_pkg = getattr(field, 'type_package', None) if hasattr(field, 'type_package') else None
        type_pkg = type_pkg if type_pkg else getattr(field, 'package', package_name)
        if field.isEnum:
            base_type = f'{pascalCase(type_pkg)}{type_name}'
        else:
            base_type = f'{pascalCase(type_pkg)}{type_name}'
    
    # Handle arrays
    if field.is_array:
        if field.fieldType == "string":
            # String arrays are byte[] in C#
            return "byte[]"
        else:
            if field.isEnum:
                return "byte[]"
            else:
                return f"{base_type}[]"
    
    # Handle regular strings
    elif field.fieldType == "string":
        return "byte[]"
    
    # Handle regular fields
    else:
        return base_type


class SdkInterfaceGen:
    """Generates C# SDK interface class for message sending and subscribing"""
    
    @staticmethod
    def generate(package):
        """Generate the SDK interface class for a package"""
        yield '// Automatically generated SDK Interface for C#\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'
        
        yield 'using System;\n'
        yield 'using System.Threading.Tasks;\n'
        yield 'using StructFrame;\n'
        yield 'using StructFrame.Sdk;\n'
        
        # Collect referenced packages for using directives
        referenced_packages = set()
        for key, msg in package.messages.items():
            for field_name, field in msg.fields.items():
                if field.type_package and field.type_package != package.name:
                    referenced_packages.add(field.type_package)
        
        # Add using directives for referenced packages
        if referenced_packages:
            for ref_pkg in sorted(referenced_packages):
                yield f'using StructFrame.{pascalCase(ref_pkg)};\n'
        
        yield f'using StructFrame.{pascalCase(package.name)};\n'
        yield '\n'
        
        namespace_name = pascalCase(package.name)
        yield f'namespace StructFrame.{namespace_name}.Sdk\n'
        yield '{\n'
        
        # Generate the SDK interface class
        yield '    /// <summary>\n'
        yield f'    /// High-level SDK interface for {package.name} messages\n'
        yield '    /// Provides type-safe send and subscribe methods for each message type\n'
        yield '    /// </summary>\n'
        yield f'    public class {namespace_name}SdkInterface\n'
        yield '    {\n'
        yield '        private readonly StructFrameSdk _sdk;\n'
        yield '\n'
        
        # Constructor
        yield '        /// <summary>\n'
        yield f'        /// Initialize the {namespace_name} SDK Interface\n'
        yield '        /// </summary>\n'
        yield '        /// <param name="sdk">The StructFrameSdk instance to use for communication</param>\n'
        yield f'        public {namespace_name}SdkInterface(StructFrameSdk sdk)\n'
        yield '        {\n'
        yield '            _sdk = sdk ?? throw new ArgumentNullException(nameof(sdk));\n'
        yield '        }\n'
        yield '\n'
        
        # Expose underlying SDK for advanced usage
        yield '        /// <summary>\n'
        yield '        /// The underlying StructFrameSdk instance\n'
        yield '        /// </summary>\n'
        yield '        public StructFrameSdk Sdk => _sdk;\n'
        yield '\n'
        
        # Generate send and subscribe methods for each message with msgid
        for key, msg in package.sortedMessages().items():
            if msg.id:  # Only generate for messages with a message ID
                yield from SdkInterfaceGen._generate_send_methods(msg, package.name)
                yield from SdkInterfaceGen._generate_subscribe_method(msg, package.name)
        
        yield '    }\n'
        yield '}\n'
    
    @staticmethod
    def _generate_subscribe_method(msg, package_name):
        """Generate subscribe method for a single message"""
        struct_name = f'{pascalCase(package_name)}{msg.name}'
        method_name = f'Subscribe{msg.name}'
        
        yield '        /// <summary>\n'
        yield f'        /// Subscribe to {msg.name} messages\n'
        yield '        /// </summary>\n'
        yield f'        /// <param name="handler">Handler to call when {msg.name} message is received</param>\n'
        yield '        /// <returns>Action to unsubscribe</returns>\n'
        yield f'        public Action {method_name}(MessageHandler<{struct_name}> handler)\n'
        yield '        {\n'
        yield f'            return _sdk.Subscribe<{struct_name}>(handler);\n'
        yield '        }\n'
        yield '\n'
    
    @staticmethod
    def _generate_send_methods(msg, package_name):
        """Generate send methods for a single message"""
        struct_name = f'{pascalCase(package_name)}{msg.name}'
        method_name = f'Send{msg.name}'
        
        # Method 1: Send with struct reference
        yield '        /// <summary>\n'
        yield f'        /// Send {msg.name} message\n'
        yield '        /// </summary>\n'
        yield f'        /// <param name="message">The {msg.name} message to send</param>\n'
        yield f'        /// <param name="seq">Sequence number (optional)</param>\n'
        yield f'        /// <param name="sysId">System ID (optional)</param>\n'
        yield f'        /// <param name="compId">Component ID (optional)</param>\n'
        yield f'        public async Task {method_name}({struct_name} message, byte seq = 0, byte sysId = 0, byte compId = 0)\n'
        yield '        {\n'
        yield '            await _sdk.SendAsync(message, seq, sysId, compId);\n'
        yield '        }\n'
        yield '\n'
        
        # Method 2: Send with individual fields (only if message has fields)
        if msg.fields:
            yield '        /// <summary>\n'
            yield f'        /// Send {msg.name} message with individual field values\n'
            yield '        /// </summary>\n'
            
            # Generate parameters
            params = []
            for field_name, field in msg.fields.items():
                csharp_type = get_csharp_field_type(field, package_name)
                param_name = pascalCase(field.name).lower()
                
                # Add parameter with comment
                yield f'        /// <param name="{param_name}">{field.name}</param>\n'
                params.append(f'{csharp_type} {param_name}')
            
            param_str = ', '.join(params)
            yield f'        public async Task {method_name}({param_str})\n'
            yield '        {\n'
            yield f'            var message = new {struct_name}();\n'
            
            # Assign each field
            for field_name, field in msg.fields.items():
                param_name = pascalCase(field.name).lower()
                struct_field_name = pascalCase(field.name)
                
                # Handle different field types
                if field.is_array:
                    if field.fieldType == "string":
                        # String arrays
                        if field.size_option is not None:
                            # Fixed string array
                            yield f'            message.{struct_field_name} = {param_name};\n'
                        elif field.max_size is not None:
                            # Variable string array - use integer division
                            yield f'            message.{struct_field_name}Count = (byte)Math.Min({param_name}.Length / {field.element_size}, {field.max_size});\n'
                            yield f'            message.{struct_field_name}Data = {param_name};\n'
                    else:
                        # Non-string arrays
                        if field.size_option is not None:
                            # Fixed array
                            yield f'            message.{struct_field_name} = {param_name};\n'
                        elif field.max_size is not None:
                            # Variable array
                            yield f'            message.{struct_field_name}Count = (byte)Math.Min({param_name}.Length, {field.max_size});\n'
                            yield f'            message.{struct_field_name}Data = {param_name};\n'
                elif field.fieldType == "string":
                    # Regular strings
                    if field.size_option is not None:
                        # Fixed string
                        yield f'            message.{struct_field_name} = {param_name};\n'
                    elif field.max_size is not None:
                        # Variable string
                        yield f'            message.{struct_field_name}Length = (byte)Math.Min({param_name}.Length, {field.max_size});\n'
                        yield f'            message.{struct_field_name}Data = {param_name};\n'
                else:
                    # Regular fields
                    yield f'            message.{struct_field_name} = {param_name};\n'
            
            yield f'            await {method_name}(message);\n'
            yield '        }\n'
            yield '\n'


def generate_csharp_sdk_interface(package):
    """Generate C# SDK interface code from a package"""
    return ''.join(SdkInterfaceGen.generate(package))
