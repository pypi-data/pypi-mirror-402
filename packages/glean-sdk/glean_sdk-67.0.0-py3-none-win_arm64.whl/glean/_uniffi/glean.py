# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
from dataclasses import dataclass
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform


# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_glean_core_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_glean_core_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_glean_core_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError(f"junk data left in buffer at end of consume_with_stream {s.remaining()}")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError(f"junk data left in buffer at end of read_with_stream {s.remaining()}")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiFfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))
# Initial value and increment amount for handles. 
# These ensure that Python-generated handles always have the lowest bit set
_UNIFFI_HANDLEMAP_INITIAL = 1
_UNIFFI_HANDLEMAP_DELTA = 2

class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = _UNIFFI_HANDLEMAP_INITIAL

    def insert(self, obj):
        with self._lock:
            return self._insert(obj)

    """Low-level insert, this assumes `self._lock` is held."""
    def _insert(self, obj):
        handle = self._counter
        self._counter += _UNIFFI_HANDLEMAP_DELTA
        self._map[handle] = obj
        return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.get: Invalid handle {handle}")

    def clone(self, handle):
        try:
            with self._lock:
                obj = self._map[handle]
                return self._insert(obj)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.clone: Invalid handle {handle}")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.remove: Invalid handle: {handle}")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("glean_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 30
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_glean_core_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_glean_core_checksum_func_glean_apply_server_knobs_config() != 60669:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_enable_logging() != 23531:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_enable_logging_to_fd() != 3838:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_get_debug_view_tag() != 53587:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_get_log_pings() != 20267:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_get_registered_ping_names() != 28073:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_get_upload_task() != 14859:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_handle_client_active() != 15870:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_handle_client_inactive() != 53329:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_initialize() != 28494:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_initialize_for_subprocess() != 51463:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_persist_ping_lifetime_data() != 63318:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_process_ping_upload_response() != 40546:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_register_event_listener() != 53202:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_set_debug_view_tag() != 40313:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_set_dirty_flag() != 30094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_set_experiment_active() != 34395:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_set_experiment_inactive() != 10322:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_set_experimentation_id() != 36389:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_set_log_pings() != 11842:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_set_source_tags() != 52804:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_set_test_mode() != 4528:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_set_upload_enabled() != 20119:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_shutdown() != 1598:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_submit_ping_by_name() != 21256:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_submit_ping_by_name_sync() != 31450:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_test_destroy_glean() != 29595:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_test_get_attribution() != 56753:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_test_get_distribution() != 37826:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_test_get_experiment_data() != 14791:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_test_get_experimentation_id() != 22050:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_unregister_event_listener() != 22885:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_update_attribution() != 25183:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_func_glean_update_distribution() != 64281:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_booleanmetric_new() != 21464:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_booleanmetric_set() != 19099:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_booleanmetric_test_get_num_recorded_errors() != 30931:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_booleanmetric_test_get_value() != 22115:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_countermetric_new() != 10560:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_countermetric_add() != 14751:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_countermetric_test_get_num_recorded_errors() != 60595:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_countermetric_test_get_value() != 35354:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_customdistributionmetric_new() != 55228:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_customdistributionmetric_accumulate_samples() != 46157:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_customdistributionmetric_accumulate_single_sample() != 6740:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_customdistributionmetric_test_get_num_recorded_errors() != 55105:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_customdistributionmetric_test_get_value() != 17206:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_datetimemetric_new() != 41604:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_datetimemetric_set() != 20042:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_datetimemetric_test_get_num_recorded_errors() != 58017:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_datetimemetric_test_get_value() != 55668:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_datetimemetric_test_get_value_as_string() != 40012:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_denominatormetric_new() != 55721:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_denominatormetric_add() != 41776:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_denominatormetric_test_get_num_recorded_errors() != 24854:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_denominatormetric_test_get_value() != 46881:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_duallabeledcountermetric_new() != 45810:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_duallabeledcountermetric_get() != 50530:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_duallabeledcountermetric_test_get_num_recorded_errors() != 62649:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_duallabeledcountermetric_test_get_value() != 58041:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_eventmetric_new() != 29941:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_eventmetric_record() != 51108:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_eventmetric_test_get_num_recorded_errors() != 10295:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_eventmetric_test_get_value() != 4783:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_labeledboolean_new() != 23334:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledboolean_get() != 36885:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledboolean_test_get_num_recorded_errors() != 41403:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledboolean_test_get_value() != 26140:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_labeledcounter_new() != 9547:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledcounter_get() != 3774:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledcounter_test_get_num_recorded_errors() != 51813:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledcounter_test_get_value() != 17302:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_labeledquantity_new() != 14259:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledquantity_get() != 38059:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledquantity_test_get_num_recorded_errors() != 9664:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledquantity_test_get_value() != 34143:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_labeledstring_new() != 18295:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledstring_get() != 2112:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledstring_test_get_num_recorded_errors() != 28933:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_labeledstring_test_get_value() != 29720:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_memorydistributionmetric_new() != 55298:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_memorydistributionmetric_accumulate() != 16560:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_memorydistributionmetric_accumulate_samples() != 30941:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_memorydistributionmetric_test_get_num_recorded_errors() != 17855:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_memorydistributionmetric_test_get_value() != 52514:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_numeratormetric_new() != 64748:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_numeratormetric_add_to_numerator() != 58999:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_numeratormetric_test_get_num_recorded_errors() != 29380:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_numeratormetric_test_get_value() != 8315:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_objectmetric_new() != 41544:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_objectmetric_record_schema_error() != 3744:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_objectmetric_set_string() != 54610:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_objectmetric_test_get_num_recorded_errors() != 46553:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_objectmetric_test_get_value() != 54185:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_pingtype_new() != 31559:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_pingtype_set_enabled() != 4503:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_pingtype_submit() != 53889:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_quantitymetric_new() != 29178:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_quantitymetric_set() != 13316:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_quantitymetric_test_get_num_recorded_errors() != 49441:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_quantitymetric_test_get_value() != 22798:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_ratemetric_new() != 5933:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_ratemetric_add_to_denominator() != 17172:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_ratemetric_add_to_numerator() != 60459:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_ratemetric_test_get_num_recorded_errors() != 62517:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_ratemetric_test_get_value() != 47946:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_stringlistmetric_new() != 21458:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_stringlistmetric_add() != 12458:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_stringlistmetric_set() != 43322:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_stringlistmetric_test_get_num_recorded_errors() != 53037:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_stringlistmetric_test_get_value() != 39568:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_stringmetric_new() != 26725:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_stringmetric_set() != 8753:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_stringmetric_test_get_num_recorded_errors() != 9432:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_stringmetric_test_get_value() != 28188:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_textmetric_new() != 245:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_textmetric_set() != 10629:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_textmetric_test_get_num_recorded_errors() != 5912:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_textmetric_test_get_value() != 46411:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_timespanmetric_new() != 27434:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timespanmetric_cancel() != 2028:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timespanmetric_set_raw_nanos() != 24170:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timespanmetric_start() != 49038:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timespanmetric_stop() != 44342:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timespanmetric_test_get_num_recorded_errors() != 42515:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timespanmetric_test_get_value() != 2478:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_timingdistributionmetric_new() != 16339:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timingdistributionmetric_accumulate_samples() != 42794:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timingdistributionmetric_accumulate_single_sample() != 698:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timingdistributionmetric_cancel() != 7886:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timingdistributionmetric_start() != 11833:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timingdistributionmetric_stop_and_accumulate() != 39652:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timingdistributionmetric_test_get_num_recorded_errors() != 9297:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_timingdistributionmetric_test_get_value() != 27222:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_urlmetric_new() != 33728:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_urlmetric_set() != 6154:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_urlmetric_test_get_num_recorded_errors() != 54863:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_urlmetric_test_get_value() != 9557:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_constructor_uuidmetric_new() != 617:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_uuidmetric_generate_and_set() != 53248:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_uuidmetric_set() != 42714:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_uuidmetric_test_get_num_recorded_errors() != 43091:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glean_core_checksum_method_uuidmetric_test_get_value() != 54933:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.ffi_glean_core_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_glean_core_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_glean_core_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rustbuffer_free.restype = None
_UniffiLib.ffi_glean_core_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rustbuffer_reserve.restype = _UniffiRustBuffer
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFutureDroppedCallbackStruct(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK),
    ]
_UniffiLib.ffi_glean_core_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_u8.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_glean_core_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_u8.restype = None
_UniffiLib.ffi_glean_core_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_i8.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_glean_core_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_i8.restype = None
_UniffiLib.ffi_glean_core_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_u16.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_glean_core_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_u16.restype = None
_UniffiLib.ffi_glean_core_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_i16.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_glean_core_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_i16.restype = None
_UniffiLib.ffi_glean_core_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_u32.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_glean_core_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_u32.restype = None
_UniffiLib.ffi_glean_core_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_i32.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_glean_core_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_i32.restype = None
_UniffiLib.ffi_glean_core_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_u64.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_glean_core_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_u64.restype = None
_UniffiLib.ffi_glean_core_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_i64.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_glean_core_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_i64.restype = None
_UniffiLib.ffi_glean_core_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_f32.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_glean_core_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_f32.restype = None
_UniffiLib.ffi_glean_core_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_f64.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_glean_core_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_f64.restype = None
_UniffiLib.ffi_glean_core_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_glean_core_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_glean_core_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_poll_void.restype = None
_UniffiLib.ffi_glean_core_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_cancel_void.restype = None
_UniffiLib.ffi_glean_core_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glean_core_rust_future_complete_void.restype = None
_UniffiLib.ffi_glean_core_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glean_core_rust_future_free_void.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_booleanmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_booleanmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_booleanmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_booleanmetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_countermetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_countermetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_countermetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_countermetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_customdistributionmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_customdistributionmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_customdistributionmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_customdistributionmetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_datetimemetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_datetimemetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_datetimemetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_datetimemetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_denominatormetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_denominatormetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_denominatormetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_denominatormetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_duallabeledcountermetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_duallabeledcountermetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_duallabeledcountermetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_duallabeledcountermetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_eventmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_eventmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_eventmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_eventmetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_labeledboolean.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_labeledboolean.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_labeledboolean.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_labeledboolean.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_labeledcounter.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_labeledcounter.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_labeledcounter.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_labeledcounter.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_labeledquantity.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_labeledquantity.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_labeledquantity.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_labeledquantity.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_labeledstring.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_labeledstring.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_labeledstring.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_labeledstring.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_memorydistributionmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_memorydistributionmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_memorydistributionmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_memorydistributionmetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_numeratormetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_numeratormetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_numeratormetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_numeratormetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_objectmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_objectmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_objectmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_objectmetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_pingtype.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_pingtype.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_pingtype.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_pingtype.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_quantitymetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_quantitymetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_quantitymetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_quantitymetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_ratemetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_ratemetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_ratemetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_ratemetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_stringlistmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_stringlistmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_stringlistmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_stringlistmetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_stringmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_stringmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_stringmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_stringmetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_textmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_textmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_textmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_textmetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_timespanmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_timespanmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_timespanmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_timespanmetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_timingdistributionmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_timingdistributionmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_timingdistributionmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_timingdistributionmetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_urlmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_urlmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_urlmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_urlmetric.restype = None
_UniffiLib.uniffi_glean_core_fn_clone_uuidmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_clone_uuidmetric.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_free_uuidmetric.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_free_uuidmetric.restype = None
_UNIFFI_CALLBACK_INTERFACE_GLEAN_GLEAN_EVENT_LISTENER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_CLONE_GLEAN_GLEAN_EVENT_LISTENER = ctypes.CFUNCTYPE(ctypes.c_uint64,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE_GLEAN_GLEAN_EVENT_LISTENER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiVTableCallbackInterfaceGleanGleanEventListener(ctypes.Structure):
    _fields_ = [
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE_GLEAN_GLEAN_EVENT_LISTENER),
        ("uniffi_clone", _UNIFFI_CALLBACK_INTERFACE_CLONE_GLEAN_GLEAN_EVENT_LISTENER),
        ("on_event_recorded", _UNIFFI_CALLBACK_INTERFACE_GLEAN_GLEAN_EVENT_LISTENER_METHOD0),
    ]
_UniffiLib.uniffi_glean_core_fn_init_callback_vtable_gleaneventlistener.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceGleanGleanEventListener),
)
_UniffiLib.uniffi_glean_core_fn_init_callback_vtable_gleaneventlistener.restype = None
_UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.POINTER(ctypes.c_int8),
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD3 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD4 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_CLONE_GLEAN_ON_GLEAN_EVENTS = ctypes.CFUNCTYPE(ctypes.c_uint64,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE_GLEAN_ON_GLEAN_EVENTS = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiVTableCallbackInterfaceGleanOnGleanEvents(ctypes.Structure):
    _fields_ = [
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE_GLEAN_ON_GLEAN_EVENTS),
        ("uniffi_clone", _UNIFFI_CALLBACK_INTERFACE_CLONE_GLEAN_ON_GLEAN_EVENTS),
        ("initialize_finished", _UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD0),
        ("trigger_upload", _UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD1),
        ("start_metrics_ping_scheduler", _UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD2),
        ("cancel_uploads", _UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD3),
        ("shutdown", _UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD4),
    ]
_UniffiLib.uniffi_glean_core_fn_init_callback_vtable_ongleanevents.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceGleanOnGleanEvents),
)
_UniffiLib.uniffi_glean_core_fn_init_callback_vtable_ongleanevents.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_apply_server_knobs_config.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_apply_server_knobs_config.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_enable_logging.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_enable_logging.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_enable_logging_to_fd.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_enable_logging_to_fd.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_get_debug_view_tag.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_get_debug_view_tag.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_func_glean_get_log_pings.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_get_log_pings.restype = ctypes.c_int8
_UniffiLib.uniffi_glean_core_fn_func_glean_get_registered_ping_names.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_get_registered_ping_names.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_func_glean_get_upload_task.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_get_upload_task.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_func_glean_handle_client_active.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_handle_client_active.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_handle_client_inactive.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_handle_client_inactive.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_initialize.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_initialize.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_initialize_for_subprocess.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_initialize_for_subprocess.restype = ctypes.c_int8
_UniffiLib.uniffi_glean_core_fn_func_glean_persist_ping_lifetime_data.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_persist_ping_lifetime_data.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_process_ping_upload_response.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_process_ping_upload_response.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_func_glean_register_event_listener.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_register_event_listener.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_set_debug_view_tag.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_set_debug_view_tag.restype = ctypes.c_int8
_UniffiLib.uniffi_glean_core_fn_func_glean_set_dirty_flag.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_set_dirty_flag.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_set_experiment_active.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_set_experiment_active.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_set_experiment_inactive.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_set_experiment_inactive.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_set_experimentation_id.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_set_experimentation_id.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_set_log_pings.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_set_log_pings.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_set_source_tags.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_set_source_tags.restype = ctypes.c_int8
_UniffiLib.uniffi_glean_core_fn_func_glean_set_test_mode.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_set_test_mode.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_set_upload_enabled.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_set_upload_enabled.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_shutdown.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_shutdown.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_submit_ping_by_name.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_submit_ping_by_name.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_submit_ping_by_name_sync.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_submit_ping_by_name_sync.restype = ctypes.c_int8
_UniffiLib.uniffi_glean_core_fn_func_glean_test_destroy_glean.argtypes = (
    ctypes.c_int8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_test_destroy_glean.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_test_get_attribution.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_test_get_attribution.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_func_glean_test_get_distribution.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_test_get_distribution.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_func_glean_test_get_experiment_data.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_test_get_experiment_data.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_func_glean_test_get_experimentation_id.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_test_get_experimentation_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_func_glean_unregister_event_listener.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_unregister_event_listener.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_update_attribution.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_update_attribution.restype = None
_UniffiLib.uniffi_glean_core_fn_func_glean_update_distribution.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_func_glean_update_distribution.restype = None
_UniffiLib.uniffi_glean_core_fn_constructor_booleanmetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_booleanmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_set.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_set.restype = None
_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_booleanmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_countermetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_countermetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_countermetric_add.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_countermetric_add.restype = None
_UniffiLib.uniffi_glean_core_fn_method_countermetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_countermetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_countermetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_countermetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_customdistributionmetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int64,
    ctypes.c_int64,
    ctypes.c_int64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_customdistributionmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_accumulate_samples.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_accumulate_samples.restype = None
_UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_accumulate_single_sample.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_accumulate_single_sample.restype = None
_UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_datetimemetric_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_datetimemetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_datetimemetric_set.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_datetimemetric_set.restype = None
_UniffiLib.uniffi_glean_core_fn_method_datetimemetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_datetimemetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_datetimemetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_datetimemetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_method_datetimemetric_test_get_value_as_string.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_datetimemetric_test_get_value_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_denominatormetric_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_denominatormetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_denominatormetric_add.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_denominatormetric_add.restype = None
_UniffiLib.uniffi_glean_core_fn_method_denominatormetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_denominatormetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_denominatormetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_denominatormetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_duallabeledcountermetric_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_duallabeledcountermetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_duallabeledcountermetric_get.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_duallabeledcountermetric_get.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_duallabeledcountermetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_duallabeledcountermetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_duallabeledcountermetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_duallabeledcountermetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_eventmetric_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_eventmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_eventmetric_record.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_eventmetric_record.restype = None
_UniffiLib.uniffi_glean_core_fn_method_eventmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_eventmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_eventmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_eventmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_labeledboolean_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_labeledboolean_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_labeledboolean_get.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledboolean_get.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_labeledboolean_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledboolean_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_labeledboolean_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledboolean_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_labeledcounter_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_labeledcounter_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_labeledcounter_get.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledcounter_get.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_labeledcounter_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledcounter_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_labeledcounter_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledcounter_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_labeledquantity_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_labeledquantity_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_labeledquantity_get.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledquantity_get.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_labeledquantity_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledquantity_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_labeledquantity_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledquantity_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_labeledstring_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_labeledstring_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_labeledstring_get.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledstring_get.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_labeledstring_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledstring_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_labeledstring_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_labeledstring_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_memorydistributionmetric_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_memorydistributionmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_accumulate.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_accumulate.restype = None
_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_accumulate_samples.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_accumulate_samples.restype = None
_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_numeratormetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_numeratormetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_numeratormetric_add_to_numerator.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_numeratormetric_add_to_numerator.restype = None
_UniffiLib.uniffi_glean_core_fn_method_numeratormetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_numeratormetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_numeratormetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_numeratormetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_objectmetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_objectmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_objectmetric_record_schema_error.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_objectmetric_record_schema_error.restype = None
_UniffiLib.uniffi_glean_core_fn_method_objectmetric_set_string.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_objectmetric_set_string.restype = None
_UniffiLib.uniffi_glean_core_fn_method_objectmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_objectmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_objectmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_objectmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_pingtype_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.c_int8,
    ctypes.c_int8,
    ctypes.c_int8,
    ctypes.c_int8,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_int8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_pingtype_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_pingtype_set_enabled.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_pingtype_set_enabled.restype = None
_UniffiLib.uniffi_glean_core_fn_method_pingtype_submit.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_pingtype_submit.restype = None
_UniffiLib.uniffi_glean_core_fn_constructor_quantitymetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_quantitymetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_set.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_set.restype = None
_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_quantitymetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_ratemetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_ratemetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_ratemetric_add_to_denominator.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_ratemetric_add_to_denominator.restype = None
_UniffiLib.uniffi_glean_core_fn_method_ratemetric_add_to_numerator.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_ratemetric_add_to_numerator.restype = None
_UniffiLib.uniffi_glean_core_fn_method_ratemetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_ratemetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_ratemetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_ratemetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_stringlistmetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_stringlistmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_add.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_add.restype = None
_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_set.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_set.restype = None
_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_stringmetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_stringmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_stringmetric_set.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_stringmetric_set.restype = None
_UniffiLib.uniffi_glean_core_fn_method_stringmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_stringmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_stringmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_stringmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_textmetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_textmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_textmetric_set.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_textmetric_set.restype = None
_UniffiLib.uniffi_glean_core_fn_method_textmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_textmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_textmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_textmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_timespanmetric_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_timespanmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_cancel.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_cancel.restype = None
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_set_raw_nanos.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_set_raw_nanos.restype = None
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_start.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_start.restype = None
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_stop.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_stop.restype = None
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timespanmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_timingdistributionmetric_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_timingdistributionmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_accumulate_samples.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_accumulate_samples.restype = None
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_accumulate_single_sample.argtypes = (
    ctypes.c_uint64,
    ctypes.c_int64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_accumulate_single_sample.restype = None
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_cancel.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_cancel.restype = None
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_start.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_start.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_stop_and_accumulate.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_stop_and_accumulate.restype = None
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_urlmetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_urlmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_urlmetric_set.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_urlmetric_set.restype = None
_UniffiLib.uniffi_glean_core_fn_method_urlmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_urlmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_urlmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_urlmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_constructor_uuidmetric_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_constructor_uuidmetric_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_glean_core_fn_method_uuidmetric_generate_and_set.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_uuidmetric_generate_and_set.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glean_core_fn_method_uuidmetric_set.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_uuidmetric_set.restype = None
_UniffiLib.uniffi_glean_core_fn_method_uuidmetric_test_get_num_recorded_errors.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_uuidmetric_test_get_num_recorded_errors.restype = ctypes.c_int32
_UniffiLib.uniffi_glean_core_fn_method_uuidmetric_test_get_value.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glean_core_fn_method_uuidmetric_test_get_value.restype = _UniffiRustBuffer
_UniffiLib.ffi_glean_core_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_glean_core_uniffi_contract_version.restype = ctypes.c_uint32
_UniffiLib.uniffi_glean_core_checksum_func_glean_apply_server_knobs_config.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_apply_server_knobs_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_enable_logging.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_enable_logging.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_enable_logging_to_fd.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_enable_logging_to_fd.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_get_debug_view_tag.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_get_debug_view_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_get_log_pings.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_get_log_pings.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_get_registered_ping_names.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_get_registered_ping_names.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_get_upload_task.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_get_upload_task.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_handle_client_active.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_handle_client_active.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_handle_client_inactive.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_handle_client_inactive.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_initialize.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_initialize.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_initialize_for_subprocess.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_initialize_for_subprocess.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_persist_ping_lifetime_data.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_persist_ping_lifetime_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_process_ping_upload_response.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_process_ping_upload_response.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_register_event_listener.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_register_event_listener.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_debug_view_tag.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_debug_view_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_dirty_flag.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_dirty_flag.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_experiment_active.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_experiment_active.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_experiment_inactive.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_experiment_inactive.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_experimentation_id.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_experimentation_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_log_pings.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_log_pings.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_source_tags.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_source_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_test_mode.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_test_mode.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_upload_enabled.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_set_upload_enabled.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_shutdown.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_shutdown.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_submit_ping_by_name.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_submit_ping_by_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_submit_ping_by_name_sync.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_submit_ping_by_name_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_test_destroy_glean.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_test_destroy_glean.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_test_get_attribution.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_test_get_attribution.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_test_get_distribution.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_test_get_distribution.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_test_get_experiment_data.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_test_get_experiment_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_test_get_experimentation_id.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_test_get_experimentation_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_unregister_event_listener.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_unregister_event_listener.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_update_attribution.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_update_attribution.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_func_glean_update_distribution.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_func_glean_update_distribution.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_booleanmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_booleanmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_booleanmetric_set.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_booleanmetric_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_booleanmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_booleanmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_booleanmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_booleanmetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_countermetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_countermetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_countermetric_add.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_countermetric_add.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_countermetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_countermetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_countermetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_countermetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_customdistributionmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_customdistributionmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_customdistributionmetric_accumulate_samples.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_customdistributionmetric_accumulate_samples.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_customdistributionmetric_accumulate_single_sample.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_customdistributionmetric_accumulate_single_sample.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_customdistributionmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_customdistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_customdistributionmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_customdistributionmetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_datetimemetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_datetimemetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_datetimemetric_set.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_datetimemetric_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_datetimemetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_datetimemetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_datetimemetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_datetimemetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_datetimemetric_test_get_value_as_string.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_datetimemetric_test_get_value_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_denominatormetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_denominatormetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_denominatormetric_add.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_denominatormetric_add.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_denominatormetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_denominatormetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_denominatormetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_denominatormetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_duallabeledcountermetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_duallabeledcountermetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_duallabeledcountermetric_get.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_duallabeledcountermetric_get.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_duallabeledcountermetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_duallabeledcountermetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_duallabeledcountermetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_duallabeledcountermetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_eventmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_eventmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_eventmetric_record.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_eventmetric_record.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_eventmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_eventmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_eventmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_eventmetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_labeledboolean_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_labeledboolean_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledboolean_get.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledboolean_get.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledboolean_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledboolean_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledboolean_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledboolean_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_labeledcounter_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_labeledcounter_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledcounter_get.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledcounter_get.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledcounter_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledcounter_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledcounter_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledcounter_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_labeledquantity_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_labeledquantity_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledquantity_get.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledquantity_get.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledquantity_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledquantity_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledquantity_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledquantity_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_labeledstring_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_labeledstring_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledstring_get.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledstring_get.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledstring_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledstring_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_labeledstring_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_labeledstring_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_memorydistributionmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_memorydistributionmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_memorydistributionmetric_accumulate.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_memorydistributionmetric_accumulate.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_memorydistributionmetric_accumulate_samples.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_memorydistributionmetric_accumulate_samples.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_memorydistributionmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_memorydistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_memorydistributionmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_memorydistributionmetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_numeratormetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_numeratormetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_numeratormetric_add_to_numerator.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_numeratormetric_add_to_numerator.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_numeratormetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_numeratormetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_numeratormetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_numeratormetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_objectmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_objectmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_objectmetric_record_schema_error.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_objectmetric_record_schema_error.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_objectmetric_set_string.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_objectmetric_set_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_objectmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_objectmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_objectmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_objectmetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_pingtype_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_pingtype_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_pingtype_set_enabled.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_pingtype_set_enabled.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_pingtype_submit.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_pingtype_submit.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_quantitymetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_quantitymetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_quantitymetric_set.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_quantitymetric_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_quantitymetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_quantitymetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_quantitymetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_quantitymetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_ratemetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_ratemetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_ratemetric_add_to_denominator.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_ratemetric_add_to_denominator.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_ratemetric_add_to_numerator.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_ratemetric_add_to_numerator.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_ratemetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_ratemetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_ratemetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_ratemetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_stringlistmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_stringlistmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_stringlistmetric_add.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_stringlistmetric_add.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_stringlistmetric_set.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_stringlistmetric_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_stringlistmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_stringlistmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_stringlistmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_stringlistmetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_stringmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_stringmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_stringmetric_set.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_stringmetric_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_stringmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_stringmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_stringmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_stringmetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_textmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_textmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_textmetric_set.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_textmetric_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_textmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_textmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_textmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_textmetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_timespanmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_timespanmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_cancel.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_cancel.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_set_raw_nanos.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_set_raw_nanos.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_start.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_start.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_stop.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_stop.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timespanmetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_timingdistributionmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_timingdistributionmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_accumulate_samples.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_accumulate_samples.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_accumulate_single_sample.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_accumulate_single_sample.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_cancel.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_cancel.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_start.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_start.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_stop_and_accumulate.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_stop_and_accumulate.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_timingdistributionmetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_urlmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_urlmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_urlmetric_set.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_urlmetric_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_urlmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_urlmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_urlmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_urlmetric_test_get_value.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_constructor_uuidmetric_new.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_constructor_uuidmetric_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_uuidmetric_generate_and_set.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_uuidmetric_generate_and_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_uuidmetric_set.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_uuidmetric_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_uuidmetric_test_get_num_recorded_errors.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_uuidmetric_test_get_num_recorded_errors.restype = ctypes.c_uint16
_UniffiLib.uniffi_glean_core_checksum_method_uuidmetric_test_get_value.argtypes = (
)
_UniffiLib.uniffi_glean_core_checksum_method_uuidmetric_test_get_value.restype = ctypes.c_uint16

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)



# Public interface members begin here.


class _UniffiFfiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiFfiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class AttributionMetrics:
    def __init__(self, *, source:typing.Optional[str] = _DEFAULT, medium:typing.Optional[str] = _DEFAULT, campaign:typing.Optional[str] = _DEFAULT, term:typing.Optional[str] = _DEFAULT, content:typing.Optional[str] = _DEFAULT):
        if source is _DEFAULT:
            self.source = None
        else:
            self.source = source
        if medium is _DEFAULT:
            self.medium = None
        else:
            self.medium = medium
        if campaign is _DEFAULT:
            self.campaign = None
        else:
            self.campaign = campaign
        if term is _DEFAULT:
            self.term = None
        else:
            self.term = term
        if content is _DEFAULT:
            self.content = None
        else:
            self.content = content
        
        

    
    def __str__(self):
        return "AttributionMetrics(source={}, medium={}, campaign={}, term={}, content={})".format(self.source, self.medium, self.campaign, self.term, self.content)
    def __eq__(self, other):
        if self.source != other.source:
            return False
        if self.medium != other.medium:
            return False
        if self.campaign != other.campaign:
            return False
        if self.term != other.term:
            return False
        if self.content != other.content:
            return False
        return True

class _UniffiFfiConverterTypeAttributionMetrics(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AttributionMetrics(
            source=_UniffiFfiConverterOptionalString.read(buf),
            medium=_UniffiFfiConverterOptionalString.read(buf),
            campaign=_UniffiFfiConverterOptionalString.read(buf),
            term=_UniffiFfiConverterOptionalString.read(buf),
            content=_UniffiFfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterOptionalString.check_lower(value.source)
        _UniffiFfiConverterOptionalString.check_lower(value.medium)
        _UniffiFfiConverterOptionalString.check_lower(value.campaign)
        _UniffiFfiConverterOptionalString.check_lower(value.term)
        _UniffiFfiConverterOptionalString.check_lower(value.content)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterOptionalString.write(value.source, buf)
        _UniffiFfiConverterOptionalString.write(value.medium, buf)
        _UniffiFfiConverterOptionalString.write(value.campaign, buf)
        _UniffiFfiConverterOptionalString.write(value.term, buf)
        _UniffiFfiConverterOptionalString.write(value.content, buf)

class _UniffiFfiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiFfiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

@dataclass
class Datetime:
    def __init__(self, *, year:int, month:int, day:int, hour:int, minute:int, second:int, nanosecond:int, offset_seconds:int):
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second
        self.nanosecond = nanosecond
        self.offset_seconds = offset_seconds
        
        

    
    def __str__(self):
        return "Datetime(year={}, month={}, day={}, hour={}, minute={}, second={}, nanosecond={}, offset_seconds={})".format(self.year, self.month, self.day, self.hour, self.minute, self.second, self.nanosecond, self.offset_seconds)
    def __eq__(self, other):
        if self.year != other.year:
            return False
        if self.month != other.month:
            return False
        if self.day != other.day:
            return False
        if self.hour != other.hour:
            return False
        if self.minute != other.minute:
            return False
        if self.second != other.second:
            return False
        if self.nanosecond != other.nanosecond:
            return False
        if self.offset_seconds != other.offset_seconds:
            return False
        return True

class _UniffiFfiConverterTypeDatetime(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Datetime(
            year=_UniffiFfiConverterInt32.read(buf),
            month=_UniffiFfiConverterUInt32.read(buf),
            day=_UniffiFfiConverterUInt32.read(buf),
            hour=_UniffiFfiConverterUInt32.read(buf),
            minute=_UniffiFfiConverterUInt32.read(buf),
            second=_UniffiFfiConverterUInt32.read(buf),
            nanosecond=_UniffiFfiConverterUInt32.read(buf),
            offset_seconds=_UniffiFfiConverterInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterInt32.check_lower(value.year)
        _UniffiFfiConverterUInt32.check_lower(value.month)
        _UniffiFfiConverterUInt32.check_lower(value.day)
        _UniffiFfiConverterUInt32.check_lower(value.hour)
        _UniffiFfiConverterUInt32.check_lower(value.minute)
        _UniffiFfiConverterUInt32.check_lower(value.second)
        _UniffiFfiConverterUInt32.check_lower(value.nanosecond)
        _UniffiFfiConverterInt32.check_lower(value.offset_seconds)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterInt32.write(value.year, buf)
        _UniffiFfiConverterUInt32.write(value.month, buf)
        _UniffiFfiConverterUInt32.write(value.day, buf)
        _UniffiFfiConverterUInt32.write(value.hour, buf)
        _UniffiFfiConverterUInt32.write(value.minute, buf)
        _UniffiFfiConverterUInt32.write(value.second, buf)
        _UniffiFfiConverterUInt32.write(value.nanosecond, buf)
        _UniffiFfiConverterInt32.write(value.offset_seconds, buf)

class _UniffiFfiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiFfiConverterOptionalInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class ClientInfoMetrics:
    def __init__(self, *, app_build:str, app_display_version:str, app_build_date:Datetime, architecture:str, os_version:str, channel:typing.Optional[str] = _DEFAULT, locale:typing.Optional[str] = _DEFAULT, device_manufacturer:typing.Optional[str] = _DEFAULT, device_model:typing.Optional[str] = _DEFAULT, android_sdk_version:typing.Optional[str] = _DEFAULT, windows_build_number:typing.Optional[int] = _DEFAULT):
        self.app_build = app_build
        self.app_display_version = app_display_version
        self.app_build_date = app_build_date
        self.architecture = architecture
        self.os_version = os_version
        if channel is _DEFAULT:
            self.channel = None
        else:
            self.channel = channel
        if locale is _DEFAULT:
            self.locale = None
        else:
            self.locale = locale
        if device_manufacturer is _DEFAULT:
            self.device_manufacturer = None
        else:
            self.device_manufacturer = device_manufacturer
        if device_model is _DEFAULT:
            self.device_model = None
        else:
            self.device_model = device_model
        if android_sdk_version is _DEFAULT:
            self.android_sdk_version = None
        else:
            self.android_sdk_version = android_sdk_version
        if windows_build_number is _DEFAULT:
            self.windows_build_number = None
        else:
            self.windows_build_number = windows_build_number
        
        

    
    def __str__(self):
        return "ClientInfoMetrics(app_build={}, app_display_version={}, app_build_date={}, architecture={}, os_version={}, channel={}, locale={}, device_manufacturer={}, device_model={}, android_sdk_version={}, windows_build_number={})".format(self.app_build, self.app_display_version, self.app_build_date, self.architecture, self.os_version, self.channel, self.locale, self.device_manufacturer, self.device_model, self.android_sdk_version, self.windows_build_number)
    def __eq__(self, other):
        if self.app_build != other.app_build:
            return False
        if self.app_display_version != other.app_display_version:
            return False
        if self.app_build_date != other.app_build_date:
            return False
        if self.architecture != other.architecture:
            return False
        if self.os_version != other.os_version:
            return False
        if self.channel != other.channel:
            return False
        if self.locale != other.locale:
            return False
        if self.device_manufacturer != other.device_manufacturer:
            return False
        if self.device_model != other.device_model:
            return False
        if self.android_sdk_version != other.android_sdk_version:
            return False
        if self.windows_build_number != other.windows_build_number:
            return False
        return True

class _UniffiFfiConverterTypeClientInfoMetrics(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClientInfoMetrics(
            app_build=_UniffiFfiConverterString.read(buf),
            app_display_version=_UniffiFfiConverterString.read(buf),
            app_build_date=_UniffiFfiConverterTypeDatetime.read(buf),
            architecture=_UniffiFfiConverterString.read(buf),
            os_version=_UniffiFfiConverterString.read(buf),
            channel=_UniffiFfiConverterOptionalString.read(buf),
            locale=_UniffiFfiConverterOptionalString.read(buf),
            device_manufacturer=_UniffiFfiConverterOptionalString.read(buf),
            device_model=_UniffiFfiConverterOptionalString.read(buf),
            android_sdk_version=_UniffiFfiConverterOptionalString.read(buf),
            windows_build_number=_UniffiFfiConverterOptionalInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.app_build)
        _UniffiFfiConverterString.check_lower(value.app_display_version)
        _UniffiFfiConverterTypeDatetime.check_lower(value.app_build_date)
        _UniffiFfiConverterString.check_lower(value.architecture)
        _UniffiFfiConverterString.check_lower(value.os_version)
        _UniffiFfiConverterOptionalString.check_lower(value.channel)
        _UniffiFfiConverterOptionalString.check_lower(value.locale)
        _UniffiFfiConverterOptionalString.check_lower(value.device_manufacturer)
        _UniffiFfiConverterOptionalString.check_lower(value.device_model)
        _UniffiFfiConverterOptionalString.check_lower(value.android_sdk_version)
        _UniffiFfiConverterOptionalInt64.check_lower(value.windows_build_number)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.app_build, buf)
        _UniffiFfiConverterString.write(value.app_display_version, buf)
        _UniffiFfiConverterTypeDatetime.write(value.app_build_date, buf)
        _UniffiFfiConverterString.write(value.architecture, buf)
        _UniffiFfiConverterString.write(value.os_version, buf)
        _UniffiFfiConverterOptionalString.write(value.channel, buf)
        _UniffiFfiConverterOptionalString.write(value.locale, buf)
        _UniffiFfiConverterOptionalString.write(value.device_manufacturer, buf)
        _UniffiFfiConverterOptionalString.write(value.device_model, buf)
        _UniffiFfiConverterOptionalString.write(value.android_sdk_version, buf)
        _UniffiFfiConverterOptionalInt64.write(value.windows_build_number, buf)

class _UniffiFfiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterString.read(buf) for i in range(count)
        ]






class Lifetime(enum.Enum):
    
    PING = 0
    
    APPLICATION = 1
    
    USER = 2
    


class _UniffiFfiConverterTypeLifetime(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Lifetime.PING
        if variant == 2:
            return Lifetime.APPLICATION
        if variant == 3:
            return Lifetime.USER
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Lifetime.PING:
            return
        if value == Lifetime.APPLICATION:
            return
        if value == Lifetime.USER:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Lifetime.PING:
            buf.write_i32(1)
        if value == Lifetime.APPLICATION:
            buf.write_i32(2)
        if value == Lifetime.USER:
            buf.write_i32(3)



class _UniffiFfiConverterBoolean:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)






class DynamicLabelType:
    """
    The type of dynamic label applied to a base metric. Used to help identify
    the necessary validation to be performed.
"""
    def __init__(self):
        raise RuntimeError("DynamicLabelType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    @dataclass
    class LABEL:
        """
        A dynamic label applied from a `LabeledMetric`
"""
        
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

    
            
            

    
        def __str__(self):
            return f"DynamicLabelType.LABEL{self._values!r}"
        def __eq__(self, other):
            if not isinstance(other, DynamicLabelType):
                return NotImplemented
            if not other.is_LABEL():
                return False
            return self._values == other._values

    @dataclass
    class KEY_ONLY:
        """
        A label applied by a `DualLabeledCounter` that contains a dynamic key
"""
        
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

    
            
            

    
        def __str__(self):
            return f"DynamicLabelType.KEY_ONLY{self._values!r}"
        def __eq__(self, other):
            if not isinstance(other, DynamicLabelType):
                return NotImplemented
            if not other.is_KEY_ONLY():
                return False
            return self._values == other._values

    @dataclass
    class CATEGORY_ONLY:
        """
        A label applied by a `DualLabeledCounter` that contains a dynamic category
"""
        
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

    
            
            

    
        def __str__(self):
            return f"DynamicLabelType.CATEGORY_ONLY{self._values!r}"
        def __eq__(self, other):
            if not isinstance(other, DynamicLabelType):
                return NotImplemented
            if not other.is_CATEGORY_ONLY():
                return False
            return self._values == other._values

    @dataclass
    class KEY_AND_CATEGORY:
        """
        A label applied by a `DualLabeledCounter` that contains a dynamic key and category
"""
        
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

    
            
            

    
        def __str__(self):
            return f"DynamicLabelType.KEY_AND_CATEGORY{self._values!r}"
        def __eq__(self, other):
            if not isinstance(other, DynamicLabelType):
                return NotImplemented
            if not other.is_KEY_AND_CATEGORY():
                return False
            return self._values == other._values

    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_LABEL(self) -> bool:
        return isinstance(self, DynamicLabelType.LABEL)
    def is_label(self) -> bool:
        return isinstance(self, DynamicLabelType.LABEL)
    def is_KEY_ONLY(self) -> bool:
        return isinstance(self, DynamicLabelType.KEY_ONLY)
    def is_key_only(self) -> bool:
        return isinstance(self, DynamicLabelType.KEY_ONLY)
    def is_CATEGORY_ONLY(self) -> bool:
        return isinstance(self, DynamicLabelType.CATEGORY_ONLY)
    def is_category_only(self) -> bool:
        return isinstance(self, DynamicLabelType.CATEGORY_ONLY)
    def is_KEY_AND_CATEGORY(self) -> bool:
        return isinstance(self, DynamicLabelType.KEY_AND_CATEGORY)
    def is_key_and_category(self) -> bool:
        return isinstance(self, DynamicLabelType.KEY_AND_CATEGORY)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DynamicLabelType.LABEL = type("DynamicLabelType.LABEL", (DynamicLabelType.LABEL, DynamicLabelType,), {})  # type: ignore
DynamicLabelType.KEY_ONLY = type("DynamicLabelType.KEY_ONLY", (DynamicLabelType.KEY_ONLY, DynamicLabelType,), {})  # type: ignore
DynamicLabelType.CATEGORY_ONLY = type("DynamicLabelType.CATEGORY_ONLY", (DynamicLabelType.CATEGORY_ONLY, DynamicLabelType,), {})  # type: ignore
DynamicLabelType.KEY_AND_CATEGORY = type("DynamicLabelType.KEY_AND_CATEGORY", (DynamicLabelType.KEY_AND_CATEGORY, DynamicLabelType,), {})  # type: ignore




class _UniffiFfiConverterTypeDynamicLabelType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DynamicLabelType.LABEL(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 2:
            return DynamicLabelType.KEY_ONLY(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 3:
            return DynamicLabelType.CATEGORY_ONLY(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 4:
            return DynamicLabelType.KEY_AND_CATEGORY(
                _UniffiFfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_LABEL():
            _UniffiFfiConverterString.check_lower(value._values[0])
            return
        if value.is_KEY_ONLY():
            _UniffiFfiConverterString.check_lower(value._values[0])
            return
        if value.is_CATEGORY_ONLY():
            _UniffiFfiConverterString.check_lower(value._values[0])
            return
        if value.is_KEY_AND_CATEGORY():
            _UniffiFfiConverterString.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_LABEL():
            buf.write_i32(1)
            _UniffiFfiConverterString.write(value._values[0], buf)
        if value.is_KEY_ONLY():
            buf.write_i32(2)
            _UniffiFfiConverterString.write(value._values[0], buf)
        if value.is_CATEGORY_ONLY():
            buf.write_i32(3)
            _UniffiFfiConverterString.write(value._values[0], buf)
        if value.is_KEY_AND_CATEGORY():
            buf.write_i32(4)
            _UniffiFfiConverterString.write(value._values[0], buf)



class _UniffiFfiConverterOptionalTypeDynamicLabelType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeDynamicLabelType.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeDynamicLabelType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeDynamicLabelType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class CommonMetricData:
    def __init__(self, *, category:str, name:str, send_in_pings:typing.List[str], lifetime:Lifetime, disabled:bool, dynamic_label:typing.Optional[DynamicLabelType] = _DEFAULT):
        self.category = category
        self.name = name
        self.send_in_pings = send_in_pings
        self.lifetime = lifetime
        self.disabled = disabled
        if dynamic_label is _DEFAULT:
            self.dynamic_label = None
        else:
            self.dynamic_label = dynamic_label
        
        

    
    def __str__(self):
        return "CommonMetricData(category={}, name={}, send_in_pings={}, lifetime={}, disabled={}, dynamic_label={})".format(self.category, self.name, self.send_in_pings, self.lifetime, self.disabled, self.dynamic_label)
    def __eq__(self, other):
        if self.category != other.category:
            return False
        if self.name != other.name:
            return False
        if self.send_in_pings != other.send_in_pings:
            return False
        if self.lifetime != other.lifetime:
            return False
        if self.disabled != other.disabled:
            return False
        if self.dynamic_label != other.dynamic_label:
            return False
        return True

class _UniffiFfiConverterTypeCommonMetricData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CommonMetricData(
            category=_UniffiFfiConverterString.read(buf),
            name=_UniffiFfiConverterString.read(buf),
            send_in_pings=_UniffiFfiConverterSequenceString.read(buf),
            lifetime=_UniffiFfiConverterTypeLifetime.read(buf),
            disabled=_UniffiFfiConverterBoolean.read(buf),
            dynamic_label=_UniffiFfiConverterOptionalTypeDynamicLabelType.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.category)
        _UniffiFfiConverterString.check_lower(value.name)
        _UniffiFfiConverterSequenceString.check_lower(value.send_in_pings)
        _UniffiFfiConverterTypeLifetime.check_lower(value.lifetime)
        _UniffiFfiConverterBoolean.check_lower(value.disabled)
        _UniffiFfiConverterOptionalTypeDynamicLabelType.check_lower(value.dynamic_label)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.category, buf)
        _UniffiFfiConverterString.write(value.name, buf)
        _UniffiFfiConverterSequenceString.write(value.send_in_pings, buf)
        _UniffiFfiConverterTypeLifetime.write(value.lifetime, buf)
        _UniffiFfiConverterBoolean.write(value.disabled, buf)
        _UniffiFfiConverterOptionalTypeDynamicLabelType.write(value.dynamic_label, buf)

class _UniffiFfiConverterMapInt64Int64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiFfiConverterInt64.check_lower(key)
            _UniffiFfiConverterInt64.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiFfiConverterInt64.write(key, buf)
            _UniffiFfiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiFfiConverterInt64.read(buf)
            val = _UniffiFfiConverterInt64.read(buf)
            d[key] = val
        return d

@dataclass
class DistributionData:
    def __init__(self, *, values:dict[int, int], sum:int, count:int):
        self.values = values
        self.sum = sum
        self.count = count
        
        

    
    def __str__(self):
        return "DistributionData(values={}, sum={}, count={})".format(self.values, self.sum, self.count)
    def __eq__(self, other):
        if self.values != other.values:
            return False
        if self.sum != other.sum:
            return False
        if self.count != other.count:
            return False
        return True

class _UniffiFfiConverterTypeDistributionData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DistributionData(
            values=_UniffiFfiConverterMapInt64Int64.read(buf),
            sum=_UniffiFfiConverterInt64.read(buf),
            count=_UniffiFfiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterMapInt64Int64.check_lower(value.values)
        _UniffiFfiConverterInt64.check_lower(value.sum)
        _UniffiFfiConverterInt64.check_lower(value.count)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterMapInt64Int64.write(value.values, buf)
        _UniffiFfiConverterInt64.write(value.sum, buf)
        _UniffiFfiConverterInt64.write(value.count, buf)

@dataclass
class DistributionMetrics:
    def __init__(self, *, name:typing.Optional[str] = _DEFAULT):
        if name is _DEFAULT:
            self.name = None
        else:
            self.name = name
        
        

    
    def __str__(self):
        return "DistributionMetrics(name={})".format(self.name)
    def __eq__(self, other):
        if self.name != other.name:
            return False
        return True

class _UniffiFfiConverterTypeDistributionMetrics(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DistributionMetrics(
            name=_UniffiFfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterOptionalString.check_lower(value.name)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterOptionalString.write(value.name, buf)

class _UniffiFfiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")






class LevelFilter(enum.Enum):
    
    OFF = 0
    
    ERROR = 1
    
    WARN = 2
    
    INFO = 3
    
    DEBUG = 4
    
    TRACE = 5
    


class _UniffiFfiConverterTypeLevelFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LevelFilter.OFF
        if variant == 2:
            return LevelFilter.ERROR
        if variant == 3:
            return LevelFilter.WARN
        if variant == 4:
            return LevelFilter.INFO
        if variant == 5:
            return LevelFilter.DEBUG
        if variant == 6:
            return LevelFilter.TRACE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == LevelFilter.OFF:
            return
        if value == LevelFilter.ERROR:
            return
        if value == LevelFilter.WARN:
            return
        if value == LevelFilter.INFO:
            return
        if value == LevelFilter.DEBUG:
            return
        if value == LevelFilter.TRACE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == LevelFilter.OFF:
            buf.write_i32(1)
        if value == LevelFilter.ERROR:
            buf.write_i32(2)
        if value == LevelFilter.WARN:
            buf.write_i32(3)
        if value == LevelFilter.INFO:
            buf.write_i32(4)
        if value == LevelFilter.DEBUG:
            buf.write_i32(5)
        if value == LevelFilter.TRACE:
            buf.write_i32(6)



class _UniffiFfiConverterOptionalTypeLevelFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeLevelFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeLevelFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeLevelFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

@dataclass
class PingRateLimit:
    def __init__(self, *, seconds_per_interval:int, pings_per_interval:int):
        self.seconds_per_interval = seconds_per_interval
        self.pings_per_interval = pings_per_interval
        
        

    
    def __str__(self):
        return "PingRateLimit(seconds_per_interval={}, pings_per_interval={})".format(self.seconds_per_interval, self.pings_per_interval)
    def __eq__(self, other):
        if self.seconds_per_interval != other.seconds_per_interval:
            return False
        if self.pings_per_interval != other.pings_per_interval:
            return False
        return True

class _UniffiFfiConverterTypePingRateLimit(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PingRateLimit(
            seconds_per_interval=_UniffiFfiConverterUInt64.read(buf),
            pings_per_interval=_UniffiFfiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.seconds_per_interval)
        _UniffiFfiConverterUInt32.check_lower(value.pings_per_interval)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.seconds_per_interval, buf)
        _UniffiFfiConverterUInt32.write(value.pings_per_interval, buf)

class _UniffiFfiConverterOptionalTypePingRateLimit(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypePingRateLimit.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypePingRateLimit.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypePingRateLimit.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterMapStringSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiFfiConverterString.check_lower(key)
            _UniffiFfiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiFfiConverterString.write(key, buf)
            _UniffiFfiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiFfiConverterString.read(buf)
            val = _UniffiFfiConverterSequenceString.read(buf)
            d[key] = val
        return d

@dataclass
class InternalConfiguration:
    def __init__(self, *, data_path:str, application_id:str, language_binding_name:str, upload_enabled:bool, max_events:typing.Optional[int], delay_ping_lifetime_io:bool, app_build:str, use_core_mps:bool, trim_data_to_registered_pings:bool, log_level:typing.Optional[LevelFilter], rate_limit:typing.Optional[PingRateLimit], enable_event_timestamps:bool, experimentation_id:typing.Optional[str], enable_internal_pings:bool, ping_schedule:dict[str, typing.List[str]], ping_lifetime_threshold:int, ping_lifetime_max_time:int):
        self.data_path = data_path
        self.application_id = application_id
        self.language_binding_name = language_binding_name
        self.upload_enabled = upload_enabled
        self.max_events = max_events
        self.delay_ping_lifetime_io = delay_ping_lifetime_io
        self.app_build = app_build
        self.use_core_mps = use_core_mps
        self.trim_data_to_registered_pings = trim_data_to_registered_pings
        self.log_level = log_level
        self.rate_limit = rate_limit
        self.enable_event_timestamps = enable_event_timestamps
        self.experimentation_id = experimentation_id
        self.enable_internal_pings = enable_internal_pings
        self.ping_schedule = ping_schedule
        self.ping_lifetime_threshold = ping_lifetime_threshold
        self.ping_lifetime_max_time = ping_lifetime_max_time
        
        

    
    def __str__(self):
        return "InternalConfiguration(data_path={}, application_id={}, language_binding_name={}, upload_enabled={}, max_events={}, delay_ping_lifetime_io={}, app_build={}, use_core_mps={}, trim_data_to_registered_pings={}, log_level={}, rate_limit={}, enable_event_timestamps={}, experimentation_id={}, enable_internal_pings={}, ping_schedule={}, ping_lifetime_threshold={}, ping_lifetime_max_time={})".format(self.data_path, self.application_id, self.language_binding_name, self.upload_enabled, self.max_events, self.delay_ping_lifetime_io, self.app_build, self.use_core_mps, self.trim_data_to_registered_pings, self.log_level, self.rate_limit, self.enable_event_timestamps, self.experimentation_id, self.enable_internal_pings, self.ping_schedule, self.ping_lifetime_threshold, self.ping_lifetime_max_time)
    def __eq__(self, other):
        if self.data_path != other.data_path:
            return False
        if self.application_id != other.application_id:
            return False
        if self.language_binding_name != other.language_binding_name:
            return False
        if self.upload_enabled != other.upload_enabled:
            return False
        if self.max_events != other.max_events:
            return False
        if self.delay_ping_lifetime_io != other.delay_ping_lifetime_io:
            return False
        if self.app_build != other.app_build:
            return False
        if self.use_core_mps != other.use_core_mps:
            return False
        if self.trim_data_to_registered_pings != other.trim_data_to_registered_pings:
            return False
        if self.log_level != other.log_level:
            return False
        if self.rate_limit != other.rate_limit:
            return False
        if self.enable_event_timestamps != other.enable_event_timestamps:
            return False
        if self.experimentation_id != other.experimentation_id:
            return False
        if self.enable_internal_pings != other.enable_internal_pings:
            return False
        if self.ping_schedule != other.ping_schedule:
            return False
        if self.ping_lifetime_threshold != other.ping_lifetime_threshold:
            return False
        if self.ping_lifetime_max_time != other.ping_lifetime_max_time:
            return False
        return True

class _UniffiFfiConverterTypeInternalConfiguration(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InternalConfiguration(
            data_path=_UniffiFfiConverterString.read(buf),
            application_id=_UniffiFfiConverterString.read(buf),
            language_binding_name=_UniffiFfiConverterString.read(buf),
            upload_enabled=_UniffiFfiConverterBoolean.read(buf),
            max_events=_UniffiFfiConverterOptionalUInt32.read(buf),
            delay_ping_lifetime_io=_UniffiFfiConverterBoolean.read(buf),
            app_build=_UniffiFfiConverterString.read(buf),
            use_core_mps=_UniffiFfiConverterBoolean.read(buf),
            trim_data_to_registered_pings=_UniffiFfiConverterBoolean.read(buf),
            log_level=_UniffiFfiConverterOptionalTypeLevelFilter.read(buf),
            rate_limit=_UniffiFfiConverterOptionalTypePingRateLimit.read(buf),
            enable_event_timestamps=_UniffiFfiConverterBoolean.read(buf),
            experimentation_id=_UniffiFfiConverterOptionalString.read(buf),
            enable_internal_pings=_UniffiFfiConverterBoolean.read(buf),
            ping_schedule=_UniffiFfiConverterMapStringSequenceString.read(buf),
            ping_lifetime_threshold=_UniffiFfiConverterUInt64.read(buf),
            ping_lifetime_max_time=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.data_path)
        _UniffiFfiConverterString.check_lower(value.application_id)
        _UniffiFfiConverterString.check_lower(value.language_binding_name)
        _UniffiFfiConverterBoolean.check_lower(value.upload_enabled)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.max_events)
        _UniffiFfiConverterBoolean.check_lower(value.delay_ping_lifetime_io)
        _UniffiFfiConverterString.check_lower(value.app_build)
        _UniffiFfiConverterBoolean.check_lower(value.use_core_mps)
        _UniffiFfiConverterBoolean.check_lower(value.trim_data_to_registered_pings)
        _UniffiFfiConverterOptionalTypeLevelFilter.check_lower(value.log_level)
        _UniffiFfiConverterOptionalTypePingRateLimit.check_lower(value.rate_limit)
        _UniffiFfiConverterBoolean.check_lower(value.enable_event_timestamps)
        _UniffiFfiConverterOptionalString.check_lower(value.experimentation_id)
        _UniffiFfiConverterBoolean.check_lower(value.enable_internal_pings)
        _UniffiFfiConverterMapStringSequenceString.check_lower(value.ping_schedule)
        _UniffiFfiConverterUInt64.check_lower(value.ping_lifetime_threshold)
        _UniffiFfiConverterUInt64.check_lower(value.ping_lifetime_max_time)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.data_path, buf)
        _UniffiFfiConverterString.write(value.application_id, buf)
        _UniffiFfiConverterString.write(value.language_binding_name, buf)
        _UniffiFfiConverterBoolean.write(value.upload_enabled, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.max_events, buf)
        _UniffiFfiConverterBoolean.write(value.delay_ping_lifetime_io, buf)
        _UniffiFfiConverterString.write(value.app_build, buf)
        _UniffiFfiConverterBoolean.write(value.use_core_mps, buf)
        _UniffiFfiConverterBoolean.write(value.trim_data_to_registered_pings, buf)
        _UniffiFfiConverterOptionalTypeLevelFilter.write(value.log_level, buf)
        _UniffiFfiConverterOptionalTypePingRateLimit.write(value.rate_limit, buf)
        _UniffiFfiConverterBoolean.write(value.enable_event_timestamps, buf)
        _UniffiFfiConverterOptionalString.write(value.experimentation_id, buf)
        _UniffiFfiConverterBoolean.write(value.enable_internal_pings, buf)
        _UniffiFfiConverterMapStringSequenceString.write(value.ping_schedule, buf)
        _UniffiFfiConverterUInt64.write(value.ping_lifetime_threshold, buf)
        _UniffiFfiConverterUInt64.write(value.ping_lifetime_max_time, buf)

class _UniffiFfiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiFfiConverterSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterUInt8.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterUInt8.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterMapStringString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiFfiConverterString.check_lower(key)
            _UniffiFfiConverterString.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiFfiConverterString.write(key, buf)
            _UniffiFfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiFfiConverterString.read(buf)
            val = _UniffiFfiConverterString.read(buf)
            d[key] = val
        return d

@dataclass
class PingRequest:
    def __init__(self, *, document_id:str, path:str, body:typing.List[int], headers:dict[str, str], body_has_info_sections:bool, ping_name:str, uploader_capabilities:typing.List[str]):
        self.document_id = document_id
        self.path = path
        self.body = body
        self.headers = headers
        self.body_has_info_sections = body_has_info_sections
        self.ping_name = ping_name
        self.uploader_capabilities = uploader_capabilities
        
        

    
    def __str__(self):
        return "PingRequest(document_id={}, path={}, body={}, headers={}, body_has_info_sections={}, ping_name={}, uploader_capabilities={})".format(self.document_id, self.path, self.body, self.headers, self.body_has_info_sections, self.ping_name, self.uploader_capabilities)
    def __eq__(self, other):
        if self.document_id != other.document_id:
            return False
        if self.path != other.path:
            return False
        if self.body != other.body:
            return False
        if self.headers != other.headers:
            return False
        if self.body_has_info_sections != other.body_has_info_sections:
            return False
        if self.ping_name != other.ping_name:
            return False
        if self.uploader_capabilities != other.uploader_capabilities:
            return False
        return True

class _UniffiFfiConverterTypePingRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PingRequest(
            document_id=_UniffiFfiConverterString.read(buf),
            path=_UniffiFfiConverterString.read(buf),
            body=_UniffiFfiConverterSequenceUInt8.read(buf),
            headers=_UniffiFfiConverterMapStringString.read(buf),
            body_has_info_sections=_UniffiFfiConverterBoolean.read(buf),
            ping_name=_UniffiFfiConverterString.read(buf),
            uploader_capabilities=_UniffiFfiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.document_id)
        _UniffiFfiConverterString.check_lower(value.path)
        _UniffiFfiConverterSequenceUInt8.check_lower(value.body)
        _UniffiFfiConverterMapStringString.check_lower(value.headers)
        _UniffiFfiConverterBoolean.check_lower(value.body_has_info_sections)
        _UniffiFfiConverterString.check_lower(value.ping_name)
        _UniffiFfiConverterSequenceString.check_lower(value.uploader_capabilities)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.document_id, buf)
        _UniffiFfiConverterString.write(value.path, buf)
        _UniffiFfiConverterSequenceUInt8.write(value.body, buf)
        _UniffiFfiConverterMapStringString.write(value.headers, buf)
        _UniffiFfiConverterBoolean.write(value.body_has_info_sections, buf)
        _UniffiFfiConverterString.write(value.ping_name, buf)
        _UniffiFfiConverterSequenceString.write(value.uploader_capabilities, buf)

@dataclass
class Rate:
    def __init__(self, *, numerator:int, denominator:int):
        self.numerator = numerator
        self.denominator = denominator
        
        

    
    def __str__(self):
        return "Rate(numerator={}, denominator={})".format(self.numerator, self.denominator)
    def __eq__(self, other):
        if self.numerator != other.numerator:
            return False
        if self.denominator != other.denominator:
            return False
        return True

class _UniffiFfiConverterTypeRate(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Rate(
            numerator=_UniffiFfiConverterInt32.read(buf),
            denominator=_UniffiFfiConverterInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterInt32.check_lower(value.numerator)
        _UniffiFfiConverterInt32.check_lower(value.denominator)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterInt32.write(value.numerator, buf)
        _UniffiFfiConverterInt32.write(value.denominator, buf)

class _UniffiFfiConverterOptionalMapStringString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterMapStringString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterMapStringString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterMapStringString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class RecordedEvent:
    def __init__(self, *, timestamp:int, category:str, name:str, extra:typing.Optional[dict[str, str]]):
        self.timestamp = timestamp
        self.category = category
        self.name = name
        self.extra = extra
        
        

    
    def __str__(self):
        return "RecordedEvent(timestamp={}, category={}, name={}, extra={})".format(self.timestamp, self.category, self.name, self.extra)
    def __eq__(self, other):
        if self.timestamp != other.timestamp:
            return False
        if self.category != other.category:
            return False
        if self.name != other.name:
            return False
        if self.extra != other.extra:
            return False
        return True

class _UniffiFfiConverterTypeRecordedEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecordedEvent(
            timestamp=_UniffiFfiConverterUInt64.read(buf),
            category=_UniffiFfiConverterString.read(buf),
            name=_UniffiFfiConverterString.read(buf),
            extra=_UniffiFfiConverterOptionalMapStringString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.timestamp)
        _UniffiFfiConverterString.check_lower(value.category)
        _UniffiFfiConverterString.check_lower(value.name)
        _UniffiFfiConverterOptionalMapStringString.check_lower(value.extra)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.timestamp, buf)
        _UniffiFfiConverterString.write(value.category, buf)
        _UniffiFfiConverterString.write(value.name, buf)
        _UniffiFfiConverterOptionalMapStringString.write(value.extra, buf)

@dataclass
class RecordedExperiment:
    def __init__(self, *, branch:str, extra:typing.Optional[dict[str, str]]):
        self.branch = branch
        self.extra = extra
        
        

    
    def __str__(self):
        return "RecordedExperiment(branch={}, extra={})".format(self.branch, self.extra)
    def __eq__(self, other):
        if self.branch != other.branch:
            return False
        if self.extra != other.extra:
            return False
        return True

class _UniffiFfiConverterTypeRecordedExperiment(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RecordedExperiment(
            branch=_UniffiFfiConverterString.read(buf),
            extra=_UniffiFfiConverterOptionalMapStringString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.branch)
        _UniffiFfiConverterOptionalMapStringString.check_lower(value.extra)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.branch, buf)
        _UniffiFfiConverterOptionalMapStringString.write(value.extra, buf)

@dataclass
class TimerId:
    def __init__(self, *, id:int):
        self.id = id
        
        

    
    def __str__(self):
        return "TimerId(id={})".format(self.id)
    def __eq__(self, other):
        if self.id != other.id:
            return False
        return True

class _UniffiFfiConverterTypeTimerId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TimerId(
            id=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.id)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.id, buf)



# CallbackError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class CallbackError(Exception):
    pass

_UniffiTempCallbackError = CallbackError

class CallbackError:  # type: ignore
    
    class UnexpectedError(_UniffiTempCallbackError):
        def __repr__(self):
            return "CallbackError.UnexpectedError({})".format(repr(str(self)))
    _UniffiTempCallbackError.UnexpectedError = UnexpectedError # type: ignore

CallbackError = _UniffiTempCallbackError # type: ignore
del _UniffiTempCallbackError


class _UniffiFfiConverterTypeCallbackError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CallbackError.UnexpectedError(
                _UniffiFfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, CallbackError.UnexpectedError):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, CallbackError.UnexpectedError):
            buf.write_i32(1)






class ErrorType(enum.Enum):
    
    INVALID_VALUE = 0
    
    INVALID_LABEL = 1
    
    INVALID_STATE = 2
    
    INVALID_OVERFLOW = 3
    


class _UniffiFfiConverterTypeErrorType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ErrorType.INVALID_VALUE
        if variant == 2:
            return ErrorType.INVALID_LABEL
        if variant == 3:
            return ErrorType.INVALID_STATE
        if variant == 4:
            return ErrorType.INVALID_OVERFLOW
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ErrorType.INVALID_VALUE:
            return
        if value == ErrorType.INVALID_LABEL:
            return
        if value == ErrorType.INVALID_STATE:
            return
        if value == ErrorType.INVALID_OVERFLOW:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ErrorType.INVALID_VALUE:
            buf.write_i32(1)
        if value == ErrorType.INVALID_LABEL:
            buf.write_i32(2)
        if value == ErrorType.INVALID_STATE:
            buf.write_i32(3)
        if value == ErrorType.INVALID_OVERFLOW:
            buf.write_i32(4)








class HistogramType(enum.Enum):
    
    LINEAR = 0
    
    EXPONENTIAL = 1
    


class _UniffiFfiConverterTypeHistogramType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return HistogramType.LINEAR
        if variant == 2:
            return HistogramType.EXPONENTIAL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == HistogramType.LINEAR:
            return
        if value == HistogramType.EXPONENTIAL:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == HistogramType.LINEAR:
            buf.write_i32(1)
        if value == HistogramType.EXPONENTIAL:
            buf.write_i32(2)








class MemoryUnit(enum.Enum):
    
    BYTE = 0
    
    KILOBYTE = 1
    
    MEGABYTE = 2
    
    GIGABYTE = 3
    


class _UniffiFfiConverterTypeMemoryUnit(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MemoryUnit.BYTE
        if variant == 2:
            return MemoryUnit.KILOBYTE
        if variant == 3:
            return MemoryUnit.MEGABYTE
        if variant == 4:
            return MemoryUnit.GIGABYTE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == MemoryUnit.BYTE:
            return
        if value == MemoryUnit.KILOBYTE:
            return
        if value == MemoryUnit.MEGABYTE:
            return
        if value == MemoryUnit.GIGABYTE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == MemoryUnit.BYTE:
            buf.write_i32(1)
        if value == MemoryUnit.KILOBYTE:
            buf.write_i32(2)
        if value == MemoryUnit.MEGABYTE:
            buf.write_i32(3)
        if value == MemoryUnit.GIGABYTE:
            buf.write_i32(4)








class TimeUnit(enum.Enum):
    
    NANOSECOND = 0
    
    MICROSECOND = 1
    
    MILLISECOND = 2
    
    SECOND = 3
    
    MINUTE = 4
    
    HOUR = 5
    
    DAY = 6
    


class _UniffiFfiConverterTypeTimeUnit(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TimeUnit.NANOSECOND
        if variant == 2:
            return TimeUnit.MICROSECOND
        if variant == 3:
            return TimeUnit.MILLISECOND
        if variant == 4:
            return TimeUnit.SECOND
        if variant == 5:
            return TimeUnit.MINUTE
        if variant == 6:
            return TimeUnit.HOUR
        if variant == 7:
            return TimeUnit.DAY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == TimeUnit.NANOSECOND:
            return
        if value == TimeUnit.MICROSECOND:
            return
        if value == TimeUnit.MILLISECOND:
            return
        if value == TimeUnit.SECOND:
            return
        if value == TimeUnit.MINUTE:
            return
        if value == TimeUnit.HOUR:
            return
        if value == TimeUnit.DAY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == TimeUnit.NANOSECOND:
            buf.write_i32(1)
        if value == TimeUnit.MICROSECOND:
            buf.write_i32(2)
        if value == TimeUnit.MILLISECOND:
            buf.write_i32(3)
        if value == TimeUnit.SECOND:
            buf.write_i32(4)
        if value == TimeUnit.MINUTE:
            buf.write_i32(5)
        if value == TimeUnit.HOUR:
            buf.write_i32(6)
        if value == TimeUnit.DAY:
            buf.write_i32(7)








class LabeledMetricData:
    def __init__(self):
        raise RuntimeError("LabeledMetricData cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    @dataclass
    class COMMON:
        
        def __init__(self, cmd:CommonMetricData):
            self.cmd = cmd
            
            
            pass

    
            
            
    
        def __str__(self):
            return "LabeledMetricData.COMMON(cmd={})".format(self.cmd)
        def __eq__(self, other):
            if not isinstance(other, LabeledMetricData):
                return NotImplemented
            if not other.is_COMMON():
                return False
            if self.cmd != other.cmd:
                return False
            return True

    @dataclass
    class CUSTOM_DISTRIBUTION:
        
        def __init__(self, cmd:CommonMetricData, range_min:int, range_max:int, bucket_count:int, histogram_type:HistogramType):
            self.cmd = cmd
            
            
            self.range_min = range_min
            
            
            self.range_max = range_max
            
            
            self.bucket_count = bucket_count
            
            
            self.histogram_type = histogram_type
            
            
            pass

    
            
            
    
        def __str__(self):
            return "LabeledMetricData.CUSTOM_DISTRIBUTION(cmd={}, range_min={}, range_max={}, bucket_count={}, histogram_type={})".format(self.cmd, self.range_min, self.range_max, self.bucket_count, self.histogram_type)
        def __eq__(self, other):
            if not isinstance(other, LabeledMetricData):
                return NotImplemented
            if not other.is_CUSTOM_DISTRIBUTION():
                return False
            if self.cmd != other.cmd:
                return False
            if self.range_min != other.range_min:
                return False
            if self.range_max != other.range_max:
                return False
            if self.bucket_count != other.bucket_count:
                return False
            if self.histogram_type != other.histogram_type:
                return False
            return True

    @dataclass
    class MEMORY_DISTRIBUTION:
        
        def __init__(self, cmd:CommonMetricData, unit:MemoryUnit):
            self.cmd = cmd
            
            
            self.unit = unit
            
            
            pass

    
            
            
    
        def __str__(self):
            return "LabeledMetricData.MEMORY_DISTRIBUTION(cmd={}, unit={})".format(self.cmd, self.unit)
        def __eq__(self, other):
            if not isinstance(other, LabeledMetricData):
                return NotImplemented
            if not other.is_MEMORY_DISTRIBUTION():
                return False
            if self.cmd != other.cmd:
                return False
            if self.unit != other.unit:
                return False
            return True

    @dataclass
    class TIMING_DISTRIBUTION:
        
        def __init__(self, cmd:CommonMetricData, unit:TimeUnit):
            self.cmd = cmd
            
            
            self.unit = unit
            
            
            pass

    
            
            
    
        def __str__(self):
            return "LabeledMetricData.TIMING_DISTRIBUTION(cmd={}, unit={})".format(self.cmd, self.unit)
        def __eq__(self, other):
            if not isinstance(other, LabeledMetricData):
                return NotImplemented
            if not other.is_TIMING_DISTRIBUTION():
                return False
            if self.cmd != other.cmd:
                return False
            if self.unit != other.unit:
                return False
            return True

    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_COMMON(self) -> bool:
        return isinstance(self, LabeledMetricData.COMMON)
    def is_common(self) -> bool:
        return isinstance(self, LabeledMetricData.COMMON)
    def is_CUSTOM_DISTRIBUTION(self) -> bool:
        return isinstance(self, LabeledMetricData.CUSTOM_DISTRIBUTION)
    def is_custom_distribution(self) -> bool:
        return isinstance(self, LabeledMetricData.CUSTOM_DISTRIBUTION)
    def is_MEMORY_DISTRIBUTION(self) -> bool:
        return isinstance(self, LabeledMetricData.MEMORY_DISTRIBUTION)
    def is_memory_distribution(self) -> bool:
        return isinstance(self, LabeledMetricData.MEMORY_DISTRIBUTION)
    def is_TIMING_DISTRIBUTION(self) -> bool:
        return isinstance(self, LabeledMetricData.TIMING_DISTRIBUTION)
    def is_timing_distribution(self) -> bool:
        return isinstance(self, LabeledMetricData.TIMING_DISTRIBUTION)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LabeledMetricData.COMMON = type("LabeledMetricData.COMMON", (LabeledMetricData.COMMON, LabeledMetricData,), {})  # type: ignore
LabeledMetricData.CUSTOM_DISTRIBUTION = type("LabeledMetricData.CUSTOM_DISTRIBUTION", (LabeledMetricData.CUSTOM_DISTRIBUTION, LabeledMetricData,), {})  # type: ignore
LabeledMetricData.MEMORY_DISTRIBUTION = type("LabeledMetricData.MEMORY_DISTRIBUTION", (LabeledMetricData.MEMORY_DISTRIBUTION, LabeledMetricData,), {})  # type: ignore
LabeledMetricData.TIMING_DISTRIBUTION = type("LabeledMetricData.TIMING_DISTRIBUTION", (LabeledMetricData.TIMING_DISTRIBUTION, LabeledMetricData,), {})  # type: ignore




class _UniffiFfiConverterTypeLabeledMetricData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LabeledMetricData.COMMON(
                _UniffiFfiConverterTypeCommonMetricData.read(buf),
            )
        if variant == 2:
            return LabeledMetricData.CUSTOM_DISTRIBUTION(
                _UniffiFfiConverterTypeCommonMetricData.read(buf),
                _UniffiFfiConverterInt64.read(buf),
                _UniffiFfiConverterInt64.read(buf),
                _UniffiFfiConverterInt64.read(buf),
                _UniffiFfiConverterTypeHistogramType.read(buf),
            )
        if variant == 3:
            return LabeledMetricData.MEMORY_DISTRIBUTION(
                _UniffiFfiConverterTypeCommonMetricData.read(buf),
                _UniffiFfiConverterTypeMemoryUnit.read(buf),
            )
        if variant == 4:
            return LabeledMetricData.TIMING_DISTRIBUTION(
                _UniffiFfiConverterTypeCommonMetricData.read(buf),
                _UniffiFfiConverterTypeTimeUnit.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_COMMON():
            _UniffiFfiConverterTypeCommonMetricData.check_lower(value.cmd)
            return
        if value.is_CUSTOM_DISTRIBUTION():
            _UniffiFfiConverterTypeCommonMetricData.check_lower(value.cmd)
            _UniffiFfiConverterInt64.check_lower(value.range_min)
            _UniffiFfiConverterInt64.check_lower(value.range_max)
            _UniffiFfiConverterInt64.check_lower(value.bucket_count)
            _UniffiFfiConverterTypeHistogramType.check_lower(value.histogram_type)
            return
        if value.is_MEMORY_DISTRIBUTION():
            _UniffiFfiConverterTypeCommonMetricData.check_lower(value.cmd)
            _UniffiFfiConverterTypeMemoryUnit.check_lower(value.unit)
            return
        if value.is_TIMING_DISTRIBUTION():
            _UniffiFfiConverterTypeCommonMetricData.check_lower(value.cmd)
            _UniffiFfiConverterTypeTimeUnit.check_lower(value.unit)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_COMMON():
            buf.write_i32(1)
            _UniffiFfiConverterTypeCommonMetricData.write(value.cmd, buf)
        if value.is_CUSTOM_DISTRIBUTION():
            buf.write_i32(2)
            _UniffiFfiConverterTypeCommonMetricData.write(value.cmd, buf)
            _UniffiFfiConverterInt64.write(value.range_min, buf)
            _UniffiFfiConverterInt64.write(value.range_max, buf)
            _UniffiFfiConverterInt64.write(value.bucket_count, buf)
            _UniffiFfiConverterTypeHistogramType.write(value.histogram_type, buf)
        if value.is_MEMORY_DISTRIBUTION():
            buf.write_i32(3)
            _UniffiFfiConverterTypeCommonMetricData.write(value.cmd, buf)
            _UniffiFfiConverterTypeMemoryUnit.write(value.unit, buf)
        if value.is_TIMING_DISTRIBUTION():
            buf.write_i32(4)
            _UniffiFfiConverterTypeCommonMetricData.write(value.cmd, buf)
            _UniffiFfiConverterTypeTimeUnit.write(value.unit, buf)



class _UniffiFfiConverterInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i8"
    VALUE_MIN = -2**7
    VALUE_MAX = 2**7

    @staticmethod
    def read(buf):
        return buf.read_i8()

    @staticmethod
    def write(value, buf):
        buf.write_i8(value)






class PingUploadTask:
    def __init__(self):
        raise RuntimeError("PingUploadTask cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    @dataclass
    class UPLOAD:
        
        def __init__(self, request:PingRequest):
            self.request = request
            
            
            pass

    
            
            
    
        def __str__(self):
            return "PingUploadTask.UPLOAD(request={})".format(self.request)
        def __eq__(self, other):
            if not isinstance(other, PingUploadTask):
                return NotImplemented
            if not other.is_UPLOAD():
                return False
            if self.request != other.request:
                return False
            return True

    @dataclass
    class WAIT:
        
        def __init__(self, time:int):
            self.time = time
            
            
            pass

    
            
            
    
        def __str__(self):
            return "PingUploadTask.WAIT(time={})".format(self.time)
        def __eq__(self, other):
            if not isinstance(other, PingUploadTask):
                return NotImplemented
            if not other.is_WAIT():
                return False
            if self.time != other.time:
                return False
            return True

    @dataclass
    class DONE:
        
        def __init__(self, unused:int):
            self.unused = unused
            
            
            pass

    
            
            
    
        def __str__(self):
            return "PingUploadTask.DONE(unused={})".format(self.unused)
        def __eq__(self, other):
            if not isinstance(other, PingUploadTask):
                return NotImplemented
            if not other.is_DONE():
                return False
            if self.unused != other.unused:
                return False
            return True

    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_UPLOAD(self) -> bool:
        return isinstance(self, PingUploadTask.UPLOAD)
    def is_upload(self) -> bool:
        return isinstance(self, PingUploadTask.UPLOAD)
    def is_WAIT(self) -> bool:
        return isinstance(self, PingUploadTask.WAIT)
    def is_wait(self) -> bool:
        return isinstance(self, PingUploadTask.WAIT)
    def is_DONE(self) -> bool:
        return isinstance(self, PingUploadTask.DONE)
    def is_done(self) -> bool:
        return isinstance(self, PingUploadTask.DONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PingUploadTask.UPLOAD = type("PingUploadTask.UPLOAD", (PingUploadTask.UPLOAD, PingUploadTask,), {})  # type: ignore
PingUploadTask.WAIT = type("PingUploadTask.WAIT", (PingUploadTask.WAIT, PingUploadTask,), {})  # type: ignore
PingUploadTask.DONE = type("PingUploadTask.DONE", (PingUploadTask.DONE, PingUploadTask,), {})  # type: ignore




class _UniffiFfiConverterTypePingUploadTask(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PingUploadTask.UPLOAD(
                _UniffiFfiConverterTypePingRequest.read(buf),
            )
        if variant == 2:
            return PingUploadTask.WAIT(
                _UniffiFfiConverterUInt64.read(buf),
            )
        if variant == 3:
            return PingUploadTask.DONE(
                _UniffiFfiConverterInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_UPLOAD():
            _UniffiFfiConverterTypePingRequest.check_lower(value.request)
            return
        if value.is_WAIT():
            _UniffiFfiConverterUInt64.check_lower(value.time)
            return
        if value.is_DONE():
            _UniffiFfiConverterInt8.check_lower(value.unused)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_UPLOAD():
            buf.write_i32(1)
            _UniffiFfiConverterTypePingRequest.write(value.request, buf)
        if value.is_WAIT():
            buf.write_i32(2)
            _UniffiFfiConverterUInt64.write(value.time, buf)
        if value.is_DONE():
            buf.write_i32(3)
            _UniffiFfiConverterInt8.write(value.unused, buf)








class UploadResult:
    def __init__(self):
        raise RuntimeError("UploadResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    @dataclass
    class RECOVERABLE_FAILURE:
        
        def __init__(self, unused:int):
            self.unused = unused
            
            
            pass

    
            
            
    
        def __str__(self):
            return "UploadResult.RECOVERABLE_FAILURE(unused={})".format(self.unused)
        def __eq__(self, other):
            if not isinstance(other, UploadResult):
                return NotImplemented
            if not other.is_RECOVERABLE_FAILURE():
                return False
            if self.unused != other.unused:
                return False
            return True

    @dataclass
    class UNRECOVERABLE_FAILURE:
        
        def __init__(self, unused:int):
            self.unused = unused
            
            
            pass

    
            
            
    
        def __str__(self):
            return "UploadResult.UNRECOVERABLE_FAILURE(unused={})".format(self.unused)
        def __eq__(self, other):
            if not isinstance(other, UploadResult):
                return NotImplemented
            if not other.is_UNRECOVERABLE_FAILURE():
                return False
            if self.unused != other.unused:
                return False
            return True

    @dataclass
    class INCAPABLE:
        
        def __init__(self, unused:int):
            self.unused = unused
            
            
            pass

    
            
            
    
        def __str__(self):
            return "UploadResult.INCAPABLE(unused={})".format(self.unused)
        def __eq__(self, other):
            if not isinstance(other, UploadResult):
                return NotImplemented
            if not other.is_INCAPABLE():
                return False
            if self.unused != other.unused:
                return False
            return True

    @dataclass
    class HTTP_STATUS:
        
        def __init__(self, code:int):
            self.code = code
            
            
            pass

    
            
            
    
        def __str__(self):
            return "UploadResult.HTTP_STATUS(code={})".format(self.code)
        def __eq__(self, other):
            if not isinstance(other, UploadResult):
                return NotImplemented
            if not other.is_HTTP_STATUS():
                return False
            if self.code != other.code:
                return False
            return True

    @dataclass
    class DONE:
        
        def __init__(self, unused:int):
            self.unused = unused
            
            
            pass

    
            
            
    
        def __str__(self):
            return "UploadResult.DONE(unused={})".format(self.unused)
        def __eq__(self, other):
            if not isinstance(other, UploadResult):
                return NotImplemented
            if not other.is_DONE():
                return False
            if self.unused != other.unused:
                return False
            return True

    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_RECOVERABLE_FAILURE(self) -> bool:
        return isinstance(self, UploadResult.RECOVERABLE_FAILURE)
    def is_recoverable_failure(self) -> bool:
        return isinstance(self, UploadResult.RECOVERABLE_FAILURE)
    def is_UNRECOVERABLE_FAILURE(self) -> bool:
        return isinstance(self, UploadResult.UNRECOVERABLE_FAILURE)
    def is_unrecoverable_failure(self) -> bool:
        return isinstance(self, UploadResult.UNRECOVERABLE_FAILURE)
    def is_INCAPABLE(self) -> bool:
        return isinstance(self, UploadResult.INCAPABLE)
    def is_incapable(self) -> bool:
        return isinstance(self, UploadResult.INCAPABLE)
    def is_HTTP_STATUS(self) -> bool:
        return isinstance(self, UploadResult.HTTP_STATUS)
    def is_http_status(self) -> bool:
        return isinstance(self, UploadResult.HTTP_STATUS)
    def is_DONE(self) -> bool:
        return isinstance(self, UploadResult.DONE)
    def is_done(self) -> bool:
        return isinstance(self, UploadResult.DONE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
UploadResult.RECOVERABLE_FAILURE = type("UploadResult.RECOVERABLE_FAILURE", (UploadResult.RECOVERABLE_FAILURE, UploadResult,), {})  # type: ignore
UploadResult.UNRECOVERABLE_FAILURE = type("UploadResult.UNRECOVERABLE_FAILURE", (UploadResult.UNRECOVERABLE_FAILURE, UploadResult,), {})  # type: ignore
UploadResult.INCAPABLE = type("UploadResult.INCAPABLE", (UploadResult.INCAPABLE, UploadResult,), {})  # type: ignore
UploadResult.HTTP_STATUS = type("UploadResult.HTTP_STATUS", (UploadResult.HTTP_STATUS, UploadResult,), {})  # type: ignore
UploadResult.DONE = type("UploadResult.DONE", (UploadResult.DONE, UploadResult,), {})  # type: ignore




class _UniffiFfiConverterTypeUploadResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return UploadResult.RECOVERABLE_FAILURE(
                _UniffiFfiConverterInt8.read(buf),
            )
        if variant == 2:
            return UploadResult.UNRECOVERABLE_FAILURE(
                _UniffiFfiConverterInt8.read(buf),
            )
        if variant == 3:
            return UploadResult.INCAPABLE(
                _UniffiFfiConverterInt8.read(buf),
            )
        if variant == 4:
            return UploadResult.HTTP_STATUS(
                _UniffiFfiConverterInt32.read(buf),
            )
        if variant == 5:
            return UploadResult.DONE(
                _UniffiFfiConverterInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_RECOVERABLE_FAILURE():
            _UniffiFfiConverterInt8.check_lower(value.unused)
            return
        if value.is_UNRECOVERABLE_FAILURE():
            _UniffiFfiConverterInt8.check_lower(value.unused)
            return
        if value.is_INCAPABLE():
            _UniffiFfiConverterInt8.check_lower(value.unused)
            return
        if value.is_HTTP_STATUS():
            _UniffiFfiConverterInt32.check_lower(value.code)
            return
        if value.is_DONE():
            _UniffiFfiConverterInt8.check_lower(value.unused)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_RECOVERABLE_FAILURE():
            buf.write_i32(1)
            _UniffiFfiConverterInt8.write(value.unused, buf)
        if value.is_UNRECOVERABLE_FAILURE():
            buf.write_i32(2)
            _UniffiFfiConverterInt8.write(value.unused, buf)
        if value.is_INCAPABLE():
            buf.write_i32(3)
            _UniffiFfiConverterInt8.write(value.unused, buf)
        if value.is_HTTP_STATUS():
            buf.write_i32(4)
            _UniffiFfiConverterInt32.write(value.code, buf)
        if value.is_DONE():
            buf.write_i32(5)
            _UniffiFfiConverterInt8.write(value.unused, buf)








class UploadTaskAction(enum.Enum):
    
    NEXT = 0
    
    END = 1
    


class _UniffiFfiConverterTypeUploadTaskAction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return UploadTaskAction.NEXT
        if variant == 2:
            return UploadTaskAction.END
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == UploadTaskAction.NEXT:
            return
        if value == UploadTaskAction.END:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == UploadTaskAction.NEXT:
            buf.write_i32(1)
        if value == UploadTaskAction.END:
            buf.write_i32(2)




class _UniffiFfiConverterTypeCowString:
    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiFfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiFfiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiFfiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiFfiConverterString.lower(value)


CowString = str


class _UniffiFfiConverterTypeJsonValue:
    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiFfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiFfiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiFfiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiFfiConverterString.lower(value)


JsonValue = str

class _UniffiFfiConverterOptionalBoolean(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterBoolean.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterBoolean.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterBoolean.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class BooleanMetricProtocol(typing.Protocol):
    
    def set(self, value: bool) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[bool]:
        raise NotImplementedError

class BooleanMetric(BooleanMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeBooleanMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_booleanmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_booleanmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_booleanmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def set(self, value: bool) -> None:
        
        _UniffiFfiConverterBoolean.check_lower(value)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterBoolean.lower(value),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_booleanmetric_set,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_booleanmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[bool]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalBoolean.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_booleanmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeBooleanMetric:
    @staticmethod
    def lift(value: int) -> BooleanMetric:
        return BooleanMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: BooleanMetric):
        if not isinstance(value, BooleanMetric):
            raise TypeError("Expected BooleanMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BooleanMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> BooleanMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BooleanMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterOptionalInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class CounterMetricProtocol(typing.Protocol):
    
    def add(self, amount: int = 1) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[int]:
        raise NotImplementedError

class CounterMetric(CounterMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeCounterMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_countermetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_countermetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_countermetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def add(self, amount: int = 1) -> None:
        
        _UniffiFfiConverterInt32.check_lower(amount)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterInt32.lower(amount),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_countermetric_add,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_countermetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[int]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_countermetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeCounterMetric:
    @staticmethod
    def lift(value: int) -> CounterMetric:
        return CounterMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: CounterMetric):
        if not isinstance(value, CounterMetric):
            raise TypeError("Expected CounterMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CounterMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> CounterMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CounterMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterSequenceInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterInt64.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterInt64.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalTypeDistributionData(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeDistributionData.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeDistributionData.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeDistributionData.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class CustomDistributionMetricProtocol(typing.Protocol):
    
    def accumulate_samples(self, samples: typing.List[int]) -> None:
        raise NotImplementedError
    def accumulate_single_sample(self, sample: int) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[DistributionData]:
        raise NotImplementedError

class CustomDistributionMetric(CustomDistributionMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData,range_min: int,range_max: int,bucket_count: int,histogram_type: HistogramType):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)

        _UniffiFfiConverterInt64.check_lower(range_min)

        _UniffiFfiConverterInt64.check_lower(range_max)

        _UniffiFfiConverterInt64.check_lower(bucket_count)

        _UniffiFfiConverterTypeHistogramType.check_lower(histogram_type)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
            _UniffiFfiConverterInt64.lower(range_min),
            _UniffiFfiConverterInt64.lower(range_max),
            _UniffiFfiConverterInt64.lower(bucket_count),
            _UniffiFfiConverterTypeHistogramType.lower(histogram_type),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeCustomDistributionMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_customdistributionmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_customdistributionmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_customdistributionmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def accumulate_samples(self, samples: typing.List[int]) -> None:
        
        _UniffiFfiConverterSequenceInt64.check_lower(samples)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterSequenceInt64.lower(samples),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_accumulate_samples,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def accumulate_single_sample(self, sample: int) -> None:
        
        _UniffiFfiConverterInt64.check_lower(sample)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterInt64.lower(sample),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_accumulate_single_sample,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[DistributionData]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeDistributionData.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_customdistributionmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeCustomDistributionMetric:
    @staticmethod
    def lift(value: int) -> CustomDistributionMetric:
        return CustomDistributionMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: CustomDistributionMetric):
        if not isinstance(value, CustomDistributionMetric):
            raise TypeError("Expected CustomDistributionMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CustomDistributionMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> CustomDistributionMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CustomDistributionMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterOptionalTypeDatetime(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeDatetime.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeDatetime.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeDatetime.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class DatetimeMetricProtocol(typing.Protocol):
    
    def set(self, value: typing.Union[object, typing.Optional[Datetime]] = _DEFAULT) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[Datetime]:
        raise NotImplementedError
    def test_get_value_as_string(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[str]:
        raise NotImplementedError

class DatetimeMetric(DatetimeMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData,time_unit: TimeUnit):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)

        _UniffiFfiConverterTypeTimeUnit.check_lower(time_unit)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
            _UniffiFfiConverterTypeTimeUnit.lower(time_unit),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeDatetimeMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_datetimemetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_datetimemetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_datetimemetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def set(self, value: typing.Union[object, typing.Optional[Datetime]] = _DEFAULT) -> None:
        
        if value is _DEFAULT:
            value = None
        _UniffiFfiConverterOptionalTypeDatetime.check_lower(value)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalTypeDatetime.lower(value),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_datetimemetric_set,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_datetimemetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[Datetime]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeDatetime.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_datetimemetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value_as_string(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[str]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalString.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_datetimemetric_test_get_value_as_string,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeDatetimeMetric:
    @staticmethod
    def lift(value: int) -> DatetimeMetric:
        return DatetimeMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: DatetimeMetric):
        if not isinstance(value, DatetimeMetric):
            raise TypeError("Expected DatetimeMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DatetimeMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> DatetimeMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DatetimeMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class DenominatorMetricProtocol(typing.Protocol):
    
    def add(self, amount: int) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[int]:
        raise NotImplementedError

class DenominatorMetric(DenominatorMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData,numerators: typing.List[CommonMetricData]):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)

        _UniffiFfiConverterSequenceTypeCommonMetricData.check_lower(numerators)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
            _UniffiFfiConverterSequenceTypeCommonMetricData.lower(numerators),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeDenominatorMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_denominatormetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_denominatormetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_denominatormetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def add(self, amount: int) -> None:
        
        _UniffiFfiConverterInt32.check_lower(amount)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterInt32.lower(amount),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_denominatormetric_add,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_denominatormetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[int]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_denominatormetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeDenominatorMetric:
    @staticmethod
    def lift(value: int) -> DenominatorMetric:
        return DenominatorMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: DenominatorMetric):
        if not isinstance(value, DenominatorMetric):
            raise TypeError("Expected DenominatorMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DenominatorMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> DenominatorMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DenominatorMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterMapStringInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiFfiConverterString.check_lower(key)
            _UniffiFfiConverterInt32.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiFfiConverterString.write(key, buf)
            _UniffiFfiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiFfiConverterString.read(buf)
            val = _UniffiFfiConverterInt32.read(buf)
            d[key] = val
        return d

class _UniffiFfiConverterMapStringMapStringInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiFfiConverterString.check_lower(key)
            _UniffiFfiConverterMapStringInt32.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiFfiConverterString.write(key, buf)
            _UniffiFfiConverterMapStringInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiFfiConverterString.read(buf)
            val = _UniffiFfiConverterMapStringInt32.read(buf)
            d[key] = val
        return d

class _UniffiFfiConverterOptionalMapStringMapStringInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterMapStringMapStringInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterMapStringMapStringInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterMapStringMapStringInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class DualLabeledCounterMetricProtocol(typing.Protocol):
    
    def get(self, key: str,category: str) -> CounterMetric:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[dict[str, dict[str, int]]]:
        raise NotImplementedError

class DualLabeledCounterMetric(DualLabeledCounterMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData,keys: typing.Optional[typing.List[CowString]],categories: typing.Optional[typing.List[CowString]]):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)

        _UniffiFfiConverterOptionalSequenceTypeCowString.check_lower(keys)

        _UniffiFfiConverterOptionalSequenceTypeCowString.check_lower(categories)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
            _UniffiFfiConverterOptionalSequenceTypeCowString.lower(keys),
            _UniffiFfiConverterOptionalSequenceTypeCowString.lower(categories),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeDualLabeledCounterMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_duallabeledcountermetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_duallabeledcountermetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_duallabeledcountermetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def get(self, key: str,category: str) -> CounterMetric:
        
        _UniffiFfiConverterString.check_lower(key)

        _UniffiFfiConverterString.check_lower(category)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(key),
            _UniffiFfiConverterString.lower(category),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeCounterMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_duallabeledcountermetric_get,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_duallabeledcountermetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[dict[str, dict[str, int]]]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalMapStringMapStringInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_duallabeledcountermetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeDualLabeledCounterMetric:
    @staticmethod
    def lift(value: int) -> DualLabeledCounterMetric:
        return DualLabeledCounterMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: DualLabeledCounterMetric):
        if not isinstance(value, DualLabeledCounterMetric):
            raise TypeError("Expected DualLabeledCounterMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DualLabeledCounterMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> DualLabeledCounterMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DualLabeledCounterMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterSequenceTypeRecordedEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeRecordedEvent.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeRecordedEvent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeRecordedEvent.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalSequenceTypeRecordedEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterSequenceTypeRecordedEvent.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterSequenceTypeRecordedEvent.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterSequenceTypeRecordedEvent.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class EventMetricProtocol(typing.Protocol):
    
    def record(self, extra: dict[str, str]) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[typing.List[RecordedEvent]]:
        raise NotImplementedError

class EventMetric(EventMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData,allowed_extra_keys: typing.List[str]):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)

        _UniffiFfiConverterSequenceString.check_lower(allowed_extra_keys)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
            _UniffiFfiConverterSequenceString.lower(allowed_extra_keys),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeEventMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_eventmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_eventmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_eventmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def record(self, extra: dict[str, str]) -> None:
        
        _UniffiFfiConverterMapStringString.check_lower(extra)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterMapStringString.lower(extra),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_eventmetric_record,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_eventmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[typing.List[RecordedEvent]]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalSequenceTypeRecordedEvent.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_eventmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeEventMetric:
    @staticmethod
    def lift(value: int) -> EventMetric:
        return EventMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: EventMetric):
        if not isinstance(value, EventMetric):
            raise TypeError("Expected EventMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> EventMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterMapStringBoolean(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiFfiConverterString.check_lower(key)
            _UniffiFfiConverterBoolean.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiFfiConverterString.write(key, buf)
            _UniffiFfiConverterBoolean.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiFfiConverterString.read(buf)
            val = _UniffiFfiConverterBoolean.read(buf)
            d[key] = val
        return d

class _UniffiFfiConverterOptionalMapStringBoolean(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterMapStringBoolean.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterMapStringBoolean.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterMapStringBoolean.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class LabeledBooleanProtocol(typing.Protocol):
    
    def get(self, label: str) -> BooleanMetric:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[dict[str, bool]]:
        raise NotImplementedError

class LabeledBoolean(LabeledBooleanProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: LabeledMetricData,labels: typing.Optional[typing.List[CowString]]):
        
        _UniffiFfiConverterTypeLabeledMetricData.check_lower(meta)

        _UniffiFfiConverterOptionalSequenceTypeCowString.check_lower(labels)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeLabeledMetricData.lower(meta),
            _UniffiFfiConverterOptionalSequenceTypeCowString.lower(labels),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeLabeledBoolean.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_labeledboolean_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_labeledboolean, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_labeledboolean, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def get(self, label: str) -> BooleanMetric:
        
        _UniffiFfiConverterString.check_lower(label)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(label),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeBooleanMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledboolean_get,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledboolean_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[dict[str, bool]]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalMapStringBoolean.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledboolean_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeLabeledBoolean:
    @staticmethod
    def lift(value: int) -> LabeledBoolean:
        return LabeledBoolean._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: LabeledBoolean):
        if not isinstance(value, LabeledBoolean):
            raise TypeError("Expected LabeledBoolean instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: LabeledBoolean) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> LabeledBoolean:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: LabeledBoolean, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterOptionalMapStringInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterMapStringInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterMapStringInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterMapStringInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class LabeledCounterProtocol(typing.Protocol):
    
    def get(self, label: str) -> CounterMetric:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[dict[str, int]]:
        raise NotImplementedError

class LabeledCounter(LabeledCounterProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: LabeledMetricData,labels: typing.Optional[typing.List[CowString]]):
        
        _UniffiFfiConverterTypeLabeledMetricData.check_lower(meta)

        _UniffiFfiConverterOptionalSequenceTypeCowString.check_lower(labels)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeLabeledMetricData.lower(meta),
            _UniffiFfiConverterOptionalSequenceTypeCowString.lower(labels),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeLabeledCounter.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_labeledcounter_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_labeledcounter, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_labeledcounter, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def get(self, label: str) -> CounterMetric:
        
        _UniffiFfiConverterString.check_lower(label)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(label),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeCounterMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledcounter_get,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledcounter_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[dict[str, int]]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalMapStringInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledcounter_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeLabeledCounter:
    @staticmethod
    def lift(value: int) -> LabeledCounter:
        return LabeledCounter._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: LabeledCounter):
        if not isinstance(value, LabeledCounter):
            raise TypeError("Expected LabeledCounter instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: LabeledCounter) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> LabeledCounter:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: LabeledCounter, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class QuantityMetricProtocol(typing.Protocol):
    
    def set(self, value: int) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[int]:
        raise NotImplementedError

class QuantityMetric(QuantityMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeQuantityMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_quantitymetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_quantitymetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_quantitymetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def set(self, value: int) -> None:
        
        _UniffiFfiConverterInt64.check_lower(value)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterInt64.lower(value),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_quantitymetric_set,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_quantitymetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[int]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalInt64.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_quantitymetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeQuantityMetric:
    @staticmethod
    def lift(value: int) -> QuantityMetric:
        return QuantityMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: QuantityMetric):
        if not isinstance(value, QuantityMetric):
            raise TypeError("Expected QuantityMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: QuantityMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> QuantityMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: QuantityMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterMapStringInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiFfiConverterString.check_lower(key)
            _UniffiFfiConverterInt64.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiFfiConverterString.write(key, buf)
            _UniffiFfiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiFfiConverterString.read(buf)
            val = _UniffiFfiConverterInt64.read(buf)
            d[key] = val
        return d

class _UniffiFfiConverterOptionalMapStringInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterMapStringInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterMapStringInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterMapStringInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class LabeledQuantityProtocol(typing.Protocol):
    
    def get(self, label: str) -> QuantityMetric:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[dict[str, int]]:
        raise NotImplementedError

class LabeledQuantity(LabeledQuantityProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: LabeledMetricData,labels: typing.Optional[typing.List[CowString]]):
        
        _UniffiFfiConverterTypeLabeledMetricData.check_lower(meta)

        _UniffiFfiConverterOptionalSequenceTypeCowString.check_lower(labels)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeLabeledMetricData.lower(meta),
            _UniffiFfiConverterOptionalSequenceTypeCowString.lower(labels),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeLabeledQuantity.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_labeledquantity_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_labeledquantity, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_labeledquantity, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def get(self, label: str) -> QuantityMetric:
        
        _UniffiFfiConverterString.check_lower(label)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(label),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeQuantityMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledquantity_get,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledquantity_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[dict[str, int]]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalMapStringInt64.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledquantity_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeLabeledQuantity:
    @staticmethod
    def lift(value: int) -> LabeledQuantity:
        return LabeledQuantity._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: LabeledQuantity):
        if not isinstance(value, LabeledQuantity):
            raise TypeError("Expected LabeledQuantity instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: LabeledQuantity) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> LabeledQuantity:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: LabeledQuantity, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class StringMetricProtocol(typing.Protocol):
    
    def set(self, value: str) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[str]:
        raise NotImplementedError

class StringMetric(StringMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeStringMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_stringmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_stringmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_stringmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def set(self, value: str) -> None:
        
        _UniffiFfiConverterString.check_lower(value)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(value),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_stringmetric_set,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_stringmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[str]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalString.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_stringmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeStringMetric:
    @staticmethod
    def lift(value: int) -> StringMetric:
        return StringMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: StringMetric):
        if not isinstance(value, StringMetric):
            raise TypeError("Expected StringMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StringMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> StringMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StringMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class LabeledStringProtocol(typing.Protocol):
    
    def get(self, label: str) -> StringMetric:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[dict[str, str]]:
        raise NotImplementedError

class LabeledString(LabeledStringProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: LabeledMetricData,labels: typing.Optional[typing.List[CowString]]):
        
        _UniffiFfiConverterTypeLabeledMetricData.check_lower(meta)

        _UniffiFfiConverterOptionalSequenceTypeCowString.check_lower(labels)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeLabeledMetricData.lower(meta),
            _UniffiFfiConverterOptionalSequenceTypeCowString.lower(labels),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeLabeledString.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_labeledstring_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_labeledstring, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_labeledstring, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def get(self, label: str) -> StringMetric:
        
        _UniffiFfiConverterString.check_lower(label)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(label),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeStringMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledstring_get,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledstring_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[dict[str, str]]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalMapStringString.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_labeledstring_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeLabeledString:
    @staticmethod
    def lift(value: int) -> LabeledString:
        return LabeledString._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: LabeledString):
        if not isinstance(value, LabeledString):
            raise TypeError("Expected LabeledString instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: LabeledString) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> LabeledString:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: LabeledString, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class MemoryDistributionMetricProtocol(typing.Protocol):
    
    def accumulate(self, sample: int) -> None:
        raise NotImplementedError
    def accumulate_samples(self, samples: typing.List[int]) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[DistributionData]:
        raise NotImplementedError

class MemoryDistributionMetric(MemoryDistributionMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData,memory_unit: MemoryUnit):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)

        _UniffiFfiConverterTypeMemoryUnit.check_lower(memory_unit)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
            _UniffiFfiConverterTypeMemoryUnit.lower(memory_unit),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeMemoryDistributionMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_memorydistributionmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_memorydistributionmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_memorydistributionmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def accumulate(self, sample: int) -> None:
        
        _UniffiFfiConverterInt64.check_lower(sample)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterInt64.lower(sample),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_accumulate,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def accumulate_samples(self, samples: typing.List[int]) -> None:
        
        _UniffiFfiConverterSequenceInt64.check_lower(samples)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterSequenceInt64.lower(samples),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_accumulate_samples,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[DistributionData]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeDistributionData.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_memorydistributionmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeMemoryDistributionMetric:
    @staticmethod
    def lift(value: int) -> MemoryDistributionMetric:
        return MemoryDistributionMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: MemoryDistributionMetric):
        if not isinstance(value, MemoryDistributionMetric):
            raise TypeError("Expected MemoryDistributionMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MemoryDistributionMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> MemoryDistributionMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MemoryDistributionMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterOptionalTypeRate(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeRate.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeRate.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeRate.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class NumeratorMetricProtocol(typing.Protocol):
    
    def add_to_numerator(self, amount: int) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[Rate]:
        raise NotImplementedError

class NumeratorMetric(NumeratorMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeNumeratorMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_numeratormetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_numeratormetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_numeratormetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def add_to_numerator(self, amount: int) -> None:
        
        _UniffiFfiConverterInt32.check_lower(amount)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterInt32.lower(amount),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_numeratormetric_add_to_numerator,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_numeratormetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[Rate]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeRate.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_numeratormetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeNumeratorMetric:
    @staticmethod
    def lift(value: int) -> NumeratorMetric:
        return NumeratorMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: NumeratorMetric):
        if not isinstance(value, NumeratorMetric):
            raise TypeError("Expected NumeratorMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NumeratorMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> NumeratorMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NumeratorMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterOptionalTypeJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeJsonValue.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeJsonValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeJsonValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class ObjectMetricProtocol(typing.Protocol):
    
    def record_schema_error(self, ) -> None:
        raise NotImplementedError
    def set_string(self, object: str) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[JsonValue]:
        raise NotImplementedError

class ObjectMetric(ObjectMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeObjectMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_objectmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_objectmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_objectmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def record_schema_error(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_objectmetric_record_schema_error,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def set_string(self, object: str) -> None:
        
        _UniffiFfiConverterString.check_lower(object)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(object),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_objectmetric_set_string,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_objectmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[JsonValue]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeJsonValue.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_objectmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeObjectMetric:
    @staticmethod
    def lift(value: int) -> ObjectMetric:
        return ObjectMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: ObjectMetric):
        if not isinstance(value, ObjectMetric):
            raise TypeError("Expected ObjectMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ObjectMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> ObjectMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ObjectMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class PingTypeProtocol(typing.Protocol):
    
    def set_enabled(self, enabled: bool) -> None:
        raise NotImplementedError
    def submit(self, reason: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> None:
        raise NotImplementedError

class PingType(PingTypeProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, name: str,include_client_id: bool,send_if_empty: bool,precise_timestamps: bool,include_info_sections: bool,enabled: bool,schedules_pings: typing.List[str],reason_codes: typing.List[str],follows_collection_enabled: bool,uploader_capabilities: typing.List[str]):
        
        _UniffiFfiConverterString.check_lower(name)

        _UniffiFfiConverterBoolean.check_lower(include_client_id)

        _UniffiFfiConverterBoolean.check_lower(send_if_empty)

        _UniffiFfiConverterBoolean.check_lower(precise_timestamps)

        _UniffiFfiConverterBoolean.check_lower(include_info_sections)

        _UniffiFfiConverterBoolean.check_lower(enabled)

        _UniffiFfiConverterSequenceString.check_lower(schedules_pings)

        _UniffiFfiConverterSequenceString.check_lower(reason_codes)

        _UniffiFfiConverterBoolean.check_lower(follows_collection_enabled)

        _UniffiFfiConverterSequenceString.check_lower(uploader_capabilities)
        _uniffi_lowered_args = (
            _UniffiFfiConverterString.lower(name),
            _UniffiFfiConverterBoolean.lower(include_client_id),
            _UniffiFfiConverterBoolean.lower(send_if_empty),
            _UniffiFfiConverterBoolean.lower(precise_timestamps),
            _UniffiFfiConverterBoolean.lower(include_info_sections),
            _UniffiFfiConverterBoolean.lower(enabled),
            _UniffiFfiConverterSequenceString.lower(schedules_pings),
            _UniffiFfiConverterSequenceString.lower(reason_codes),
            _UniffiFfiConverterBoolean.lower(follows_collection_enabled),
            _UniffiFfiConverterSequenceString.lower(uploader_capabilities),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypePingType.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_pingtype_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_pingtype, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_pingtype, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def set_enabled(self, enabled: bool) -> None:
        
        _UniffiFfiConverterBoolean.check_lower(enabled)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterBoolean.lower(enabled),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_pingtype_set_enabled,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def submit(self, reason: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> None:
        
        if reason is _DEFAULT:
            reason = None
        _UniffiFfiConverterOptionalString.check_lower(reason)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(reason),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_pingtype_submit,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypePingType:
    @staticmethod
    def lift(value: int) -> PingType:
        return PingType._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: PingType):
        if not isinstance(value, PingType):
            raise TypeError("Expected PingType instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PingType) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> PingType:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PingType, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class RateMetricProtocol(typing.Protocol):
    
    def add_to_denominator(self, amount: int) -> None:
        raise NotImplementedError
    def add_to_numerator(self, amount: int) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[Rate]:
        raise NotImplementedError

class RateMetric(RateMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeRateMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_ratemetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_ratemetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_ratemetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def add_to_denominator(self, amount: int) -> None:
        
        _UniffiFfiConverterInt32.check_lower(amount)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterInt32.lower(amount),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_ratemetric_add_to_denominator,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def add_to_numerator(self, amount: int) -> None:
        
        _UniffiFfiConverterInt32.check_lower(amount)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterInt32.lower(amount),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_ratemetric_add_to_numerator,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_ratemetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[Rate]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeRate.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_ratemetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeRateMetric:
    @staticmethod
    def lift(value: int) -> RateMetric:
        return RateMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: RateMetric):
        if not isinstance(value, RateMetric):
            raise TypeError("Expected RateMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RateMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> RateMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RateMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class StringListMetricProtocol(typing.Protocol):
    
    def add(self, value: str) -> None:
        raise NotImplementedError
    def set(self, value: typing.List[str]) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[typing.List[str]]:
        raise NotImplementedError

class StringListMetric(StringListMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeStringListMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_stringlistmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_stringlistmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_stringlistmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def add(self, value: str) -> None:
        
        _UniffiFfiConverterString.check_lower(value)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(value),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_add,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def set(self, value: typing.List[str]) -> None:
        
        _UniffiFfiConverterSequenceString.check_lower(value)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterSequenceString.lower(value),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_set,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[typing.List[str]]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalSequenceString.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_stringlistmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeStringListMetric:
    @staticmethod
    def lift(value: int) -> StringListMetric:
        return StringListMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: StringListMetric):
        if not isinstance(value, StringListMetric):
            raise TypeError("Expected StringListMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StringListMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> StringListMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StringListMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class TextMetricProtocol(typing.Protocol):
    
    def set(self, value: str) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[str]:
        raise NotImplementedError

class TextMetric(TextMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeTextMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_textmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_textmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_textmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def set(self, value: str) -> None:
        
        _UniffiFfiConverterString.check_lower(value)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(value),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_textmetric_set,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_textmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[str]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalString.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_textmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeTextMetric:
    @staticmethod
    def lift(value: int) -> TextMetric:
        return TextMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: TextMetric):
        if not isinstance(value, TextMetric):
            raise TypeError("Expected TextMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TextMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> TextMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TextMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class TimespanMetricProtocol(typing.Protocol):
    
    def cancel(self, ) -> None:
        raise NotImplementedError
    def set_raw_nanos(self, elapsed: int) -> None:
        raise NotImplementedError
    def start(self, ) -> None:
        raise NotImplementedError
    def stop(self, ) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[int]:
        raise NotImplementedError

class TimespanMetric(TimespanMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData,time_unit: TimeUnit):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)

        _UniffiFfiConverterTypeTimeUnit.check_lower(time_unit)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
            _UniffiFfiConverterTypeTimeUnit.lower(time_unit),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeTimespanMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_timespanmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_timespanmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_timespanmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def cancel(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timespanmetric_cancel,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def set_raw_nanos(self, elapsed: int) -> None:
        
        _UniffiFfiConverterInt64.check_lower(elapsed)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterInt64.lower(elapsed),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timespanmetric_set_raw_nanos,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def start(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timespanmetric_start,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def stop(self, ) -> None:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timespanmetric_stop,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timespanmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[int]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalInt64.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timespanmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeTimespanMetric:
    @staticmethod
    def lift(value: int) -> TimespanMetric:
        return TimespanMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: TimespanMetric):
        if not isinstance(value, TimespanMetric):
            raise TypeError("Expected TimespanMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TimespanMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> TimespanMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TimespanMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class TimingDistributionMetricProtocol(typing.Protocol):
    
    def accumulate_samples(self, samples: typing.List[int]) -> None:
        raise NotImplementedError
    def accumulate_single_sample(self, sample: int) -> None:
        raise NotImplementedError
    def cancel(self, timer_id: TimerId) -> None:
        raise NotImplementedError
    def start(self, ) -> TimerId:
        raise NotImplementedError
    def stop_and_accumulate(self, timer_id: TimerId) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[DistributionData]:
        raise NotImplementedError

class TimingDistributionMetric(TimingDistributionMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData,time_unit: TimeUnit):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)

        _UniffiFfiConverterTypeTimeUnit.check_lower(time_unit)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
            _UniffiFfiConverterTypeTimeUnit.lower(time_unit),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeTimingDistributionMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_timingdistributionmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_timingdistributionmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_timingdistributionmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def accumulate_samples(self, samples: typing.List[int]) -> None:
        
        _UniffiFfiConverterSequenceInt64.check_lower(samples)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterSequenceInt64.lower(samples),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_accumulate_samples,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def accumulate_single_sample(self, sample: int) -> None:
        
        _UniffiFfiConverterInt64.check_lower(sample)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterInt64.lower(sample),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_accumulate_single_sample,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def cancel(self, timer_id: TimerId) -> None:
        
        _UniffiFfiConverterTypeTimerId.check_lower(timer_id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeTimerId.lower(timer_id),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_cancel,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def start(self, ) -> TimerId:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeTimerId.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_start,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def stop_and_accumulate(self, timer_id: TimerId) -> None:
        
        _UniffiFfiConverterTypeTimerId.check_lower(timer_id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeTimerId.lower(timer_id),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_stop_and_accumulate,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[DistributionData]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeDistributionData.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_timingdistributionmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeTimingDistributionMetric:
    @staticmethod
    def lift(value: int) -> TimingDistributionMetric:
        return TimingDistributionMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: TimingDistributionMetric):
        if not isinstance(value, TimingDistributionMetric):
            raise TypeError("Expected TimingDistributionMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TimingDistributionMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> TimingDistributionMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TimingDistributionMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class UrlMetricProtocol(typing.Protocol):
    
    def set(self, value: str) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[str]:
        raise NotImplementedError

class UrlMetric(UrlMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeUrlMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_urlmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_urlmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_urlmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def set(self, value: str) -> None:
        
        _UniffiFfiConverterString.check_lower(value)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(value),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_urlmetric_set,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_urlmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[str]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalString.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_urlmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeUrlMetric:
    @staticmethod
    def lift(value: int) -> UrlMetric:
        return UrlMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: UrlMetric):
        if not isinstance(value, UrlMetric):
            raise TypeError("Expected UrlMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UrlMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> UrlMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UrlMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class UuidMetricProtocol(typing.Protocol):
    
    def generate_and_set(self, ) -> str:
        raise NotImplementedError
    def set(self, value: str) -> None:
        raise NotImplementedError
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        raise NotImplementedError
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[str]:
        raise NotImplementedError

class UuidMetric(UuidMetricProtocol):
    
    _handle: ctypes.c_uint64
    def __init__(self, meta: CommonMetricData):
        
        _UniffiFfiConverterTypeCommonMetricData.check_lower(meta)
        _uniffi_lowered_args = (
            _UniffiFfiConverterTypeCommonMetricData.lower(meta),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeUuidMetric.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_constructor_uuidmetric_new,
            *_uniffi_lowered_args,
        )
        self._handle = _uniffi_ffi_result

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_free_uuidmetric, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glean_core_fn_clone_uuidmetric, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def generate_and_set(self, ) -> str:
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterString.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_uuidmetric_generate_and_set,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def set(self, value: str) -> None:
        
        _UniffiFfiConverterString.check_lower(value)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(value),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_uuidmetric_set,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_num_recorded_errors(self, error: ErrorType) -> int:
        
        _UniffiFfiConverterTypeErrorType.check_lower(error)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeErrorType.lower(error),
        )
        _uniffi_lift_return = _UniffiFfiConverterInt32.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_uuidmetric_test_get_num_recorded_errors,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def test_get_value(self, ping_name: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> typing.Optional[str]:
        
        if ping_name is _DEFAULT:
            ping_name = None
        _UniffiFfiConverterOptionalString.check_lower(ping_name)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalString.lower(ping_name),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalString.lift
        _uniffi_error_converter = None
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_glean_core_fn_method_uuidmetric_test_get_value,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeUuidMetric:
    @staticmethod
    def lift(value: int) -> UuidMetric:
        return UuidMetric._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: UuidMetric):
        if not isinstance(value, UuidMetric):
            raise TypeError("Expected UuidMetric instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UuidMetric) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> UuidMetric:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UuidMetric, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))




class GleanEventListener(typing.Protocol):
    
    def on_event_recorded(self, id: str) -> None:
        raise NotImplementedError
# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplGleanEventListenerImpl:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_GLEAN_GLEAN_EVENT_LISTENER_METHOD0
    def on_event_recorded(
            uniffi_handle,
            id,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiFfiConverterTypeGleanEventListener._handle_map.get(uniffi_handle)
        def make_call():
            uniffi_args = (_UniffiFfiConverterString.lift(id), )
            uniffi_method = uniffi_obj.on_event_recorded
            return uniffi_method(*uniffi_args)
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE_GLEAN_GLEAN_EVENT_LISTENER
    def _uniffi_free(uniffi_handle):
        _UniffiFfiConverterTypeGleanEventListener._handle_map.remove(uniffi_handle)

    @_UNIFFI_CALLBACK_INTERFACE_CLONE_GLEAN_GLEAN_EVENT_LISTENER
    def _uniffi_clone(uniffi_handle):
        return _UniffiFfiConverterTypeGleanEventListener._handle_map.clone(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceGleanGleanEventListener(
        _uniffi_free,
        _uniffi_clone,
        on_event_recorded,
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_glean_core_fn_init_callback_vtable_gleaneventlistener(ctypes.byref(_uniffi_vtable))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiFfiConverterTypeGleanEventListener = _UniffiCallbackInterfaceFfiConverter()




class OnGleanEvents(typing.Protocol):
    
    def initialize_finished(self, ) -> None:
        raise NotImplementedError
    def trigger_upload(self, ) -> None:
        raise NotImplementedError
    def start_metrics_ping_scheduler(self, ) -> bool:
        raise NotImplementedError
    def cancel_uploads(self, ) -> None:
        raise NotImplementedError
    def shutdown(self, ) -> None:
        raise NotImplementedError
# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplOnGleanEventsImpl:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD0
    def initialize_finished(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiFfiConverterTypeOnGleanEvents._handle_map.get(uniffi_handle)
        def make_call():
            uniffi_args = ()
            uniffi_method = uniffi_obj.initialize_finished
            return uniffi_method(*uniffi_args)
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD1
    def trigger_upload(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiFfiConverterTypeOnGleanEvents._handle_map.get(uniffi_handle)
        def make_call():
            uniffi_args = ()
            uniffi_method = uniffi_obj.trigger_upload
            return uniffi_method(*uniffi_args)
        write_return_value = lambda v: None
        _uniffi_trait_interface_call_with_error(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
                CallbackError,
                _UniffiFfiConverterTypeCallbackError.lower,
        )

    @_UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD2
    def start_metrics_ping_scheduler(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiFfiConverterTypeOnGleanEvents._handle_map.get(uniffi_handle)
        def make_call():
            uniffi_args = ()
            uniffi_method = uniffi_obj.start_metrics_ping_scheduler
            return uniffi_method(*uniffi_args)
        def write_return_value(v):
            uniffi_out_return[0] = _UniffiFfiConverterBoolean.lower(v)
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD3
    def cancel_uploads(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiFfiConverterTypeOnGleanEvents._handle_map.get(uniffi_handle)
        def make_call():
            uniffi_args = ()
            uniffi_method = uniffi_obj.cancel_uploads
            return uniffi_method(*uniffi_args)
        write_return_value = lambda v: None
        _uniffi_trait_interface_call_with_error(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
                CallbackError,
                _UniffiFfiConverterTypeCallbackError.lower,
        )

    @_UNIFFI_CALLBACK_INTERFACE_GLEAN_ON_GLEAN_EVENTS_METHOD4
    def shutdown(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiFfiConverterTypeOnGleanEvents._handle_map.get(uniffi_handle)
        def make_call():
            uniffi_args = ()
            uniffi_method = uniffi_obj.shutdown
            return uniffi_method(*uniffi_args)
        write_return_value = lambda v: None
        _uniffi_trait_interface_call_with_error(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
                CallbackError,
                _UniffiFfiConverterTypeCallbackError.lower,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE_GLEAN_ON_GLEAN_EVENTS
    def _uniffi_free(uniffi_handle):
        _UniffiFfiConverterTypeOnGleanEvents._handle_map.remove(uniffi_handle)

    @_UNIFFI_CALLBACK_INTERFACE_CLONE_GLEAN_ON_GLEAN_EVENTS
    def _uniffi_clone(uniffi_handle):
        return _UniffiFfiConverterTypeOnGleanEvents._handle_map.clone(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceGleanOnGleanEvents(
        _uniffi_free,
        _uniffi_clone,
        initialize_finished,
        trigger_upload,
        start_metrics_ping_scheduler,
        cancel_uploads,
        shutdown,
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_glean_core_fn_init_callback_vtable_ongleanevents(ctypes.byref(_uniffi_vtable))

# The _UniffiConverter which transforms the Callbacks in to Handles to pass to Rust.
_UniffiFfiConverterTypeOnGleanEvents = _UniffiCallbackInterfaceFfiConverter()

class _UniffiFfiConverterOptionalTypeRecordedExperiment(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeRecordedExperiment.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeRecordedExperiment.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeRecordedExperiment.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterSequenceTypeCommonMetricData(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeCommonMetricData.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeCommonMetricData.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeCommonMetricData.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterSequenceTypeCowString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeCowString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeCowString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeCowString.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalSequenceTypeCowString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterSequenceTypeCowString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterSequenceTypeCowString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterSequenceTypeCowString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")
def glean_apply_server_knobs_config(json: str) -> None:
    
    _UniffiFfiConverterString.check_lower(json)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(json),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_apply_server_knobs_config,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_enable_logging() -> None:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_enable_logging,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_enable_logging_to_fd(fd: int) -> None:
    
    _UniffiFfiConverterUInt64.check_lower(fd)
    _uniffi_lowered_args = (
        _UniffiFfiConverterUInt64.lower(fd),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_enable_logging_to_fd,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_get_debug_view_tag() -> typing.Optional[str]:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = _UniffiFfiConverterOptionalString.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_get_debug_view_tag,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_get_log_pings() -> bool:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = _UniffiFfiConverterBoolean.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_get_log_pings,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_get_registered_ping_names() -> typing.List[str]:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = _UniffiFfiConverterSequenceString.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_get_registered_ping_names,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_get_upload_task() -> PingUploadTask:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = _UniffiFfiConverterTypePingUploadTask.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_get_upload_task,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_handle_client_active() -> None:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_handle_client_active,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_handle_client_inactive() -> None:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_handle_client_inactive,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_initialize(cfg: InternalConfiguration,client_info: ClientInfoMetrics,callbacks: OnGleanEvents) -> None:
    
    _UniffiFfiConverterTypeInternalConfiguration.check_lower(cfg)

    _UniffiFfiConverterTypeClientInfoMetrics.check_lower(client_info)

    _UniffiFfiConverterTypeOnGleanEvents.check_lower(callbacks)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeInternalConfiguration.lower(cfg),
        _UniffiFfiConverterTypeClientInfoMetrics.lower(client_info),
        _UniffiFfiConverterTypeOnGleanEvents.lower(callbacks),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_initialize,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_initialize_for_subprocess(cfg: InternalConfiguration) -> bool:
    
    _UniffiFfiConverterTypeInternalConfiguration.check_lower(cfg)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeInternalConfiguration.lower(cfg),
    )
    _uniffi_lift_return = _UniffiFfiConverterBoolean.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_initialize_for_subprocess,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_persist_ping_lifetime_data() -> None:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_persist_ping_lifetime_data,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_process_ping_upload_response(uuid: str,result: UploadResult) -> UploadTaskAction:
    
    _UniffiFfiConverterString.check_lower(uuid)

    _UniffiFfiConverterTypeUploadResult.check_lower(result)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(uuid),
        _UniffiFfiConverterTypeUploadResult.lower(result),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeUploadTaskAction.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_process_ping_upload_response,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_register_event_listener(tag: str,listener: GleanEventListener) -> None:
    
    _UniffiFfiConverterString.check_lower(tag)

    _UniffiFfiConverterTypeGleanEventListener.check_lower(listener)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(tag),
        _UniffiFfiConverterTypeGleanEventListener.lower(listener),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_register_event_listener,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_set_debug_view_tag(tag: str) -> bool:
    
    _UniffiFfiConverterString.check_lower(tag)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(tag),
    )
    _uniffi_lift_return = _UniffiFfiConverterBoolean.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_set_debug_view_tag,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_set_dirty_flag(flag: bool) -> None:
    
    _UniffiFfiConverterBoolean.check_lower(flag)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBoolean.lower(flag),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_set_dirty_flag,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_set_experiment_active(experiment_id: str,branch: str,extra: dict[str, str]) -> None:
    
    _UniffiFfiConverterString.check_lower(experiment_id)

    _UniffiFfiConverterString.check_lower(branch)

    _UniffiFfiConverterMapStringString.check_lower(extra)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(experiment_id),
        _UniffiFfiConverterString.lower(branch),
        _UniffiFfiConverterMapStringString.lower(extra),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_set_experiment_active,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_set_experiment_inactive(experiment_id: str) -> None:
    
    _UniffiFfiConverterString.check_lower(experiment_id)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(experiment_id),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_set_experiment_inactive,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_set_experimentation_id(experimentation_id: str) -> None:
    
    _UniffiFfiConverterString.check_lower(experimentation_id)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(experimentation_id),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_set_experimentation_id,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_set_log_pings(value: bool) -> None:
    
    _UniffiFfiConverterBoolean.check_lower(value)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBoolean.lower(value),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_set_log_pings,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_set_source_tags(tags: typing.List[str]) -> bool:
    
    _UniffiFfiConverterSequenceString.check_lower(tags)
    _uniffi_lowered_args = (
        _UniffiFfiConverterSequenceString.lower(tags),
    )
    _uniffi_lift_return = _UniffiFfiConverterBoolean.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_set_source_tags,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_set_test_mode(enabled: bool) -> None:
    
    _UniffiFfiConverterBoolean.check_lower(enabled)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBoolean.lower(enabled),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_set_test_mode,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_set_upload_enabled(enabled: bool) -> None:
    
    _UniffiFfiConverterBoolean.check_lower(enabled)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBoolean.lower(enabled),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_set_upload_enabled,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_shutdown() -> None:
    """
    Shuts down Glean in an orderly fashion.
"""
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_shutdown,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_submit_ping_by_name(ping_name: str,reason: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> None:
    
    _UniffiFfiConverterString.check_lower(ping_name)

    if reason is _DEFAULT:
        reason = None
    _UniffiFfiConverterOptionalString.check_lower(reason)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(ping_name),
        _UniffiFfiConverterOptionalString.lower(reason),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_submit_ping_by_name,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_submit_ping_by_name_sync(ping_name: str,reason: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> bool:
    
    _UniffiFfiConverterString.check_lower(ping_name)

    if reason is _DEFAULT:
        reason = None
    _UniffiFfiConverterOptionalString.check_lower(reason)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(ping_name),
        _UniffiFfiConverterOptionalString.lower(reason),
    )
    _uniffi_lift_return = _UniffiFfiConverterBoolean.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_submit_ping_by_name_sync,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_test_destroy_glean(clear_stores: bool,data_path: typing.Union[object, typing.Optional[str]] = _DEFAULT) -> None:
    
    _UniffiFfiConverterBoolean.check_lower(clear_stores)

    if data_path is _DEFAULT:
        data_path = None
    _UniffiFfiConverterOptionalString.check_lower(data_path)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBoolean.lower(clear_stores),
        _UniffiFfiConverterOptionalString.lower(data_path),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_test_destroy_glean,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_test_get_attribution() -> AttributionMetrics:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeAttributionMetrics.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_test_get_attribution,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_test_get_distribution() -> DistributionMetrics:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeDistributionMetrics.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_test_get_distribution,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_test_get_experiment_data(experiment_id: str) -> typing.Optional[RecordedExperiment]:
    
    _UniffiFfiConverterString.check_lower(experiment_id)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(experiment_id),
    )
    _uniffi_lift_return = _UniffiFfiConverterOptionalTypeRecordedExperiment.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_test_get_experiment_data,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_test_get_experimentation_id() -> typing.Optional[str]:
    _uniffi_lowered_args = (
    )
    _uniffi_lift_return = _UniffiFfiConverterOptionalString.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_test_get_experimentation_id,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_unregister_event_listener(tag: str) -> None:
    
    _UniffiFfiConverterString.check_lower(tag)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(tag),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_unregister_event_listener,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_update_attribution(attribution: AttributionMetrics) -> None:
    
    _UniffiFfiConverterTypeAttributionMetrics.check_lower(attribution)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeAttributionMetrics.lower(attribution),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_update_attribution,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def glean_update_distribution(distribution: DistributionMetrics) -> None:
    
    _UniffiFfiConverterTypeDistributionMetrics.check_lower(distribution)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeDistributionMetrics.lower(distribution),
    )
    _uniffi_lift_return = lambda val: None
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_glean_core_fn_func_glean_update_distribution,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)

__all__ = [
    "InternalError",
    "Lifetime",
    "DynamicLabelType",
    "LevelFilter",
    "CallbackError",
    "ErrorType",
    "HistogramType",
    "MemoryUnit",
    "TimeUnit",
    "LabeledMetricData",
    "PingUploadTask",
    "UploadResult",
    "UploadTaskAction",
    "AttributionMetrics",
    "Datetime",
    "ClientInfoMetrics",
    "CommonMetricData",
    "DistributionData",
    "DistributionMetrics",
    "PingRateLimit",
    "InternalConfiguration",
    "PingRequest",
    "Rate",
    "RecordedEvent",
    "RecordedExperiment",
    "TimerId",
    "glean_apply_server_knobs_config",
    "glean_enable_logging",
    "glean_enable_logging_to_fd",
    "glean_get_debug_view_tag",
    "glean_get_log_pings",
    "glean_get_registered_ping_names",
    "glean_get_upload_task",
    "glean_handle_client_active",
    "glean_handle_client_inactive",
    "glean_initialize",
    "glean_initialize_for_subprocess",
    "glean_persist_ping_lifetime_data",
    "glean_process_ping_upload_response",
    "glean_register_event_listener",
    "glean_set_debug_view_tag",
    "glean_set_dirty_flag",
    "glean_set_experiment_active",
    "glean_set_experiment_inactive",
    "glean_set_experimentation_id",
    "glean_set_log_pings",
    "glean_set_source_tags",
    "glean_set_test_mode",
    "glean_set_upload_enabled",
    "glean_shutdown",
    "glean_submit_ping_by_name",
    "glean_submit_ping_by_name_sync",
    "glean_test_destroy_glean",
    "glean_test_get_attribution",
    "glean_test_get_distribution",
    "glean_test_get_experiment_data",
    "glean_test_get_experimentation_id",
    "glean_unregister_event_listener",
    "glean_update_attribution",
    "glean_update_distribution",
    "BooleanMetric",
    "BooleanMetricProtocol",
    "CounterMetric",
    "CounterMetricProtocol",
    "CustomDistributionMetric",
    "CustomDistributionMetricProtocol",
    "DatetimeMetric",
    "DatetimeMetricProtocol",
    "DenominatorMetric",
    "DenominatorMetricProtocol",
    "DualLabeledCounterMetric",
    "DualLabeledCounterMetricProtocol",
    "EventMetric",
    "EventMetricProtocol",
    "LabeledBoolean",
    "LabeledBooleanProtocol",
    "LabeledCounter",
    "LabeledCounterProtocol",
    "QuantityMetric",
    "QuantityMetricProtocol",
    "LabeledQuantity",
    "LabeledQuantityProtocol",
    "StringMetric",
    "StringMetricProtocol",
    "LabeledString",
    "LabeledStringProtocol",
    "MemoryDistributionMetric",
    "MemoryDistributionMetricProtocol",
    "NumeratorMetric",
    "NumeratorMetricProtocol",
    "ObjectMetric",
    "ObjectMetricProtocol",
    "PingType",
    "PingTypeProtocol",
    "RateMetric",
    "RateMetricProtocol",
    "StringListMetric",
    "StringListMetricProtocol",
    "TextMetric",
    "TextMetricProtocol",
    "TimespanMetric",
    "TimespanMetricProtocol",
    "TimingDistributionMetric",
    "TimingDistributionMetricProtocol",
    "UrlMetric",
    "UrlMetricProtocol",
    "UuidMetric",
    "UuidMetricProtocol",
    "GleanEventListener",
    "OnGleanEvents",
]