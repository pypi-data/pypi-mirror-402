# v3.5 Allureé›†æˆè®¡åˆ’ï¼šç°ä»£åŒ–è°ƒè¯•ç³»ç»Ÿ

> **ç›®æ ‡**: åŸºäºpytest + Allureå®ç°é›¶é…ç½®ã€ç°ä»£åŒ–çš„æµ‹è¯•è°ƒè¯•ä½“éªŒ
> **åŸåˆ™**: ä¸è€ƒè™‘å†å²åŒ…è¢±ï¼Œé‡‡ç”¨è¡Œä¸šæœ€ä½³å®è·µ

---

## ä¸€ã€è®¾è®¡åŸåˆ™

### 1.1 æ ¸å¿ƒåŸåˆ™

- âœ… **é›¶é…ç½®** - pytestè¿è¡Œæ—¶è‡ªåŠ¨å¯ç”¨ï¼Œæ— éœ€æ‰‹åŠ¨setup
- âœ… **é™é»˜ç»ˆç«¯** - æµ‹è¯•é€šè¿‡æ—¶æœ€å°åŒ–è¾“å‡ºï¼Œå¤±è´¥æ—¶è¯¦æƒ…åœ¨AllureæŠ¥å‘Šä¸­
- âœ… **ç»Ÿä¸€æ ¼å¼** - HTTP/DB/æ‹¦æˆªå™¨ä½¿ç”¨ç›¸åŒçš„è®°å½•æ ¼å¼
- âœ… **è¡Œä¸šæ ‡å‡†** - ä½¿ç”¨Allure Reportï¼ˆä¸šç•Œæ ‡å‡†ï¼‰ï¼Œè€Œéè‡ªå®šä¹‰æ–¹æ¡ˆ
- âœ… **æ— ä¾µå…¥** - æµ‹è¯•ä»£ç æ— éœ€ä¿®æ”¹ï¼Œé€šè¿‡Observeræ¨¡å¼è‡ªåŠ¨è¿½è¸ª

### 1.2 ä¸ç°æœ‰æ¶æ„çš„å®Œç¾é€‚é…

**ç°æœ‰æ¶æ„ï¼ˆv3.5 Phase 1å®Œæˆï¼‰**:
```
HttpClient
    â†“
InterceptorChain
    â†“
[SignatureInterceptor, TokenInterceptor, BearerTokenInterceptor, ...]
    â†“
PathFilteredInterceptor (è·¯å¾„åŒ¹é…åŒ…è£…å™¨)
```

**Allureé›†æˆç‚¹**:
```
AllureObserver (ç›‘å¬è€…)
    â†“ è‡ªåŠ¨ç›‘å¬
HttpClient.request()
    â”œâ”€ before: observer.on_http_request_start()
    â”œâ”€ interceptor: observer.on_interceptor_execute()
    â””â”€ after: observer.on_http_request_end()
```

---

## äºŒã€æŠ€æœ¯æ–¹æ¡ˆ

### 2.1 æ ¸å¿ƒç»„ä»¶æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Pytest Autouse Fixture (_auto_allure_observer)        â”‚
â”‚  - æ¯ä¸ªæµ‹è¯•è‡ªåŠ¨åˆ›å»º AllureObserver                      â”‚
â”‚  - é€šè¿‡ ContextVar æ³¨å…¥åˆ°å…¨å±€ä¸Šä¸‹æ–‡                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AllureObserver (æ ¸å¿ƒè§‚å¯Ÿè€…)                            â”‚
â”‚  - on_http_request_start() â†’ åˆ›å»º Allure step          â”‚
â”‚  - on_interceptor_execute() â†’ è®°å½•æ‹¦æˆªå™¨ä¿®æ”¹            â”‚
â”‚  - on_http_request_end() â†’ é™„åŠ å“åº”è¯¦æƒ…                â”‚
â”‚  - on_error() â†’ è®°å½•é”™è¯¯ä¿¡æ¯                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  HttpClient.request()                                   â”‚
â”‚  1. è·å– observer = get_current_observer()              â”‚
â”‚  2. request_id = observer.on_http_request_start()       â”‚
â”‚  3. æ‰§è¡Œæ‹¦æˆªå™¨é“¾ï¼ˆä¼ é€’ request_id å’Œ observerï¼‰         â”‚
â”‚  4. å‘é€ HTTP è¯·æ±‚                                      â”‚
â”‚  5. observer.on_http_request_end()                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  InterceptorChain.execute_before_request()              â”‚
â”‚  - éå†æ‰€æœ‰æ‹¦æˆªå™¨                                        â”‚
â”‚  - å¯¹æ¯”ä¿®æ”¹å‰åçš„ Request å¯¹è±¡                           â”‚
â”‚  - è°ƒç”¨ observer.on_interceptor_execute() è®°å½•å˜åŒ–       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Allure HTML Report                                     â”‚
â”‚  - å®Œæ•´çš„è¯·æ±‚/å“åº”è¯¦æƒ…                                   â”‚
â”‚  - æ‹¦æˆªå™¨æ‰§è¡Œè¿‡ç¨‹å¯è§ï¼ˆsub-stepsï¼‰                       â”‚
â”‚  - Timelineæ—¶é—´çº¿                                        â”‚
â”‚  - æ”¯æŒæˆªå›¾/è§†é¢‘/é™„ä»¶                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 AllureObserveræ ¸å¿ƒå®ç°

**æ–‡ä»¶ä½ç½®**: `src/df_test_framework/testing/observers/allure_observer.py`

```python
"""Allureæµ‹è¯•è§‚å¯Ÿè€…

é›¶é…ç½®è‡ªåŠ¨è®°å½•HTTPè¯·æ±‚ã€æ‹¦æˆªå™¨ã€æ•°æ®åº“æŸ¥è¯¢ç­‰æ“ä½œåˆ°AllureæŠ¥å‘Š
"""
from contextvars import ContextVar
import json
import time
from typing import Optional, Dict, Any, TYPE_CHECKING

try:
    import allure
    ALLURE_AVAILABLE = True
except ImportError:
    ALLURE_AVAILABLE = False

if TYPE_CHECKING:
    from df_test_framework.clients.http.core import Request, Response


# çº¿ç¨‹å®‰å…¨çš„å½“å‰Observer
_current_observer: ContextVar[Optional['AllureObserver']] = ContextVar(
    'allure_observer', default=None
)


class AllureObserver:
    """Allureæµ‹è¯•è§‚å¯Ÿè€…

    è‡ªåŠ¨è®°å½•æµ‹è¯•æ“ä½œåˆ°AllureæŠ¥å‘Š:
    - HTTPè¯·æ±‚/å“åº”è¯¦æƒ…
    - æ‹¦æˆªå™¨æ‰§è¡Œè¿‡ç¨‹
    - æ•°æ®åº“æŸ¥è¯¢ (å¯é€‰)
    - é”™è¯¯å’Œå¼‚å¸¸

    ä½¿ç”¨æ–¹å¼:
        # å®Œå…¨è‡ªåŠ¨ï¼Œé€šè¿‡ autouse fixture æ³¨å…¥
        def test_api(http_client):
            response = http_client.post("/api/users", json={"name": "Alice"})
            assert response.status_code == 201

        # AllureæŠ¥å‘Šè‡ªåŠ¨åŒ…å«å®Œæ•´çš„è¯·æ±‚/å“åº”è¯¦æƒ…
    """

    def __init__(self, test_name: str):
        """åˆå§‹åŒ–Observer

        Args:
            test_name: å½“å‰æµ‹è¯•åç§°
        """
        self.test_name = test_name
        self.request_counter = 0
        self._current_step_context = None
        self._current_request_id = None
        self._request_start_time = None

    def on_http_request_start(
        self,
        request: 'Request'
    ) -> str:
        """HTTPè¯·æ±‚å¼€å§‹

        åˆ›å»ºAllure stepå¹¶é™„åŠ è¯·æ±‚è¯¦æƒ…

        Args:
            request: Requestå¯¹è±¡

        Returns:
            request_id - ç”¨äºå…³è”åç»­äº‹ä»¶
        """
        if not ALLURE_AVAILABLE:
            return None

        self.request_counter += 1
        request_id = f"req-{self.request_counter:03d}"
        self._request_start_time = time.time()

        # åˆ›å»ºAllure step (å¸¦emojiå›¾æ ‡)
        step_title = f"ğŸŒ {request.method} {request.url}"
        self._current_step_context = allure.step(step_title)
        self._current_step_context.__enter__()
        self._current_request_id = request_id

        # é™„åŠ è¯·æ±‚è¯¦æƒ…
        request_details = {
            "request_id": request_id,
            "method": request.method,
            "url": request.url,
            "headers": dict(request.headers) if request.headers else {},
            "params": request.params,
            "json": request.json,
            "data": request.data,
        }

        allure.attach(
            json.dumps(request_details, indent=2, ensure_ascii=False),
            name="ğŸ“¤ Request Details",
            attachment_type=allure.attachment_type.JSON
        )

        return request_id

    def on_interceptor_execute(
        self,
        request_id: str,
        interceptor_name: str,
        changes: Dict[str, Any]
    ) -> None:
        """æ‹¦æˆªå™¨æ‰§è¡Œè®°å½•

        åœ¨å½“å‰HTTPè¯·æ±‚stepä¸‹åˆ›å»ºå­step

        Args:
            request_id: è¯·æ±‚ID
            interceptor_name: æ‹¦æˆªå™¨åç§°
            changes: æ‹¦æˆªå™¨åšçš„ä¿®æ”¹
        """
        if not ALLURE_AVAILABLE or not changes:
            return

        with allure.step(f"  âš™ï¸ {interceptor_name}"):
            allure.attach(
                json.dumps(changes, indent=2, ensure_ascii=False),
                name="Changes",
                attachment_type=allure.attachment_type.JSON
            )

    def on_http_request_end(
        self,
        request_id: str,
        response: 'Response',
        duration_ms: Optional[float] = None
    ) -> None:
        """HTTPè¯·æ±‚ç»“æŸ

        é™„åŠ å“åº”è¯¦æƒ…å¹¶å…³é—­step

        Args:
            request_id: è¯·æ±‚ID
            response: Responseå¯¹è±¡
            duration_ms: è¯·æ±‚è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
        """
        if not ALLURE_AVAILABLE:
            return

        # è®¡ç®—è€—æ—¶
        if duration_ms is None and self._request_start_time:
            duration_ms = (time.time() - self._request_start_time) * 1000

        # å“åº”è¯¦æƒ…
        response_details = {
            "request_id": request_id,
            "status_code": response.status_code,
            "headers": dict(response.headers) if response.headers else {},
            "body": response.body[:1000] if response.body else None,  # æˆªæ–­
            "duration_ms": round(duration_ms, 2) if duration_ms else None,
        }

        # æ ¹æ®çŠ¶æ€ç é€‰æ‹©emoji
        status_emoji = "âœ…" if 200 <= response.status_code < 300 else "âŒ"
        attachment_name = f"{status_emoji} Response ({response.status_code})"
        if duration_ms:
            attachment_name += f" - {round(duration_ms, 2)}ms"

        allure.attach(
            json.dumps(response_details, indent=2, ensure_ascii=False),
            name=attachment_name,
            attachment_type=allure.attachment_type.JSON
        )

        # å…³é—­å½“å‰step
        if self._current_step_context:
            self._current_step_context.__exit__(None, None, None)
            self._current_step_context = None
            self._current_request_id = None
            self._request_start_time = None

    def on_error(
        self,
        error: Exception,
        context: Dict[str, Any]
    ) -> None:
        """é”™è¯¯è®°å½•

        Args:
            error: å¼‚å¸¸å¯¹è±¡
            context: é”™è¯¯ä¸Šä¸‹æ–‡ä¿¡æ¯
        """
        if not ALLURE_AVAILABLE:
            return

        error_details = {
            "error_type": type(error).__name__,
            "error_message": str(error),
            "context": context
        }

        allure.attach(
            json.dumps(error_details, indent=2, ensure_ascii=False),
            name="âŒ Error",
            attachment_type=allure.attachment_type.JSON
        )


def get_current_observer() -> Optional[AllureObserver]:
    """è·å–å½“å‰æµ‹è¯•çš„Observer

    Returns:
        å½“å‰æµ‹è¯•çš„AllureObserverå®ä¾‹ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å›None
    """
    return _current_observer.get()


def set_current_observer(observer: Optional[AllureObserver]) -> None:
    """è®¾ç½®å½“å‰æµ‹è¯•çš„Observer

    Args:
        observer: AllureObserverå®ä¾‹æˆ–None
    """
    _current_observer.set(observer)


__all__ = [
    'AllureObserver',
    'get_current_observer',
    'set_current_observer',
    'ALLURE_AVAILABLE',
]
```

### 2.3 Pytest Fixtureï¼ˆé›¶é…ç½®ï¼‰

**æ–‡ä»¶ä½ç½®**: `src/df_test_framework/testing/fixtures/allure.py`

```python
"""Allureé›†æˆ - è‡ªåŠ¨è®°å½•æµ‹è¯•æ“ä½œåˆ°AllureæŠ¥å‘Š

é€šè¿‡ autouse fixture å®ç°é›¶é…ç½®
"""
import pytest
from typing import Generator, Optional

from ..observers.allure_observer import (
    AllureObserver,
    set_current_observer,
    ALLURE_AVAILABLE,
)

try:
    import allure
except ImportError:
    allure = None


@pytest.fixture(scope="function", autouse=True)
def _auto_allure_observer(request) -> Generator[Optional[AllureObserver], None, None]:
    """è‡ªåŠ¨å¯ç”¨Allureè§‚å¯Ÿè€…ï¼ˆé›¶é…ç½®ï¼‰

    autouse=True: å¯¹æ‰€æœ‰æµ‹è¯•è‡ªåŠ¨ç”Ÿæ•ˆ
    scope=function: æ¯ä¸ªæµ‹è¯•å‡½æ•°ç‹¬ç«‹çš„observer

    ç‰¹æ€§:
    - é›¶é…ç½®ï¼šæ— éœ€åœ¨æµ‹è¯•ä»£ç ä¸­æ‰‹åŠ¨å¯ç”¨
    - è‡ªåŠ¨è®°å½•ï¼šHTTPè¯·æ±‚ã€æ‹¦æˆªå™¨ã€æ•°æ®åº“æŸ¥è¯¢
    - é™é»˜ç»ˆç«¯ï¼šæµ‹è¯•é€šè¿‡æ—¶æ— é¢å¤–è¾“å‡º
    - è¯¦ç»†æŠ¥å‘Šï¼šAllure HTMLæŠ¥å‘ŠåŒ…å«å®Œæ•´è¯¦æƒ…

    ä½¿ç”¨åœºæ™¯:
        # æµ‹è¯•ä»£ç æ— éœ€ä»»ä½•ä¿®æ”¹ï¼Œè‡ªåŠ¨è®°å½•
        def test_create_user(http_client):
            response = http_client.post("/api/users", json={"name": "Alice"})
            assert response.status_code == 201

        # ç”ŸæˆæŠ¥å‘Š: pytest --alluredir=./allure-results
        # æŸ¥çœ‹æŠ¥å‘Š: allure serve ./allure-results
    """
    # å¦‚æœAllureä¸å¯ç”¨ï¼Œç›´æ¥è·³è¿‡
    if not ALLURE_AVAILABLE or allure is None:
        yield None
        return

    # åˆ›å»ºå½“å‰æµ‹è¯•çš„observer
    test_name = request.node.name
    observer = AllureObserver(test_name=test_name)

    # è®¾ç½®ä¸ºå½“å‰ä¸Šä¸‹æ–‡çš„observer
    set_current_observer(observer)

    # æ ‡è®°æµ‹è¯•å¼€å§‹ï¼ˆå¯é€‰ï¼Œç”¨äºAllureæŠ¥å‘Šä¸­çš„è§†è§‰åˆ†ç»„ï¼‰
    # æ³¨æ„ï¼šè¿™é‡Œä¸ç”¨withï¼Œå› ä¸ºæ•´ä¸ªæµ‹è¯•è¿‡ç¨‹å°±æ˜¯è¿™ä¸ªstep
    # with allure.step(f"ğŸ§ª Test: {test_name}"):
    #     yield observer

    yield observer

    # æµ‹è¯•ç»“æŸï¼Œæ¸…ç†
    set_current_observer(None)


__all__ = ['_auto_allure_observer']
```

### 2.4 HttpClienté›†æˆ

**ä¿®æ”¹æ–‡ä»¶**: `src/df_test_framework/clients/http/rest/httpx/client.py`

åœ¨`request()`æ–¹æ³•ä¸­æ·»åŠ Observeré›†æˆï¼š

```python
def request(
    self,
    method: str,
    url: str,
    **kwargs,
) -> httpx.Response:
    """å‘é€HTTPè¯·æ±‚ï¼ˆv3.5 Allureé›†æˆï¼‰

    v3.5æ–°å¢:
    - é›†æˆAllureObserverè‡ªåŠ¨è®°å½•è¯·æ±‚/å“åº”
    - æ‹¦æˆªå™¨æ‰§è¡Œè¿‡ç¨‹å¯è§
    """
    # âœ… v3.5: è·å–å½“å‰æµ‹è¯•çš„AllureObserver
    from .....testing.observers.allure_observer import get_current_observer
    observer = get_current_observer()

    # v3: Debugæ”¯æŒ (ä¿ç•™å‘åå…¼å®¹ï¼Œä½†å°†æ¥ä¼šåºŸå¼ƒ)
    from .....testing.debug.http_debugger import get_global_debugger
    debugger = get_global_debugger()

    # v3.5: åˆ›å»ºRequestå¯¹è±¡
    request_obj = Request(
        method=method,
        url=url,
        headers=kwargs.get('headers', {}),
        params=kwargs.get('params'),
        json=kwargs.get('json'),
        data=kwargs.get('data'),
    )

    # âœ… v3.5: è®°å½•è¯·æ±‚å¼€å§‹ï¼ˆåˆ›å»ºAllure stepï¼‰
    request_id = None
    if observer:
        request_id = observer.on_http_request_start(request_obj)

    # v3.5: æ‰§è¡Œbefore_requestæ‹¦æˆªå™¨é“¾ï¼ˆä¼ é€’request_idå’Œobserverï¼‰
    start_time = time.time()
    try:
        modified_request = self.interceptor_chain.execute_before_request(
            request_obj,
            request_id=request_id,  # âœ… ä¼ é€’ç»™æ‹¦æˆªå™¨é“¾
            observer=observer,       # âœ… ä¼ é€’observer
        )
        if modified_request:
            request_obj = modified_request
    except Exception as e:
        # âœ… v3.5: è®°å½•é”™è¯¯åˆ°Allure
        if observer:
            observer.on_error(e, {"stage": "before_request", "request_id": request_id})
        # æ‰§è¡Œæ‹¦æˆªå™¨é“¾çš„é”™è¯¯å¤„ç†
        self.interceptor_chain.execute_on_error(e, request_obj)
        raise

    # v3.5: å°†Requestå¯¹è±¡è½¬å›kwargs
    kwargs['headers'] = dict(request_obj.headers) if request_obj.headers else {}
    if request_obj.params:
        kwargs['params'] = dict(request_obj.params)
    if request_obj.json:
        kwargs['json'] = request_obj.json
    if request_obj.data:
        kwargs['data'] = request_obj.data

    # è¯·æ±‚æ—¥å¿—ï¼ˆè„±æ•æ•æ„Ÿä¿¡æ¯ï¼‰
    sanitized_url = sanitize_url(request_obj.url)
    logger.info(f"[{request_obj.method}] {sanitized_url}")
    # ... (çœç•¥æ—¥å¿—ä»£ç )

    # v3: è®°å½•è¯·æ±‚å¼€å§‹ (HTTPDebuggerï¼Œä¿ç•™å‘åå…¼å®¹)
    if debugger:
        debugger.log_request(
            method=request_obj.method,
            url=request_obj.url,
            headers=request_obj.headers,
            body=request_obj.json or request_obj.data,
            params=request_obj.params
        )

    # å®ç°é‡è¯•é€»è¾‘
    last_exception = None
    for attempt in range(self.max_retries + 1):
        try:
            # å‘é€è¯·æ±‚
            httpx_response = self.client.request(method, url, **kwargs)

            # å“åº”æ—¥å¿—
            logger.info(f"Response Status: {httpx_response.status_code}")
            logger.debug(f"Response Body: {httpx_response.text[:500]}")

            # æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¯• (5xxæœåŠ¡å™¨é”™è¯¯)
            if httpx_response.status_code >= 500 and attempt < self.max_retries:
                logger.warning(
                    f"æœåŠ¡å™¨é”™è¯¯ {httpx_response.status_code}, "
                    f"é‡è¯• {attempt + 1}/{self.max_retries}"
                )
                wait_time = 2 ** attempt
                time.sleep(wait_time)
                continue

            # v3.5: åˆ›å»ºResponseå¯¹è±¡å¹¶æ‰§è¡Œafter_responseæ‹¦æˆªå™¨é“¾
            json_data = None
            try:
                if httpx_response.headers.get('content-type', '').startswith('application/json'):
                    json_data = httpx_response.json()
            except Exception:
                pass

            response_obj = Response(
                status_code=httpx_response.status_code,
                headers=dict(httpx_response.headers),
                body=httpx_response.text,
                json_data=json_data,
            )

            try:
                modified_response = self.interceptor_chain.execute_after_response(response_obj)
                if modified_response:
                    response_obj = modified_response
            except Exception as e:
                # after_responseé”™è¯¯å¤„ç†
                self.interceptor_chain.execute_on_error(e, request_obj)
                logger.warning(f"[HttpClient] after_responseæ‹¦æˆªå™¨å¤±è´¥: {e}")

            # âœ… v3.5: è®°å½•å“åº”ç»“æŸ
            if observer and request_id:
                duration_ms = (time.time() - start_time) * 1000
                observer.on_http_request_end(request_id, response_obj, duration_ms)

            # v3: è®°å½•æœ€ç»ˆå“åº”(HTTPDebuggerï¼Œä¿ç•™å‘åå…¼å®¹)
            if debugger:
                debugger.log_response(
                    status_code=httpx_response.status_code,
                    headers=dict(httpx_response.headers),
                    body=httpx_response.text
                )

            return httpx_response

        except httpx.TimeoutException as e:
            last_exception = e
            if attempt < self.max_retries:
                wait_time = 2 ** attempt
                logger.warning(
                    f"è¯·æ±‚è¶…æ—¶, é‡è¯• {attempt + 1}/{self.max_retries}, "
                    f"ç­‰å¾… {wait_time}s"
                )
                time.sleep(wait_time)
                continue
            else:
                # âœ… v3.5: è®°å½•è¶…æ—¶é”™è¯¯
                if observer:
                    observer.on_error(e, {
                        "stage": "request",
                        "request_id": request_id,
                        "attempt": attempt + 1
                    })
                logger.error(f"è¯·æ±‚è¶…æ—¶ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•° {self.max_retries}")
                raise

        except Exception as e:
            # âœ… v3.5: è®°å½•å…¶ä»–é”™è¯¯
            if observer:
                observer.on_error(e, {
                    "stage": "request",
                    "request_id": request_id,
                    "attempt": attempt + 1
                })
            raise

    # ä¸åº”è¯¥åˆ°è¿™é‡Œ
    if last_exception:
        raise last_exception
```

### 2.5 InterceptorChainé›†æˆ

**ä¿®æ”¹æ–‡ä»¶**: `src/df_test_framework/clients/http/core/chain.py`

ä¿®æ”¹`execute_before_request()`æ–¹æ³•ï¼š

```python
def execute_before_request(
    self,
    request: Request,
    request_id: Optional[str] = None,  # âœ… v3.5: æ–°å¢å‚æ•°
    observer: Optional['AllureObserver'] = None,  # âœ… v3.5: æ–°å¢å‚æ•°
) -> Request:
    """æ‰§è¡Œæ‰€æœ‰before_requesté’©å­ï¼ˆv3.5 Allureé›†æˆï¼‰

    v3.5æ–°å¢:
    - æ”¯æŒä¼ å…¥request_idå’Œobserver
    - è‡ªåŠ¨è®°å½•æ‹¦æˆªå™¨ä¿®æ”¹åˆ°AllureæŠ¥å‘Š

    Args:
        request: åŸå§‹è¯·æ±‚å¯¹è±¡
        request_id: è¯·æ±‚IDï¼ˆå¯é€‰ï¼Œç”¨äºAllureå…³è”ï¼‰
        observer: Allureè§‚å¯Ÿè€…ï¼ˆå¯é€‰ï¼‰

    Returns:
        å¤„ç†åçš„è¯·æ±‚å¯¹è±¡

    Raises:
        InterceptorAbort: æ‹¦æˆªå™¨ä¸»åŠ¨ç»ˆæ­¢è¯·æ±‚
    """
    current_request = request

    for interceptor in self.interceptors:
        try:
            # è®°å½•æ‹¦æˆªå™¨å¼€å§‹æ‰§è¡Œï¼ˆä»…å½“observerå­˜åœ¨æ—¶ï¼‰
            request_before = current_request

            # æ‰§è¡Œæ‹¦æˆªå™¨
            modified_request = interceptor.before_request(current_request)
            if modified_request is not None:
                current_request = modified_request

            # âœ… v3.5: è®°å½•æ‹¦æˆªå™¨ä¿®æ”¹ï¼ˆå¦‚æœæœ‰å˜åŒ–ï¼‰
            if observer and request_id and modified_request:
                changes = self._diff_request(request_before, modified_request)
                if changes:
                    observer.on_interceptor_execute(
                        request_id,
                        interceptor.name,
                        changes
                    )

            logger.debug(
                f"[æ‹¦æˆªå™¨] {interceptor.name} (priority={interceptor.priority}) "
                f"æ‰§è¡ŒæˆåŠŸ"
            )

        except InterceptorAbort as e:
            logger.warning(
                f"[æ‹¦æˆªå™¨] {interceptor.name} ä¸»åŠ¨ç»ˆæ­¢è¯·æ±‚: {e}"
            )
            raise

        except Exception as e:
            # âœ… v3.5: è®°å½•æ‹¦æˆªå™¨é”™è¯¯åˆ°Allure
            if observer:
                observer.on_error(e, {
                    "interceptor": interceptor.name,
                    "request_id": request_id
                })
            logger.error(
                f"[æ‹¦æˆªå™¨] {interceptor.name} æ‰§è¡Œå¤±è´¥: {e}",
                exc_info=True
            )
            # é»˜è®¤å®¹é”™ï¼šç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨

    return current_request

def _diff_request(self, before: Request, after: Request) -> Dict[str, Any]:
    """å¯¹æ¯”ä¸¤ä¸ªRequestï¼Œè¿”å›å˜åŒ–çš„å­—æ®µ

    ç”¨äºAllureæŠ¥å‘Šå±•ç¤ºæ‹¦æˆªå™¨åšäº†ä»€ä¹ˆä¿®æ”¹

    Args:
        before: ä¿®æ”¹å‰çš„Request
        after: ä¿®æ”¹åçš„Request

    Returns:
        å˜åŒ–çš„å­—æ®µå­—å…¸
    """
    changes = {}

    # å¯¹æ¯”headers
    if before.headers != after.headers:
        added = {k: v for k, v in after.headers.items()
                 if k not in before.headers}
        modified = {k: v for k, v in after.headers.items()
                    if k in before.headers and before.headers[k] != v}

        if added or modified:
            changes['headers'] = {}
            if added:
                changes['headers']['added'] = added
            if modified:
                changes['headers']['modified'] = modified

    # å¯¹æ¯”params
    if before.params != after.params:
        changes['params'] = {
            'before': before.params,
            'after': after.params
        }

    # å¯¹æ¯”json/data
    if before.json != after.json:
        changes['json'] = {
            'before': before.json,
            'after': after.json
        }

    if before.data != after.data:
        changes['data'] = {
            'before': before.data,
            'after': after.data
        }

    return changes
```

---

## ä¸‰ã€ä½¿ç”¨ç¤ºä¾‹

### 3.1 é›¶é…ç½®ä½¿ç”¨

**æµ‹è¯•ä»£ç **ï¼ˆæ— éœ€ä»»ä½•ä¿®æ”¹ï¼‰:
```python
def test_create_user(http_client):
    """åˆ›å»ºç”¨æˆ· - å®Œå…¨é›¶é…ç½®"""
    response = http_client.post("/api/users", json={"name": "Alice"})
    assert response.status_code == 201
```

**è¿è¡Œæµ‹è¯•**:
```bash
# ç”ŸæˆAllureç»“æœ
pytest tests/test_api.py --alluredir=./allure-results

# æŸ¥çœ‹æŠ¥å‘Š
allure serve ./allure-results
```

**ç»ˆç«¯è¾“å‡º**ï¼ˆé™é»˜ï¼‰:
```
tests/test_api.py::test_create_user PASSED [100%]
```

**AllureæŠ¥å‘Š**ï¼ˆè¯¦ç»†ï¼‰:
```
ğŸ§ª Test: test_create_user
  â””â”€ ğŸŒ POST /api/users
      â”œâ”€ ğŸ“¤ Request Details
      â”‚   {
      â”‚     "request_id": "req-001",
      â”‚     "method": "POST",
      â”‚     "url": "/api/users",
      â”‚     "json": {"name": "Alice"}
      â”‚   }
      â”œâ”€ âš™ï¸ SignatureInterceptor
      â”‚   â””â”€ Changes
      â”‚       {
      â”‚         "headers": {
      â”‚           "added": {"X-Sign": "md5_abc123..."}
      â”‚         }
      â”‚       }
      â”œâ”€ âš™ï¸ TokenInterceptor
      â”‚   â””â”€ Changes
      â”‚       {
      â”‚         "headers": {
      â”‚           "added": {"Authorization": "Bearer tok..."}
      â”‚         }
      â”‚       }
      â””â”€ âœ… Response (201) - 145.23ms
          {
            "request_id": "req-001",
            "status_code": 201,
            "body": "{\"id\": 123, \"name\": \"Alice\"}"
          }
```

### 3.2 æµ‹è¯•å¤±è´¥æ—¶

**æµ‹è¯•ä»£ç **:
```python
def test_create_duplicate_user(http_client):
    response = http_client.post("/api/users", json={"email": "duplicate@example.com"})
    assert response.status_code == 201  # å®é™…è¿”å›400
```

**ç»ˆç«¯è¾“å‡º**:
```
tests/test_api.py::test_create_duplicate_user FAILED [100%]

E   AssertionError: assert 400 == 201
```

**AllureæŠ¥å‘Š**ï¼ˆè‡ªåŠ¨å±•å¼€æ‰€æœ‰è¯¦æƒ…ï¼‰:
```
ğŸ§ª Test: test_create_duplicate_user âŒ
  â””â”€ ğŸŒ POST /api/users
      â”œâ”€ ğŸ“¤ Request Details
      â”œâ”€ âš™ï¸ SignatureInterceptor
      â”œâ”€ âš™ï¸ TokenInterceptor
      â””â”€ âŒ Response (400) - 89.45ms
          {
            "status_code": 400,
            "body": "{\"error\": \"Email already exists\"}"
          }
```

### 3.3 å¤æ‚åœºæ™¯ï¼šå¤šæ­¥éª¤æµ‹è¯•

```python
def test_user_lifecycle(http_client):
    """ç”¨æˆ·ç”Ÿå‘½å‘¨æœŸæµ‹è¯• - è‡ªåŠ¨è®°å½•æ‰€æœ‰æ­¥éª¤"""

    # Step 1: åˆ›å»ºç”¨æˆ·
    create_resp = http_client.post("/api/users", json={"name": "Bob"})
    assert create_resp.status_code == 201
    user_id = create_resp.json()["id"]

    # Step 2: è·å–ç”¨æˆ·
    get_resp = http_client.get(f"/api/users/{user_id}")
    assert get_resp.status_code == 200

    # Step 3: æ›´æ–°ç”¨æˆ·
    update_resp = http_client.put(
        f"/api/users/{user_id}",
        json={"name": "Bob Updated"}
    )
    assert update_resp.status_code == 200

    # Step 4: åˆ é™¤ç”¨æˆ·
    delete_resp = http_client.delete(f"/api/users/{user_id}")
    assert delete_resp.status_code == 204
```

**AllureæŠ¥å‘Š**ï¼ˆè‡ªåŠ¨å±•ç¤ºå®Œæ•´æµç¨‹ï¼‰:
```
ğŸ§ª Test: test_user_lifecycle
  â”œâ”€ ğŸŒ POST /api/users (req-001)
  â”‚   â”œâ”€ ğŸ“¤ Request Details
  â”‚   â”œâ”€ âš™ï¸ SignatureInterceptor
  â”‚   â””â”€ âœ… Response (201) - 145ms
  â”œâ”€ ğŸŒ GET /api/users/123 (req-002)
  â”‚   â””â”€ âœ… Response (200) - 67ms
  â”œâ”€ ğŸŒ PUT /api/users/123 (req-003)
  â”‚   â””â”€ âœ… Response (200) - 89ms
  â””â”€ ğŸŒ DELETE /api/users/123 (req-004)
      â””â”€ âœ… Response (204) - 45ms
```

---

## å››ã€å®æ–½è®¡åˆ’

### Phase 2: Allureé›†æˆå®æ–½ï¼ˆ2å¤©ï¼‰

#### Day 1: æ ¸å¿ƒå®ç°ï¼ˆ6å°æ—¶ï¼‰

**ä¸Šåˆï¼ˆ3å°æ—¶ï¼‰**:
- [ ] Task 2.1: åˆ›å»º`AllureObserver`ç±»
  - æ–‡ä»¶: `src/df_test_framework/testing/observers/__init__.py`
  - æ–‡ä»¶: `src/df_test_framework/testing/observers/allure_observer.py`
  - å®ç°`on_http_request_start/end`
  - å®ç°`on_interceptor_execute`
  - å®ç°`on_error`
  - å®ç°`get_current_observer/set_current_observer`

**ä¸‹åˆï¼ˆ3å°æ—¶ï¼‰**:
- [ ] Task 2.2: åˆ›å»ºpytest fixture
  - æ–‡ä»¶: `src/df_test_framework/testing/fixtures/allure.py`
  - å®ç°`_auto_allure_observer` autouse fixture
  - é›†æˆContextVarç®¡ç†
  - æ·»åŠ Allureå¯ç”¨æ€§æ£€æµ‹

- [ ] Task 2.3: HttpClienté›†æˆ
  - ä¿®æ”¹: `src/df_test_framework/clients/http/rest/httpx/client.py`
  - åœ¨`request()`æ–¹æ³•ä¸­æ·»åŠ Observerè°ƒç”¨
  - ä¼ é€’`request_id`å’Œ`observer`ç»™æ‹¦æˆªå™¨é“¾
  - å¤„ç†é”™è¯¯è®°å½•

#### Day 2: æ‹¦æˆªå™¨é“¾é›†æˆä¸æµ‹è¯•ï¼ˆ6å°æ—¶ï¼‰

**ä¸Šåˆï¼ˆ2å°æ—¶ï¼‰**:
- [ ] Task 2.4: InterceptorChainé›†æˆ
  - ä¿®æ”¹: `src/df_test_framework/clients/http/core/chain.py`
  - ä¿®æ”¹`execute_before_request()`ç­¾å
  - å®ç°`_diff_request()`å¯¹æ¯”é€»è¾‘
  - è°ƒç”¨`observer.on_interceptor_execute()`

**ä¸‹åˆï¼ˆ4å°æ—¶ï¼‰**:
- [ ] Task 2.5: é›†æˆæµ‹è¯•
  - åˆ›å»º: `tests/test_allure_integration.py`
  - æµ‹è¯•é›¶é…ç½®è‡ªåŠ¨è®°å½•
  - æµ‹è¯•æ‹¦æˆªå™¨å¯è§æ€§
  - æµ‹è¯•é”™è¯¯å¤„ç†
  - ç”ŸæˆAllureæŠ¥å‘ŠéªŒè¯

- [ ] Task 2.6: æ–‡æ¡£æ›´æ–°
  - æ›´æ–°: `README.md`
  - åˆ›å»º: `docs/ALLURE_USAGE.md`
  - æ·»åŠ ä½¿ç”¨ç¤ºä¾‹
  - æ·»åŠ æˆªå›¾

### éªŒæ”¶æ ‡å‡†

- âœ… é›¶é…ç½®å³å¯ä½¿ç”¨ï¼ˆæ— éœ€ä¿®æ”¹æµ‹è¯•ä»£ç ï¼‰
- âœ… æ‹¦æˆªå™¨æ‰§è¡Œè¿‡ç¨‹å¯è§ï¼ˆAllureæŠ¥å‘Šä¸­æœ‰sub-stepsï¼‰
- âœ… ç»ˆç«¯é™é»˜ï¼ˆæµ‹è¯•é€šè¿‡æ—¶æ— é¢å¤–è¾“å‡ºï¼‰
- âœ… AllureæŠ¥å‘Šå®Œæ•´ï¼ˆåŒ…å«è¯·æ±‚/å“åº”/æ‹¦æˆªå™¨/é”™è¯¯ï¼‰
- âœ… æ‰€æœ‰ç°æœ‰æµ‹è¯•é€šè¿‡ï¼ˆ317ä¸ªæµ‹è¯•ï¼‰
- âœ… å‘åå…¼å®¹ï¼ˆHTTPDebuggerä¿ç•™ä½†æ ‡è®°ä¸ºdeprecatedï¼‰

---

## äº”ã€ä¸æ—§æ–¹æ¡ˆå¯¹æ¯”

| ç‰¹æ€§ | HTTPDebuggerï¼ˆæ—§ï¼‰ | AllureObserverï¼ˆæ–°ï¼‰ |
|------|-------------------|---------------------|
| **é…ç½®æ–¹å¼** | éœ€è¦æ‰‹åŠ¨`start()`/`stop()` | âœ… é›¶é…ç½®ï¼ˆautouse fixtureï¼‰ |
| **è¾“å‡ºä½ç½®** | ç»ˆç«¯ï¼ˆæ··ä¹±ï¼‰ | âœ… Allure HTMLæŠ¥å‘Šï¼ˆå¯è§†åŒ–ï¼‰ |
| **æ‹¦æˆªå™¨å¯è§** | âŒ ä¸å¯è§ | âœ… æ¯ä¸ªæ‹¦æˆªå™¨éƒ½æœ‰sub-step |
| **ç»ˆç«¯é™é»˜** | âŒ å¤§é‡è¾“å‡º | âœ… æµ‹è¯•é€šè¿‡æ—¶é™é»˜ |
| **å¯è§†åŒ–** | âŒ çº¯æ–‡æœ¬ | âœ… HTMLæŠ¥å‘Š+Timeline |
| **CIé›†æˆ** | âŒ å›°éš¾ | âœ… åŸç”Ÿæ”¯æŒï¼ˆJenkins/GitLabï¼‰ |
| **è¡Œä¸šæ ‡å‡†** | âŒ è‡ªå®šä¹‰ | âœ… Allureï¼ˆä¸šç•Œæ ‡å‡†ï¼‰ |

---

## å…­ã€æœªæ¥æ‰©å±•

### 6.1 å…¶ä»–Observer

- `DatabaseObserver` - æ•°æ®åº“æŸ¥è¯¢è¿½è¸ªï¼ˆSQLã€å‚æ•°ã€è€—æ—¶ï¼‰
- `RedisObserver` - Redisæ“ä½œè¿½è¸ª
- `MessageQueueObserver` - æ¶ˆæ¯é˜Ÿåˆ—è¿½è¸ª

### 6.2 é«˜çº§åŠŸèƒ½

- æ€§èƒ½åˆ†æï¼ˆæ‹¦æˆªå™¨å¼€é”€ã€ç½‘ç»œå¼€é”€ï¼‰
- è¯·æ±‚é—´å…³è”åˆ†æï¼ˆå¦‚tokenä¼ é€’é“¾è·¯ï¼‰
- å¯¼å‡ºè°ƒè¯•æ—¥å¿—ï¼ˆJSON/CSVæ ¼å¼ï¼‰
- é›†æˆåˆ°CIæŠ¥å‘Šï¼ˆJenkins/GitLab CIï¼‰

---

**æ€»ç»“**: æ–°çš„Allureé›†æˆæ–¹æ¡ˆæä¾›**é›¶é…ç½®ã€è¡Œä¸šæ ‡å‡†ã€å¯è§†åŒ–**çš„ç°ä»£åŒ–æµ‹è¯•è°ƒè¯•ä½“éªŒï¼Œå®Œç¾é€‚é…v3.5æ¶æ„ã€‚
