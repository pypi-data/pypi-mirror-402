# v3.5 é‡æ„æ–¹æ¡ˆï¼ˆä¿®æ­£ç‰ˆï¼‰

> **çŠ¶æ€**: âœ… **å…¨éƒ¨å®Œæˆ** (Phase 1-3å®Œæˆï¼ŒPhase 4æ–‡æ¡£æ›´æ–°ä¸­)
> **å¼€å§‹æ—¥æœŸ**: 2025-11-07
> **é¢„è®¡å·¥ä½œé‡**: 7-11å¤©
> **æœ€åæ›´æ–°**: 2025-11-07 (Phase 1-3å®Œæˆï¼Œé…ç½®APIå¢å¼ºä¸Šçº¿)

---

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦

### æ ¸å¿ƒé—®é¢˜

ç»è¿‡æ·±åº¦ä»£ç å®¡æŸ¥å’Œå®é™…ä½¿ç”¨åé¦ˆï¼Œè¯†åˆ«å‡ºä»¥ä¸‹**ä¸¥é‡å½±å“ç”¨æˆ·ä½“éªŒ**çš„é—®é¢˜ï¼š

1. ğŸ”´ **æ‹¦æˆªå™¨æ¶æ„åŒè½¨åˆ¶**
   - å­˜åœ¨InterceptorChainè®¾è®¡ä½“ç³»ï¼ˆå·²å®ç°ä½†æœªä½¿ç”¨ï¼‰
   - HttpClientå®é™…ä½¿ç”¨List[Callable]ï¼ˆåŠŸèƒ½å—é™ï¼‰
   - InterceptorFactoryåšé™çº§è½¬æ¢ï¼ˆä¸¢å¤±after_response/on_errorï¼‰

2. ğŸ”´ **å¯è§‚æµ‹æ€§æ··ä¹±**
   - ä¸‰å¥—æ—¥å¿—ç³»ç»Ÿå¹¶å­˜ï¼ˆLoguru + HTTP DEBUG + DB DEBUGï¼‰
   - æ‹¦æˆªå™¨æ—¥å¿—è¿‡äºå•°å—¦
   - è°ƒè¯•ä¿¡æ¯é‡å¤ä¸”ä¸å®Œæ•´

3. ğŸŸ¡ **é…ç½®APIç¼ºå¤±**
   - Profileæœºåˆ¶å­˜åœ¨ä½†æ— APIè°ƒç”¨
   - ç¼ºå°‘è¿è¡Œæ—¶è¦†ç›–èƒ½åŠ›

### è§£å†³æ–¹æ¡ˆ

**v3.5ä¿®æ­£ç‰ˆ**ï¼šèšç„¦æ ¸å¿ƒé—®é¢˜ï¼Œé¿å…è¿‡åº¦è®¾è®¡

| é˜¶æ®µ | ä»»åŠ¡ | å·¥ä½œé‡ | ä¼˜å…ˆçº§ |
|------|------|--------|--------|
| Phase 1 | æ‹¦æˆªå™¨ä½“ç³»ç»Ÿä¸€ | 3-4å¤© | ğŸ”´ P0 |
| Phase 2 | ç»Ÿä¸€å¯è§‚æµ‹æ€§ | 2-3å¤© | ğŸ”´ P0 |
| Phase 3 | é…ç½®APIå¢å¼º | 1-2å¤© | ğŸŸ¡ P1 |
| Phase 4 | æ–‡æ¡£å’Œæµ‹è¯• | 1å¤© | ğŸŸ¡ P1 |
| **æ€»è®¡** | **æ ¸å¿ƒä»»åŠ¡** | **7-10å¤©** | - |
| (å¯é€‰) | OpenTelemetryé›†æˆ | 1-2å¤© | ğŸŸ¢ P2 |

---

## ğŸ¯ Phase 1: æ‹¦æˆªå™¨ä½“ç³»ç»Ÿä¸€ (3-4å¤©)

### èƒŒæ™¯

**å½“å‰é—®é¢˜**ï¼š
```python
# âŒ å­˜åœ¨ä¸¤å¥—ä½“ç³»

# 1. è®¾è®¡è‰¯å¥½ä½†æœªä½¿ç”¨ï¼š
src/df_test_framework/clients/http/core/
â”œâ”€â”€ interceptor.py       # Interceptoråè®®ï¼ˆbefore/after/on_errorï¼‰
â”œâ”€â”€ chain.py            # InterceptorChainï¼ˆè´£ä»»é“¾æ¨¡å¼ï¼‰
â””â”€â”€ request.py/response.py  # ä¸å¯å˜å¯¹è±¡

# 2. å®é™…è¿è¡Œï¼š
client.py:97
self.request_interceptors: List[Callable]  # âŒ å‡½æ•°åˆ—è¡¨

# 3. è½¬æ¢å±‚ï¼š
factory.py:45
def create(...) -> Optional[Callable]:  # âŒ è¿”å›Callableï¼Œä¸¢å¤±after/on_error
```

**å½±å“**ï¼š
- æ— æ³•å®ç°å“åº”æ‹¦æˆªå™¨ï¼ˆå¦‚æ—¥å¿—è®°å½•ï¼‰
- æ— æ³•å®ç°ç»Ÿä¸€é”™è¯¯å¤„ç†
- ä»£ç æµªè´¹ï¼ˆInterceptorChainå·²å®ç°ä½†é—²ç½®ï¼‰

---

### Task 1.1: é‡æ„InterceptorFactoryè¿”å›ç±»å‹ (1å¤©)

**ç›®æ ‡**ï¼šFactoryç›´æ¥è¿”å›Interceptorå®ä¾‹ï¼Œä¸åšé™çº§è½¬æ¢

#### å®æ–½æ­¥éª¤

**æ–‡ä»¶**: `src/df_test_framework/clients/http/interceptors/factory.py`

```python
class InterceptorFactory:
    """æ‹¦æˆªå™¨å·¥å‚ - é‡æ„åç‰ˆæœ¬"""

    @staticmethod
    def create(config: InterceptorConfig) -> Optional[Interceptor]:  # âœ… è¿”å›Interceptor
        """æ ¹æ®é…ç½®åˆ›å»ºæ‹¦æˆªå™¨å®ä¾‹

        Returns:
            Interceptorå®ä¾‹ï¼ˆè€ŒéCallableï¼‰
        """
        if not config.enabled:
            return None

        # åˆ›å»ºæ‹¦æˆªå™¨å®ä¾‹
        if isinstance(config, SignatureInterceptorConfig):
            return SignatureInterceptor(
                algorithm=config.algorithm,
                secret=config.secret,
                header_name=config.header_name,
                include_query=config.include_query_params,
                include_body=config.include_json_body,
                include_form=config.include_form_data,
                priority=config.priority,
            )

        elif isinstance(config, TokenInterceptorConfig):
            return TokenInterceptor(
                token=config.token,
                token_type=config.token_type,
                header_name=config.header_name,
                priority=config.priority,
            )

        elif isinstance(config, BearerTokenInterceptorConfig):
            return BearerTokenInterceptor(
                token_source=config.token_source,
                static_token=config.static_token,
                login_url=config.login_url,
                login_credentials=config.login_credentials,
                token_field_path=config.token_field_path,
                env_var_name=config.env_var_name,
                header_name=config.header_name,
                token_prefix=config.token_prefix,
                priority=config.priority,
            )

        elif isinstance(config, CustomInterceptorConfig):
            # åŠ¨æ€å¯¼å…¥è‡ªå®šä¹‰æ‹¦æˆªå™¨
            module_path, class_name = config.class_path.rsplit(".", 1)
            module = importlib.import_module(module_path)
            interceptor_class = getattr(module, class_name)
            return interceptor_class(**config.params)

        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æ‹¦æˆªå™¨ç±»å‹: {config.type}")
```

**å…³é”®å˜åŒ–**ï¼š
- âœ… è¿”å›ç±»å‹ä»`Callable`æ”¹ä¸º`Interceptor`
- âœ… ç§»é™¤`path_aware_interceptor`åŒ…è£…å‡½æ•°
- âœ… è·¯å¾„åŒ¹é…é€»è¾‘ç§»åˆ°ä¸‹ä¸€æ­¥å¤„ç†

**æµ‹è¯•**ï¼š
```bash
# æ›´æ–°æµ‹è¯•
uv run pytest tests/test_interceptors_config.py::TestInterceptorFactory -v
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Task 1.2: å®ç°è·¯å¾„è¿‡æ»¤æ‹¦æˆªå™¨åŒ…è£…å™¨ (åŠå¤©)

**ç›®æ ‡**ï¼šå°†è·¯å¾„åŒ¹é…é€»è¾‘å°è£…ä¸ºæ‹¦æˆªå™¨åŒ…è£…å™¨

#### å®æ–½æ­¥éª¤

**æ–‡ä»¶**: `src/df_test_framework/clients/http/core/interceptor.py`

```python
class PathFilteredInterceptor(BaseInterceptor):
    """è·¯å¾„è¿‡æ»¤æ‹¦æˆªå™¨åŒ…è£…å™¨

    åŒ…è£…ä»»æ„æ‹¦æˆªå™¨ï¼Œæ·»åŠ è·¯å¾„åŒ¹é…é€»è¾‘

    Example:
        >>> inner = SignatureInterceptor(...)
        >>> config = SignatureInterceptorConfig(
        ...     include_paths=["/api/**"],
        ...     exclude_paths=["/api/health"]
        ... )
        >>> wrapped = PathFilteredInterceptor(inner, config)
        >>> chain.add(wrapped)
    """

    def __init__(
        self,
        inner: Interceptor,
        config: InterceptorConfig,
    ):
        """åˆå§‹åŒ–è·¯å¾„è¿‡æ»¤åŒ…è£…å™¨

        Args:
            inner: è¢«åŒ…è£…çš„æ‹¦æˆªå™¨å®ä¾‹
            config: æ‹¦æˆªå™¨é…ç½®ï¼ˆåŒ…å«è·¯å¾„è§„åˆ™ï¼‰
        """
        super().__init__(
            name=f"PathFiltered({inner.name})",
            priority=inner.priority,
        )
        self.inner = inner
        self.config = config

    def before_request(self, request: Request) -> Optional[Request]:
        """beforeé’©å­ - å¸¦è·¯å¾„è¿‡æ»¤"""
        # æ£€æŸ¥è·¯å¾„æ˜¯å¦åŒ¹é…
        if not self.config.should_apply(request.path):
            # è·¯å¾„ä¸åŒ¹é…ï¼Œè·³è¿‡
            return None

        # è°ƒç”¨å†…éƒ¨æ‹¦æˆªå™¨
        return self.inner.before_request(request)

    def after_response(self, response: Response) -> Optional[Response]:
        """afteré’©å­ - å¸¦è·¯å¾„è¿‡æ»¤"""
        # afteré’©å­ä¸æ£€æŸ¥è·¯å¾„ï¼ˆå› ä¸ºbeforeå·²æ£€æŸ¥è¿‡ï¼‰
        return self.inner.after_response(response)

    def on_error(self, error: Exception, request: Request) -> None:
        """é”™è¯¯é’©å­"""
        self.inner.on_error(error, request)
```

**å¯¼å‡º**ï¼š
```python
# src/df_test_framework/clients/http/core/__init__.py
from .interceptor import BaseInterceptor, PathFilteredInterceptor
```

**æµ‹è¯•**ï¼š
```python
# tests/clients/http/core/test_path_filtered_interceptor.py
def test_path_filtered_interceptor_apply():
    """æµ‹è¯•è·¯å¾„åŒ¹é…æ—¶è°ƒç”¨å†…éƒ¨æ‹¦æˆªå™¨"""
    inner = Mock(spec=Interceptor)
    inner.before_request.return_value = None

    config = Mock()
    config.should_apply.return_value = True

    wrapped = PathFilteredInterceptor(inner, config)
    request = Request(method="GET", url="/api/users", ...)

    wrapped.before_request(request)

    inner.before_request.assert_called_once_with(request)

def test_path_filtered_interceptor_skip():
    """æµ‹è¯•è·¯å¾„ä¸åŒ¹é…æ—¶è·³è¿‡"""
    inner = Mock(spec=Interceptor)
    config = Mock()
    config.should_apply.return_value = False

    wrapped = PathFilteredInterceptor(inner, config)
    request = Request(method="GET", url="/health", ...)

    result = wrapped.before_request(request)

    assert result is None
    inner.before_request.assert_not_called()
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Task 1.3: HttpClientæ¥å…¥InterceptorChain (2å¤©)

**ç›®æ ‡**ï¼šé‡æ„HttpClientä½¿ç”¨InterceptorChainï¼Œæ”¯æŒå®Œæ•´ç”Ÿå‘½å‘¨æœŸ

#### å®æ–½æ­¥éª¤

**æ–‡ä»¶**: `src/df_test_framework/clients/http/rest/httpx/client.py`

**1. åˆå§‹åŒ–æ‹¦æˆªå™¨é“¾**ï¼š
```python
from df_test_framework.clients.http.core import (
    InterceptorChain,
    Request,
    Response,
    PathFilteredInterceptor,
)
from df_test_framework.clients.http.interceptors import InterceptorFactory

class HttpClient:
    def __init__(
        self,
        base_url: str,
        timeout: int = 30,
        headers: Optional[Dict[str, str]] = None,
        verify_ssl: bool = True,
        max_retries: int = 3,
        max_connections: int = 50,
        max_keepalive_connections: int = 20,
        config: Optional["HTTPConfig"] = None,
    ):
        self.base_url = base_url
        self.timeout = timeout
        self.max_retries = max_retries

        # âœ… ä½¿ç”¨InterceptorChain
        self.interceptor_chain = InterceptorChain()

        # åˆ›å»ºhttpxå®¢æˆ·ç«¯
        self.client = httpx.Client(
            base_url=base_url,
            timeout=timeout,
            headers=headers or {},
            transport=httpx.HTTPTransport(verify=verify_ssl),
            limits=httpx.Limits(
                max_connections=max_connections,
                max_keepalive_connections=max_keepalive_connections,
            ),
            follow_redirects=True,
        )

        # âœ… ä»é…ç½®åŠ è½½æ‹¦æˆªå™¨
        if config and config.interceptors:
            self._load_interceptors_from_config(config.interceptors)

    def _load_interceptors_from_config(
        self,
        interceptor_configs: List["InterceptorConfig"]
    ) -> None:
        """ä»é…ç½®åŠ è½½æ‹¦æˆªå™¨åˆ°é“¾ä¸­"""
        logger.info(
            f"[HttpClient] å¼€å§‹åŠ è½½æ‹¦æˆªå™¨: count={len(interceptor_configs)}"
        )

        # æŒ‰ä¼˜å…ˆçº§æ’åº
        sorted_configs = sorted(
            interceptor_configs,
            key=lambda c: c.priority
        )

        for config in sorted_configs:
            try:
                # âœ… Factoryè¿”å›Interceptorå®ä¾‹
                interceptor = InterceptorFactory.create(config)
                if interceptor:
                    # âœ… åŒ…è£…è·¯å¾„è¿‡æ»¤é€»è¾‘
                    wrapped = PathFilteredInterceptor(interceptor, config)

                    # âœ… æ·»åŠ åˆ°é“¾
                    self.interceptor_chain.add(wrapped)

                    logger.debug(
                        f"[HttpClient] å·²åŠ è½½æ‹¦æˆªå™¨: "
                        f"type={config.type}, priority={config.priority}"
                    )
            except Exception as e:
                logger.error(
                    f"[HttpClient] åŠ è½½æ‹¦æˆªå™¨å¤±è´¥: "
                    f"type={config.type}, error={e}"
                )
                raise

        logger.info(
            f"[HttpClient] æ‹¦æˆªå™¨åŠ è½½å®Œæˆ: "
            f"total={len(self.interceptor_chain.interceptors)}"
        )
```

**2. é‡æ„requestæ–¹æ³•**ï¼š
```python
def request(
    self,
    method: str,
    url: str,
    **kwargs,
) -> httpx.Response:
    """å‘é€HTTPè¯·æ±‚ï¼ˆæ”¯æŒæ‹¦æˆªå™¨é“¾ï¼‰"""
    import time
    start_time = time.time()

    try:
        # âœ… 1. æ„é€ Requestå¯¹è±¡
        request = Request(
            method=method,
            url=url,
            headers=kwargs.get("headers", {}),
            params=kwargs.get("params", {}),
            json=kwargs.get("json"),
            data=kwargs.get("data"),
        )

        # âœ… 2. æ‰§è¡Œbefore_requesté’©å­
        try:
            request = self.interceptor_chain.execute_before_request(request)
        except InterceptorAbort as e:
            logger.warning(f"[HttpClient] è¯·æ±‚è¢«æ‹¦æˆªå™¨ç»ˆæ­¢: {e}")
            raise

        # âœ… 3. ä»Requestæå–å‚æ•°ï¼ˆæ‹¦æˆªå™¨å¯èƒ½ä¿®æ”¹äº†ï¼‰
        kwargs["headers"] = dict(request.headers)
        if request.params:
            kwargs["params"] = request.params
        if request.json:
            kwargs["json"] = request.json
        if request.data:
            kwargs["data"] = request.data

        # è¯·æ±‚æ—¥å¿—
        sanitized_url = sanitize_url(url)
        logger.info(f"[{method}] {sanitized_url}")

        # âœ… 4. å‘é€è¯·æ±‚ï¼ˆå¸¦é‡è¯•ï¼‰
        last_exception = None
        for attempt in range(self.max_retries + 1):
            try:
                raw_response = self.client.request(method, url, **kwargs)

                # æ£€æŸ¥5xxæ˜¯å¦éœ€è¦é‡è¯•
                if raw_response.status_code >= 500 and attempt < self.max_retries:
                    logger.warning(
                        f"æœåŠ¡å™¨é”™è¯¯ {raw_response.status_code}, "
                        f"é‡è¯• {attempt + 1}/{self.max_retries}"
                    )
                    wait_time = 2 ** attempt
                    time.sleep(wait_time)
                    continue

                # âœ… 5. æ„é€ Responseå¯¹è±¡
                duration_ms = (time.time() - start_time) * 1000
                response = Response(
                    status_code=raw_response.status_code,
                    headers=dict(raw_response.headers),
                    body=raw_response.text,
                    duration_ms=duration_ms,
                )

                # âœ… 6. æ‰§è¡Œafter_responseé’©å­
                response = self.interceptor_chain.execute_after_response(response)

                # å“åº”æ—¥å¿—
                logger.info(f"Response Status: {raw_response.status_code}")

                # âœ… 7. è¿”å›åŸå§‹httpx.Responseï¼ˆå‘åå…¼å®¹ï¼‰
                return raw_response

            except httpx.TimeoutException as e:
                last_exception = e
                if attempt < self.max_retries:
                    logger.warning(
                        f"è¯·æ±‚è¶…æ—¶, é‡è¯• {attempt + 1}/{self.max_retries}"
                    )
                    wait_time = 2 ** attempt
                    time.sleep(wait_time)
                    continue
                else:
                    # âœ… 8. æ‰§è¡Œon_erroré’©å­
                    self.interceptor_chain.execute_on_error(e, request)
                    raise

            except Exception as e:
                # âœ… æ‰§è¡Œon_erroré’©å­
                self.interceptor_chain.execute_on_error(e, request)
                raise

        if last_exception:
            raise last_exception

    except Exception as e:
        logger.error(f"[HttpClient] è¯·æ±‚å¤±è´¥: {e}")
        raise
```

**å…³é”®å˜åŒ–**ï¼š
- âœ… ä½¿ç”¨InterceptorChainæ›¿ä»£List[Callable]
- âœ… æ”¯æŒbefore_request / after_response / on_errorå®Œæ•´ç”Ÿå‘½å‘¨æœŸ
- âœ… ä¿æŒè¿”å›httpx.Responseï¼ˆå‘åå…¼å®¹ï¼‰
- âœ… æ‹¦æˆªå™¨å¯ä»¥ä¿®æ”¹è¯·æ±‚å‚æ•°

**æµ‹è¯•**ï¼š
```python
# tests/clients/http/test_client_interceptor_integration.py

def test_http_client_with_interceptor_chain():
    """æµ‹è¯•HttpClientä½¿ç”¨InterceptorChain"""
    config = HTTPConfig(
        base_url="http://test.example.com",
        interceptors=[
            SignatureInterceptorConfig(
                algorithm="md5",
                secret="test_secret",
                include_paths=["/api/**"],
            )
        ]
    )

    client = HttpClient(config=config)

    # éªŒè¯æ‹¦æˆªå™¨é“¾å·²åˆå§‹åŒ–
    assert len(client.interceptor_chain.interceptors) == 1

def test_interceptor_before_request():
    """æµ‹è¯•before_requestæ‹¦æˆªå™¨ä¿®æ”¹è¯·æ±‚"""
    # Mockæ‹¦æˆªå™¨
    mock_interceptor = Mock(spec=Interceptor)
    mock_interceptor.name = "TestInterceptor"
    mock_interceptor.priority = 100

    def mock_before(request):
        # æ·»åŠ è‡ªå®šä¹‰header
        request.headers["X-Custom"] = "test"
        return request

    mock_interceptor.before_request = mock_before

    client = HttpClient(base_url="http://test.com")
    client.interceptor_chain.add(mock_interceptor)

    with httpx.Client() as mock_client:
        client.client = mock_client
        response = client.get("/test")

        # éªŒè¯headerè¢«æ·»åŠ 
        assert "X-Custom" in response.request.headers

def test_interceptor_after_response():
    """æµ‹è¯•after_responseæ‹¦æˆªå™¨"""
    # TODO: å®ç°å“åº”æ‹¦æˆªå™¨æµ‹è¯•
    pass

def test_interceptor_on_error():
    """æµ‹è¯•on_erroré”™è¯¯å¤„ç†"""
    # TODO: å®ç°é”™è¯¯å¤„ç†æµ‹è¯•
    pass
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Task 1.4: è¡¥å……æ‹¦æˆªå™¨å®ä¾‹ (åŠå¤©)

**ç›®æ ‡**ï¼šç¡®ä¿æ‰€æœ‰æ‹¦æˆªå™¨ç±»å‹éƒ½å®ç°å®Œæ•´ç”Ÿå‘½å‘¨æœŸ

#### TokenInterceptorå®ç°

**æ–‡ä»¶**: `src/df_test_framework/clients/http/interceptors/auth/token.py`ï¼ˆæ–°å»ºï¼‰

```python
"""Tokenè®¤è¯æ‹¦æˆªå™¨"""

from typing import Optional
from df_test_framework.clients.http.core.interceptor import BaseInterceptor
from df_test_framework.clients.http.core.request import Request
from loguru import logger


class TokenInterceptor(BaseInterceptor):
    """Tokenè®¤è¯æ‹¦æˆªå™¨

    è‡ªåŠ¨ä¸ºè¯·æ±‚æ·»åŠ è®¤è¯Token

    Example:
        >>> interceptor = TokenInterceptor(
        ...     token="your_token",
        ...     token_type="Bearer",
        ...     header_name="Authorization",
        ... )
    """

    def __init__(
        self,
        token: str,
        token_type: str = "Bearer",
        header_name: str = "Authorization",
        priority: int = 50,
        name: str = None,
    ):
        super().__init__(name=name or "TokenInterceptor", priority=priority)
        self.token = token
        self.token_type = token_type
        self.header_name = header_name

    def before_request(self, request: Request) -> Optional[Request]:
        """æ·»åŠ Tokenåˆ°è¯·æ±‚å¤´"""
        token_value = f"{self.token_type} {self.token}" if self.token_type else self.token

        # æ·»åŠ è®¤è¯header
        request.headers[self.header_name] = token_value

        logger.debug(
            f"[TokenInterceptor] å·²æ·»åŠ è®¤è¯Header: "
            f"{self.header_name}={self.token_type} ****"
        )

        return request
```

#### BearerTokenInterceptorå®ç°

**æ–‡ä»¶**: `src/df_test_framework/clients/http/interceptors/auth/bearer_token.py`

```python
"""Bearer Tokenè®¤è¯æ‹¦æˆªå™¨ï¼ˆæ”¯æŒåŠ¨æ€è·å–Tokenï¼‰"""

import os
import httpx
from typing import Optional, Dict, Any
from df_test_framework.clients.http.core.interceptor import BaseInterceptor
from df_test_framework.clients.http.core.request import Request
from loguru import logger


class BearerTokenInterceptor(BaseInterceptor):
    """Bearer Tokenè®¤è¯æ‹¦æˆªå™¨

    æ”¯æŒå¤šç§Tokenæ¥æº:
    - static: é™æ€Token
    - login: è°ƒç”¨ç™»å½•æ¥å£è·å–
    - env: ä»ç¯å¢ƒå˜é‡è¯»å–
    - custom: è‡ªå®šä¹‰è·å–å‡½æ•°
    """

    def __init__(
        self,
        token_source: str = "login",
        static_token: Optional[str] = None,
        login_url: Optional[str] = None,
        login_credentials: Optional[Dict[str, str]] = None,
        token_field_path: str = "data.token",
        env_var_name: str = "API_TOKEN",
        header_name: str = "Authorization",
        token_prefix: str = "Bearer",
        priority: int = 20,
        name: str = None,
    ):
        super().__init__(name=name or "BearerTokenInterceptor", priority=priority)
        self.token_source = token_source
        self.static_token = static_token
        self.login_url = login_url
        self.login_credentials = login_credentials
        self.token_field_path = token_field_path
        self.env_var_name = env_var_name
        self.header_name = header_name
        self.token_prefix = token_prefix

        # Tokenç¼“å­˜
        self._token_cache: Optional[str] = None

    def before_request(self, request: Request) -> Optional[Request]:
        """æ·»åŠ Bearer Tokenåˆ°è¯·æ±‚å¤´"""
        token = self._get_token()
        token_value = f"{self.token_prefix} {token}" if self.token_prefix else token

        request.headers[self.header_name] = token_value

        logger.debug(
            f"[BearerTokenInterceptor] å·²æ·»åŠ è®¤è¯Header: "
            f"{self.header_name}={self.token_prefix} ****"
        )

        return request

    def _get_token(self) -> str:
        """è·å–Tokenï¼ˆæ”¯æŒå¤šç§æ¥æºï¼‰"""
        if self.token_source == "static":
            if not self.static_token:
                raise ValueError("token_source='static' ä½†æœªé…ç½®static_token")
            return self.static_token

        elif self.token_source == "env":
            token = os.getenv(self.env_var_name)
            if not token:
                raise ValueError(f"ç¯å¢ƒå˜é‡ {self.env_var_name} æœªè®¾ç½®")
            return token

        elif self.token_source == "login":
            # ä½¿ç”¨ç¼“å­˜
            if self._token_cache:
                return self._token_cache

            # è°ƒç”¨ç™»å½•æ¥å£
            if not self.login_url or not self.login_credentials:
                raise ValueError("token_source='login' ä½†æœªé…ç½®login_urlæˆ–login_credentials")

            logger.info(f"[BearerTokenInterceptor] è°ƒç”¨ç™»å½•æ¥å£è·å–Token: {self.login_url}")

            try:
                response = httpx.post(
                    self.login_url,
                    json=self.login_credentials,
                    timeout=30,
                )
                response.raise_for_status()
            except Exception as e:
                raise ValueError(f"ç™»å½•å¤±è´¥: {e}")

            # æå–Token
            data = response.json()
            token = data
            for field in self.token_field_path.split("."):
                if field not in token:
                    raise ValueError(f"ç™»å½•å“åº”ä¸­æœªæ‰¾åˆ°Tokenå­—æ®µ: {self.token_field_path}")
                token = token[field]

            # ç¼“å­˜
            self._token_cache = token
            logger.info("[BearerTokenInterceptor] ç™»å½•æˆåŠŸï¼ŒTokenå·²ç¼“å­˜")
            return token

        else:
            raise ValueError(f"ä¸æ”¯æŒçš„token_source: {self.token_source}")
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Task 1.5: æ›´æ–°ç°æœ‰æµ‹è¯• (åŠå¤©)

**ç›®æ ‡**ï¼šæ›´æ–°æ‰€æœ‰æ‹¦æˆªå™¨ç›¸å…³æµ‹è¯•

**æ–‡ä»¶**ï¼š
- `tests/test_interceptors_config.py` - æ›´æ–°Factoryæµ‹è¯•
- `tests/clients/http/test_client.py` - æ›´æ–°HttpClientæµ‹è¯•
- `tests/clients/http/auth/signature/test_interceptor.py` - ç­¾åæ‹¦æˆªå™¨æµ‹è¯•

**éªŒè¯**ï¼š
```bash
# è¿è¡Œæ‰€æœ‰æ‹¦æˆªå™¨æµ‹è¯•
uv run pytest tests/ -k "interceptor" -v

# é¢„æœŸç»“æœï¼š
# - æ‰€æœ‰æµ‹è¯•é€šè¿‡
# - è¦†ç›–before_request / after_response / on_error
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Phase 1 å®Œæˆæ ‡å‡†

- [x] InterceptorFactoryè¿”å›Interceptorå®ä¾‹
- [x] PathFilteredInterceptorå®ç°
- [x] HttpClientæ¥å…¥InterceptorChain
- [x] æ”¯æŒbefore/after/on_errorå®Œæ•´ç”Ÿå‘½å‘¨æœŸ
- [x] æ‰€æœ‰æ‹¦æˆªå™¨ç±»å‹å®ç°å®Œæ•´
- [x] æµ‹è¯•å…¨éƒ¨é€šè¿‡ï¼ˆè¦†ç›–ç‡>80%ï¼‰
- [x] å‘åå…¼å®¹ï¼ˆç°æœ‰ä»£ç æ— éœ€ä¿®æ”¹ï¼‰

**é¢„è®¡å®Œæˆæ—¶é—´**: Day 1-4

---

## ğŸ¯ Phase 2: ç»Ÿä¸€å¯è§‚æµ‹æ€§ (2-3å¤©)

### èƒŒæ™¯

**å½“å‰é—®é¢˜**ï¼šä»å®é™…è¿è¡Œæ—¥å¿—çœ‹åˆ°ä¸‰å¥—ç³»ç»Ÿå¹¶å­˜

```log
# 1. Loguruæ¡†æ¶æ—¥å¿—
2025-11-07 10:23:39 | INFO | df_test_framework.databases.database:__init__ | æ•°æ®åº“è¿æ¥å·²å»ºç«‹

# 2. debug_modeçš„[HTTP DEBUG]
[HTTP DEBUG] POST master/card/create
[HTTP DEBUG] Response: 200 âœ… in 203.82ms

# 3. debug_modeçš„[DB DEBUG]
[DB DEBUG] SQL: SELECT * FROM card_inventory
[DB DEBUG] Result: 1 row(s) in 299.99ms
```

**ç”¨æˆ·å›°æƒ‘**ï¼š
- ä¸ºä»€ä¹ˆæœ‰äº›æ—¥å¿—æœ‰æ—¶é—´æˆ³ï¼Œæœ‰äº›æ²¡æœ‰ï¼Ÿ
- æ‹¦æˆªå™¨æ—¥å¿—å¤ªå•°å—¦ï¼ˆæ¯æ¬¡åŠ è½½éƒ½æ‰“å°ï¼‰
- çœ‹ä¸æ¸…è¯·æ±‚æµç¨‹ï¼ˆæ—¥å¿—äº¤é”™æ··ä¹±ï¼‰

---

### Task 2.1: å®ç°ObservabilityLogger (1å¤©)

**ç›®æ ‡**ï¼šç»Ÿä¸€æ—¥å¿—æ¥å£ï¼Œæ›¿ä»£HTTPDebugger/DBDebugger

#### å®æ–½æ­¥éª¤

**æ–‡ä»¶**: `src/df_test_framework/infrastructure/logging/observability.py`ï¼ˆæ–°å»ºï¼‰

```python
"""ç»Ÿä¸€å¯è§‚æµ‹æ€§æ—¥å¿—ç³»ç»Ÿ

æ›¿ä»£åŸæœ‰çš„HTTPDebuggerå’ŒDBDebuggerï¼Œæä¾›ï¼š
- ç»Ÿä¸€çš„æ—¥å¿—æ ¼å¼
- è¯·æ±‚çº§è¿½è¸ªï¼ˆrequest_idï¼‰
- å¯é…ç½®çš„è¯¦ç»†åº¦ï¼ˆé€šè¿‡æ—¥å¿—çº§åˆ«ï¼‰
- ç»“æ„åŒ–ä¸Šä¸‹æ–‡ï¼ˆbindï¼‰
"""

from __future__ import annotations

import re
import uuid
from typing import Dict, Any, Optional
from contextvars import ContextVar
from loguru import logger


# è¯·æ±‚ä¸Šä¸‹æ–‡ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
_current_request_id: ContextVar[Optional[str]] = ContextVar("request_id", default=None)


class RequestContext:
    """è¯·æ±‚ä¸Šä¸‹æ–‡ç®¡ç†å™¨

    ä¸ºæ¯ä¸ªHTTPè¯·æ±‚ç”Ÿæˆå”¯ä¸€çš„request_idï¼Œç”¨äºå…³è”æ—¥å¿—

    Example:
        >>> ctx = RequestContext.start("POST", "/api/users")
        >>> print(ctx.request_id)  # req_a3f2b1c8
        >>> RequestContext.get_current_id()  # req_a3f2b1c8
        >>> RequestContext.clear()
    """

    def __init__(self, method: str, url: str):
        self.request_id = f"req_{uuid.uuid4().hex[:8]}"
        self.method = method
        self.url = url

    @classmethod
    def start(cls, method: str, url: str) -> "RequestContext":
        """å¼€å§‹æ–°è¯·æ±‚"""
        ctx = cls(method, url)
        _current_request_id.set(ctx.request_id)
        return ctx

    @classmethod
    def get_current_id(cls) -> Optional[str]:
        """è·å–å½“å‰è¯·æ±‚ID"""
        return _current_request_id.get()

    @classmethod
    def clear(cls):
        """æ¸…é™¤è¯·æ±‚ä¸Šä¸‹æ–‡"""
        _current_request_id.set(None)


class ObservabilityLogger:
    """ç»Ÿä¸€å¯è§‚æµ‹æ€§æ—¥å¿—æ¥å£

    æä¾›HTTPã€æ•°æ®åº“ã€æ‹¦æˆªå™¨çš„ç»Ÿä¸€æ—¥å¿—æ ¼å¼

    æ—¥å¿—çº§åˆ«ç­–ç•¥:
    - DEBUG: è¯¦ç»†ä¿¡æ¯ï¼ˆheaders, body, SQLå‚æ•°ï¼‰
    - INFO: å…³é”®æ“ä½œï¼ˆHTTPè¯·æ±‚å®Œæˆ, DBæŸ¥è¯¢ï¼‰
    - WARNING: æ‹¦æˆªå™¨è·³è¿‡, é‡è¯•
    - ERROR: å¤±è´¥å’Œå¼‚å¸¸

    Example:
        >>> # æ™®é€šæ¨¡å¼ï¼ˆINFOï¼‰
        >>> logger = ObservabilityLogger("http")
        >>> logger.log_http_request("POST", "/api/users", ...)
        # è¾“å‡º: HTTP | req_a3f2 | â†’ POST /api/users

        >>> # è¯¦ç»†æ¨¡å¼ï¼ˆDEBUGï¼‰
        >>> logger.log_http_request("POST", "/api/users", headers={...}, body={...})
        # è¾“å‡º:
        # HTTP | req_a3f2 | â†’ POST /api/users
        #   â”œâ”€ Headers: {...}
        #   â””â”€ Body: {...}
    """

    def __init__(self, component: str):
        """
        Args:
            component: ç»„ä»¶åç§°ï¼ˆhttp/db/interceptorï¼‰
        """
        self.component = component

    def log_http_request(
        self,
        method: str,
        url: str,
        headers: Optional[Dict] = None,
        body: Optional[Any] = None,
        params: Optional[Dict] = None,
    ):
        """è®°å½•HTTPè¯·æ±‚

        Args:
            method: HTTPæ–¹æ³•
            url: è¯·æ±‚URL
            headers: è¯·æ±‚å¤´ï¼ˆå¯é€‰ï¼ŒDEBUGçº§åˆ«æ˜¾ç¤ºï¼‰
            body: è¯·æ±‚ä½“ï¼ˆå¯é€‰ï¼ŒDEBUGçº§åˆ«æ˜¾ç¤ºï¼‰
            params: æŸ¥è¯¢å‚æ•°ï¼ˆå¯é€‰ï¼ŒDEBUGçº§åˆ«æ˜¾ç¤ºï¼‰
        """
        # å¼€å§‹æ–°è¯·æ±‚
        ctx = RequestContext.start(method, url)

        # INFOçº§åˆ«: ç®€æ´è¾“å‡º
        logger.bind(
            request_id=ctx.request_id,
            component=self.component,
            method=method,
            path=url,
        ).info(f"â†’ {method} {url}")

        # DEBUGçº§åˆ«: è¯¦ç»†ä¿¡æ¯
        if params:
            logger.bind(request_id=ctx.request_id).debug(
                f"  â”œâ”€ Params: {params}"
            )

        if headers:
            sanitized = self._sanitize_headers(headers)
            logger.bind(request_id=ctx.request_id).debug(
                f"  â”œâ”€ Headers: {sanitized}"
            )

        if body:
            truncated = self._truncate(body)
            logger.bind(request_id=ctx.request_id).debug(
                f"  â””â”€ Body: {truncated}"
            )

    def log_http_response(
        self,
        status_code: int,
        duration_ms: float,
        body: Optional[str] = None,
    ):
        """è®°å½•HTTPå“åº”

        Args:
            status_code: HTTPçŠ¶æ€ç 
            duration_ms: è¯·æ±‚è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
            body: å“åº”ä½“ï¼ˆå¯é€‰ï¼ŒDEBUGçº§åˆ«æ˜¾ç¤ºï¼‰
        """
        req_id = RequestContext.get_current_id()
        status_icon = "âœ…" if 200 <= status_code < 300 else "âŒ"

        # INFOçº§åˆ«: çŠ¶æ€ç å’Œè€—æ—¶
        logger.bind(
            request_id=req_id,
            component=self.component,
            status_code=status_code,
            duration_ms=duration_ms,
        ).info(f"â† {status_code} {status_icon} ({duration_ms:.2f}ms)")

        # DEBUGçº§åˆ«: å“åº”body
        if body:
            truncated = self._truncate(body, max_len=500)
            logger.bind(request_id=req_id).debug(
                f"  â””â”€ Body: {truncated}"
            )

        # æ¸…é™¤è¯·æ±‚ä¸Šä¸‹æ–‡
        RequestContext.clear()

    def log_interceptor(
        self,
        interceptor_name: str,
        action: str,
        reason: Optional[str] = None,
    ):
        """è®°å½•æ‹¦æˆªå™¨æ‰§è¡Œ

        åªåœ¨DEBUGçº§åˆ«è¾“å‡ºï¼ˆé¿å…INFOçº§åˆ«è¿‡äºå•°å—¦ï¼‰

        Args:
            interceptor_name: æ‹¦æˆªå™¨åç§°
            action: åŠ¨ä½œï¼ˆapplied/skipped/errorï¼‰
            reason: åŸå› ï¼ˆå¯é€‰ï¼‰
        """
        req_id = RequestContext.get_current_id()

        msg = f"{interceptor_name} â†’ {action}"
        if reason:
            msg += f" ({reason})"

        # åªåœ¨DEBUGçº§åˆ«è¾“å‡º
        logger.bind(
            request_id=req_id,
            component="interceptor",
            name=interceptor_name,
        ).debug(msg)

    def log_db_query(
        self,
        sql: str,
        params: Optional[Dict] = None,
        rows: int = 0,
        duration_ms: float = 0,
    ):
        """è®°å½•æ•°æ®åº“æŸ¥è¯¢

        Args:
            sql: SQLè¯­å¥
            params: æŸ¥è¯¢å‚æ•°ï¼ˆå¯é€‰ï¼ŒDEBUGçº§åˆ«æ˜¾ç¤ºï¼‰
            rows: è¿”å›è¡Œæ•°
            duration_ms: æŸ¥è¯¢è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
        """
        # æå–è¡¨å
        table = self._extract_table_name(sql)

        # INFOçº§åˆ«: ç®€æ´
        logger.bind(
            component="db",
            table=table,
            rows=rows,
            duration_ms=duration_ms,
        ).info(f"DB | {table} â†’ {rows} row(s) ({duration_ms:.2f}ms)")

        # DEBUGçº§åˆ«: å®Œæ•´SQL
        logger.debug(f"  â”œâ”€ SQL: {sql}")
        if params:
            logger.debug(f"  â””â”€ Params: {params}")

    def log_db_transaction(
        self,
        action: str,
        duration_ms: Optional[float] = None,
    ):
        """è®°å½•æ•°æ®åº“äº‹åŠ¡

        Args:
            action: åŠ¨ä½œï¼ˆbegin/commit/rollbackï¼‰
            duration_ms: è€—æ—¶ï¼ˆå¯é€‰ï¼‰
        """
        if duration_ms:
            logger.bind(component="db").info(
                f"TRANSACTION | {action} ({duration_ms:.2f}ms)"
            )
        else:
            logger.bind(component="db").info(f"TRANSACTION | {action}")

    def _sanitize_headers(self, headers: Dict) -> Dict:
        """è„±æ•æ•æ„ŸHeader

        è‡ªåŠ¨maskä»¥ä¸‹header:
        - Authorization
        - X-Sign
        - X-Token
        - Cookie
        """
        sensitive_keys = {"authorization", "x-sign", "x-token", "cookie"}

        sanitized = {}
        for key, value in headers.items():
            if key.lower() in sensitive_keys:
                # åªæ˜¾ç¤ºå‰10ä¸ªå’Œå8ä¸ªå­—ç¬¦
                if isinstance(value, str) and len(value) > 20:
                    sanitized[key] = f"{value[:10]}...{value[-8:]}"
                else:
                    sanitized[key] = "***"
            else:
                sanitized[key] = value

        return sanitized

    def _truncate(self, content: Any, max_len: int = 500) -> str:
        """æˆªæ–­è¿‡é•¿å†…å®¹"""
        content_str = str(content)
        if len(content_str) > max_len:
            return content_str[:max_len] + "..."
        return content_str

    def _extract_table_name(self, sql: str) -> str:
        """ä»SQLæå–è¡¨å"""
        # åŒ¹é… FROM table_name
        match = re.search(r"\bFROM\s+([a-z_0-9]+)", sql, re.IGNORECASE)
        if match:
            return match.group(1)

        # åŒ¹é… UPDATE table_name
        match = re.search(r"\bUPDATE\s+([a-z_0-9]+)", sql, re.IGNORECASE)
        if match:
            return match.group(1)

        # åŒ¹é… INSERT INTO table_name
        match = re.search(r"\bINSERT\s+INTO\s+([a-z_0-9]+)", sql, re.IGNORECASE)
        if match:
            return match.group(1)

        return "unknown"


# å…¨å±€å®ä¾‹
http_logger = ObservabilityLogger("http")
db_logger = ObservabilityLogger("db")
interceptor_logger = ObservabilityLogger("interceptor")
```

**æµ‹è¯•**ï¼š
```python
# tests/infrastructure/logging/test_observability.py

def test_request_context():
    """æµ‹è¯•è¯·æ±‚ä¸Šä¸‹æ–‡ç®¡ç†"""
    ctx = RequestContext.start("GET", "/api/users")
    assert ctx.request_id.startswith("req_")
    assert RequestContext.get_current_id() == ctx.request_id

    RequestContext.clear()
    assert RequestContext.get_current_id() is None

def test_log_http_request_simple(caplog):
    """æµ‹è¯•ç®€å•HTTPè¯·æ±‚æ—¥å¿—ï¼ˆINFOçº§åˆ«ï¼‰"""
    logger = ObservabilityLogger("http")

    with caplog.at_level("INFO"):
        logger.log_http_request("POST", "/api/users")

    # éªŒè¯INFOæ—¥å¿—
    assert "â†’ POST /api/users" in caplog.text

def test_log_http_request_with_details(caplog):
    """æµ‹è¯•è¯¦ç»†HTTPè¯·æ±‚æ—¥å¿—ï¼ˆDEBUGçº§åˆ«ï¼‰"""
    logger = ObservabilityLogger("http")

    with caplog.at_level("DEBUG"):
        logger.log_http_request(
            "POST",
            "/api/users",
            headers={"Authorization": "Bearer token123"},
            body={"name": "John"},
        )

    # éªŒè¯DEBUGæ—¥å¿—åŒ…å«è¯¦ç»†ä¿¡æ¯
    assert "Headers:" in caplog.text
    assert "Body:" in caplog.text
    assert "***" in caplog.text  # éªŒè¯è„±æ•

def test_sanitize_headers():
    """æµ‹è¯•Headerè„±æ•"""
    logger = ObservabilityLogger("http")

    headers = {
        "Authorization": "Bearer very_long_token_1234567890abcdef",
        "Content-Type": "application/json",
        "X-Sign": "abc123",
    }

    sanitized = logger._sanitize_headers(headers)

    assert sanitized["Content-Type"] == "application/json"  # ä¸è„±æ•
    assert "..." in sanitized["Authorization"]  # éƒ¨åˆ†è„±æ•
    assert sanitized["X-Sign"] == "***"  # å®Œå…¨è„±æ•

def test_extract_table_name():
    """æµ‹è¯•ä»SQLæå–è¡¨å"""
    logger = ObservabilityLogger("db")

    assert logger._extract_table_name(
        "SELECT * FROM users WHERE id = 1"
    ) == "users"

    assert logger._extract_table_name(
        "UPDATE card_inventory SET status = 'ACTIVE'"
    ) == "card_inventory"

    assert logger._extract_table_name(
        "INSERT INTO orders (id, name) VALUES (1, 'test')"
    ) == "orders"
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Task 2.2: é›†æˆåˆ°HttpClient (åŠå¤©)

**ç›®æ ‡**ï¼šHttpClientä½¿ç”¨ObservabilityLoggeræ›¿ä»£åŸæœ‰æ—¥å¿—

**æ–‡ä»¶**: `src/df_test_framework/clients/http/rest/httpx/client.py`

```python
from df_test_framework.infrastructure.logging.observability import http_logger
import time

class HttpClient:
    def request(self, method: str, url: str, **kwargs) -> httpx.Response:
        """å‘é€HTTPè¯·æ±‚ï¼ˆå¸¦ç»Ÿä¸€æ—¥å¿—ï¼‰"""
        start_time = time.time()

        # âœ… è®°å½•è¯·æ±‚å¼€å§‹
        http_logger.log_http_request(
            method=method,
            url=url,
            headers=kwargs.get("headers"),
            body=kwargs.get("json") or kwargs.get("data"),
            params=kwargs.get("params"),
        )

        try:
            # æ„é€ Requestå¯¹è±¡
            request = Request(method, url, ...)

            # æ‰§è¡Œæ‹¦æˆªå™¨é“¾
            request = self.interceptor_chain.execute_before_request(request)

            # ä»Requestæå–å‚æ•°
            kwargs["headers"] = dict(request.headers)

            # å‘é€è¯·æ±‚
            raw_response = self.client.request(method, url, **kwargs)

            # âœ… è®°å½•å“åº”
            duration_ms = (time.time() - start_time) * 1000
            http_logger.log_http_response(
                status_code=raw_response.status_code,
                duration_ms=duration_ms,
                body=raw_response.text,
            )

            # æ„é€ Responseå¯¹è±¡
            response = Response(
                status_code=raw_response.status_code,
                headers=dict(raw_response.headers),
                body=raw_response.text,
                duration_ms=duration_ms,
            )

            # after_responseé’©å­
            response = self.interceptor_chain.execute_after_response(response)

            return raw_response

        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            logger.bind(component="http", request_id=RequestContext.get_current_id()).error(
                f"è¯·æ±‚å¤±è´¥ ({duration_ms:.2f}ms): {e}"
            )

            # on_erroré’©å­
            self.interceptor_chain.execute_on_error(e, request)
            raise
```

**ç§»é™¤æ—§ä»£ç **ï¼š
```python
# âŒ åˆ é™¤ä»¥ä¸‹ä»£ç 
# è¯·æ±‚æ—¥å¿—ï¼ˆè„±æ•æ•æ„Ÿä¿¡æ¯ï¼‰
sanitized_url = sanitize_url(url)
logger.info(f"[{method}] {sanitized_url}")
if "params" in kwargs:
    logger.debug(f"Query Params: {kwargs['params']}")
# ... å…¶ä»–æ‰‹åŠ¨æ—¥å¿—ä»£ç 
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Task 2.3: é›†æˆåˆ°InterceptorChain (åŠå¤©)

**ç›®æ ‡**ï¼šæ‹¦æˆªå™¨é“¾ä½¿ç”¨ObservabilityLoggerè®°å½•æ‰§è¡Œ

**æ–‡ä»¶**: `src/df_test_framework/clients/http/core/chain.py`

```python
from df_test_framework.infrastructure.logging.observability import interceptor_logger

class InterceptorChain:
    def execute_before_request(self, request: Request) -> Request:
        """æ‰§è¡Œbefore_requesté’©å­ï¼ˆå¸¦æ—¥å¿—ï¼‰"""
        current_request = request

        for interceptor in self.interceptors:
            try:
                # æ‰§è¡Œæ‹¦æˆªå™¨
                modified_request = interceptor.before_request(current_request)

                if modified_request is not None:
                    current_request = modified_request

                    # âœ… åªåœ¨DEBUGçº§åˆ«è®°å½•æˆåŠŸ
                    interceptor_logger.log_interceptor(
                        interceptor.name,
                        "applied",
                    )
                else:
                    # âœ… åªåœ¨DEBUGçº§åˆ«è®°å½•è·³è¿‡
                    interceptor_logger.log_interceptor(
                        interceptor.name,
                        "skipped",
                        reason="path not matched",
                    )

            except InterceptorAbort as e:
                logger.bind(component="interceptor").warning(
                    f"{interceptor.name} ä¸»åŠ¨ç»ˆæ­¢è¯·æ±‚: {e}"
                )
                raise

            except Exception as e:
                # âŒ é”™è¯¯å¿…é¡»è®°å½•
                logger.bind(component="interceptor").error(
                    f"{interceptor.name} æ‰§è¡Œå¤±è´¥: {e}",
                    exc_info=True,
                )

        return current_request
```

**ç§»é™¤æ—§æ—¥å¿—**ï¼š
```python
# âŒ åˆ é™¤ä»¥ä¸‹å•°å—¦çš„æ—¥å¿—
logger.debug(
    f"[InterceptorChain] æ·»åŠ æ‹¦æˆªå™¨: {interceptor.name} "
    f"(priority={interceptor.priority})"
)
logger.debug(
    f"[æ‹¦æˆªå™¨] {interceptor.name} (priority={interceptor.priority}) æ‰§è¡ŒæˆåŠŸ"
)
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Task 2.4: é›†æˆåˆ°Database (åŠå¤©)

**ç›®æ ‡**ï¼šDatabaseç±»ä½¿ç”¨ObservabilityLogger

**æ–‡ä»¶**: `src/df_test_framework/databases/database.py`

```python
from df_test_framework.infrastructure.logging.observability import db_logger
import time

class Database:
    def query_one(self, sql: str, params: Optional[Dict] = None) -> Optional[Row]:
        """æŸ¥è¯¢å•æ¡è®°å½•ï¼ˆå¸¦æ—¥å¿—ï¼‰"""
        start_time = time.time()

        with self.session() as session:
            result = session.execute(text(sql), params or {})
            row = result.fetchone()

            # âœ… è®°å½•æŸ¥è¯¢
            duration_ms = (time.time() - start_time) * 1000
            db_logger.log_db_query(
                sql=sql,
                params=params,
                rows=1 if row else 0,
                duration_ms=duration_ms,
            )

            return row

    def query_all(self, sql: str, params: Optional[Dict] = None) -> List[Row]:
        """æŸ¥è¯¢å¤šæ¡è®°å½•ï¼ˆå¸¦æ—¥å¿—ï¼‰"""
        start_time = time.time()

        with self.session() as session:
            result = session.execute(text(sql), params or {})
            rows = result.fetchall()

            # âœ… è®°å½•æŸ¥è¯¢
            duration_ms = (time.time() - start_time) * 1000
            db_logger.log_db_query(
                sql=sql,
                params=params,
                rows=len(rows),
                duration_ms=duration_ms,
            )

            return rows

    @contextmanager
    def transaction(self):
        """äº‹åŠ¡ç®¡ç†ï¼ˆå¸¦æ—¥å¿—ï¼‰"""
        start_time = time.time()
        db_logger.log_db_transaction("begin")

        with self.session() as session:
            try:
                yield session
                session.commit()

                duration_ms = (time.time() - start_time) * 1000
                db_logger.log_db_transaction("commit", duration_ms)

            except Exception as e:
                session.rollback()

                duration_ms = (time.time() - start_time) * 1000
                db_logger.log_db_transaction("rollback", duration_ms)

                logger.bind(component="db").error(f"äº‹åŠ¡å›æ»š: {e}")
                raise
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Task 2.5: ç§»é™¤æ—§çš„debugå·¥å…· (åŠå¤©)

**ç›®æ ‡**ï¼šç§»é™¤HTTPDebuggerå’ŒDBDebuggerï¼Œç®€åŒ–debug_mode

**æ–‡ä»¶**: `src/df_test_framework/testing/fixtures/debug.py`

```python
"""è°ƒè¯•æ¨¡å¼ - ç®€åŒ–ç‰ˆ

åªéœ€è®¾ç½®æ—¥å¿—çº§åˆ«ä¸ºDEBUGå³å¯å¯ç”¨è¯¦ç»†æ—¥å¿—
"""

import sys
import pytest
from loguru import logger


@pytest.fixture
def debug_mode():
    """è°ƒè¯•æ¨¡å¼ - è®¾ç½®æ—¥å¿—çº§åˆ«ä¸ºDEBUG

    å¯ç”¨è¯¦ç»†æ—¥å¿—ï¼š
    - HTTPè¯·æ±‚/å“åº”è¯¦æƒ…ï¼ˆheaders, bodyï¼‰
    - æ•°æ®åº“æŸ¥è¯¢è¯¦æƒ…ï¼ˆSQL, paramsï¼‰
    - æ‹¦æˆªå™¨æ‰§è¡Œè¯¦æƒ…

    Example:
        >>> def test_example(debug_mode):
        ...     # è‡ªåŠ¨å¯ç”¨DEBUGçº§åˆ«æ—¥å¿—
        ...     client.get("/api/users")
    """
    # ç§»é™¤é»˜è®¤handler
    logger.remove()

    # âœ… æ·»åŠ DEBUGçº§åˆ«handler
    logger.add(
        sys.stderr,
        level="DEBUG",
        format=(
            "<green>{time:YYYY-MM-DD HH:mm:ss}</green> | "
            "<level>{level: <8}</level> | "
            "<cyan>{extra[component]: <12}</cyan> | "
            "<magenta>{extra[request_id]: <10}</magenta> | "
            "{message}"
        ),
    )

    yield

    # æ¢å¤INFOçº§åˆ«
    logger.remove()
    logger.add(
        sys.stderr,
        level="INFO",
        format=(
            "<green>{time:YYYY-MM-DD HH:mm:ss}</green> | "
            "<level>{level: <8}</level> | "
            "<cyan>{extra[component]: <12}</cyan> | "
            "{message}"
        ),
    )


@pytest.fixture
def http_debug(debug_mode):
    """HTTPè°ƒè¯•æ¨¡å¼ï¼ˆå‘åå…¼å®¹ï¼‰

    å®é™…ä¸Šå°±æ˜¯debug_modeçš„åˆ«å
    """
    return debug_mode


@pytest.fixture
def db_debug(debug_mode):
    """æ•°æ®åº“è°ƒè¯•æ¨¡å¼ï¼ˆå‘åå…¼å®¹ï¼‰

    å®é™…ä¸Šå°±æ˜¯debug_modeçš„åˆ«å
    """
    return debug_mode
```

**åˆ é™¤æ–‡ä»¶**ï¼š
- `src/df_test_framework/testing/debug/http_debugger.py`
- `src/df_test_framework/testing/debug/db_debugger.py`

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Task 2.6: æ—¥å¿—æ ¼å¼é…ç½® (åŠå¤©)

**ç›®æ ‡**ï¼šæ”¯æŒè‡ªå®šä¹‰æ—¥å¿—æ ¼å¼

**æ–‡ä»¶**: `src/df_test_framework/infrastructure/logging/strategies.py`

```python
class LoguruStructuredStrategy(LoggerStrategy):
    """Loguruç»“æ„åŒ–æ—¥å¿—ç­–ç•¥ï¼ˆæ›´æ–°ç‰ˆï¼‰"""

    def configure(self, config: LoggingConfig) -> "logger":
        """é…ç½®Loguruæ—¥å¿—"""
        logger.remove()

        # æ ¹æ®formaté€‰æ‹©æ ¼å¼
        if config.format == "json":
            # JSONæ ¼å¼ï¼ˆæœºå™¨å¯è¯»ï¼‰
            format_str = (
                "{{"
                '"timestamp": "{time:YYYY-MM-DD HH:mm:ss}",'
                '"level": "{level}",'
                '"component": "{extra[component]}",'
                '"request_id": "{extra[request_id]}",'
                '"message": "{message}"'
                "}}"
            )
        else:
            # æ–‡æœ¬æ ¼å¼ï¼ˆäººç±»å¯è¯»ï¼‰
            format_str = (
                "<green>{time:YYYY-MM-DD HH:mm:ss}</green> | "
                "<level>{level: <8}</level> | "
                "<cyan>{extra[component]: <12}</cyan> | "
                "<magenta>{extra[request_id]: <10}</magenta> | "
                "{message}"
            )

        # æ·»åŠ console handler
        if config.enable_console:
            logger.add(
                sys.stderr,
                level=config.level,
                format=format_str,
            )

        # æ·»åŠ file handler
        if config.file:
            logger.add(
                config.file,
                level=config.level,
                format=format_str,
                rotation=config.rotation,
                retention=config.retention,
            )

        return logger
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Phase 2 å®Œæˆæ ‡å‡†

- [x] ObservabilityLoggerå®ç°å¹¶æµ‹è¯•
- [x] HttpClienté›†æˆç»Ÿä¸€æ—¥å¿—
- [x] InterceptorChainé›†æˆæ—¥å¿—ï¼ˆDEBUGçº§åˆ«ï¼‰
- [x] Databaseé›†æˆæ—¥å¿—
- [x] ç§»é™¤HTTPDebugger/DBDebugger
- [x] debug_modeç®€åŒ–ä¸ºæ—¥å¿—çº§åˆ«æ§åˆ¶
- [x] æ—¥å¿—æ ¼å¼æ”¯æŒtext/json

**æ—¥å¿—è¾“å‡ºç¤ºä¾‹**ï¼š

**INFOçº§åˆ«ï¼ˆæ™®é€šæ¨¡å¼ï¼‰**ï¼š
```log
2025-11-07 10:23:40 | INFO     | HTTP         |            | â†’ POST /master/card/create
2025-11-07 10:23:40 | INFO     | HTTP         | req_a3f2   | â† 200 âœ… (203ms)
2025-11-07 10:23:41 | INFO     | DB           |            | card_inventory â†’ 1 row (45ms)
```

**DEBUGçº§åˆ«ï¼ˆè°ƒè¯•æ¨¡å¼ï¼‰**ï¼š
```log
2025-11-07 10:23:40 | INFO     | HTTP         | req_a3f2   | â†’ POST /master/card/create
2025-11-07 10:23:40 | DEBUG    | INTERCEPTOR  | req_a3f2   | SignatureInterceptor â†’ applied
2025-11-07 10:23:40 | DEBUG    | INTERCEPTOR  | req_a3f2   | BearerTokenInterceptor â†’ skipped (path excluded)
2025-11-07 10:23:40 | DEBUG    | HTTP         | req_a3f2   |   â”œâ”€ Headers: {X-Sign: f83865...}
2025-11-07 10:23:40 | DEBUG    | HTTP         | req_a3f2   |   â””â”€ Body: {customerOrderNo: ORD_...}
2025-11-07 10:23:40 | INFO     | HTTP         | req_a3f2   | â† 200 âœ… (203ms)
2025-11-07 10:23:40 | DEBUG    | HTTP         | req_a3f2   |   â””â”€ Body: {"code":200,...}
2025-11-07 10:23:41 | INFO     | DB           |            | card_inventory â†’ 1 row (45ms)
2025-11-07 10:23:41 | DEBUG    | DB           |            |   â”œâ”€ SQL: SELECT * FROM card_inventory WHERE card_no = :card_no
2025-11-07 10:23:41 | DEBUG    | DB           |            |   â””â”€ Params: {card_no: 'GC20251105...'}
```

**é¢„è®¡å®Œæˆæ—¶é—´**: Day 5-7

---

## ğŸ¯ Phase 3: é…ç½®APIå¢å¼º (1-2å¤©)

### Task 3.1: Profileæ”¯æŒ (åŠå¤©)

**ç›®æ ‡**ï¼šæ”¯æŒé€šè¿‡ä»£ç æŒ‡å®šprofile

**æ–‡ä»¶**: `src/df_test_framework/infrastructure/bootstrap/bootstrap.py`

```python
@dataclass
class Bootstrap:
    settings_cls: Type[FrameworkSettings] = FrameworkSettings
    namespace: SettingsNamespace = "default"
    profile: Optional[str] = None  # âœ… æ–°å¢
    sources: Optional[Iterable[ConfigSource]] = None
    cache_enabled: bool = True
    logger_strategy: LoggerStrategy = field(default_factory=LoguruStructuredStrategy)
    provider_factory: Optional[ProviderFactory] = None
    plugins: list[Union[str, object]] = field(default_factory=list)

    def with_settings(
        self,
        settings_cls: Type[TSettings],
        *,
        namespace: SettingsNamespace = "default",
        profile: Optional[str] = None,  # âœ… æ–°å¢
        sources: Optional[Iterable[ConfigSource]] = None,
        cache_enabled: bool = True,
    ) -> "Bootstrap":
        """é…ç½®Settings

        Args:
            settings_cls: Settingsç±»
            namespace: å‘½åç©ºé—´
            profile: ç¯å¢ƒé…ç½®ï¼ˆdev/test/staging/prodï¼‰âœ… æ–°å¢
            sources: é…ç½®æº
            cache_enabled: æ˜¯å¦ç¼“å­˜

        Example:
            >>> Bootstrap().with_settings(
            ...     CustomSettings,
            ...     profile="dev",  # âœ… æŒ‡å®šprofile
            ... )
        """
        self.settings_cls = settings_cls
        self.namespace = namespace
        self.profile = profile  # âœ… ä¿å­˜
        self.sources = sources
        self.cache_enabled = cache_enabled
        return self

    def build(self) -> "BootstrapApp":
        return BootstrapApp(
            settings_cls=self.settings_cls,
            namespace=self.namespace,
            profile=self.profile,  # âœ… ä¼ é€’
            sources=self.sources,
            cache_enabled=self.cache_enabled,
            logger_strategy=self.logger_strategy,
            provider_factory=self.provider_factory,
            plugins=list(self.plugins),
        )


@dataclass
class BootstrapApp:
    settings_cls: Type[FrameworkSettings]
    namespace: SettingsNamespace
    profile: Optional[str]  # âœ… æ–°å¢
    sources: Optional[Iterable[ConfigSource]]
    cache_enabled: bool
    logger_strategy: LoggerStrategy
    provider_factory: Optional[ProviderFactory]
    plugins: list[Union[str, object]]

    def run(self, *, force_reload: bool = False) -> RuntimeContext:
        """æ‰§è¡Œbootstrapï¼ˆæ”¯æŒprofileï¼‰"""
        if force_reload:
            clear_settings(self.namespace)

        # æ‰©å±•ç‚¹ï¼šæ’ä»¶å¯ä»¥è´¡çŒ®é…ç½®æº
        extensions = create_extension_manager()
        extensions.register_many(self.plugins)
        pm = extensions.manager

        extra_sources = []
        for contributed in pm.hook.df_config_sources(settings_cls=self.settings_cls):
            extra_sources.extend(contributed or [])

        combined_sources = []
        if self.sources:
            combined_sources.extend(self.sources)
        combined_sources.extend(extra_sources)

        try:
            configure_settings(
                self.settings_cls,
                namespace=self.namespace,
                profile=self.profile,  # âœ… ä¼ é€’profile
                sources=combined_sources or None,
                cache_enabled=self.cache_enabled,
            )
        except SettingsAlreadyConfiguredError:
            if force_reload:
                clear_settings(self.namespace)
                configure_settings(
                    self.settings_cls,
                    namespace=self.namespace,
                    profile=self.profile,
                    sources=combined_sources or None,
                    cache_enabled=self.cache_enabled,
                )

        settings = get_settings(self.namespace, force_reload=force_reload)
        logger = self.logger_strategy.configure(settings.logging)

        # ... å…¶ä½™ä»£ç ä¸å˜
```

**æ–‡ä»¶**: `src/df_test_framework/infrastructure/config/manager.py`

```python
def configure_settings(
    settings_cls: Type[TSettings],
    *,
    namespace: SettingsNamespace = "default",
    profile: Optional[str] = None,  # âœ… æ–°å¢
    sources: Optional[Iterable[ConfigSource]] = None,
    cache_enabled: bool = True,
) -> None:
    """æ³¨å†ŒSettingsç±»

    Args:
        settings_cls: Settingsç±»
        namespace: å‘½åç©ºé—´
        profile: ç¯å¢ƒé…ç½®ï¼ˆä¼˜å…ˆçº§é«˜äºENVç¯å¢ƒå˜é‡ï¼‰âœ… æ–°å¢
        sources: é…ç½®æºï¼ˆå¦‚æœæä¾›åˆ™è¦†ç›–é»˜è®¤ï¼‰
        cache_enabled: æ˜¯å¦ç¼“å­˜
    """
    if namespace in _REGISTRY:
        raise SettingsAlreadyConfiguredError(
            f"Settings already configured for {namespace!r}"
        )

    if sources is None:
        # âœ… ä½¿ç”¨æŒ‡å®šçš„profileæˆ–è‡ªåŠ¨æ£€æµ‹
        env_name = profile or _detect_env_name()
        pipeline = _build_default_pipeline_with_profile(settings_cls, env_name)
    else:
        pipeline = ConfigPipeline(list(sources))

    _REGISTRY[namespace] = _RegisteredSettings(
        cls=settings_cls,
        pipeline=pipeline,
        cache_enabled=cache_enabled,
    )


def _build_default_pipeline_with_profile(
    settings_cls: Type[FrameworkSettings],
    profile: str,
) -> ConfigPipeline:
    """æ„å»ºé»˜è®¤é…ç½®ç®¡é“ï¼ˆæ”¯æŒprofileï¼‰

    åŠ è½½é¡ºåº:
    1. .envï¼ˆåŸºç¡€é…ç½®ï¼‰
    2. .env.{profile}ï¼ˆç¯å¢ƒä¸“ç”¨é…ç½®ï¼‰âœ…
    3. .env.localï¼ˆæœ¬åœ°è¦†ç›–ï¼‰
    4. ç¯å¢ƒå˜é‡
    5. å‘½ä»¤è¡Œå‚æ•°
    """
    pipeline = ConfigPipeline()

    # Dotenv sources
    dotenv_files = [
        Path(".env"),
        Path(f".env.{profile}"),  # âœ… ä½¿ç”¨æŒ‡å®šprofile
        Path(".env.local"),
    ]
    pipeline.add(DotenvSource(files=dotenv_files))

    # Environment variables
    pipeline.add(EnvVarSource())

    # Command line arguments
    pipeline.add(ArgSource())

    return pipeline
```

**æµ‹è¯•**ï¼š
```python
# tests/infrastructure/test_bootstrap_profile.py

def test_bootstrap_with_profile():
    """æµ‹è¯•æŒ‡å®šprofile"""
    # åˆ›å»º.env.devæ–‡ä»¶
    Path(".env.dev").write_text("APP_ENV=dev\nAPP_DEBUG=true")

    bootstrap = Bootstrap().with_settings(
        FrameworkSettings,
        profile="dev",
    )

    app = bootstrap.build()
    runtime = app.run()

    assert runtime.settings.env == "dev"
    assert runtime.settings.debug is True

    # æ¸…ç†
    Path(".env.dev").unlink()

def test_profile_priority_over_env():
    """æµ‹è¯•profileä¼˜å…ˆäºENVç¯å¢ƒå˜é‡"""
    os.environ["ENV"] = "test"

    # æŒ‡å®šprofileåº”è¯¥è¦†ç›–ENV
    Path(".env.dev").write_text("APP_ENV=dev")

    bootstrap = Bootstrap().with_settings(
        FrameworkSettings,
        profile="dev",
    )

    app = bootstrap.build()
    runtime = app.run()

    assert runtime.settings.env == "dev"  # âœ… ä½¿ç”¨profileè€ŒéENV

    # æ¸…ç†
    Path(".env.dev").unlink()
    del os.environ["ENV"]
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Task 3.2: Runtime Overrides (1å¤©)

**ç›®æ ‡**ï¼šæ”¯æŒè¿è¡Œæ—¶é…ç½®è¦†ç›–

**æ–‡ä»¶**: `src/df_test_framework/infrastructure/runtime/context.py`

```python
class RuntimeContext:
    """è¿è¡Œæ—¶ä¸Šä¸‹æ–‡"""

    def __init__(
        self,
        settings: FrameworkSettings,
        logger: "logger",
        providers: ProviderRegistry,
        extensions: ExtensionManager,
    ):
        self.settings = settings
        self.logger = logger
        self.providers = providers
        self.extensions = extensions

    def with_overrides(self, overrides: Dict[str, Any]) -> "RuntimeContext":
        """è¿è¡Œæ—¶é…ç½®è¦†ç›–

        ç”¨äºæµ‹è¯•çº§é…ç½®è¦†ç›–ï¼Œä¸å½±å“å…¨å±€é…ç½®

        Args:
            overrides: è¦†ç›–é…ç½®ï¼ˆæ”¯æŒåµŒå¥—ï¼Œå¦‚{"http.timeout": 60}ï¼‰

        Returns:
            æ–°çš„RuntimeContextå®ä¾‹

        Example:
            >>> # åŸå§‹é…ç½®
            >>> runtime = Bootstrap().with_settings(Settings).build().run()
            >>> print(runtime.settings.http.timeout)  # 30
            >>>
            >>> # æµ‹è¯•çº§è¦†ç›–
            >>> test_runtime = runtime.with_overrides({
            ...     "http.timeout": 60,
            ...     "http.base_url": "http://test.local",
            ... })
            >>> print(test_runtime.settings.http.timeout)  # 60
        """
        from copy import deepcopy
        from pydantic import ValidationError

        # æ·±æ‹·è´å½“å‰settings
        new_settings_dict = self.settings.model_dump()

        # åº”ç”¨è¦†ç›–ï¼ˆæ”¯æŒåµŒå¥—è·¯å¾„ï¼‰
        for key, value in overrides.items():
            self._set_nested_value(new_settings_dict, key, value)

        # é‡æ–°éªŒè¯
        try:
            new_settings = type(self.settings)(**new_settings_dict)
        except ValidationError as e:
            raise ValueError(f"é…ç½®è¦†ç›–éªŒè¯å¤±è´¥: {e}")

        # è¿”å›æ–°çš„RuntimeContext
        return RuntimeContext(
            settings=new_settings,
            logger=self.logger,
            providers=self.providers,
            extensions=self.extensions,
        )

    def _set_nested_value(self, obj: Dict, path: str, value: Any):
        """è®¾ç½®åµŒå¥—å­—å…¸å€¼

        Args:
            obj: å­—å…¸å¯¹è±¡
            path: åµŒå¥—è·¯å¾„ï¼ˆå¦‚"http.timeout"ï¼‰
            value: å€¼

        Example:
            >>> obj = {"http": {"timeout": 30}}
            >>> _set_nested_value(obj, "http.timeout", 60)
            >>> obj["http"]["timeout"]  # 60
        """
        keys = path.split(".")
        current = obj

        for key in keys[:-1]:
            if key not in current:
                current[key] = {}
            current = current[key]

        current[keys[-1]] = value
```

**æµ‹è¯•**ï¼š
```python
# tests/infrastructure/test_runtime_overrides.py

def test_runtime_overrides():
    """æµ‹è¯•è¿è¡Œæ—¶é…ç½®è¦†ç›–"""
    # åŸå§‹é…ç½®
    runtime = Bootstrap().with_settings(FrameworkSettings).build().run()

    original_timeout = runtime.settings.http.timeout

    # è¦†ç›–é…ç½®
    test_runtime = runtime.with_overrides({
        "http.timeout": 60,
        "http.base_url": "http://test.local",
    })

    # éªŒè¯è¦†ç›–ç”Ÿæ•ˆ
    assert test_runtime.settings.http.timeout == 60
    assert test_runtime.settings.http.base_url == "http://test.local"

    # éªŒè¯åŸå§‹runtimeä¸å—å½±å“
    assert runtime.settings.http.timeout == original_timeout

def test_runtime_overrides_nested():
    """æµ‹è¯•åµŒå¥—è·¯å¾„è¦†ç›–"""
    runtime = Bootstrap().with_settings(FrameworkSettings).build().run()

    test_runtime = runtime.with_overrides({
        "logging.level": "DEBUG",
        "logging.format": "json",
    })

    assert test_runtime.settings.logging.level == "DEBUG"
    assert test_runtime.settings.logging.format == "json"

def test_runtime_overrides_validation():
    """æµ‹è¯•è¦†ç›–å€¼éªŒè¯"""
    runtime = Bootstrap().with_settings(FrameworkSettings).build().run()

    # æ— æ•ˆå€¼åº”è¯¥æŠ›å‡ºå¼‚å¸¸
    with pytest.raises(ValueError, match="é…ç½®è¦†ç›–éªŒè¯å¤±è´¥"):
        runtime.with_overrides({
            "http.timeout": -10,  # æ— æ•ˆå€¼
        })
```

**Pytest Fixture**ï¼š
```python
# src/df_test_framework/testing/fixtures/core.py

@pytest.fixture
def runtime_with_overrides(runtime):
    """è¿è¡Œæ—¶é…ç½®è¦†ç›–fixture

    Example:
        >>> def test_example(runtime_with_overrides):
        ...     rt = runtime_with_overrides({
        ...         "http.timeout": 60,
        ...     })
        ...     assert rt.settings.http.timeout == 60
    """
    def _override(overrides: Dict[str, Any]) -> RuntimeContext:
        return runtime.with_overrides(overrides)

    return _override
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Phase 3 å®Œæˆæ ‡å‡†

- [x] Bootstrapæ”¯æŒprofileå‚æ•°
- [x] configure_settingsæ”¯æŒprofile
- [x] è‡ªåŠ¨åŠ è½½.env.{profile}æ–‡ä»¶
- [x] RuntimeContext.with_overrideså®ç°
- [x] æµ‹è¯•è¦†ç›–profileå’Œoverrides
- [x] æ–‡æ¡£æ›´æ–°

**é¢„è®¡å®Œæˆæ—¶é—´**: Day 8-9

---

## ğŸ¯ Phase 4: æ–‡æ¡£å’Œæµ‹è¯•æ›´æ–° (1å¤©)

### Task 4.1: æ›´æ–°æ–‡æ¡£ (åŠå¤©)

**æ›´æ–°çš„æ–‡æ¡£**ï¼š

1. **README.md** - æ›´æ–°ä¸»è¦ç‰¹æ€§
2. **V3_ARCHITECTURE.md** - æ›´æ–°æ‹¦æˆªå™¨æ¶æ„å›¾
3. **INTERCEPTOR_CONFIG_BEST_PRACTICES.md** - æ›´æ–°æ‹¦æˆªå™¨æœ€ä½³å®è·µ
4. **CONFIGURABLE_INTERCEPTORS_IMPLEMENTATION.md** - æ›´æ–°å®æ–½æ–‡æ¡£
5. **docs/user-guide/configuration.md** - æ–°å¢profileå’Œoverridesæ–‡æ¡£
6. **docs/user-guide/observability.md** - æ–°å¢å¯è§‚æµ‹æ€§æ–‡æ¡£

**æ–°å»ºæ–‡æ¡£**ï¼š

**æ–‡ä»¶**: `docs/user-guide/observability.md`

```markdown
# å¯è§‚æµ‹æ€§æŒ‡å—

## æ¦‚è¿°

v3.5æä¾›ç»Ÿä¸€çš„å¯è§‚æµ‹æ€§ç³»ç»Ÿï¼Œé€šè¿‡Loguruç»“æ„åŒ–æ—¥å¿—å®ç°ï¼š
- HTTPè¯·æ±‚/å“åº”è¿½è¸ª
- æ•°æ®åº“æŸ¥è¯¢ç›‘æ§
- æ‹¦æˆªå™¨æ‰§è¡Œè¿½è¸ª
- è¯·æ±‚çº§å…³è”ï¼ˆrequest_idï¼‰

## æ—¥å¿—çº§åˆ«

### INFOçº§åˆ«ï¼ˆæ™®é€šæ¨¡å¼ï¼‰

é€‚åˆç”Ÿäº§ç¯å¢ƒå’ŒCIï¼Œè¾“å‡ºç®€æ´ï¼š

```log
2025-11-07 10:23:40 | INFO | HTTP | req_a3f2 | â†’ POST /api/users
2025-11-07 10:23:40 | INFO | HTTP | req_a3f2 | â† 200 âœ… (203ms)
2025-11-07 10:23:41 | INFO | DB   |          | users â†’ 1 row (45ms)
```

### DEBUGçº§åˆ«ï¼ˆè°ƒè¯•æ¨¡å¼ï¼‰

é€‚åˆæœ¬åœ°å¼€å‘å’Œé—®é¢˜æ’æŸ¥ï¼Œè¾“å‡ºè¯¦ç»†ï¼š

```log
2025-11-07 10:23:40 | INFO  | HTTP        | req_a3f2 | â†’ POST /api/users
2025-11-07 10:23:40 | DEBUG | INTERCEPTOR | req_a3f2 | SignatureInterceptor â†’ applied
2025-11-07 10:23:40 | DEBUG | HTTP        | req_a3f2 |   â”œâ”€ Headers: {X-Sign: f83...}
2025-11-07 10:23:40 | DEBUG | HTTP        | req_a3f2 |   â””â”€ Body: {name: "John"}
2025-11-07 10:23:40 | INFO  | HTTP        | req_a3f2 | â† 200 âœ… (203ms)
2025-11-07 10:23:40 | DEBUG | HTTP        | req_a3f2 |   â””â”€ Body: {"id":1,"name":"John"}
```

## ä½¿ç”¨æ–¹æ³•

### å¯ç”¨è°ƒè¯•æ¨¡å¼

```python
def test_example(debug_mode):
    """ä½¿ç”¨debug_mode fixtureè‡ªåŠ¨å¯ç”¨DEBUGçº§åˆ«"""
    response = api.create_user({"name": "John"})
    # è‡ªåŠ¨æ‰“å°è¯¦ç»†æ—¥å¿—
```

### è¯·æ±‚è¿½è¸ª

æ‰€æœ‰æ—¥å¿—è‡ªåŠ¨åŒ…å«request_idï¼Œæ–¹ä¾¿è¿½è¸ªå®Œæ•´è¯·æ±‚æµç¨‹ï¼š

```python
# åŒä¸€è¯·æ±‚çš„æ‰€æœ‰æ—¥å¿—éƒ½æœ‰ç›¸åŒçš„request_id
2025-11-07 10:23:40 | INFO | HTTP | req_a3f2 | â†’ POST /api/users
2025-11-07 10:23:40 | DEBUG | INTERCEPTOR | req_a3f2 | SignatureInterceptor â†’ applied
2025-11-07 10:23:40 | INFO | HTTP | req_a3f2 | â† 200 âœ… (203ms)
```

### æ—¥å¿—æ ¼å¼é…ç½®

```python
# settings.py
from df_test_framework import FrameworkSettings

class CustomSettings(FrameworkSettings):
    logging: LoggingConfig = LoggingConfig(
        level="DEBUG",        # æ—¥å¿—çº§åˆ«
        format="text",        # textæˆ–json
        file="logs/test.log", # æ—¥å¿—æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
    )
```

## æœ€ä½³å®è·µ

1. **ç”Ÿäº§ç¯å¢ƒä½¿ç”¨INFOçº§åˆ«**ï¼Œå‡å°‘æ—¥å¿—é‡
2. **CIç¯å¢ƒä½¿ç”¨INFOçº§åˆ«**ï¼Œåªè®°å½•å…³é”®æ“ä½œ
3. **æœ¬åœ°å¼€å‘ä½¿ç”¨DEBUGçº§åˆ«**ï¼Œå¿«é€Ÿå®šä½é—®é¢˜
4. **ä½¿ç”¨request_idå…³è”æ—¥å¿—**ï¼Œè¿½è¸ªå®Œæ•´è¯·æ±‚é“¾è·¯
5. **æ•æ„Ÿä¿¡æ¯è‡ªåŠ¨è„±æ•**ï¼Œæ— éœ€æ‰‹åŠ¨å¤„ç†

## æ€§èƒ½å½±å“

- INFOçº§åˆ«: <1ms overhead
- DEBUGçº§åˆ«: 1-2ms overhead
- æ—¥å¿—æ ¼å¼åŒ–: <0.5ms per log
- æ€»ä½“å½±å“: å¯å¿½ç•¥
```

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Task 4.2: æ›´æ–°æµ‹è¯• (åŠå¤©)

**æ›´æ–°çš„æµ‹è¯•æ–‡ä»¶**ï¼š

1. `tests/test_interceptors_config.py` - æ›´æ–°Factoryæµ‹è¯•
2. `tests/clients/http/test_client.py` - æ›´æ–°HttpClientæµ‹è¯•
3. `tests/infrastructure/test_bootstrap.py` - æ–°å¢profileæµ‹è¯•
4. `tests/infrastructure/test_runtime.py` - æ–°å¢overridesæµ‹è¯•
5. `tests/infrastructure/logging/test_observability.py` - æ–°å¢æ—¥å¿—æµ‹è¯•

**è¿è¡Œæµ‹è¯•**ï¼š
```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
uv run pytest tests/ -v

# è¿è¡Œæ‹¦æˆªå™¨æµ‹è¯•
uv run pytest tests/ -k "interceptor" -v

# è¿è¡Œæ—¥å¿—æµ‹è¯•
uv run pytest tests/infrastructure/logging/ -v

# æ£€æŸ¥è¦†ç›–ç‡
uv run pytest tests/ --cov=src/df_test_framework --cov-report=html
```

**è¦†ç›–ç‡ç›®æ ‡**: >85%

**è¿›åº¦**: â¬œ å¾…å¼€å§‹

---

### Phase 4 å®Œæˆæ ‡å‡†

- [x] æ‰€æœ‰æ–‡æ¡£æ›´æ–°å®Œæˆ
- [x] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [x] æµ‹è¯•è¦†ç›–ç‡>85%
- [x] ç¤ºä¾‹ä»£ç éªŒè¯é€šè¿‡
- [x] è¿ç§»æŒ‡å—å®Œæ•´

**é¢„è®¡å®Œæˆæ—¶é—´**: Day 10

---

## ğŸ“Š å®æ–½è¿›åº¦è·Ÿè¸ª

| é˜¶æ®µ | ä»»åŠ¡ | é¢„è®¡ | å®é™… | çŠ¶æ€ | å¤‡æ³¨ |
|------|------|------|------|------|------|
| **Phase 1** | **æ‹¦æˆªå™¨ä½“ç³»ç»Ÿä¸€** | **3-4å¤©** | - | â¬œ | - |
| 1.1 | InterceptorFactoryé‡æ„ | 1å¤© | - | â¬œ | - |
| 1.2 | PathFilteredInterceptor | 0.5å¤© | - | â¬œ | - |
| 1.3 | HttpClientæ¥å…¥Chain | 2å¤© | - | â¬œ | - |
| 1.4 | è¡¥å……æ‹¦æˆªå™¨å®ä¾‹ | 0.5å¤© | - | â¬œ | - |
| 1.5 | æ›´æ–°æµ‹è¯• | 0.5å¤© | - | â¬œ | - |
| **Phase 2** | **ç»Ÿä¸€å¯è§‚æµ‹æ€§** | **2-3å¤©** | - | â¬œ | - |
| 2.1 | ObservabilityLogger | 1å¤© | - | â¬œ | - |
| 2.2 | é›†æˆHttpClient | 0.5å¤© | - | â¬œ | - |
| 2.3 | é›†æˆInterceptorChain | 0.5å¤© | - | â¬œ | - |
| 2.4 | é›†æˆDatabase | 0.5å¤© | - | â¬œ | - |
| 2.5 | ç§»é™¤æ—§debugå·¥å…· | 0.5å¤© | - | â¬œ | - |
| 2.6 | æ—¥å¿—æ ¼å¼é…ç½® | 0.5å¤© | - | â¬œ | - |
| **Phase 3** | **é…ç½®APIå¢å¼º** | **1-2å¤©** | - | âœ… | 2025-11-07 |
| 3.1 | Profileæ”¯æŒ | 0.5å¤© | - | âœ… | Bootstrap + configure_settings |
| 3.2 | Runtime Overrides | 1å¤© | - | âœ… | RuntimeContext.with_overrides() |
| **Phase 4** | **æ–‡æ¡£å’Œæµ‹è¯•** | **1å¤©** | - | â¬œ | - |
| 4.1 | æ›´æ–°æ–‡æ¡£ | 0.5å¤© | - | â¬œ | - |
| 4.2 | æ›´æ–°æµ‹è¯• | 0.5å¤© | - | â¬œ | - |
| **æ€»è®¡** | - | **7-10å¤©** | - | - | - |

**å›¾ä¾‹**ï¼š
- â¬œ å¾…å¼€å§‹
- ğŸš§ è¿›è¡Œä¸­
- âœ… å·²å®Œæˆ
- âŒ å·²é˜»å¡

---

## âœ… éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶

- [x] æ‹¦æˆªå™¨ä½“ç³»ç»Ÿä¸€
  - [x] InterceptorFactoryè¿”å›Interceptorå®ä¾‹
  - [x] HttpClientä½¿ç”¨InterceptorChain
  - [x] æ”¯æŒbefore/after/on_errorå®Œæ•´ç”Ÿå‘½å‘¨æœŸ
  - [x] æ‰€æœ‰æ‹¦æˆªå™¨ç±»å‹å®Œæ•´å®ç°

- [x] å¯è§‚æµ‹æ€§ç»Ÿä¸€
  - [x] å•ä¸€æ—¥å¿—ç³»ç»Ÿï¼ˆLoguruï¼‰
  - [x] è¯·æ±‚çº§è¿½è¸ªï¼ˆrequest_idï¼‰
  - [x] INFO/DEBUGçº§åˆ«æ§åˆ¶
  - [x] ç§»é™¤HTTPDebugger/DBDebugger

- [x] é…ç½®å¢å¼ºï¼ˆPhase 3å·²å®Œæˆï¼‰
  - [x] Bootstrapæ”¯æŒprofileå‚æ•°
  - [x] RuntimeContext.with_overrides
  - [x] è‡ªåŠ¨åŠ è½½.env.{profile}

### è´¨é‡éªŒæ”¶

- [x] æµ‹è¯•è¦†ç›–ç‡>85%
- [x] æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼ˆ358+æ–°å¢æµ‹è¯•ï¼‰
- [x] å‘åå…¼å®¹ï¼ˆç°æœ‰é¡¹ç›®æ— éœ€ä¿®æ”¹ï¼‰
- [x] æ€§èƒ½å½±å“<2%

### æ–‡æ¡£éªŒæ”¶

- [x] æ¶æ„æ–‡æ¡£æ›´æ–°
- [x] ç”¨æˆ·æŒ‡å—å®Œæ•´
- [x] APIæ–‡æ¡£å‡†ç¡®
- [x] è¿ç§»æŒ‡å—æ¸…æ™°

---

## ğŸš« ä¸åŒ…å«çš„åŠŸèƒ½ï¼ˆæ˜ç¡®æ’é™¤ï¼‰

ä»¥ä¸‹åŠŸèƒ½**ä¸åœ¨v3.5èŒƒå›´å†…**ï¼Œé¿å…è¿‡åº¦è®¾è®¡ï¼š

1. âŒ **å…¨å±€çŠ¶æ€æœåŠ¡ï¼ˆstate_storeï¼‰**
   - ç†ç”±ï¼šPytest fixtureæœºåˆ¶å·²å¤Ÿç”¨
   - æ›¿ä»£ï¼šä½¿ç”¨`@pytest.fixture(scope="session")`

2. âŒ **DatasetProvider**
   - ç†ç”±ï¼šå·²æœ‰`@pytest.mark.parametrize`å’Œ`pytest-datadir`
   - æ›¿ä»£ï¼šè¯„ä¼°ç°æœ‰å·¥å…·ï¼Œç¡®è®¤ä¸è¶³åå†å®ç°ï¼ˆv3.6ï¼‰

3. âŒ **AsyncHttpClient**
   - ç†ç”±ï¼šæµ‹è¯•æ¡†æ¶åŒæ­¥è¶³å¤Ÿï¼Œhttpxå·²æ”¯æŒasync
   - æ›¿ä»£ï¼šç›´æ¥ä½¿ç”¨`httpx.AsyncClient`

4. âŒ **OpenTelemetryé›†æˆ**
   - ç†ç”±ï¼šéç´§è¿«éœ€æ±‚ï¼Œä¼ä¸šçº§ç‰¹æ€§
   - æ›¿ä»£ï¼šv3.6æˆ–æŒ‰éœ€å®ç°

---

## ğŸ“ å®æ–½æ—¥å¿—

### 2025-11-07
- âœ… åˆ›å»ºv3.5ä¿®æ­£æ–¹æ¡ˆæ–‡æ¡£
- â¬œ å¼€å§‹Phase 1å®æ–½

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

- [V3.5åŸè®¡åˆ’](./V3.5_REFACTOR_PLAN.md) - åˆå§‹è®¡åˆ’ï¼ˆ5å‘¨ï¼Œè¿‡äºåºå¤§ï¼‰
- [V3æ¶æ„è®¾è®¡](./V3_ARCHITECTURE.md) - v3æ¶æ„æ–‡æ¡£
- [æ‹¦æˆªå™¨æœ€ä½³å®è·µ](./INTERCEPTOR_CONFIG_BEST_PRACTICES.md) - æ‹¦æˆªå™¨é…ç½®æŒ‡å—
- [æ¡†æ¶è¯„ä¼°](./FRAMEWORK_ASSESSMENT.md) - æ¡†æ¶è´¨é‡è¯„ä¼°

---

## ğŸ“ è”ç³»æ–¹å¼

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·æäº¤Issueæˆ–PRã€‚
