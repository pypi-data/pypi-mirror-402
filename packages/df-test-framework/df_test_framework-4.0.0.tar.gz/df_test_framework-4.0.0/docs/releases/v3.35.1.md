# v3.35.1 发布说明 - 嵌套配置深度合并修复

**发布日期**: 2025-12-18

## 概述

v3.35.1 修复了 v3.35.0 中 YAML 分层配置与环境变量/secrets 深度合并的问题，并增强了自定义配置类支持。

## 问题修复

### 1. 嵌套配置深度合并失败

**问题描述**: 当 `config/secrets/.env.local` 中设置 `SIGNATURE__SECRET=xxx` 时，Pydantic Settings v2 会创建一个只包含 `{secret: xxx}` 的对象，完全覆盖 YAML 配置中的完整配置，导致 `algorithm` 等必需字段丢失。

**错误信息**:
```
signature.algorithm
  Field required [type=missing, input_value={'secret': '******'}, input_type=dict]
```

**修复方案**:
- 手动解析环境变量并转换为嵌套字典
- 与 YAML 配置进行深度合并
- 创建禁用 Pydantic 环境变量解析的临时子类

### 2. pytest 插件执行顺序错误

**问题描述**: `core.pytest_configure` 在 `env_plugin.pytest_configure` 之前执行，导致 `ConfigRegistry.is_initialized()` 返回 `False`。

**修复方案**: 在 `env_plugin.pytest_configure` 添加 `@hookimpl(tryfirst=True)` 装饰器。

### 3. 配置类不匹配

**问题描述**: `ConfigLoader` 只返回 `FrameworkSettings` 实例，项目自定义配置类（如 `GiftCardSettings`）的额外字段丢失。

**修复方案**:
- `ConfigLoader` 支持 `settings_class` 参数
- `env_plugin` 自动从 `df_settings_class` 配置获取项目配置类

## 功能增强

### 1. ConfigLoader 支持自定义配置类

```python
from df_test_framework.infrastructure.config import ConfigLoader
from myproject.config import MySettings

# 使用自定义配置类
loader = ConfigLoader(config_dir="config", settings_class=MySettings)
settings = loader.load("staging")

# settings 是 MySettings 实例，包含所有自定义字段
print(settings.business.api_key)
```

### 2. ConfigRegistry 支持自定义配置类

```python
from df_test_framework.infrastructure.config import ConfigRegistry
from myproject.config import MySettings

# 初始化时指定配置类
ConfigRegistry.initialize("staging", "config", settings_class=MySettings)

# 或创建实例时指定
registry = ConfigRegistry.for_environment("staging", "config", MySettings)
```

### 3. env_plugin 自动获取项目配置类

从 `pyproject.toml` 的 `df_settings_class` 配置自动获取：

```toml
[tool.pytest.ini_options]
df_settings_class = "myproject.config.MySettings"
```

## 配置优先级（确认）

```
1. 环境变量（最高优先级）
2. config/secrets/.env.local（敏感配置）
3. config/environments/{env}.yaml
4. config/base.yaml
5. 代码默认值（最低优先级）
```

## 修改文件清单

| 文件路径 | 修改类型 | 说明 |
|---------|---------|------|
| `infrastructure/config/loader.py` | 增强 | 深度合并 + 自定义配置类 |
| `infrastructure/config/registry.py` | 增强 | settings_class 参数 |
| `testing/plugins/env_plugin.py` | 增强 | hookimpl(tryfirst) + 配置类解析 |
| `testing/fixtures/core.py` | 增强 | ConfigRegistry 集成 |
| `tests/infrastructure/config/test_loader.py` | 修复 | 环境变量清理 fixture |
| `tests/infrastructure/config/test_registry.py` | 修复 | 环境变量清理 fixture |

## 升级指南

### 从 v3.35.0 升级

1. **无需修改代码**: 修复完全向后兼容

2. **可选优化**: 删除根目录的 `.env` 文件，将敏感配置移到 `config/secrets/.env.local`

3. **确保 conftest.py 配置正确**:
```python
pytest_plugins = [
    "df_test_framework.testing.plugins.env_plugin",  # 必须在最前面
    "df_test_framework.testing.fixtures.core",
    # ...其他插件
]
```

4. **确保 pyproject.toml 中有 df_settings_class 配置**:
```toml
[tool.pytest.ini_options]
df_settings_class = "your_project.config.YourSettings"
```

## 测试验证

```bash
# 框架测试
uv run pytest tests/infrastructure/config/ -v
# 结果: 80 passed

# 项目测试（无 .env 文件）
rm .env  # 删除根目录 .env
pytest tests/ -v
# 结果: 全部通过
```

## 技术细节

### 深度合并实现

```python
def _deep_merge(self, base: dict, override: dict) -> dict:
    """深度合并配置"""
    result = base.copy()
    for key, value in override.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = self._deep_merge(result[key], value)
        else:
            result[key] = value
    return result
```

### 环境变量转嵌套字典

```python
def _env_vars_to_nested_dict(self, env_vars: dict) -> dict:
    """将环境变量转换为嵌套字典

    Example:
        >>> _env_vars_to_nested_dict({"SIGNATURE__SECRET": "xxx"})
        {"signature": {"secret": "xxx"}}
    """
    result = {}
    for key, value in env_vars.items():
        parts = key.lower().split("__")
        current = result
        for part in parts[:-1]:
            current = current.setdefault(part, {})
        current[parts[-1]] = self._parse_env_value(value)
    return result
```

### 禁用 Pydantic 环境变量解析

```python
def _create_settings(self, config: dict) -> FrameworkSettings:
    base_class = self.settings_class or FrameworkSettings

    class _SettingsNoEnv(base_class):
        model_config = SettingsConfigDict(
            env_file=None,
            secrets_dir=None,
        )

        @classmethod
        def settings_customise_sources(cls, settings_cls, init_settings, ...):
            return (init_settings,)  # 只使用 init_settings

    return _SettingsNoEnv(**config)
```
