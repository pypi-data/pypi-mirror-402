# v3.19.0 发布说明 - 认证控制增强

**发布日期**: 2025-12-11

---

## 核心特性

新增请求级别认证控制，支持跳过认证和自定义 Token，解决认证测试场景中的隔离问题。

---

## 背景问题

在进行认证相关测试时，经常遇到以下场景：

1. **测试未认证场景**：某些接口需要验证"未登录时返回错误"
2. **测试完整认证流程**：登录 → 操作 → 登出 → 验证无法访问
3. **测试特定 Token**：需要用登录返回的特定 Token 进行后续操作

现有的 `BearerTokenMiddleware` 会自动登录并缓存 Token，导致：

- 无法测试"未认证"场景（该接口在别的场景需要认证，不能添加到 `exclude_paths`）
- 登出后中间件仍使用缓存的（已失效的）Token
- 无法手动控制使用哪个 Token

### 关于 httpx 状态共享

**Q**: httpx 是否会自动共享登录状态？如果一条测试用例登出了，后续测试会失败吗？

**A**:

| 层面 | 说明 |
|------|------|
| **httpx 本身** | 不共享状态。每个 `httpx.Client` 实例有独立的 Cookie Jar，不会跨实例共享 |
| **问题在框架层** | `BearerTokenMiddleware` 缓存 Token。如果 fixture 是 session scope，多个测试共享同一个中间件实例 |
| **影响** | 一个测试登出后，中间件缓存的 Token 失效，后续测试继续使用该 Token 会失败 |
| **解决方案** | 使用 `token` 参数传入特定 Token，或用 `clear_auth_cache()` 清除缓存 |

**问题场景示例**：

```
如果 admin_auth_api 是 session scope 的 fixture：

Test 1: test_admin_logout
    └── 登出 → 服务端让 Token 失效
    └── 但中间件缓存的 Token 没有清除！

Test 2: test_full_auth_flow
    └── 中间件继续使用已失效的缓存 Token
    └── ❌ 401 Unauthorized
```

### 完整认证流程测试

`test_full_auth_flow` 的核心测试逻辑：

```
┌─────────────────────────────────────────────────────────────┐
│                   test_full_auth_flow                       │
│                                                             │
│  1. 登录 ──────────────────────> 获取 Token A               │
│                                                             │
│  2. 用 Token A 获取用户 ────────> ✅ 成功                    │
│                                                             │
│  3. 用 Token A 登出 ────────────> 服务端让 Token A 失效      │
│                                                             │
│  4. 用 Token A 获取用户 ────────> ❌ 应该失败（Token A 无效）│
│                                                             │
│     关键：步骤 2 和 4 必须用同一个 Token A                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 解决方案

### 1. `skip_auth` 参数 - 跳过认证

```python
# 测试未认证场景
def test_get_current_user_without_login(admin_auth_api):
    with pytest.raises((BusinessError, HTTPStatusError)):
        admin_auth_api.get_current_user(skip_auth=True)  # 不添加 Token
```

### 2. `token` 参数 - 使用自定义 Token

```python
# 测试完整认证流程
def test_full_auth_flow(admin_auth_api, settings):
    # 1. 登录，获取 Token
    login_response = admin_auth_api.login(username, password)
    token = login_response.data.token  # 拿到 Token A

    # 2. 用 Token A 获取当前用户
    user_response = admin_auth_api.get_current_user(token=token)
    assert user_response.success

    # 3. 登出（服务端让 Token A 失效）
    admin_auth_api.logout(token=token)

    # 4. 继续用 Token A（已失效），验证无法访问
    with pytest.raises((BusinessError, HTTPStatusError)):
        admin_auth_api.get_current_user(token=token)  # 同一个 Token A
```

### 3. `clear_auth_cache()` - 清除 Token 缓存

```python
# 登出后清除缓存，让下次请求重新登录
admin_auth_api.logout()
http_client.clear_auth_cache()

# 下次请求会重新登录获取新 Token
admin_auth_api.get_current_user()
```

---

## API 变更

### Request 类

```python
@dataclass(frozen=True)
class Request:
    # 现有字段...

    # v3.19.0 新增
    metadata: dict[str, Any] = field(default_factory=dict)

    def with_metadata(self, key: str, value: Any) -> "Request":
        """设置元数据（返回新实例）"""

    def get_metadata(self, key: str, default: Any = None) -> Any:
        """获取元数据"""
```

### BaseAPI 方法签名

所有 HTTP 方法（get/post/put/delete/patch）新增参数：

```python
def get(
    self,
    endpoint: str,
    model: type[T] | None = None,
    skip_auth: bool = False,      # v3.19.0 新增
    token: str | None = None,     # v3.19.0 新增
    **kwargs,
) -> T | dict[str, Any]:
```

### BearerTokenMiddleware

```python
class BearerTokenMiddleware:
    def clear_cache(self) -> None:
        """清除缓存的 Token（v3.19.0）"""
```

### HttpClient

```python
class HttpClient:
    def clear_auth_cache(self) -> None:
        """清除所有认证中间件的缓存（v3.19.0）"""
```

---

## 使用场景覆盖

| 测试场景 | 用法 |
|----------|------|
| 正常业务测试 | 默认行为，中间件自动认证 |
| 测试未认证场景 | `api.method(skip_auth=True)` |
| 测试特定 Token | `api.method(token="xxx")` |
| 登出后重置状态 | `http_client.clear_auth_cache()` |

---

## 向后兼容性

- ✅ 所有改动向后兼容
- ✅ 现有代码无需修改
- ✅ 新参数均为可选，默认行为不变

---

## 迁移指南

无需迁移。如需使用新功能，直接添加 `skip_auth` 或 `token` 参数即可。

---

## 测试

新增测试文件：`tests/unit/clients/http/test_auth_control.py`

测试覆盖：

- ✅ Request.metadata 功能
- ✅ skip_auth 跳过认证
- ✅ custom_token 自定义 Token
- ✅ clear_cache 清除缓存

---

## 设计说明

### 为什么只针对 BearerTokenMiddleware？

v3.19.0 的 `skip_auth` 和 `token` 参数只针对 `BearerTokenMiddleware`，因为：

1. **认证控制是最常见的需求**：测试中经常需要模拟未登录、使用特定 Token 等场景
2. **Request.metadata 是通用机制**：其他中间件可以复用相同的模式

### 其他中间件如何实现类似功能？

`Request.metadata` 是通用的元数据机制，任何中间件都可以使用：

```python
# SignatureMiddleware 可以检查
request.get_metadata("skip_signature")  # 跳过签名

# RetryMiddleware 可以检查
request.get_metadata("skip_retry")      # 跳过重试
request.get_metadata("max_retries")     # 覆盖重试次数
```

### 未来扩展方向

如果需要更通用的中间件控制，可以考虑：

**方案 A：通用跳过机制**
```python
# 跳过指定中间件
api.get("/users", skip_middlewares=["BearerToken", "Signature"])
```

**方案 B：中间件配置字典**
```python
# 灵活配置每个中间件
api.get("/users", middleware_options={
    "BearerToken": {"skip": True},
    "Retry": {"max_retries": 5},
})
```

当前方案（每个中间件定义自己的 metadata key）在大多数场景下足够使用。

---

## 参考

- [中间件使用指南](../guides/middleware_guide.md) - BearerTokenMiddleware 四种模式
- [CHANGELOG](../../CHANGELOG.md)
