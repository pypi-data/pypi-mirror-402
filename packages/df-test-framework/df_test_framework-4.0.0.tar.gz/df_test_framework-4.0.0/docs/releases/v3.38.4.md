# v3.38.4 - structlog 最佳实践改进

**发布日期**: 2025-12-25

## 概述

本版本完善了 structlog 的实现，使其完全符合官方最佳实践。主要改进包括：使用 `ProcessorFormatter` 统一第三方日志格式、支持 ISO 8601 + UTC 时间戳、orjson 高性能 JSON 序列化，以及异步日志接口。

## 核心改进

### 1. ProcessorFormatter 统一第三方日志格式

**问题**: v3.38.2 中，第三方库（httpx、sqlalchemy 等）的日志格式与 structlog 不一致，缺少 trace_id、统一时间戳等关键字段。

**解决方案**: 使用 `ProcessorFormatter` 作为 `logging.Formatter`，统一处理所有日志：

```python
# 现在第三方日志也会有统一格式
processor_formatter = structlog.stdlib.ProcessorFormatter(
    # 第三方日志的预处理链
    foreign_pre_chain=shared_processors,
    # 最终渲染处理器
    processors=[
        structlog.stdlib.ProcessorFormatter.remove_processors_meta,
        renderer,
    ],
)
```

**效果**:
- httpx 请求日志包含 trace_id
- sqlalchemy SQL 日志有统一时间戳
- 所有日志格式一致，便于聚合分析

### 2. ISO 8601 + UTC 时间戳

**最佳实践**: 生产环境应使用 ISO 8601 格式 + UTC 时区，便于日志聚合系统解析。

**配置方式**:

```yaml
# config/prod.yaml
logging:
  level: INFO
  format: json
  use_utc: true  # 新增配置项
```

**输出格式对比**:

```json
// use_utc: false（开发环境，本地时间）
{"timestamp": "2025-12-25 15:30:45.123456", ...}

// use_utc: true（生产环境，ISO 8601 + UTC）
{"timestamp": "2025-12-25T07:30:45.123456Z", ...}
```

**注意**: 当 `format: json` 时，自动启用 ISO 8601 + UTC 时间戳。

### 3. orjson 高性能 JSON 序列化

**性能提升**: orjson 比标准库 json 快 5-10 倍。

**安装**:

```bash
# 方式 1: 单独安装
pip install orjson

# 方式 2: 使用 performance 依赖组
pip install df-test-framework[performance]
```

**配置**:

```yaml
logging:
  format: json
  use_orjson: true  # 默认值，如果 orjson 已安装则自动使用
```

**检查是否可用**:

```python
from df_test_framework.infrastructure.logging import is_orjson_available

if is_orjson_available():
    print("orjson 已启用，JSON 序列化性能优化")
```

### 4. CallsiteParameterAdder 调用位置信息

**用途**: 在日志中添加调用位置信息（文件名、函数名、行号），便于调试。

**配置**:

```yaml
logging:
  add_callsite: true  # 默认 false
```

**输出示例**:

```json
{
  "event": "用户登录",
  "user_id": 123,
  "filename": "auth.py",
  "func_name": "login",
  "lineno": 42
}
```

**注意**: 会增加少量性能开销，建议仅在开发/调试时启用。

### 5. AsyncLogger Protocol

**用途**: 为异步应用提供非阻塞日志方法。

**接口定义**:

```python
from df_test_framework.infrastructure.logging import AsyncLogger

async def handle_request(logger: AsyncLogger):
    # 异步方法在独立线程池执行，不阻塞主协程
    await logger.ainfo("处理请求", request_id="abc123")
    await logger.adebug("调试信息")
    await logger.aerror("错误信息")
```

**适用场景**:
- 高并发异步应用
- I/O 密集型场景
- 需要 JSON 序列化大量数据时

## 新增配置项

| 配置项 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `use_utc` | bool | false | 使用 UTC 时间戳（ISO 8601 格式） |
| `use_orjson` | bool | true | 使用 orjson 序列化（如果已安装） |
| `add_callsite` | bool | false | 添加调用位置信息 |

## 配置示例

### 开发环境

```yaml
# config/dev.yaml
logging:
  level: DEBUG
  format: text
  sanitize: true
  add_callsite: true  # 开发时启用，便于调试
```

### 生产环境

```yaml
# config/prod.yaml
logging:
  level: INFO
  format: json
  use_utc: true       # 生产环境使用 UTC
  use_orjson: true    # 启用高性能序列化
  file: logs/app.log
  rotation: "500 MB"
  retention: "30 days"
```

## 迁移指南

### 从 v3.38.2 升级

无破坏性变更，直接升级即可。新配置项都有合理默认值。

**可选优化**:

1. 安装 orjson 获得性能提升：
   ```bash
   pip install orjson
   ```

2. 生产环境启用 UTC 时间戳：
   ```yaml
   logging:
     use_utc: true
   ```

## 技术细节

### Processor 链执行顺序

```
1. merge_contextvars      # 合并上下文变量
2. add_log_level          # 添加日志级别
3. add_logger_name        # 添加 logger 名称
4. _sanitize_sensitive_data  # 脱敏（如果启用）
5. TimeStamper            # 添加时间戳
6. CallsiteParameterAdder # 添加调用位置（如果启用）
7. _add_trace_info        # 添加 OpenTelemetry trace
8. StackInfoRenderer      # 渲染堆栈信息
9. format_exc_info        # 格式化异常
10. UnicodeDecoder        # Unicode 解码
11. wrap_for_formatter    # 包装为 ProcessorFormatter 格式
```

### 第三方日志处理流程

```
第三方库日志 (httpx, sqlalchemy, etc.)
    ↓
logging.Logger
    ↓
ProcessorFormatter (foreign_pre_chain)
    ↓
统一格式输出
```

## 测试

- 全部 1893 个测试通过
- 日志模块 20 个测试全部通过

## TimeMocker 修复

### 问题

`time_mock` fixture 的 `tick()` 和 `move_to()` 方法在 freezegun 1.5+ 版本无法正常工作。

### 原因

freezegun 的 API 变更：`freeze_time().start()` 返回 `FrozenDateTimeFactory` 对象（包含 `tick()`/`move_to()` 方法），而非 `_freeze_time` 对象。

### 修复

正确存储 `FrozenDateTimeFactory` 实例：

```python
# 修复前
self._current_freeze = freeze_time(time_to_freeze)
self._current_freeze.start()  # 返回值被忽略
self._current_freeze.tick(...)  # ❌ 报错

# 修复后
self._freeze_time_obj = freeze_time(time_to_freeze)
self._frozen_factory = self._freeze_time_obj.start()  # 保存返回值
self._frozen_factory.tick(...)  # ✅ 正常工作
```

### freezegun 使用注意事项

**重要**: 使用 `time_mock` fixture 时，必须使用 `import datetime` 而非 `from datetime import datetime`：

```python
# ✅ 正确 - freezegun 可以 patch
import datetime
now = datetime.datetime.now()

# ❌ 错误 - freezegun 无法 patch
from datetime import datetime
now = datetime.now()
```

这是 freezegun 的已知限制：`from X import Y` 在导入时获取原始对象引用，后续的 monkey-patch 无法影响它。

## 依赖变更

### 新增核心依赖

```toml
dependencies = [
    # ...
    "freezegun>=1.5.0",  # time_mock fixture 需要
]
```

### 新增可选依赖

```toml
[project.optional-dependencies]
performance = [
    "orjson>=3.9.0",
]
```

### all 依赖组更新

```toml
all = [
    # ... 其他依赖
    "orjson>=3.9.0",  # 新增
]
```
