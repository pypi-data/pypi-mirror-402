# v3.20.0 发布说明 - HTTP 能力完善

**发布日期**: 2025-12-12

---

## 核心特性

完善 HTTP 客户端能力，新增 multipart/form-data 文件上传、raw body 二进制数据支持，以及 HEAD/OPTIONS HTTP 方法。

---

## 背景问题

现有框架 HTTP 客户端仅支持 GET/POST/PUT/DELETE/PATCH 方法和 JSON/表单编码两种 Content-Type，缺少：

1. **文件上传**：无法发送 `multipart/form-data` 请求
2. **二进制数据**：无法发送 `application/octet-stream` 请求
3. **HEAD 方法**：无法检查资源存在性和获取元数据
4. **OPTIONS 方法**：无法进行 CORS 预检和获取 API 元信息

### 典型场景

| 场景 | 现有支持 | v3.20.0 |
|------|----------|---------|
| 上传图片/文件 | ❌ | ✅ `files` 参数 |
| 混合表单（文字+图片） | ❌ | ✅ `with_form_field` + `with_file` |
| 发送二进制流 | ❌ | ✅ `content` 参数 |
| 检查资源是否存在 | ❌ | ✅ `head()` 方法 |
| CORS 预检 | ❌ | ✅ `options()` 方法 |

---

## 解决方案

### 1. 文件上传 - `files` 参数

支持 httpx 原生的 `files` 参数格式：

```python
from df_test_framework import BaseAPI

class UploadAPI(BaseAPI):
    def upload_image(self, image_bytes: bytes) -> dict:
        return self.post(
            "/upload",
            files={"image": ("photo.jpg", image_bytes, "image/jpeg")}
        )

    def upload_with_form(self, name: str, image_bytes: bytes) -> dict:
        # 混合表单：文字字段 + 文件
        return self.post(
            "/templates",
            files={
                "name": (None, name.encode(), None),  # 表单字段
                "image": ("photo.jpg", image_bytes, "image/jpeg"),  # 文件
            }
        )
```

### 2. Request 链式 API

使用不可变的 `with_*` 方法链式构建请求：

```python
from df_test_framework import Request

request = (
    Request(method="POST", url="/templates")
    .with_form_field("name", "模板名称")
    .with_form_field("price", "100.00")
    .with_file("image", ("photo.jpg", image_bytes, "image/jpeg"))
)
```

### 3. 二进制数据 - `content` 参数

发送原始字节或文本：

```python
# 发送二进制流
response = http_client.post(
    "/upload/binary",
    content=binary_data,
    headers={"Content-Type": "application/octet-stream"}
)

# 发送纯文本
response = http_client.post(
    "/webhook",
    content="plain text payload",
    headers={"Content-Type": "text/plain"}
)
```

### 4. HEAD/OPTIONS 方法

```python
# HEAD - 检查资源存在性
response = api.head("/files/123")
if response.status_code == 200:
    content_length = response.headers.get("Content-Length")

# OPTIONS - CORS 预检
response = api.options("/api/users")
allowed_methods = response.headers.get("Allow")
```

---

## API 变更

### Request 类

```python
from typing import Union, BinaryIO

# 类型定义
FileContent = Union[bytes, BinaryIO]
FileTypes = Union[
    bytes,                                          # 简单字节
    tuple[str, FileContent],                        # (filename, content)
    tuple[str | None, FileContent, str | None],     # (filename, content, mime)
    tuple[str | None, FileContent, str | None, dict[str, str]],  # + headers
]
FilesTypes = Union[
    dict[str, FileTypes],           # {"field": file}
    list[tuple[str, FileTypes]],    # [("field", file), ...]  支持同名字段
]

@dataclass(frozen=True)
class Request:
    # 现有字段...

    # v3.20.0 新增
    files: FilesTypes | None = None
    content: bytes | str | None = None

    # 链式方法
    def with_file(self, name: str, file: FileTypes) -> "Request": ...
    def with_files(self, files: FilesTypes) -> "Request": ...
    def with_form_field(self, name: str, value: str) -> "Request": ...
    def with_form_fields(self, fields: dict[str, str]) -> "Request": ...
    def with_content(self, content: bytes | str) -> "Request": ...
```

### HttpClient

```python
class HttpClient:
    # 现有方法新增参数
    def post(self, url, json=None, data=None, files=None, content=None, **kwargs): ...
    def put(self, url, json=None, data=None, files=None, content=None, **kwargs): ...
    def patch(self, url, json=None, data=None, files=None, content=None, **kwargs): ...

    # v3.20.0 新增方法
    def head(self, url: str, **kwargs) -> httpx.Response: ...
    def options(self, url: str, **kwargs) -> httpx.Response: ...
```

### BaseAPI

```python
class BaseAPI:
    # 现有方法新增参数
    def post(self, endpoint, model=None, files=None, **kwargs): ...
    def put(self, endpoint, model=None, files=None, **kwargs): ...
    def patch(self, endpoint, model=None, files=None, **kwargs): ...

    # v3.20.0 新增方法
    def head(self, endpoint, skip_auth=False, token=None, **kwargs): ...
    def options(self, endpoint, skip_auth=False, token=None, **kwargs): ...
```

### LoggingMiddleware

新增 files/content 日志支持，记录文件元信息而非文件内容：

```python
class LoggingMiddleware:
    def _format_files_info(self, files) -> str:
        """格式化文件元信息（文件名、大小、MIME 类型）"""

    def _format_content_info(self, content: bytes | str) -> str:
        """格式化 content 信息（类型、大小）"""

    def _extract_file_info(self, field_name: str, file_data) -> str:
        """提取单个文件的元信息"""
```

**日志输出示例**：

```
→ POST /templates
  Files: name(<form field>, 12 bytes), image(cover.jpg, 1024 bytes, image/jpeg)
```

---

## 使用示例

### 示例 1：图片上传

```python
class ImageAPI(BaseAPI):
    def upload(self, image_path: str) -> dict:
        with open(image_path, "rb") as f:
            return self.post(
                "/images",
                files={"file": (Path(image_path).name, f.read(), "image/jpeg")}
            )

def test_upload_image(image_api):
    result = image_api.upload("/tmp/test.jpg")
    assert result["url"].startswith("https://")
```

### 示例 2：混合表单

```python
def test_create_template_with_image(template_api):
    result = template_api.post(
        "/templates",
        files={
            "name": (None, "测试模板".encode("utf-8"), None),
            "description": (None, "模板描述".encode("utf-8"), None),
            "cover": ("cover.jpg", cover_bytes, "image/jpeg"),
        }
    )
    assert result["id"] is not None
```

### 示例 3：多文件上传（同名字段）

```python
def test_batch_upload(upload_api):
    # 使用 list 格式支持同名字段
    files = [
        ("files", ("doc1.pdf", pdf1_bytes, "application/pdf")),
        ("files", ("doc2.pdf", pdf2_bytes, "application/pdf")),
    ]
    result = upload_api.post("/batch-upload", files=files)
    assert len(result["uploaded"]) == 2
```

### 示例 4：二进制数据

```python
def test_upload_binary(api):
    binary_data = b"\x00\x01\x02\x03"
    response = api.client.post(
        "/upload/binary",
        content=binary_data,
        headers={"Content-Type": "application/octet-stream"}
    )
    assert response.status_code == 200
```

### 示例 5：资源检查

```python
def test_file_exists(file_api):
    response = file_api.head("/files/123")

    if response.status_code == 200:
        size = int(response.headers["Content-Length"])
        print(f"文件存在，大小：{size} bytes")
    elif response.status_code == 404:
        print("文件不存在")
```

---

## 向后兼容性

- ✅ 所有改动向后兼容
- ✅ 现有代码无需修改
- ✅ 新参数和方法均为可选

---

## 迁移指南

无需迁移。新功能为增量添加，直接使用即可。

---

## 测试

新增测试文件：`tests/capabilities/clients/http/core/test_request.py`

测试覆盖：
- ✅ `with_file` - 添加单文件
- ✅ `with_files` - 字典和列表格式
- ✅ `with_form_field` - 单个表单字段
- ✅ `with_form_fields` - 批量表单字段
- ✅ `with_content` - bytes 和 str
- ✅ 不可变性验证
- ✅ 类型注解测试

共 19 个测试全部通过。

---

## 技术细节

### httpx 参数对应

| Request 字段 | httpx 参数 | Content-Type |
|-------------|-----------|--------------|
| `json` | `json=` | application/json |
| `data` | `data=` | application/x-www-form-urlencoded |
| `files` | `files=` | multipart/form-data |
| `content` | `content=` | 自定义（需手动设置 header）|

### 优先级规则

当多个 body 参数同时存在时，httpx 按以下优先级处理：

1. `content` - 最高优先级，直接作为请求体
2. `files` - 次优先级，转为 multipart/form-data
3. `json` - 转为 JSON 字符串
4. `data` - 转为 URL 编码

建议每次请求只使用一种 body 参数。

---

## 参考

- [RFC: HTTP 能力完善](../plans/RFC_MULTIPART_FORM_DATA_SUPPORT.md)
- [httpx 文件上传文档](https://www.python-httpx.org/quickstart/#sending-multipart-file-uploads)
- [CHANGELOG](../../CHANGELOG.md)
