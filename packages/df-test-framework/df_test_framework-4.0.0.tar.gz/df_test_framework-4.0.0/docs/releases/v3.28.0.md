# v3.28.0 发布说明 - 调试系统重构与简化

> **发布日期**: 2025-12-14
> **Python 要求**: >= 3.12

---

## 概述

v3.28.0 完成调试系统的统一重构，移除了旧版的 HTTPDebugger 和 DBDebugger，统一使用事件驱动的 ConsoleDebugObserver。新增 `@pytest.mark.debug` marker，允许为特定测试启用调试输出。

---

## 背景

v3.27.0 将 HTTPDebugger 标记为废弃，但保留了代码以向后兼容。经过评估，旧版调试器（HTTPDebugger/DBDebugger）存在以下问题：

1. **手动调用模式** - 需要手动调用 `log_request()`/`log_response()` 等方法
2. **与 EventBus 不兼容** - 无法自动捕获 HTTP/DB 事件
3. **代码重复** - ConsoleDebugObserver 已完全覆盖其功能
4. **维护负担** - 保留废弃代码增加复杂性

同时，用户反馈全局配置 `DEBUG_OUTPUT=false` 时无法为特定测试启用调试，这限制了调试灵活性。

---

## 新增功能

### 1. @pytest.mark.debug marker

为特定测试强制启用调试输出：

```python
import pytest

@pytest.mark.debug
def test_problematic_api(http_client):
    """此测试会输出详细调试信息，无论全局配置如何"""
    response = http_client.post("/api/order", json={"product": "Phone"})
    assert response.status_code == 201

@pytest.mark.debug
class TestDebugAPI:
    """整个类的测试都会输出调试信息"""
    def test_get_users(self, http_client):
        response = http_client.get("/users")
```

### 2. 调试输出控制优先级

新的优先级机制（从高到低）：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        调试输出控制优先级                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. @pytest.mark.debug       ──► 强制启用（最高优先级）                       │
│  2. 显式使用 console_debugger ──► 启用（用户明确请求）                        │
│  3. DEBUG_OUTPUT=true        ──► 全局启用                                   │
│  4. DEBUG_OUTPUT=false       ──► 全局禁用（默认）                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3. 显式 fixture 优先

显式使用 `console_debugger` fixture 时，始终创建调试器：

```python
# 全局配置 DEBUG_OUTPUT=false

def test_normal(http_client):
    """不输出调试信息"""
    pass

def test_with_debug(http_client, console_debugger):
    """输出调试信息 - 显式使用 fixture"""
    pass
```

---

## 移除内容

### 已移除的类

| 类 | 原位置 | 替代方案 |
|----|--------|----------|
| `HTTPDebugger` | `testing/debugging/http.py` | `ConsoleDebugObserver` |
| `DBDebugger` | `testing/debugging/database.py` | `ConsoleDebugObserver` |

### 已移除的 fixture

| fixture | 替代方案 |
|---------|----------|
| `http_debugger` | `console_debugger` |

### 已移除的函数

| 函数 | 替代方案 |
|------|----------|
| `enable_http_debug()` | 使用 `console_debugger` fixture |
| `disable_http_debug()` | fixture 自动管理生命周期 |
| `enable_db_debug()` | 使用 `console_debugger` fixture |
| `disable_db_debug()` | fixture 自动管理生命周期 |
| `get_global_debugger()` | 不再需要 |
| `get_global_db_debugger()` | 不再需要 |

---

## 迁移指南

### 从 HTTPDebugger 迁移

```python
# ❌ 旧方式（已移除）
from df_test_framework.testing.debugging import HTTPDebugger

debugger = HTTPDebugger()
debugger.start()
debugger.log_request("GET", "/api/users")
debugger.log_response(200, {"id": 1})
debugger.print_summary()

# ✅ 新方式：使用 fixture
def test_api(http_client, console_debugger):
    response = http_client.get("/api/users")
    # 调试信息自动输出

# ✅ 新方式：使用 marker
@pytest.mark.debug
def test_api(http_client):
    response = http_client.get("/api/users")
    # 调试信息自动输出
```

### 从 DBDebugger 迁移

```python
# ❌ 旧方式（已移除）
from df_test_framework.testing.debugging import enable_db_debug

debugger = enable_db_debug(slow_query_threshold_ms=100)
# 执行 SQL
debugger.print_summary()

# ✅ 新方式：使用 fixture
def test_db(database, console_debugger):
    database.execute("SELECT * FROM users")
    # SQL 调试信息自动输出
```

### 从 http_debugger fixture 迁移

```python
# ❌ 旧方式（已移除）
def test_api(http_client, http_debugger):
    response = http_client.get("/users")
    http_debugger.print_summary()

# ✅ 新方式
def test_api(http_client, console_debugger):
    response = http_client.get("/users")
    # 调试信息自动输出，无需手动 print_summary
```

---

## 使用示例

### 场景 1：调试特定失败测试

```python
# 全局配置：DEBUG_OUTPUT=false（默认不输出）

@pytest.mark.debug  # 只为这个测试启用调试
def test_failing_order_creation(http_client):
    response = http_client.post("/api/orders", json={"product": "Phone"})
    # 控制台会输出完整的请求/响应详情
    assert response.status_code == 201
```

### 场景 2：调试整个测试类

```python
@pytest.mark.debug
class TestOrderAPI:
    """订单 API 调试"""

    def test_create_order(self, http_client):
        response = http_client.post("/api/orders", json={"product": "Phone"})
        assert response.status_code == 201

    def test_get_order(self, http_client):
        response = http_client.get("/api/orders/1")
        assert response.status_code == 200
```

### 场景 3：临时调试（显式 fixture）

```python
def test_complex_flow(http_client, console_debugger):
    """需要看详细请求/响应时使用"""
    # 创建用户
    user = http_client.post("/api/users", json={"name": "test"}).json()

    # 创建订单
    order = http_client.post("/api/orders", json={"user_id": user["id"]}).json()

    # 所有请求/响应都会输出到控制台
```

---

## 技术实现

### _auto_debug_by_marker fixture

```python
@pytest.fixture(autouse=True)
def _auto_debug_by_marker(request: pytest.FixtureRequest):
    """自动检测 marker 或全局配置，启用调试"""
    # 检查 @pytest.mark.debug
    has_debug_marker = request.node.get_closest_marker("debug") is not None

    # 检查是否已显式使用 console_debugger
    if "console_debugger" in request.fixturenames:
        yield
        return

    # 检查是否需要自动启用
    should_enable = has_debug_marker or _is_global_debug_enabled()

    if should_enable:
        debugger = _create_console_debugger()
        yield
        debugger.unsubscribe()
    else:
        yield
```

---

## 变更列表

### 新增

- `@pytest.mark.debug` marker - 强制启用调试输出
- `_auto_debug_by_marker` autouse fixture - 自动检测 marker
- 显式 fixture 优先机制

### 移除

- `HTTPDebugger` 类
- `DBDebugger` 类
- `http_debugger` fixture
- `enable_http_debug()` / `disable_http_debug()` 函数
- `enable_db_debug()` / `disable_db_debug()` 函数
- `get_global_debugger()` / `get_global_db_debugger()` 函数

### 文档

- `docs/releases/v3.28.0.md` - 本发布说明
- 更新 `docs/architecture/observability-debugging-unification.md`

---

## 向后兼容性

- ⚠️ **破坏性变更**：移除了 HTTPDebugger、DBDebugger 及相关函数
- 如果代码中使用了这些被移除的组件，需要按迁移指南更新

---

## 相关文档

- [可观测性与调试系统统一设计](../architecture/observability-debugging-unification.md)
- [可观测性架构设计](../architecture/observability-architecture.md)
