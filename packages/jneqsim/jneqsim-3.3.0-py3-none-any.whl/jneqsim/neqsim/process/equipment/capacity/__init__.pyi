
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import java.util.function
import jneqsim.neqsim.process.equipment
import typing



class BottleneckResult:
    def __init__(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface, capacityConstraint: 'CapacityConstraint', double: float): ...
    @staticmethod
    def empty() -> 'BottleneckResult': ...
    def getConstraint(self) -> 'CapacityConstraint': ...
    def getConstraintName(self) -> java.lang.String: ...
    def getEquipment(self) -> jneqsim.neqsim.process.equipment.ProcessEquipmentInterface: ...
    def getEquipmentName(self) -> java.lang.String: ...
    def getMargin(self) -> float: ...
    def getMarginPercent(self) -> float: ...
    def getUtilization(self) -> float: ...
    def getUtilizationPercent(self) -> float: ...
    def hasBottleneck(self) -> bool: ...
    def isExceeded(self) -> bool: ...
    def isNearLimit(self) -> bool: ...
    def toString(self) -> java.lang.String: ...

class CapacityConstrainedEquipment:
    def addCapacityConstraint(self, capacityConstraint: 'CapacityConstraint') -> None: ...
    def clearCapacityConstraints(self) -> None: ...
    def getAvailableMargin(self) -> float: ...
    def getAvailableMarginPercent(self) -> float: ...
    def getBottleneckConstraint(self) -> 'CapacityConstraint': ...
    def getCapacityConstraints(self) -> java.util.Map[java.lang.String, 'CapacityConstraint']: ...
    def getMaxUtilization(self) -> float: ...
    def getMaxUtilizationPercent(self) -> float: ...
    def getUtilizationSummary(self) -> java.util.Map[java.lang.String, float]: ...
    def isCapacityExceeded(self) -> bool: ...
    def isHardLimitExceeded(self) -> bool: ...
    def isNearCapacityLimit(self) -> bool: ...
    def removeCapacityConstraint(self, string: typing.Union[java.lang.String, str]) -> bool: ...

class CapacityConstraint(java.io.Serializable):
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], constraintType: 'CapacityConstraint.ConstraintType'): ...
    def getCurrentValue(self) -> float: ...
    def getDescription(self) -> java.lang.String: ...
    def getDesignValue(self) -> float: ...
    def getDisplayDesignValue(self) -> float: ...
    def getMargin(self) -> float: ...
    def getMarginPercent(self) -> float: ...
    def getMaxValue(self) -> float: ...
    def getMinValue(self) -> float: ...
    def getName(self) -> java.lang.String: ...
    def getSeverity(self) -> 'CapacityConstraint.ConstraintSeverity': ...
    def getType(self) -> 'CapacityConstraint.ConstraintType': ...
    def getUnit(self) -> java.lang.String: ...
    def getUtilization(self) -> float: ...
    def getUtilizationPercent(self) -> float: ...
    def getWarningThreshold(self) -> float: ...
    def isCriticalViolation(self) -> bool: ...
    def isHardLimitExceeded(self) -> bool: ...
    def isMinimumConstraint(self) -> bool: ...
    def isNearLimit(self) -> bool: ...
    def isViolated(self) -> bool: ...
    def setCurrentValue(self, double: float) -> 'CapacityConstraint': ...
    def setDescription(self, string: typing.Union[java.lang.String, str]) -> 'CapacityConstraint': ...
    def setDesignValue(self, double: float) -> 'CapacityConstraint': ...
    def setMaxValue(self, double: float) -> 'CapacityConstraint': ...
    def setMinValue(self, double: float) -> 'CapacityConstraint': ...
    def setSeverity(self, constraintSeverity: 'CapacityConstraint.ConstraintSeverity') -> 'CapacityConstraint': ...
    def setUnit(self, string: typing.Union[java.lang.String, str]) -> 'CapacityConstraint': ...
    def setValueSupplier(self, doubleSupplier: typing.Union[java.util.function.DoubleSupplier, typing.Callable]) -> 'CapacityConstraint': ...
    def setWarningThreshold(self, double: float) -> 'CapacityConstraint': ...
    def toString(self) -> java.lang.String: ...
    class ConstraintSeverity(java.lang.Enum['CapacityConstraint.ConstraintSeverity']):
        CRITICAL: typing.ClassVar['CapacityConstraint.ConstraintSeverity'] = ...
        HARD: typing.ClassVar['CapacityConstraint.ConstraintSeverity'] = ...
        SOFT: typing.ClassVar['CapacityConstraint.ConstraintSeverity'] = ...
        ADVISORY: typing.ClassVar['CapacityConstraint.ConstraintSeverity'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'CapacityConstraint.ConstraintSeverity': ...
        @staticmethod
        def values() -> typing.MutableSequence['CapacityConstraint.ConstraintSeverity']: ...
    class ConstraintType(java.lang.Enum['CapacityConstraint.ConstraintType']):
        HARD: typing.ClassVar['CapacityConstraint.ConstraintType'] = ...
        SOFT: typing.ClassVar['CapacityConstraint.ConstraintType'] = ...
        DESIGN: typing.ClassVar['CapacityConstraint.ConstraintType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'CapacityConstraint.ConstraintType': ...
        @staticmethod
        def values() -> typing.MutableSequence['CapacityConstraint.ConstraintType']: ...

class EquipmentCapacityStrategy:
    def evaluateCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def evaluateMaxCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getAvailableMargin(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getBottleneckConstraint(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> CapacityConstraint: ...
    def getConstraints(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.Map[java.lang.String, CapacityConstraint]: ...
    def getEquipmentClass(self) -> typing.Type[jneqsim.neqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getName(self) -> java.lang.String: ...
    def getPriority(self) -> int: ...
    def getViolations(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.List[CapacityConstraint]: ...
    def isWithinHardLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def isWithinSoftLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def supports(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...

class EquipmentCapacityStrategyRegistry:
    def evaluateCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def findStrategy(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> EquipmentCapacityStrategy: ...
    def getAllStrategies(self) -> java.util.List[EquipmentCapacityStrategy]: ...
    def getConstraints(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.Map[java.lang.String, CapacityConstraint]: ...
    @staticmethod
    def getInstance() -> 'EquipmentCapacityStrategyRegistry': ...
    def getStrategyCount(self) -> int: ...
    def isWithinHardLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def register(self, equipmentCapacityStrategy: EquipmentCapacityStrategy) -> None: ...
    def reset(self) -> None: ...
    def unregister(self, string: typing.Union[java.lang.String, str]) -> bool: ...

class StandardConstraintType(java.lang.Enum['StandardConstraintType']):
    SEPARATOR_GAS_LOAD_FACTOR: typing.ClassVar['StandardConstraintType'] = ...
    SEPARATOR_LIQUID_LOAD_FACTOR: typing.ClassVar['StandardConstraintType'] = ...
    SEPARATOR_RESIDENCE_TIME: typing.ClassVar['StandardConstraintType'] = ...
    COMPRESSOR_SPEED: typing.ClassVar['StandardConstraintType'] = ...
    COMPRESSOR_MIN_SPEED: typing.ClassVar['StandardConstraintType'] = ...
    COMPRESSOR_POWER: typing.ClassVar['StandardConstraintType'] = ...
    COMPRESSOR_SURGE_MARGIN: typing.ClassVar['StandardConstraintType'] = ...
    COMPRESSOR_STONEWALL_MARGIN: typing.ClassVar['StandardConstraintType'] = ...
    COMPRESSOR_DISCHARGE_TEMP: typing.ClassVar['StandardConstraintType'] = ...
    PUMP_NPSH_MARGIN: typing.ClassVar['StandardConstraintType'] = ...
    PUMP_FLOW_RATE: typing.ClassVar['StandardConstraintType'] = ...
    PUMP_POWER: typing.ClassVar['StandardConstraintType'] = ...
    HEAT_EXCHANGER_DUTY: typing.ClassVar['StandardConstraintType'] = ...
    HEAT_EXCHANGER_APPROACH_TEMP: typing.ClassVar['StandardConstraintType'] = ...
    HEAT_EXCHANGER_PRESSURE_DROP: typing.ClassVar['StandardConstraintType'] = ...
    VALVE_CV_UTILIZATION: typing.ClassVar['StandardConstraintType'] = ...
    VALVE_PRESSURE_DROP: typing.ClassVar['StandardConstraintType'] = ...
    VALVE_OPENING: typing.ClassVar['StandardConstraintType'] = ...
    PIPE_VELOCITY: typing.ClassVar['StandardConstraintType'] = ...
    PIPE_EROSIONAL_VELOCITY: typing.ClassVar['StandardConstraintType'] = ...
    PIPE_PRESSURE_DROP: typing.ClassVar['StandardConstraintType'] = ...
    def createConstraint(self) -> CapacityConstraint: ...
    def getDescription(self) -> java.lang.String: ...
    def getName(self) -> java.lang.String: ...
    def getType(self) -> CapacityConstraint.ConstraintType: ...
    def getUnit(self) -> java.lang.String: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> 'StandardConstraintType': ...
    @staticmethod
    def values() -> typing.MutableSequence['StandardConstraintType']: ...

class CompressorCapacityStrategy(EquipmentCapacityStrategy):
    DEFAULT_MIN_SURGE_MARGIN: typing.ClassVar[float] = ...
    DEFAULT_MIN_STONEWALL_MARGIN: typing.ClassVar[float] = ...
    DEFAULT_MAX_DISCHARGE_TEMP: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    def evaluateCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def evaluateMaxCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getBottleneckConstraint(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> CapacityConstraint: ...
    def getConstraints(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.Map[java.lang.String, CapacityConstraint]: ...
    def getEquipmentClass(self) -> typing.Type[jneqsim.neqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getMaxDischargeTemp(self) -> float: ...
    def getMinStonewallMargin(self) -> float: ...
    def getMinSurgeMargin(self) -> float: ...
    def getName(self) -> java.lang.String: ...
    def getPriority(self) -> int: ...
    def getViolations(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.List[CapacityConstraint]: ...
    def isWithinHardLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def isWithinSoftLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def setMaxDischargeTemp(self, double: float) -> None: ...
    def setMinStonewallMargin(self, double: float) -> None: ...
    def setMinSurgeMargin(self, double: float) -> None: ...
    def supports(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...

class EjectorCapacityStrategy(EquipmentCapacityStrategy):
    DEFAULT_MAX_ENTRAINMENT_RATIO: typing.ClassVar[float] = ...
    DEFAULT_MIN_SUCTION_PRESSURE: typing.ClassVar[float] = ...
    DEFAULT_MAX_MOTIVE_FLOW: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    def evaluateCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def evaluateMaxCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getAvailableMargin(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getBottleneckConstraint(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> CapacityConstraint: ...
    def getConstraints(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.Map[java.lang.String, CapacityConstraint]: ...
    def getEquipmentClass(self) -> typing.Type[jneqsim.neqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getName(self) -> java.lang.String: ...
    def getPriority(self) -> int: ...
    def getViolations(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.List[CapacityConstraint]: ...
    def isWithinHardLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def isWithinSoftLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def setMaxEntrainmentRatio(self, double: float) -> None: ...
    def setMaxMotiveFlowRate(self, double: float) -> None: ...
    def setMinSuctionPressure(self, double: float) -> None: ...
    def supports(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...

class ExpanderCapacityStrategy(EquipmentCapacityStrategy):
    DEFAULT_MAX_POWER_RATIO: typing.ClassVar[float] = ...
    DEFAULT_MIN_SPEED_RATIO: typing.ClassVar[float] = ...
    DEFAULT_MAX_SPEED_RATIO: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    def evaluateCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def evaluateMaxCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getAvailableMargin(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getBottleneckConstraint(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> CapacityConstraint: ...
    def getConstraints(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.Map[java.lang.String, CapacityConstraint]: ...
    def getEquipmentClass(self) -> typing.Type[jneqsim.neqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getName(self) -> java.lang.String: ...
    def getPriority(self) -> int: ...
    def getViolations(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.List[CapacityConstraint]: ...
    def isWithinHardLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def isWithinSoftLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def setMaxPowerRatio(self, double: float) -> None: ...
    def setMaxSpeedRatio(self, double: float) -> None: ...
    def setMinSpeedRatio(self, double: float) -> None: ...
    def supports(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...

class HeatExchangerCapacityStrategy(EquipmentCapacityStrategy):
    DEFAULT_MIN_APPROACH_TEMP: typing.ClassVar[float] = ...
    DEFAULT_MAX_DUTY_RATIO: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    def evaluateCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def evaluateMaxCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getBottleneckConstraint(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> CapacityConstraint: ...
    def getConstraints(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.Map[java.lang.String, CapacityConstraint]: ...
    def getEquipmentClass(self) -> typing.Type[jneqsim.neqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getMaxDutyRatio(self) -> float: ...
    def getMinApproachTemp(self) -> float: ...
    def getName(self) -> java.lang.String: ...
    def getPriority(self) -> int: ...
    def getViolations(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.List[CapacityConstraint]: ...
    def isWithinHardLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def isWithinSoftLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def setMaxDutyRatio(self, double: float) -> None: ...
    def setMinApproachTemp(self, double: float) -> None: ...
    def supports(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...

class PipeCapacityStrategy(EquipmentCapacityStrategy):
    DEFAULT_MAX_GAS_VELOCITY: typing.ClassVar[float] = ...
    DEFAULT_MAX_LIQUID_VELOCITY: typing.ClassVar[float] = ...
    DEFAULT_MAX_MULTIPHASE_VELOCITY: typing.ClassVar[float] = ...
    DEFAULT_MAX_EROSIONAL_RATIO: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    def evaluateCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def evaluateMaxCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getBottleneckConstraint(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> CapacityConstraint: ...
    def getConstraints(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.Map[java.lang.String, CapacityConstraint]: ...
    def getEquipmentClass(self) -> typing.Type[jneqsim.neqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getMaxErosionalRatio(self) -> float: ...
    def getMaxGasVelocity(self) -> float: ...
    def getMaxLiquidVelocity(self) -> float: ...
    def getMaxMultiphaseVelocity(self) -> float: ...
    def getName(self) -> java.lang.String: ...
    def getPriority(self) -> int: ...
    def getViolations(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.List[CapacityConstraint]: ...
    def isWithinHardLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def isWithinSoftLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def setMaxErosionalRatio(self, double: float) -> None: ...
    def setMaxGasVelocity(self, double: float) -> None: ...
    def setMaxLiquidVelocity(self, double: float) -> None: ...
    def setMaxMultiphaseVelocity(self, double: float) -> None: ...
    def supports(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...

class PumpCapacityStrategy(EquipmentCapacityStrategy):
    DEFAULT_MIN_NPSH_MARGIN: typing.ClassVar[float] = ...
    DEFAULT_MAX_POWER_FACTOR: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    def evaluateCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def evaluateMaxCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getBottleneckConstraint(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> CapacityConstraint: ...
    def getConstraints(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.Map[java.lang.String, CapacityConstraint]: ...
    def getEquipmentClass(self) -> typing.Type[jneqsim.neqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getMaxPowerFactor(self) -> float: ...
    def getMinNpshMargin(self) -> float: ...
    def getName(self) -> java.lang.String: ...
    def getPriority(self) -> int: ...
    def getViolations(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.List[CapacityConstraint]: ...
    def isWithinHardLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def isWithinSoftLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def setMaxPowerFactor(self, double: float) -> None: ...
    def setMinNpshMargin(self, double: float) -> None: ...
    def supports(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...

class SeparatorCapacityStrategy(EquipmentCapacityStrategy):
    DEFAULT_MAX_GAS_LOAD_FACTOR: typing.ClassVar[float] = ...
    DEFAULT_MAX_LIQUID_LEVEL: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    def evaluateCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def evaluateMaxCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getBottleneckConstraint(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> CapacityConstraint: ...
    def getConstraints(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.Map[java.lang.String, CapacityConstraint]: ...
    def getEquipmentClass(self) -> typing.Type[jneqsim.neqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getMaxGasLoadFactor(self) -> float: ...
    def getMaxLiquidLevel(self) -> float: ...
    def getName(self) -> java.lang.String: ...
    def getPriority(self) -> int: ...
    def getViolations(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.List[CapacityConstraint]: ...
    def isWithinHardLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def isWithinSoftLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def setMaxGasLoadFactor(self, double: float) -> None: ...
    def setMaxLiquidLevel(self, double: float) -> None: ...
    def supports(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...

class ValveCapacityStrategy(EquipmentCapacityStrategy):
    DEFAULT_MAX_OPENING: typing.ClassVar[float] = ...
    DEFAULT_MIN_OPENING: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    def evaluateCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def evaluateMaxCapacity(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> float: ...
    def getBottleneckConstraint(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> CapacityConstraint: ...
    def getConstraints(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.Map[java.lang.String, CapacityConstraint]: ...
    def getEquipmentClass(self) -> typing.Type[jneqsim.neqsim.process.equipment.ProcessEquipmentInterface]: ...
    def getMaxOpening(self) -> float: ...
    def getMinOpening(self) -> float: ...
    def getName(self) -> java.lang.String: ...
    def getPriority(self) -> int: ...
    def getViolations(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> java.util.List[CapacityConstraint]: ...
    def isWithinHardLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def isWithinSoftLimits(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...
    def setMaxOpening(self, double: float) -> None: ...
    def setMinOpening(self, double: float) -> None: ...
    def supports(self, processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface) -> bool: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.neqsim.process.equipment.capacity")``.

    BottleneckResult: typing.Type[BottleneckResult]
    CapacityConstrainedEquipment: typing.Type[CapacityConstrainedEquipment]
    CapacityConstraint: typing.Type[CapacityConstraint]
    CompressorCapacityStrategy: typing.Type[CompressorCapacityStrategy]
    EjectorCapacityStrategy: typing.Type[EjectorCapacityStrategy]
    EquipmentCapacityStrategy: typing.Type[EquipmentCapacityStrategy]
    EquipmentCapacityStrategyRegistry: typing.Type[EquipmentCapacityStrategyRegistry]
    ExpanderCapacityStrategy: typing.Type[ExpanderCapacityStrategy]
    HeatExchangerCapacityStrategy: typing.Type[HeatExchangerCapacityStrategy]
    PipeCapacityStrategy: typing.Type[PipeCapacityStrategy]
    PumpCapacityStrategy: typing.Type[PumpCapacityStrategy]
    SeparatorCapacityStrategy: typing.Type[SeparatorCapacityStrategy]
    StandardConstraintType: typing.Type[StandardConstraintType]
    ValveCapacityStrategy: typing.Type[ValveCapacityStrategy]
