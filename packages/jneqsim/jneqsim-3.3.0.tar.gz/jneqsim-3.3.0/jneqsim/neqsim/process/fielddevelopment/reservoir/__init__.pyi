
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jpype
import jneqsim.neqsim.process.equipment.reservoir
import jneqsim.neqsim.process.processmodel
import jneqsim.neqsim.thermo.system
import typing



class InjectionStrategy(java.io.Serializable):
    def __init__(self, strategyType: 'InjectionStrategy.StrategyType'): ...
    def calculateInjection(self, simpleReservoir: jneqsim.neqsim.process.equipment.reservoir.SimpleReservoir, double: float, double2: float, double3: float) -> 'InjectionStrategy.InjectionResult': ...
    @staticmethod
    def gasInjection(double: float) -> 'InjectionStrategy': ...
    def getStrategyType(self) -> 'InjectionStrategy.StrategyType': ...
    def getTargetVRR(self) -> float: ...
    @staticmethod
    def pressureMaintenance(double: float) -> 'InjectionStrategy': ...
    def setInjectionTemperature(self, double: float) -> 'InjectionStrategy': ...
    def setMaxGasRate(self, double: float) -> 'InjectionStrategy': ...
    def setMaxWaterRate(self, double: float) -> 'InjectionStrategy': ...
    def setTargetVRR(self, double: float) -> 'InjectionStrategy': ...
    @staticmethod
    def wag(double: float, double2: float) -> 'InjectionStrategy': ...
    @staticmethod
    def waterInjection(double: float) -> 'InjectionStrategy': ...
    class InjectionResult(java.io.Serializable):
        strategyType: 'InjectionStrategy.StrategyType' = ...
        waterInjectionRate: float = ...
        gasInjectionRate: float = ...
        productionVoidage: float = ...
        achievedVRR: float = ...
        def __init__(self): ...
        def toString(self) -> java.lang.String: ...
    class StrategyType(java.lang.Enum['InjectionStrategy.StrategyType']):
        NATURAL_DEPLETION: typing.ClassVar['InjectionStrategy.StrategyType'] = ...
        WATER_INJECTION: typing.ClassVar['InjectionStrategy.StrategyType'] = ...
        GAS_INJECTION: typing.ClassVar['InjectionStrategy.StrategyType'] = ...
        WAG: typing.ClassVar['InjectionStrategy.StrategyType'] = ...
        PRESSURE_MAINTENANCE: typing.ClassVar['InjectionStrategy.StrategyType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'InjectionStrategy.StrategyType': ...
        @staticmethod
        def values() -> typing.MutableSequence['InjectionStrategy.StrategyType']: ...

class InjectionWellModel(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, injectionType: 'InjectionWellModel.InjectionType'): ...
    def calculate(self, double: float) -> 'InjectionWellModel.InjectionWellResult': ...
    def calculateMaximumRate(self) -> 'InjectionWellModel.InjectionWellResult': ...
    def calculateWithInterference(self, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> 'InjectionWellModel.InjectionWellResult': ...
    def setDrainageRadius(self, double: float) -> 'InjectionWellModel': ...
    def setFormationPermeability(self, double: float, string: typing.Union[java.lang.String, str]) -> 'InjectionWellModel': ...
    def setFormationThickness(self, double: float, string: typing.Union[java.lang.String, str]) -> 'InjectionWellModel': ...
    def setFracturePressure(self, double: float, string: typing.Union[java.lang.String, str]) -> 'InjectionWellModel': ...
    def setMaxBHP(self, double: float, string: typing.Union[java.lang.String, str]) -> 'InjectionWellModel': ...
    def setPumpEfficiency(self, double: float) -> 'InjectionWellModel': ...
    def setReservoirPressure(self, double: float, string: typing.Union[java.lang.String, str]) -> 'InjectionWellModel': ...
    def setReservoirTemperature(self, double: float, string: typing.Union[java.lang.String, str]) -> 'InjectionWellModel': ...
    def setSkinFactor(self, double: float) -> 'InjectionWellModel': ...
    def setSurfaceInjectionPressure(self, double: float, string: typing.Union[java.lang.String, str]) -> 'InjectionWellModel': ...
    def setTubingID(self, double: float, string: typing.Union[java.lang.String, str]) -> 'InjectionWellModel': ...
    def setWaterViscosity(self, double: float) -> 'InjectionWellModel': ...
    def setWellDepth(self, double: float, string: typing.Union[java.lang.String, str]) -> 'InjectionWellModel': ...
    def setWellType(self, injectionType: 'InjectionWellModel.InjectionType') -> 'InjectionWellModel': ...
    def setWellboreRadius(self, double: float) -> 'InjectionWellModel': ...
    class InjectionPattern(java.io.Serializable):
        def __init__(self, patternType: 'InjectionWellModel.InjectionPattern.PatternType'): ...
        def getArealSweepEfficiency(self, double: float) -> float: ...
        def getWellSpacing(self) -> float: ...
        def setWellSpacing(self, double: float) -> 'InjectionWellModel.InjectionPattern': ...
        class PatternType(java.lang.Enum['InjectionWellModel.InjectionPattern.PatternType']):
            FIVE_SPOT: typing.ClassVar['InjectionWellModel.InjectionPattern.PatternType'] = ...
            INVERTED_FIVE_SPOT: typing.ClassVar['InjectionWellModel.InjectionPattern.PatternType'] = ...
            LINE_DRIVE: typing.ClassVar['InjectionWellModel.InjectionPattern.PatternType'] = ...
            STAGGERED_LINE_DRIVE: typing.ClassVar['InjectionWellModel.InjectionPattern.PatternType'] = ...
            SEVEN_SPOT: typing.ClassVar['InjectionWellModel.InjectionPattern.PatternType'] = ...
            NINE_SPOT: typing.ClassVar['InjectionWellModel.InjectionPattern.PatternType'] = ...
            PERIPHERAL: typing.ClassVar['InjectionWellModel.InjectionPattern.PatternType'] = ...
            _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
            @typing.overload
            @staticmethod
            def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
            @typing.overload
            @staticmethod
            def valueOf(string: typing.Union[java.lang.String, str]) -> 'InjectionWellModel.InjectionPattern.PatternType': ...
            @staticmethod
            def values() -> typing.MutableSequence['InjectionWellModel.InjectionPattern.PatternType']: ...
    class InjectionType(java.lang.Enum['InjectionWellModel.InjectionType']):
        WATER_INJECTOR: typing.ClassVar['InjectionWellModel.InjectionType'] = ...
        GAS_INJECTOR: typing.ClassVar['InjectionWellModel.InjectionType'] = ...
        CO2_INJECTOR: typing.ClassVar['InjectionWellModel.InjectionType'] = ...
        WAG_INJECTOR: typing.ClassVar['InjectionWellModel.InjectionType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'InjectionWellModel.InjectionType': ...
        @staticmethod
        def values() -> typing.MutableSequence['InjectionWellModel.InjectionType']: ...
    class InjectionWellResult(java.io.Serializable):
        injectionType: 'InjectionWellModel.InjectionType' = ...
        targetRate: float = ...
        achievableRate: float = ...
        injectivityIndex: float = ...
        requiredBHP: float = ...
        bottomholePressure: float = ...
        wellheadPressure: float = ...
        limitedByPressure: bool = ...
        needsPump: bool = ...
        requiredPumpDeltaP: float = ...
        pumpPower: float = ...
        hallSlope: float = ...
        expectedHallSlope: float = ...
        skinContribution: float = ...
        interferencePressure: float = ...
        effectiveReservoirPressure: float = ...
        achievableRateWithInterference: float = ...
        def __init__(self): ...
        def getAchievableRate(self) -> float: ...
        def getBottomholePressure(self) -> float: ...
        def getInjectivityIndex(self) -> float: ...
        def getPumpPower(self) -> float: ...
        def getWellheadPressure(self) -> float: ...
        def toString(self) -> java.lang.String: ...

class ReservoirCouplingExporter(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem): ...
    def addGroupConstraint(self, date: java.util.Date, string: typing.Union[java.lang.String, str], double: float, double2: float, double3: float) -> None: ...
    def addVfpReference(self, date: java.util.Date, string: typing.Union[java.lang.String, str], int: int) -> None: ...
    def addWellControl(self, date: java.util.Date, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float) -> None: ...
    def clear(self) -> None: ...
    def exportProductionForecastCsv(self, intArray: typing.Union[typing.List[int], jpype.JArray], doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray]) -> java.lang.String: ...
    def exportSeparatorEfficiency(self, string: typing.Union[java.lang.String, str], doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray]) -> java.lang.String: ...
    def exportToFile(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def generateVfpInj(self, string: typing.Union[java.lang.String, str], systemInterface: jneqsim.neqsim.thermo.system.SystemInterface, int: int) -> 'ReservoirCouplingExporter.VfpTable': ...
    def generateVfpProd(self, string: typing.Union[java.lang.String, str], systemInterface: jneqsim.neqsim.thermo.system.SystemInterface, int: int) -> 'ReservoirCouplingExporter.VfpTable': ...
    def getEclipseKeywords(self) -> java.lang.String: ...
    def getVfpTables(self) -> java.util.List['ReservoirCouplingExporter.VfpTable']: ...
    def setDatumDepth(self, double: float) -> None: ...
    def setFormat(self, exportFormat: 'ReservoirCouplingExporter.ExportFormat') -> None: ...
    def setGorRange(self, double: float, double2: float, int: int) -> None: ...
    def setPressureRange(self, double: float, double2: float, int: int) -> None: ...
    def setRateRange(self, double: float, double2: float, int: int) -> None: ...
    def setWctRange(self, double: float, double2: float, int: int) -> None: ...
    class ExportFormat(java.lang.Enum['ReservoirCouplingExporter.ExportFormat']):
        ECLIPSE_100: typing.ClassVar['ReservoirCouplingExporter.ExportFormat'] = ...
        E300_COMPOSITIONAL: typing.ClassVar['ReservoirCouplingExporter.ExportFormat'] = ...
        INTERSECT: typing.ClassVar['ReservoirCouplingExporter.ExportFormat'] = ...
        CSV: typing.ClassVar['ReservoirCouplingExporter.ExportFormat'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ReservoirCouplingExporter.ExportFormat': ...
        @staticmethod
        def values() -> typing.MutableSequence['ReservoirCouplingExporter.ExportFormat']: ...
    class ScheduleEntry(java.io.Serializable):
        def __init__(self, date: java.util.Date, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]): ...
        def getContent(self) -> java.lang.String: ...
        def getDate(self) -> java.util.Date: ...
        def getKeyword(self) -> java.lang.String: ...
    class VfpTable(java.io.Serializable):
        def __init__(self): ...
        def getBhpValues(self) -> typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[float]]]]]: ...
        def getDatumDepth(self) -> float: ...
        def getFlowRates(self) -> typing.MutableSequence[float]: ...
        def getGorValues(self) -> typing.MutableSequence[float]: ...
        def getTableNumber(self) -> int: ...
        def getThpValues(self) -> typing.MutableSequence[float]: ...
        def getWctValues(self) -> typing.MutableSequence[float]: ...
        def getWellName(self) -> java.lang.String: ...
        def setDatumDepth(self, double: float) -> None: ...
        def setTableNumber(self, int: int) -> None: ...
        def setWellName(self, string: typing.Union[java.lang.String, str]) -> None: ...

class TransientWellModel(java.io.Serializable):
    def __init__(self): ...
    def addRateChange(self, double: float, double2: float) -> 'TransientWellModel': ...
    def calculateBuildup(self, double: float) -> 'TransientWellModel.BuildupResult': ...
    def calculateDrawdown(self, double: float, double2: float) -> 'TransientWellModel.DrawdownResult': ...
    def calculatePressureWithSuperposition(self, double: float) -> float: ...
    def clearRateHistory(self) -> 'TransientWellModel': ...
    def generateLogTimePoints(self, double: float, double2: float, int: int) -> typing.MutableSequence[float]: ...
    def generatePressureProfile(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> java.util.List['TransientWellModel.PressurePoint']: ...
    def getHydraulicDiffusivity(self) -> float: ...
    def getInitialPressure(self) -> float: ...
    def getRateHistory(self) -> java.util.List['TransientWellModel.RateChange']: ...
    def getTransmissibility(self) -> float: ...
    def setBoundaryType(self, boundaryType: 'TransientWellModel.BoundaryType') -> 'TransientWellModel': ...
    def setDrainageRadius(self, double: float, string: typing.Union[java.lang.String, str]) -> 'TransientWellModel': ...
    def setFluidViscosity(self, double: float, string: typing.Union[java.lang.String, str]) -> 'TransientWellModel': ...
    def setFormationThickness(self, double: float, string: typing.Union[java.lang.String, str]) -> 'TransientWellModel': ...
    def setFormationVolumeFactor(self, double: float) -> 'TransientWellModel': ...
    def setPermeability(self, double: float, string: typing.Union[java.lang.String, str]) -> 'TransientWellModel': ...
    def setPorosity(self, double: float) -> 'TransientWellModel': ...
    def setReservoirPressure(self, double: float, string: typing.Union[java.lang.String, str]) -> 'TransientWellModel': ...
    def setSkinFactor(self, double: float) -> 'TransientWellModel': ...
    def setTotalCompressibility(self, double: float, string: typing.Union[java.lang.String, str]) -> 'TransientWellModel': ...
    def setWellType(self, wellType: 'TransientWellModel.WellType') -> 'TransientWellModel': ...
    def setWellboreRadius(self, double: float, string: typing.Union[java.lang.String, str]) -> 'TransientWellModel': ...
    class BoundaryType(java.lang.Enum['TransientWellModel.BoundaryType']):
        INFINITE: typing.ClassVar['TransientWellModel.BoundaryType'] = ...
        NO_FLOW: typing.ClassVar['TransientWellModel.BoundaryType'] = ...
        CONSTANT_PRESSURE: typing.ClassVar['TransientWellModel.BoundaryType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'TransientWellModel.BoundaryType': ...
        @staticmethod
        def values() -> typing.MutableSequence['TransientWellModel.BoundaryType']: ...
    class BuildupResult(java.io.Serializable):
        shutInTime: float = ...
        producingTime: float = ...
        rateBeforeShutIn: float = ...
        shutInPressure: float = ...
        initialPressure: float = ...
        pressureRecovery: float = ...
        permeabilityFromSlope: float = ...
        skinFromIntercept: float = ...
        extrapolatedPressure: float = ...
        hornerSlope: float = ...
        def __init__(self): ...
        def toString(self) -> java.lang.String: ...
    class DrawdownResult(java.io.Serializable):
        time: float = ...
        flowRate: float = ...
        initialPressure: float = ...
        flowingPressure: float = ...
        drawdown: float = ...
        radiusOfInvestigation: float = ...
        infiniteActing: bool = ...
        productivityIndex: float = ...
        def __init__(self): ...
        def toString(self) -> java.lang.String: ...
    class PressurePoint(java.io.Serializable):
        time: float = ...
        pressure: float = ...
        rate: float = ...
        def __init__(self, double: float, double2: float, double3: float): ...
    class RateChange(java.io.Serializable):
        time: float = ...
        rate: float = ...
        def __init__(self, double: float, double2: float): ...
    class WellType(java.lang.Enum['TransientWellModel.WellType']):
        OIL_PRODUCER: typing.ClassVar['TransientWellModel.WellType'] = ...
        GAS_PRODUCER: typing.ClassVar['TransientWellModel.WellType'] = ...
        WATER_INJECTOR: typing.ClassVar['TransientWellModel.WellType'] = ...
        GAS_INJECTOR: typing.ClassVar['TransientWellModel.WellType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'TransientWellModel.WellType': ...
        @staticmethod
        def values() -> typing.MutableSequence['TransientWellModel.WellType']: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.neqsim.process.fielddevelopment.reservoir")``.

    InjectionStrategy: typing.Type[InjectionStrategy]
    InjectionWellModel: typing.Type[InjectionWellModel]
    ReservoirCouplingExporter: typing.Type[ReservoirCouplingExporter]
    TransientWellModel: typing.Type[TransientWellModel]
