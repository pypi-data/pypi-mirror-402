
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.time
import java.util
import jneqsim.neqsim.process.equipment.separator
import jneqsim.neqsim.process.equipment.stream
import jneqsim.neqsim.process.equipment.watertreatment
import jneqsim.neqsim.process.fielddevelopment.concept
import jneqsim.neqsim.process.fielddevelopment.economics
import jneqsim.neqsim.process.fielddevelopment.facility
import jneqsim.neqsim.process.fielddevelopment.screening
import jneqsim.neqsim.process.processmodel
import typing



class BatchConceptRunner:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, conceptEvaluator: 'ConceptEvaluator'): ...
    def addConcept(self, fieldConcept: jneqsim.neqsim.process.fielddevelopment.concept.FieldConcept) -> 'BatchConceptRunner': ...
    def addConcepts(self, list: java.util.List[jneqsim.neqsim.process.fielddevelopment.concept.FieldConcept]) -> 'BatchConceptRunner': ...
    def clear(self) -> 'BatchConceptRunner': ...
    def getConceptCount(self) -> int: ...
    def onProgress(self, progressListener: typing.Union['BatchConceptRunner.ProgressListener', typing.Callable]) -> 'BatchConceptRunner': ...
    def parallelism(self, int: int) -> 'BatchConceptRunner': ...
    def quickScreenAll(self) -> 'BatchConceptRunner.BatchResults': ...
    def runAll(self) -> 'BatchConceptRunner.BatchResults': ...
    class BatchResults:
        def getBestConcept(self) -> 'ConceptKPIs': ...
        def getBestEconomicConcept(self) -> 'ConceptKPIs': ...
        def getBestEnvironmentalConcept(self) -> 'ConceptKPIs': ...
        def getComparisonSummary(self) -> java.lang.String: ...
        def getErrors(self) -> java.util.List[java.lang.String]: ...
        def getFailureCount(self) -> int: ...
        def getLowestCapexConcept(self) -> 'ConceptKPIs': ...
        def getLowestEmissionsConcept(self) -> 'ConceptKPIs': ...
        def getRankedResults(self) -> java.util.List['ConceptKPIs']: ...
        def getResults(self) -> java.util.List['ConceptKPIs']: ...
        def getSuccessCount(self) -> int: ...
        def getViableConcepts(self) -> java.util.List['ConceptKPIs']: ...
        def toString(self) -> java.lang.String: ...
    class ProgressListener:
        def onProgress(self, int: int, int2: int) -> None: ...

class BottleneckAnalyzer(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem): ...
    def evaluateDebottleneckOptions(self, string: typing.Union[java.lang.String, str], double: float) -> java.util.List['BottleneckAnalyzer.DebottleneckOption']: ...
    def generateReport(self) -> java.lang.String: ...
    def getActiveBottlenecks(self) -> java.util.List['BottleneckAnalyzer.BottleneckResult']: ...
    def getPrimaryBottleneck(self) -> 'BottleneckAnalyzer.BottleneckResult': ...
    def identifyBottlenecks(self) -> java.util.List['BottleneckAnalyzer.BottleneckResult']: ...
    def setUtilizationThreshold(self, double: float) -> 'BottleneckAnalyzer': ...
    class BottleneckResult(java.io.Serializable):
        def __init__(self): ...
        def getConstraintDescription(self) -> java.lang.String: ...
        def getConstraintType(self) -> 'BottleneckAnalyzer.ConstraintType': ...
        def getCurrentValue(self) -> float: ...
        def getEquipmentName(self) -> java.lang.String: ...
        def getEquipmentType(self) -> 'BottleneckAnalyzer.EquipmentType': ...
        def getMaxValue(self) -> float: ...
        def getRemainingCapacity(self) -> float: ...
        def getUnit(self) -> java.lang.String: ...
        def getUtilization(self) -> float: ...
        def toString(self) -> java.lang.String: ...
    class ConstraintType(java.lang.Enum['BottleneckAnalyzer.ConstraintType']):
        GAS_VELOCITY: typing.ClassVar['BottleneckAnalyzer.ConstraintType'] = ...
        LIQUID_RETENTION: typing.ClassVar['BottleneckAnalyzer.ConstraintType'] = ...
        POWER: typing.ClassVar['BottleneckAnalyzer.ConstraintType'] = ...
        SURGE: typing.ClassVar['BottleneckAnalyzer.ConstraintType'] = ...
        STONEWALL: typing.ClassVar['BottleneckAnalyzer.ConstraintType'] = ...
        HEAD: typing.ClassVar['BottleneckAnalyzer.ConstraintType'] = ...
        NPSH: typing.ClassVar['BottleneckAnalyzer.ConstraintType'] = ...
        THERMAL: typing.ClassVar['BottleneckAnalyzer.ConstraintType'] = ...
        VALVE_CV: typing.ClassVar['BottleneckAnalyzer.ConstraintType'] = ...
        PRESSURE_DROP: typing.ClassVar['BottleneckAnalyzer.ConstraintType'] = ...
        VELOCITY: typing.ClassVar['BottleneckAnalyzer.ConstraintType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'BottleneckAnalyzer.ConstraintType': ...
        @staticmethod
        def values() -> typing.MutableSequence['BottleneckAnalyzer.ConstraintType']: ...
    class DebottleneckOption(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, double2: float, int: int): ...
        def getCapacityIncrease(self) -> float: ...
        def getDescription(self) -> java.lang.String: ...
        def getEstimatedCostMUSD(self) -> float: ...
        def getImplementationMonths(self) -> int: ...
        def getName(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class EquipmentType(java.lang.Enum['BottleneckAnalyzer.EquipmentType']):
        SEPARATOR: typing.ClassVar['BottleneckAnalyzer.EquipmentType'] = ...
        COMPRESSOR: typing.ClassVar['BottleneckAnalyzer.EquipmentType'] = ...
        PUMP: typing.ClassVar['BottleneckAnalyzer.EquipmentType'] = ...
        HEAT_EXCHANGER: typing.ClassVar['BottleneckAnalyzer.EquipmentType'] = ...
        VALVE: typing.ClassVar['BottleneckAnalyzer.EquipmentType'] = ...
        PIPELINE: typing.ClassVar['BottleneckAnalyzer.EquipmentType'] = ...
        OTHER: typing.ClassVar['BottleneckAnalyzer.EquipmentType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'BottleneckAnalyzer.EquipmentType': ...
        @staticmethod
        def values() -> typing.MutableSequence['BottleneckAnalyzer.EquipmentType']: ...

class ConceptEvaluator:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, flowAssuranceScreener: jneqsim.neqsim.process.fielddevelopment.screening.FlowAssuranceScreener, safetyScreener: jneqsim.neqsim.process.fielddevelopment.screening.SafetyScreener, emissionsTracker: jneqsim.neqsim.process.fielddevelopment.screening.EmissionsTracker, economicsEstimator: jneqsim.neqsim.process.fielddevelopment.screening.EconomicsEstimator): ...
    @typing.overload
    def evaluate(self, fieldConcept: jneqsim.neqsim.process.fielddevelopment.concept.FieldConcept) -> 'ConceptKPIs': ...
    @typing.overload
    def evaluate(self, fieldConcept: jneqsim.neqsim.process.fielddevelopment.concept.FieldConcept, facilityConfig: jneqsim.neqsim.process.fielddevelopment.facility.FacilityConfig) -> 'ConceptKPIs': ...
    def quickScreen(self, fieldConcept: jneqsim.neqsim.process.fielddevelopment.concept.FieldConcept) -> 'ConceptKPIs': ...

class ConceptKPIs(java.io.Serializable):
    @staticmethod
    def builder(string: typing.Union[java.lang.String, str]) -> 'ConceptKPIs.Builder': ...
    def getAnnualEmissionsTonnes(self) -> float: ...
    def getAnnualOpexMUSD(self) -> float: ...
    def getBlowdownTimeMinutes(self) -> float: ...
    def getBreakEvenOilPriceUSD(self) -> float: ...
    def getCo2IntensityKgPerBoe(self) -> float: ...
    def getConceptName(self) -> java.lang.String: ...
    def getEconomicScore(self) -> float: ...
    def getEconomicsReport(self) -> jneqsim.neqsim.process.fielddevelopment.screening.EconomicsEstimator.EconomicsReport: ...
    def getEmissionsClass(self) -> java.lang.String: ...
    def getEmissionsReport(self) -> jneqsim.neqsim.process.fielddevelopment.screening.EmissionsTracker.EmissionsReport: ...
    def getEnvironmentalScore(self) -> float: ...
    def getEstimatedRecoveryPercent(self) -> float: ...
    def getEvaluationTime(self) -> java.time.LocalDateTime: ...
    def getFieldLifeYears(self) -> float: ...
    def getFlowAssuranceOverall(self) -> jneqsim.neqsim.process.fielddevelopment.screening.FlowAssuranceResult: ...
    def getFlowAssuranceReport(self) -> jneqsim.neqsim.process.fielddevelopment.screening.FlowAssuranceReport: ...
    def getHydrateMarginC(self) -> float: ...
    def getMinMetalTempC(self) -> float: ...
    def getNotes(self) -> java.util.Map[java.lang.String, java.lang.String]: ...
    def getNpv10MUSD(self) -> float: ...
    def getOneLiner(self) -> java.lang.String: ...
    def getOverallScore(self) -> float: ...
    def getPlateauRateMsm3d(self) -> float: ...
    def getSafetyLevel(self) -> jneqsim.neqsim.process.fielddevelopment.screening.SafetyReport.SafetyLevel: ...
    def getSafetyReport(self) -> jneqsim.neqsim.process.fielddevelopment.screening.SafetyReport: ...
    def getSummary(self) -> java.lang.String: ...
    def getTechnicalScore(self) -> float: ...
    def getTotalCapexMUSD(self) -> float: ...
    def getWarnings(self) -> java.util.Map[java.lang.String, java.lang.String]: ...
    def getWaxMarginC(self) -> float: ...
    def hasBlockingIssues(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    class Builder:
        def __init__(self, string: typing.Union[java.lang.String, str]): ...
        def addNote(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'ConceptKPIs.Builder': ...
        def addWarning(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'ConceptKPIs.Builder': ...
        def annualEmissions(self, double: float) -> 'ConceptKPIs.Builder': ...
        def annualOpex(self, double: float) -> 'ConceptKPIs.Builder': ...
        def blowdownTime(self, double: float) -> 'ConceptKPIs.Builder': ...
        def breakEvenPrice(self, double: float) -> 'ConceptKPIs.Builder': ...
        def build(self) -> 'ConceptKPIs': ...
        def co2Intensity(self, double: float) -> 'ConceptKPIs.Builder': ...
        def economicScore(self, double: float) -> 'ConceptKPIs.Builder': ...
        def economicsReport(self, economicsReport: jneqsim.neqsim.process.fielddevelopment.screening.EconomicsEstimator.EconomicsReport) -> 'ConceptKPIs.Builder': ...
        def emissionsClass(self, string: typing.Union[java.lang.String, str]) -> 'ConceptKPIs.Builder': ...
        def emissionsReport(self, emissionsReport: jneqsim.neqsim.process.fielddevelopment.screening.EmissionsTracker.EmissionsReport) -> 'ConceptKPIs.Builder': ...
        def environmentalScore(self, double: float) -> 'ConceptKPIs.Builder': ...
        def estimatedRecovery(self, double: float) -> 'ConceptKPIs.Builder': ...
        def evaluationTime(self, localDateTime: java.time.LocalDateTime) -> 'ConceptKPIs.Builder': ...
        def fieldLife(self, double: float) -> 'ConceptKPIs.Builder': ...
        def flowAssuranceOverall(self, flowAssuranceResult: jneqsim.neqsim.process.fielddevelopment.screening.FlowAssuranceResult) -> 'ConceptKPIs.Builder': ...
        def flowAssuranceReport(self, flowAssuranceReport: jneqsim.neqsim.process.fielddevelopment.screening.FlowAssuranceReport) -> 'ConceptKPIs.Builder': ...
        def hydrateMargin(self, double: float) -> 'ConceptKPIs.Builder': ...
        def minMetalTemp(self, double: float) -> 'ConceptKPIs.Builder': ...
        def npv10(self, double: float) -> 'ConceptKPIs.Builder': ...
        def overallScore(self, double: float) -> 'ConceptKPIs.Builder': ...
        def plateauRate(self, double: float) -> 'ConceptKPIs.Builder': ...
        def safetyLevel(self, safetyLevel: jneqsim.neqsim.process.fielddevelopment.screening.SafetyReport.SafetyLevel) -> 'ConceptKPIs.Builder': ...
        def safetyReport(self, safetyReport: jneqsim.neqsim.process.fielddevelopment.screening.SafetyReport) -> 'ConceptKPIs.Builder': ...
        def technicalScore(self, double: float) -> 'ConceptKPIs.Builder': ...
        def totalCapex(self, double: float) -> 'ConceptKPIs.Builder': ...
        def waxMargin(self, double: float) -> 'ConceptKPIs.Builder': ...

class DecommissioningEstimator(java.io.Serializable):
    def __init__(self): ...
    def generateReport(self) -> java.lang.String: ...
    def getCostBreakdown(self) -> java.util.List['DecommissioningEstimator.CostItem']: ...
    def getEstimatedDurationMonths(self) -> int: ...
    @typing.overload
    def getPipelineDecomCostMUSD(self) -> float: ...
    @typing.overload
    def getPipelineDecomCostMUSD(self, pipelineStrategy: 'DecommissioningEstimator.PipelineStrategy') -> float: ...
    def getSiteRemediationCostMUSD(self) -> float: ...
    def getSubstructureRemovalCostMUSD(self) -> float: ...
    def getTopsideRemovalCostMUSD(self) -> float: ...
    @typing.overload
    def getTotalCostMUSD(self) -> float: ...
    @typing.overload
    def getTotalCostMUSD(self, pipelineStrategy: 'DecommissioningEstimator.PipelineStrategy') -> float: ...
    def getWellPACostMUSD(self) -> float: ...
    def setAverageWellDepth(self, double: float) -> 'DecommissioningEstimator': ...
    def setFacilityType(self, facilityType: 'DecommissioningEstimator.FacilityType') -> 'DecommissioningEstimator': ...
    def setNumberOfRisers(self, int: int) -> 'DecommissioningEstimator': ...
    def setNumberOfSubseaStructures(self, int: int) -> 'DecommissioningEstimator': ...
    def setNumberOfWells(self, int: int) -> 'DecommissioningEstimator': ...
    def setPipelineDiameter(self, double: float) -> 'DecommissioningEstimator': ...
    def setPipelineLength(self, double: float) -> 'DecommissioningEstimator': ...
    def setSubstructureWeight(self, double: float) -> 'DecommissioningEstimator': ...
    def setTopsideWeight(self, double: float) -> 'DecommissioningEstimator': ...
    def setWaterDepth(self, double: float) -> 'DecommissioningEstimator': ...
    class CostItem(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], double: float, string2: typing.Union[java.lang.String, str]): ...
        def getCategory(self) -> java.lang.String: ...
        def getCostMUSD(self) -> float: ...
        def getNotes(self) -> java.lang.String: ...
    class FacilityType(java.lang.Enum['DecommissioningEstimator.FacilityType']):
        FIXED_JACKET: typing.ClassVar['DecommissioningEstimator.FacilityType'] = ...
        GRAVITY_BASED: typing.ClassVar['DecommissioningEstimator.FacilityType'] = ...
        FPSO: typing.ClassVar['DecommissioningEstimator.FacilityType'] = ...
        SEMI_SUBMERSIBLE: typing.ClassVar['DecommissioningEstimator.FacilityType'] = ...
        TLP: typing.ClassVar['DecommissioningEstimator.FacilityType'] = ...
        SPAR: typing.ClassVar['DecommissioningEstimator.FacilityType'] = ...
        SUBSEA_TIEBACK: typing.ClassVar['DecommissioningEstimator.FacilityType'] = ...
        WELLHEAD_PLATFORM: typing.ClassVar['DecommissioningEstimator.FacilityType'] = ...
        COMPLIANT_TOWER: typing.ClassVar['DecommissioningEstimator.FacilityType'] = ...
        def getCostFactor(self) -> float: ...
        def getDisplayName(self) -> java.lang.String: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'DecommissioningEstimator.FacilityType': ...
        @staticmethod
        def values() -> typing.MutableSequence['DecommissioningEstimator.FacilityType']: ...
    class PipelineStrategy(java.lang.Enum['DecommissioningEstimator.PipelineStrategy']):
        LEAVE_IN_PLACE: typing.ClassVar['DecommissioningEstimator.PipelineStrategy'] = ...
        TRENCH_BURY: typing.ClassVar['DecommissioningEstimator.PipelineStrategy'] = ...
        FULL_REMOVAL: typing.ClassVar['DecommissioningEstimator.PipelineStrategy'] = ...
        def getCostFactor(self) -> float: ...
        def getDisplayName(self) -> java.lang.String: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'DecommissioningEstimator.PipelineStrategy': ...
        @staticmethod
        def values() -> typing.MutableSequence['DecommissioningEstimator.PipelineStrategy']: ...

class DevelopmentOptionRanker(java.io.Serializable):
    def __init__(self): ...
    @typing.overload
    def addOption(self, string: typing.Union[java.lang.String, str]) -> 'DevelopmentOptionRanker.DevelopmentOption': ...
    @typing.overload
    def addOption(self, developmentOption: 'DevelopmentOptionRanker.DevelopmentOption') -> None: ...
    def clearOptions(self) -> None: ...
    def getOptions(self) -> java.util.List['DevelopmentOptionRanker.DevelopmentOption']: ...
    def getWeight(self, criterion: 'DevelopmentOptionRanker.Criterion') -> float: ...
    def normalizeWeights(self) -> None: ...
    def rank(self) -> 'DevelopmentOptionRanker.RankingResult': ...
    def rankByCriterion(self, criterion: 'DevelopmentOptionRanker.Criterion') -> java.util.List['DevelopmentOptionRanker.DevelopmentOption']: ...
    def setWeight(self, criterion: 'DevelopmentOptionRanker.Criterion', double: float) -> None: ...
    def setWeightProfile(self, string: typing.Union[java.lang.String, str]) -> None: ...
    class Criterion(java.lang.Enum['DevelopmentOptionRanker.Criterion']):
        NPV: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        IRR: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        PAYBACK: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        CAPITAL_EFFICIENCY: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        BREAKEVEN_PRICE: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        TECHNICAL_COMPLEXITY: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        TECHNICAL_RISK: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        RESERVOIR_UNCERTAINTY: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        RECOVERY_FACTOR: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        CO2_INTENSITY: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        TOTAL_EMISSIONS: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        ENVIRONMENTAL_IMPACT: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        STRATEGIC_FIT: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        INFRASTRUCTURE_SYNERGY: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        OPTIONALITY: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        SCHEDULE_FLEXIBILITY: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        HSE_RISK: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        EXECUTION_RISK: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        COMMERCIAL_RISK: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        REGULATORY_RISK: typing.ClassVar['DevelopmentOptionRanker.Criterion'] = ...
        def getDisplayName(self) -> java.lang.String: ...
        def getUnit(self) -> java.lang.String: ...
        def isHigherBetter(self) -> bool: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'DevelopmentOptionRanker.Criterion': ...
        @staticmethod
        def values() -> typing.MutableSequence['DevelopmentOptionRanker.Criterion']: ...
    class DevelopmentOption(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str]): ...
        def getDescription(self) -> java.lang.String: ...
        def getName(self) -> java.lang.String: ...
        def getNormalizedScore(self, criterion: 'DevelopmentOptionRanker.Criterion') -> float: ...
        def getRank(self) -> int: ...
        def getScore(self, criterion: 'DevelopmentOptionRanker.Criterion') -> float: ...
        def getScores(self) -> java.util.Map['DevelopmentOptionRanker.Criterion', float]: ...
        def getWeightedScore(self) -> float: ...
        def setDescription(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setScore(self, criterion: 'DevelopmentOptionRanker.Criterion', double: float) -> None: ...
    class RankingResult(java.io.Serializable):
        def __init__(self): ...
        def generateReport(self) -> java.lang.String: ...
        def getBestOption(self) -> 'DevelopmentOptionRanker.DevelopmentOption': ...
        def getRankedOptions(self) -> java.util.List['DevelopmentOptionRanker.DevelopmentOption']: ...
        def getWeights(self) -> java.util.Map['DevelopmentOptionRanker.Criterion', float]: ...
        def sensitivityAnalysis(self, criterion: 'DevelopmentOptionRanker.Criterion') -> java.util.Map[float, java.lang.String]: ...

class EnvironmentalReporter(java.io.Serializable):
    CO2_GAS_TURBINE: typing.ClassVar[float] = ...
    CO2_DIESEL: typing.ClassVar[float] = ...
    CO2_COMBINED_CYCLE: typing.ClassVar[float] = ...
    CO2_POWER_FROM_SHORE: typing.ClassVar[float] = ...
    CO2_FLARE_PER_SM3: typing.ClassVar[float] = ...
    NCS_OIW_LIMIT: typing.ClassVar[float] = ...
    BBL_TO_SM3: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, powerSupplyType: 'EnvironmentalReporter.PowerSupplyType'): ...
    @typing.overload
    def generateReport(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> 'EnvironmentalReporter.EnvironmentalReport': ...
    @typing.overload
    def generateReport(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, producedWaterTreatmentTrain: jneqsim.neqsim.process.equipment.watertreatment.ProducedWaterTreatmentTrain) -> 'EnvironmentalReporter.EnvironmentalReport': ...
    def getCO2FromFlaring(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> float: ...
    def getCO2FromPower(self, double: float) -> float: ...
    def getCO2Intensity(self, double: float) -> float: ...
    def getOilDischarge(self, producedWaterTreatmentTrain: jneqsim.neqsim.process.equipment.watertreatment.ProducedWaterTreatmentTrain) -> float: ...
    def getTotalPowerConsumption(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> float: ...
    def setOperatingHours(self, double: float) -> 'EnvironmentalReporter': ...
    def setPowerSupplyType(self, powerSupplyType: 'EnvironmentalReporter.PowerSupplyType') -> 'EnvironmentalReporter': ...
    def setProduction(self, double: float, double2: float, double3: float) -> 'EnvironmentalReporter': ...
    class EnvironmentalReport(java.io.Serializable):
        totalPowerKW: float = ...
        powerSupplyType: 'EnvironmentalReporter.PowerSupplyType' = ...
        co2FromPowerTonnesYear: float = ...
        co2FromFlaringTonnesYear: float = ...
        totalCO2TonnesYear: float = ...
        co2IntensityKgBoe: float = ...
        oilProductionSm3Year: float = ...
        gasProductionSm3Year: float = ...
        waterProductionM3Year: float = ...
        oiwMgL: float = ...
        oilDischargeTonnesYear: float = ...
        isOIWCompliant: bool = ...
        co2TaxNOK: float = ...
        isLowEmitter: bool = ...
        def __init__(self): ...
        def toMarkdown(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class PowerSupplyType(java.lang.Enum['EnvironmentalReporter.PowerSupplyType']):
        GAS_TURBINE: typing.ClassVar['EnvironmentalReporter.PowerSupplyType'] = ...
        DIESEL: typing.ClassVar['EnvironmentalReporter.PowerSupplyType'] = ...
        COMBINED_CYCLE: typing.ClassVar['EnvironmentalReporter.PowerSupplyType'] = ...
        POWER_FROM_SHORE: typing.ClassVar['EnvironmentalReporter.PowerSupplyType'] = ...
        def getEmissionFactor(self) -> float: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'EnvironmentalReporter.PowerSupplyType': ...
        @staticmethod
        def values() -> typing.MutableSequence['EnvironmentalReporter.PowerSupplyType']: ...

class MonteCarloRunner(java.io.Serializable):
    @typing.overload
    def __init__(self, cashFlowEngine: jneqsim.neqsim.process.fielddevelopment.economics.CashFlowEngine): ...
    @typing.overload
    def __init__(self, cashFlowEngine: jneqsim.neqsim.process.fielddevelopment.economics.CashFlowEngine, long: int): ...
    def addLognormal(self, string: typing.Union[java.lang.String, str], double: float, double2: float) -> None: ...
    def addNormal(self, string: typing.Union[java.lang.String, str], double: float, double2: float) -> None: ...
    def addTriangular(self, string: typing.Union[java.lang.String, str], double: float, double2: float, double3: float) -> None: ...
    def addUniform(self, string: typing.Union[java.lang.String, str], double: float, double2: float) -> None: ...
    def addVariable(self, string: typing.Union[java.lang.String, str], distributionType: 'MonteCarloRunner.DistributionType', double: float, double2: float, double3: float) -> None: ...
    def generateReport(self) -> java.lang.String: ...
    def getConvergedCount(self) -> int: ...
    def getDiscountRate(self) -> float: ...
    def getIterations(self) -> int: ...
    def getMean(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getP10(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getP50(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getP90(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getPercentile(self, string: typing.Union[java.lang.String, str], double: float) -> float: ...
    def getProbabilityNpvExceeds(self, double: float) -> float: ...
    def getProbabilityPositiveNpv(self) -> float: ...
    def getResults(self) -> java.util.List['MonteCarloRunner.IterationResult']: ...
    def getStdDev(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def run(self) -> bool: ...
    def setDiscountRate(self, double: float) -> None: ...
    def setIterations(self, int: int) -> None: ...
    def setSeed(self, long: int) -> None: ...
    class DistributionType(java.lang.Enum['MonteCarloRunner.DistributionType']):
        TRIANGULAR: typing.ClassVar['MonteCarloRunner.DistributionType'] = ...
        NORMAL: typing.ClassVar['MonteCarloRunner.DistributionType'] = ...
        LOGNORMAL: typing.ClassVar['MonteCarloRunner.DistributionType'] = ...
        UNIFORM: typing.ClassVar['MonteCarloRunner.DistributionType'] = ...
        FIXED: typing.ClassVar['MonteCarloRunner.DistributionType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'MonteCarloRunner.DistributionType': ...
        @staticmethod
        def values() -> typing.MutableSequence['MonteCarloRunner.DistributionType']: ...
    class IterationResult(java.io.Serializable):
        def __init__(self): ...
        def getInputs(self) -> java.util.Map[java.lang.String, float]: ...
        def getIrr(self) -> float: ...
        def getNpv(self) -> float: ...
        def getPaybackYears(self) -> float: ...
        def getProfitabilityIndex(self) -> float: ...
        def isConverged(self) -> bool: ...
        def setConverged(self, boolean: bool) -> None: ...
        def setInput(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
        def setIrr(self, double: float) -> None: ...
        def setNpv(self, double: float) -> None: ...
        def setPaybackYears(self, double: float) -> None: ...
        def setProfitabilityIndex(self, double: float) -> None: ...
    class UncertainVariable(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], distributionType: 'MonteCarloRunner.DistributionType', double: float, double2: float, double3: float): ...
        def getDistribution(self) -> 'MonteCarloRunner.DistributionType': ...
        def getName(self) -> java.lang.String: ...
        def getParam1(self) -> float: ...
        def getParam2(self) -> float: ...
        def getParam3(self) -> float: ...

class ProductionAllocator(java.io.Serializable):
    def __init__(self): ...
    @typing.overload
    def addSource(self, string: typing.Union[java.lang.String, str], streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface) -> 'ProductionAllocator': ...
    @typing.overload
    def addSource(self, string: typing.Union[java.lang.String, str], streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, meteringType: 'ProductionAllocator.MeteringType') -> 'ProductionAllocator': ...
    def allocateByEnergy(self) -> java.util.Map[java.lang.String, float]: ...
    def allocateByGas(self) -> java.util.Map[java.lang.String, float]: ...
    def allocateByMass(self) -> java.util.Map[java.lang.String, float]: ...
    def allocateByOil(self) -> java.util.Map[java.lang.String, float]: ...
    def generateReport(self) -> java.lang.String: ...
    def getAllocatedGasVolumes(self, double: float) -> java.util.Map[java.lang.String, float]: ...
    def getAllocatedOilVolumes(self, double: float) -> java.util.Map[java.lang.String, float]: ...
    def getAllocatedWithUncertainty(self, string: typing.Union[java.lang.String, str], double: float) -> typing.MutableSequence[float]: ...
    def getMassImbalance(self) -> float: ...
    def getOverallUncertainty(self) -> float: ...
    def getSourceUncertainty(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def isBalanceAcceptable(self, double: float) -> bool: ...
    def setExportMeter(self, string: typing.Union[java.lang.String, str], streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, meteringType: 'ProductionAllocator.MeteringType') -> 'ProductionAllocator': ...
    class MeteringType(java.lang.Enum['ProductionAllocator.MeteringType']):
        ULTRASONIC: typing.ClassVar['ProductionAllocator.MeteringType'] = ...
        CORIOLIS: typing.ClassVar['ProductionAllocator.MeteringType'] = ...
        DIFFERENTIAL_PRESSURE: typing.ClassVar['ProductionAllocator.MeteringType'] = ...
        VORTEX: typing.ClassVar['ProductionAllocator.MeteringType'] = ...
        TURBINE: typing.ClassVar['ProductionAllocator.MeteringType'] = ...
        MULTIPHASE: typing.ClassVar['ProductionAllocator.MeteringType'] = ...
        TEST_SEPARATOR: typing.ClassVar['ProductionAllocator.MeteringType'] = ...
        ESTIMATED: typing.ClassVar['ProductionAllocator.MeteringType'] = ...
        def getDisplayName(self) -> java.lang.String: ...
        def getUncertainty(self) -> float: ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProductionAllocator.MeteringType': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProductionAllocator.MeteringType']: ...

class ScenarioAnalyzer(java.io.Serializable):
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem): ...
    def addScenario(self, string: typing.Union[java.lang.String, str], scenarioParameters: 'ScenarioAnalyzer.ScenarioParameters') -> 'ScenarioAnalyzer': ...
    def clearScenarios(self) -> 'ScenarioAnalyzer': ...
    def generateReport(self) -> java.lang.String: ...
    def getResult(self, string: typing.Union[java.lang.String, str]) -> 'ScenarioAnalyzer.ScenarioResult': ...
    def getResults(self) -> java.util.List['ScenarioAnalyzer.ScenarioResult']: ...
    def runAll(self) -> java.util.List['ScenarioAnalyzer.ScenarioResult']: ...
    def setFeedStream(self, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface) -> 'ScenarioAnalyzer': ...
    class ScenarioParameters(java.io.Serializable):
        def __init__(self): ...
        def getGOR(self) -> float: ...
        def getGasRate(self) -> float: ...
        def getOilRate(self) -> float: ...
        def getPressure(self) -> float: ...
        def getTemperature(self) -> float: ...
        def getTotalMassRate(self) -> float: ...
        def getWaterCut(self) -> float: ...
        def getWaterRate(self) -> float: ...
        def setGOR(self, double: float) -> 'ScenarioAnalyzer.ScenarioParameters': ...
        def setGasRate(self, double: float) -> 'ScenarioAnalyzer.ScenarioParameters': ...
        def setOilRate(self, double: float) -> 'ScenarioAnalyzer.ScenarioParameters': ...
        def setPressure(self, double: float) -> 'ScenarioAnalyzer.ScenarioParameters': ...
        def setTemperature(self, double: float) -> 'ScenarioAnalyzer.ScenarioParameters': ...
        def setWaterCut(self, double: float) -> 'ScenarioAnalyzer.ScenarioParameters': ...
        def setWaterRate(self, double: float) -> 'ScenarioAnalyzer.ScenarioParameters': ...
    class ScenarioResult(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str]): ...
        def getCO2TonnesPerDay(self) -> float: ...
        def getCoolingDutyMW(self) -> float: ...
        def getErrorMessage(self) -> java.lang.String: ...
        def getHeatingDutyMW(self) -> float: ...
        def getName(self) -> java.lang.String: ...
        def getParameters(self) -> 'ScenarioAnalyzer.ScenarioParameters': ...
        def getPowerMW(self) -> float: ...
        def isConverged(self) -> bool: ...
        def setCO2TonnesPerDay(self, double: float) -> None: ...
        def setConverged(self, boolean: bool) -> None: ...
        def setCoolingDutyMW(self, double: float) -> None: ...
        def setErrorMessage(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setHeatingDutyMW(self, double: float) -> None: ...
        def setParameters(self, scenarioParameters: 'ScenarioAnalyzer.ScenarioParameters') -> None: ...
        def setPowerMW(self, double: float) -> None: ...

class SeparatorSizingCalculator(java.io.Serializable):
    def __init__(self): ...
    def createSeparator(self, string: typing.Union[java.lang.String, str], streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, separatorSizingResult: 'SeparatorSizingCalculator.SeparatorSizingResult') -> jneqsim.neqsim.process.equipment.separator.Separator: ...
    def gasBubbleRiseInLiquid(self, double: float, double2: float, double3: float, double4: float) -> float: ...
    def getAPI12JRetentionTime(self, double: float) -> float: ...
    def getAPI12JRetentionTimeFromAPI(self, double: float) -> float: ...
    def getRecommendedKFactor(self, separatorType: 'SeparatorSizingCalculator.SeparatorType', boolean: bool) -> float: ...
    def oilDropletSettlingInGas(self, double: float, double2: float, double3: float, double4: float) -> float: ...
    def separationTime(self, double: float, double2: float) -> float: ...
    def sizeSeparator(self, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, separatorType: 'SeparatorSizingCalculator.SeparatorType', designStandard: 'SeparatorSizingCalculator.DesignStandard') -> 'SeparatorSizingCalculator.SeparatorSizingResult': ...
    def sizeUsingNeqSimDesign(self, separator: jneqsim.neqsim.process.equipment.separator.Separator) -> 'SeparatorSizingCalculator.SeparatorSizingResult': ...
    def soudersbrownGasVelocity(self, double: float, double2: float, double3: float) -> float: ...
    def stokesSettlingVelocity(self, double: float, double2: float, double3: float, double4: float) -> float: ...
    class DesignStandard(java.lang.Enum['SeparatorSizingCalculator.DesignStandard']):
        API_12J: typing.ClassVar['SeparatorSizingCalculator.DesignStandard'] = ...
        GPSA: typing.ClassVar['SeparatorSizingCalculator.DesignStandard'] = ...
        SHELL_DEP: typing.ClassVar['SeparatorSizingCalculator.DesignStandard'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'SeparatorSizingCalculator.DesignStandard': ...
        @staticmethod
        def values() -> typing.MutableSequence['SeparatorSizingCalculator.DesignStandard']: ...
    class SeparatorSizingResult(java.io.Serializable):
        separatorType: 'SeparatorSizingCalculator.SeparatorType' = ...
        designStandard: 'SeparatorSizingCalculator.DesignStandard' = ...
        internalDiameter: float = ...
        tanTanLength: float = ...
        slendernessRatio: float = ...
        kFactor: float = ...
        maxGasVelocity: float = ...
        requiredRetentionTime: float = ...
        actualRetentionTime: float = ...
        liquidDensity: float = ...
        gasDensity: float = ...
        gasCapacityUtilization: float = ...
        liquidCapacityUtilization: float = ...
        def __init__(self): ...
        def getLiquidVolume(self) -> float: ...
        def getVolume(self) -> float: ...
        def toString(self) -> java.lang.String: ...
    class SeparatorType(java.lang.Enum['SeparatorSizingCalculator.SeparatorType']):
        HORIZONTAL: typing.ClassVar['SeparatorSizingCalculator.SeparatorType'] = ...
        VERTICAL: typing.ClassVar['SeparatorSizingCalculator.SeparatorType'] = ...
        SPHERICAL: typing.ClassVar['SeparatorSizingCalculator.SeparatorType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'SeparatorSizingCalculator.SeparatorType': ...
        @staticmethod
        def values() -> typing.MutableSequence['SeparatorSizingCalculator.SeparatorType']: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.neqsim.process.fielddevelopment.evaluation")``.

    BatchConceptRunner: typing.Type[BatchConceptRunner]
    BottleneckAnalyzer: typing.Type[BottleneckAnalyzer]
    ConceptEvaluator: typing.Type[ConceptEvaluator]
    ConceptKPIs: typing.Type[ConceptKPIs]
    DecommissioningEstimator: typing.Type[DecommissioningEstimator]
    DevelopmentOptionRanker: typing.Type[DevelopmentOptionRanker]
    EnvironmentalReporter: typing.Type[EnvironmentalReporter]
    MonteCarloRunner: typing.Type[MonteCarloRunner]
    ProductionAllocator: typing.Type[ProductionAllocator]
    ScenarioAnalyzer: typing.Type[ScenarioAnalyzer]
    SeparatorSizingCalculator: typing.Type[SeparatorSizingCalculator]
