
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import typing



class CashFlowEngine(java.io.Serializable):
    DEFAULT_DISCOUNT_RATE: typing.ClassVar[float] = ...
    DEFAULT_OPEX_PERCENT: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, norwegianTaxModel: 'NorwegianTaxModel'): ...
    @typing.overload
    def __init__(self, taxModel: 'TaxModel'): ...
    def addAnnualProduction(self, int: int, double: float, double2: float, double3: float) -> None: ...
    def addCapex(self, double: float, int: int) -> None: ...
    def calculate(self, double: float) -> 'CashFlowEngine.CashFlowResult': ...
    def calculateBreakevenGasPrice(self, double: float) -> float: ...
    def calculateBreakevenOilPrice(self, double: float) -> float: ...
    def calculateNPV(self, double: float) -> float: ...
    def getCountryCode(self) -> java.lang.String: ...
    def getCountryName(self) -> java.lang.String: ...
    def getTaxModel(self) -> 'TaxModel': ...
    def getTotalCapex(self) -> float: ...
    def setCapex(self, double: float, int: int) -> None: ...
    def setCapexSchedule(self, map: typing.Union[java.util.Map[int, float], typing.Mapping[int, float]]) -> None: ...
    def setFixedOpexPerYear(self, double: float) -> None: ...
    def setGasPrice(self, double: float) -> None: ...
    def setGasTariff(self, double: float) -> None: ...
    def setNglPrice(self, double: float) -> None: ...
    def setOilPrice(self, double: float) -> None: ...
    def setOilTariff(self, double: float) -> None: ...
    def setOpexPercentOfCapex(self, double: float) -> None: ...
    def setProductionProfile(self, map: typing.Union[java.util.Map[int, float], typing.Mapping[int, float]], map2: typing.Union[java.util.Map[int, float], typing.Mapping[int, float]], map3: typing.Union[java.util.Map[int, float], typing.Mapping[int, float]]) -> None: ...
    @typing.overload
    def setTaxModel(self, string: typing.Union[java.lang.String, str]) -> None: ...
    @typing.overload
    def setTaxModel(self, taxModel: 'TaxModel') -> None: ...
    def setVariableOpexPerBoe(self, double: float) -> None: ...
    class AnnualCashFlow(java.io.Serializable):
        def __init__(self, int: int, double: float, double2: float, double3: float, double4: float, double5: float, double6: float, double7: float, double8: float, double9: float, double10: float, double11: float, double12: float, double13: float, double14: float): ...
        def getAfterTaxCashFlow(self) -> float: ...
        def getCapex(self) -> float: ...
        def getCorporateTax(self) -> float: ...
        def getCumulativeCashFlow(self) -> float: ...
        def getDepreciation(self) -> float: ...
        def getDiscountedCashFlow(self) -> float: ...
        def getGrossRevenue(self) -> float: ...
        def getNetRevenue(self) -> float: ...
        def getOpex(self) -> float: ...
        def getPetroleumTax(self) -> float: ...
        def getPreTaxCashFlow(self) -> float: ...
        def getTariff(self) -> float: ...
        def getTotalTax(self) -> float: ...
        def getUplift(self) -> float: ...
        def getYear(self) -> int: ...
    class CashFlowResult(java.io.Serializable):
        def __init__(self, list: java.util.List['CashFlowEngine.AnnualCashFlow'], double: float, double2: float, double3: float, double4: float, double5: float, int: int, int2: int): ...
        def getAnnualCashFlows(self) -> java.util.List['CashFlowEngine.AnnualCashFlow']: ...
        def getDiscountRate(self) -> float: ...
        def getIrr(self) -> float: ...
        def getNpv(self) -> float: ...
        def getPaybackYears(self) -> float: ...
        def getProjectDuration(self) -> int: ...
        def getSummary(self) -> java.lang.String: ...
        def getTotalCapex(self) -> float: ...
        def getTotalRevenue(self) -> float: ...
        def getTotalTax(self) -> float: ...
        def toMarkdownTable(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...

class FiscalParameters(java.io.Serializable):
    @staticmethod
    def builder(string: typing.Union[java.lang.String, str]) -> 'FiscalParameters.Builder': ...
    def getCorporateTaxRate(self) -> float: ...
    def getCostRecoveryLimit(self) -> float: ...
    def getCountryCode(self) -> java.lang.String: ...
    def getCountryName(self) -> java.lang.String: ...
    def getDecliningBalanceRate(self) -> float: ...
    def getDepreciationMethod(self) -> 'FiscalParameters.DepreciationMethod': ...
    def getDepreciationYears(self) -> int: ...
    def getDescription(self) -> java.lang.String: ...
    def getFiscalSystemType(self) -> 'FiscalParameters.FiscalSystemType': ...
    def getInvestmentTaxCredit(self) -> float: ...
    def getLossCarryBackYears(self) -> int: ...
    def getLossCarryForwardInterest(self) -> float: ...
    def getLossCarryForwardYears(self) -> int: ...
    def getProfitShareContractor(self) -> float: ...
    def getProfitShareGovernment(self) -> float: ...
    def getRdEnhancementFactor(self) -> float: ...
    def getResourceTaxRate(self) -> float: ...
    def getRingFenceLevel(self) -> 'FiscalParameters.RingFenceLevel': ...
    def getRoyaltyRate(self) -> float: ...
    def getStateParticipation(self) -> float: ...
    def getTotalMarginalTaxRate(self) -> float: ...
    def getTotalUpliftPercentage(self) -> float: ...
    def getUpliftRate(self) -> float: ...
    def getUpliftYears(self) -> int: ...
    def getValidFromYear(self) -> int: ...
    def getWindfallTaxRate(self) -> float: ...
    def getWindfallTaxThreshold(self) -> float: ...
    def hasInvestmentIncentives(self) -> bool: ...
    def isDecommissioningDeductible(self) -> bool: ...
    def isDecommissioningFundDeductible(self) -> bool: ...
    def isEnhancedRdDeduction(self) -> bool: ...
    def isLossCarryBack(self) -> bool: ...
    def isLossCarryForward(self) -> bool: ...
    def isPscSystem(self) -> bool: ...
    def isRingFenced(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    class Builder:
        def build(self) -> 'FiscalParameters': ...
        def corporateTaxRate(self, double: float) -> 'FiscalParameters.Builder': ...
        def costRecoveryLimit(self, double: float) -> 'FiscalParameters.Builder': ...
        def countryName(self, string: typing.Union[java.lang.String, str]) -> 'FiscalParameters.Builder': ...
        def decliningBalanceRate(self, double: float) -> 'FiscalParameters.Builder': ...
        def decommissioning(self, boolean: bool, boolean2: bool) -> 'FiscalParameters.Builder': ...
        def depreciation(self, depreciationMethod: 'FiscalParameters.DepreciationMethod', int: int) -> 'FiscalParameters.Builder': ...
        def depreciationYears(self, int: int) -> 'FiscalParameters.Builder': ...
        def description(self, string: typing.Union[java.lang.String, str]) -> 'FiscalParameters.Builder': ...
        def enhancedRdDeduction(self, double: float) -> 'FiscalParameters.Builder': ...
        def fiscalSystemType(self, fiscalSystemType: 'FiscalParameters.FiscalSystemType') -> 'FiscalParameters.Builder': ...
        def investmentTaxCredit(self, double: float) -> 'FiscalParameters.Builder': ...
        def lossCarryBack(self, int: int) -> 'FiscalParameters.Builder': ...
        def lossCarryForward(self, int: int, double: float) -> 'FiscalParameters.Builder': ...
        def profitSharing(self, double: float, double2: float) -> 'FiscalParameters.Builder': ...
        def resourceTaxRate(self, double: float) -> 'FiscalParameters.Builder': ...
        def ringFenced(self, ringFenceLevel: 'FiscalParameters.RingFenceLevel') -> 'FiscalParameters.Builder': ...
        def royaltyRate(self, double: float) -> 'FiscalParameters.Builder': ...
        def stateParticipation(self, double: float) -> 'FiscalParameters.Builder': ...
        def uplift(self, double: float, int: int) -> 'FiscalParameters.Builder': ...
        def validFromYear(self, int: int) -> 'FiscalParameters.Builder': ...
        def windfallTax(self, double: float, double2: float) -> 'FiscalParameters.Builder': ...
    class DepreciationMethod(java.lang.Enum['FiscalParameters.DepreciationMethod']):
        STRAIGHT_LINE: typing.ClassVar['FiscalParameters.DepreciationMethod'] = ...
        DECLINING_BALANCE: typing.ClassVar['FiscalParameters.DepreciationMethod'] = ...
        UNIT_OF_PRODUCTION: typing.ClassVar['FiscalParameters.DepreciationMethod'] = ...
        IMMEDIATE: typing.ClassVar['FiscalParameters.DepreciationMethod'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'FiscalParameters.DepreciationMethod': ...
        @staticmethod
        def values() -> typing.MutableSequence['FiscalParameters.DepreciationMethod']: ...
    class FiscalSystemType(java.lang.Enum['FiscalParameters.FiscalSystemType']):
        CONCESSIONARY: typing.ClassVar['FiscalParameters.FiscalSystemType'] = ...
        PSC: typing.ClassVar['FiscalParameters.FiscalSystemType'] = ...
        SERVICE_CONTRACT: typing.ClassVar['FiscalParameters.FiscalSystemType'] = ...
        RISK_SERVICE_CONTRACT: typing.ClassVar['FiscalParameters.FiscalSystemType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'FiscalParameters.FiscalSystemType': ...
        @staticmethod
        def values() -> typing.MutableSequence['FiscalParameters.FiscalSystemType']: ...
    class RingFenceLevel(java.lang.Enum['FiscalParameters.RingFenceLevel']):
        FIELD: typing.ClassVar['FiscalParameters.RingFenceLevel'] = ...
        LICENSE: typing.ClassVar['FiscalParameters.RingFenceLevel'] = ...
        COMPANY: typing.ClassVar['FiscalParameters.RingFenceLevel'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'FiscalParameters.RingFenceLevel': ...
        @staticmethod
        def values() -> typing.MutableSequence['FiscalParameters.RingFenceLevel']: ...

class PortfolioOptimizer(java.io.Serializable):
    def __init__(self): ...
    @typing.overload
    def addProject(self, string: typing.Union[java.lang.String, str], double: float, double2: float, projectType: 'PortfolioOptimizer.ProjectType', double3: float) -> 'PortfolioOptimizer.Project': ...
    @typing.overload
    def addProject(self, string: typing.Union[java.lang.String, str], double: float, projectType: 'PortfolioOptimizer.ProjectType', double2: float, map: typing.Union[java.util.Map[int, float], typing.Mapping[int, float]]) -> 'PortfolioOptimizer.Project': ...
    @typing.overload
    def addProject(self, project: 'PortfolioOptimizer.Project') -> None: ...
    def clearProjects(self) -> None: ...
    def compareStrategies(self) -> java.util.Map['PortfolioOptimizer.OptimizationStrategy', 'PortfolioOptimizer.PortfolioResult']: ...
    def generateComparisonReport(self) -> java.lang.String: ...
    def getProjects(self) -> java.util.List['PortfolioOptimizer.Project']: ...
    def optimize(self, optimizationStrategy: 'PortfolioOptimizer.OptimizationStrategy') -> 'PortfolioOptimizer.PortfolioResult': ...
    def setAnnualBudget(self, int: int, double: float) -> None: ...
    def setMaxAllocation(self, projectType: 'PortfolioOptimizer.ProjectType', double: float) -> None: ...
    def setMinAllocation(self, projectType: 'PortfolioOptimizer.ProjectType', double: float) -> None: ...
    def setTotalBudget(self, double: float) -> None: ...
    class OptimizationStrategy(java.lang.Enum['PortfolioOptimizer.OptimizationStrategy']):
        GREEDY_NPV_RATIO: typing.ClassVar['PortfolioOptimizer.OptimizationStrategy'] = ...
        GREEDY_ABSOLUTE_NPV: typing.ClassVar['PortfolioOptimizer.OptimizationStrategy'] = ...
        RISK_WEIGHTED: typing.ClassVar['PortfolioOptimizer.OptimizationStrategy'] = ...
        BALANCED: typing.ClassVar['PortfolioOptimizer.OptimizationStrategy'] = ...
        EMV_MAXIMIZATION: typing.ClassVar['PortfolioOptimizer.OptimizationStrategy'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'PortfolioOptimizer.OptimizationStrategy': ...
        @staticmethod
        def values() -> typing.MutableSequence['PortfolioOptimizer.OptimizationStrategy']: ...
    class PortfolioResult(java.io.Serializable):
        def __init__(self): ...
        def generateReport(self) -> java.lang.String: ...
        def getAnnualBudgetRemaining(self) -> java.util.Map[int, float]: ...
        def getAnnualCapexUsed(self) -> java.util.Map[int, float]: ...
        def getCapitalEfficiency(self) -> float: ...
        def getDeferredProjects(self) -> java.util.List['PortfolioOptimizer.Project']: ...
        def getProjectCount(self) -> int: ...
        def getSelectedProjects(self) -> java.util.List['PortfolioOptimizer.Project']: ...
        def getStrategy(self) -> 'PortfolioOptimizer.OptimizationStrategy': ...
        def getTotalCapex(self) -> float: ...
        def getTotalEmv(self) -> float: ...
        def getTotalNpv(self) -> float: ...
        def setStrategy(self, optimizationStrategy: 'PortfolioOptimizer.OptimizationStrategy') -> None: ...
        def setTotalCapex(self, double: float) -> None: ...
        def setTotalEmv(self, double: float) -> None: ...
        def setTotalNpv(self, double: float) -> None: ...
    class Project(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], double: float, double2: float, projectType: 'PortfolioOptimizer.ProjectType', double3: float): ...
        def addDependency(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def getCapexForYear(self, int: int) -> float: ...
        def getCapexMusd(self) -> float: ...
        def getCapexProfile(self) -> java.util.Map[int, float]: ...
        def getDependencies(self) -> java.util.List[java.lang.String]: ...
        def getEmv(self) -> float: ...
        def getName(self) -> java.lang.String: ...
        def getNpvCapexRatio(self) -> float: ...
        def getNpvMusd(self) -> float: ...
        def getProbabilityOfSuccess(self) -> float: ...
        def getRiskWeightedRatio(self) -> float: ...
        def getStartYear(self) -> int: ...
        def getType(self) -> 'PortfolioOptimizer.ProjectType': ...
        def isMandatory(self) -> bool: ...
        def setCapexProfile(self, map: typing.Union[java.util.Map[int, float], typing.Mapping[int, float]]) -> None: ...
        def setMandatory(self, boolean: bool) -> None: ...
        def setStartYear(self, int: int) -> None: ...
    class ProjectType(java.lang.Enum['PortfolioOptimizer.ProjectType']):
        DEVELOPMENT: typing.ClassVar['PortfolioOptimizer.ProjectType'] = ...
        IOR: typing.ClassVar['PortfolioOptimizer.ProjectType'] = ...
        EXPLORATION: typing.ClassVar['PortfolioOptimizer.ProjectType'] = ...
        TIEBACK: typing.ClassVar['PortfolioOptimizer.ProjectType'] = ...
        INFRASTRUCTURE: typing.ClassVar['PortfolioOptimizer.ProjectType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'PortfolioOptimizer.ProjectType': ...
        @staticmethod
        def values() -> typing.MutableSequence['PortfolioOptimizer.ProjectType']: ...

class ProductionProfileGenerator(java.io.Serializable):
    def __init__(self): ...
    @staticmethod
    def calculateCumulativeProduction(map: typing.Union[java.util.Map[int, float], typing.Mapping[int, float]]) -> float: ...
    @staticmethod
    def calculateEUR(double: float, double2: float, declineType: 'ProductionProfileGenerator.DeclineType', double3: float) -> float: ...
    @staticmethod
    def combineProfiles(*map: typing.Union[java.util.Map[int, float], typing.Mapping[int, float]]) -> java.util.Map[int, float]: ...
    @typing.overload
    def generateExponentialDecline(self, double: float, double2: float, int: int, int2: int) -> java.util.Map[int, float]: ...
    @typing.overload
    def generateExponentialDecline(self, double: float, double2: float, int: int, int2: int, double3: float) -> java.util.Map[int, float]: ...
    @typing.overload
    def generateFullProfile(self, double: float, int: int, int2: int, double2: float, double3: float, declineType: 'ProductionProfileGenerator.DeclineType', int3: int, int4: int, double4: float) -> java.util.Map[int, float]: ...
    @typing.overload
    def generateFullProfile(self, double: float, int: int, int2: int, double2: float, declineType: 'ProductionProfileGenerator.DeclineType', int3: int, int4: int) -> java.util.Map[int, float]: ...
    @typing.overload
    def generateHarmonicDecline(self, double: float, double2: float, int: int, int2: int) -> java.util.Map[int, float]: ...
    @typing.overload
    def generateHarmonicDecline(self, double: float, double2: float, int: int, int2: int, double3: float) -> java.util.Map[int, float]: ...
    @typing.overload
    def generateHyperbolicDecline(self, double: float, double2: float, double3: float, int: int, int2: int) -> java.util.Map[int, float]: ...
    @typing.overload
    def generateHyperbolicDecline(self, double: float, double2: float, double3: float, int: int, int2: int, double4: float) -> java.util.Map[int, float]: ...
    @typing.overload
    def generateWithPlateau(self, double: float, int: int, double2: float, double3: float, declineType: 'ProductionProfileGenerator.DeclineType', int2: int, int3: int, double4: float) -> java.util.Map[int, float]: ...
    @typing.overload
    def generateWithPlateau(self, double: float, int: int, double2: float, declineType: 'ProductionProfileGenerator.DeclineType', int2: int, int3: int) -> java.util.Map[int, float]: ...
    @staticmethod
    def getProfileSummary(map: typing.Union[java.util.Map[int, float], typing.Mapping[int, float]]) -> java.lang.String: ...
    @staticmethod
    def scaleProfile(map: typing.Union[java.util.Map[int, float], typing.Mapping[int, float]], double: float) -> java.util.Map[int, float]: ...
    @staticmethod
    def shiftProfile(map: typing.Union[java.util.Map[int, float], typing.Mapping[int, float]], int: int) -> java.util.Map[int, float]: ...
    class DeclineType(java.lang.Enum['ProductionProfileGenerator.DeclineType']):
        EXPONENTIAL: typing.ClassVar['ProductionProfileGenerator.DeclineType'] = ...
        HYPERBOLIC: typing.ClassVar['ProductionProfileGenerator.DeclineType'] = ...
        HARMONIC: typing.ClassVar['ProductionProfileGenerator.DeclineType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProductionProfileGenerator.DeclineType': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProductionProfileGenerator.DeclineType']: ...

class SensitivityAnalyzer(java.io.Serializable):
    def __init__(self, cashFlowEngine: CashFlowEngine, double: float): ...
    def breakevenAnalysis(self) -> 'SensitivityAnalyzer.BreakevenResult': ...
    def monteCarloAnalysis(self, int: int) -> 'SensitivityAnalyzer.MonteCarloResult': ...
    def scenarioAnalysis(self, double: float, double2: float, double3: float, double4: float, double5: float) -> 'SensitivityAnalyzer.ScenarioResult': ...
    def setCapexDistribution(self, double: float, double2: float) -> None: ...
    def setGasPriceDistribution(self, double: float, double2: float) -> None: ...
    def setOilPriceDistribution(self, double: float, double2: float) -> None: ...
    def setOpexFactorDistribution(self, double: float, double2: float) -> None: ...
    def setProductionFactorDistribution(self, double: float, double2: float) -> None: ...
    def setRandomSeed(self, long: int) -> None: ...
    def tornadoAnalysis(self, double: float) -> 'SensitivityAnalyzer.TornadoResult': ...
    class BreakevenResult(java.io.Serializable):
        def getBreakevenGasPrice(self) -> float: ...
        def getBreakevenOilPrice(self) -> float: ...
        def getDiscountRate(self) -> float: ...
        def toString(self) -> java.lang.String: ...
    class MonteCarloResult(java.io.Serializable):
        def getCoefficientOfVariation(self) -> float: ...
        def getIrrMean(self) -> float: ...
        def getIrrP10(self) -> float: ...
        def getIrrP50(self) -> float: ...
        def getIrrP90(self) -> float: ...
        def getIterations(self) -> int: ...
        def getNpvDistribution(self) -> typing.MutableSequence[float]: ...
        def getNpvMean(self) -> float: ...
        def getNpvP10(self) -> float: ...
        def getNpvP50(self) -> float: ...
        def getNpvP90(self) -> float: ...
        def getNpvStdDev(self) -> float: ...
        def getProbabilityPositiveNpv(self) -> float: ...
        def toString(self) -> java.lang.String: ...
    class ScenarioResult(java.io.Serializable):
        def getBaseIrr(self) -> float: ...
        def getBaseNpv(self) -> float: ...
        def getHighIrr(self) -> float: ...
        def getHighNpv(self) -> float: ...
        def getLowIrr(self) -> float: ...
        def getLowNpv(self) -> float: ...
        def getNpvRange(self) -> float: ...
        def toString(self) -> java.lang.String: ...
    class TornadoItem(java.io.Serializable):
        def getBaseCaseNpv(self) -> float: ...
        def getHighNpv(self) -> float: ...
        def getImpactLevel(self) -> java.lang.String: ...
        def getLowNpv(self) -> float: ...
        def getParameterName(self) -> java.lang.String: ...
        def getSwing(self) -> float: ...
    class TornadoResult(java.io.Serializable):
        def getBaseCaseNpv(self) -> float: ...
        def getItems(self) -> java.util.List['SensitivityAnalyzer.TornadoItem']: ...
        def getMostSensitiveParameter(self) -> 'SensitivityAnalyzer.TornadoItem': ...
        def getVariationPercent(self) -> float: ...
        def toMarkdownTable(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...

class TaxModel(java.io.Serializable):
    def calculateDepreciation(self, double: float, int: int) -> float: ...
    def calculateEffectiveTaxRate(self, double: float, double2: float, double3: float, double4: float) -> float: ...
    def calculateRoyalty(self, double: float) -> float: ...
    def calculateTax(self, double: float, double2: float, double3: float, double4: float) -> 'TaxModel.TaxResult': ...
    def calculateUplift(self, double: float, int: int) -> float: ...
    def getCountryCode(self) -> java.lang.String: ...
    def getCountryName(self) -> java.lang.String: ...
    def getLossCarryForward(self) -> float: ...
    def getParameters(self) -> FiscalParameters: ...
    def getTotalMarginalTaxRate(self) -> float: ...
    def reset(self) -> None: ...
    class TaxResult(java.io.Serializable):
        @typing.overload
        def __init__(self, double: float, double2: float, double3: float, double4: float, double5: float, double6: float, double7: float, double8: float, double9: float, double10: float): ...
        @typing.overload
        def __init__(self, double: float, double2: float, double3: float, double4: float, double5: float, double6: float, double7: float, double8: float, double9: float, double10: float, double11: float): ...
        def getAfterTaxIncome(self) -> float: ...
        def getCorporateTax(self) -> float: ...
        def getCorporateTaxBase(self) -> float: ...
        def getDepreciation(self) -> float: ...
        def getEffectiveTaxRate(self) -> float: ...
        def getGovernmentTake(self) -> float: ...
        def getGovernmentTakePercentage(self) -> float: ...
        def getGrossRevenue(self) -> float: ...
        def getOpex(self) -> float: ...
        def getPetroleumTax(self) -> float: ...
        def getPetroleumTaxBase(self) -> float: ...
        def getResourceTax(self) -> float: ...
        def getResourceTaxBase(self) -> float: ...
        def getRoyalty(self) -> float: ...
        def getTotalTax(self) -> float: ...
        def getUplift(self) -> float: ...
        def toString(self) -> java.lang.String: ...

class TaxModelRegistry:
    @staticmethod
    def createModel(string: typing.Union[java.lang.String, str]) -> TaxModel: ...
    @staticmethod
    def getAllParameters() -> java.util.Map[java.lang.String, FiscalParameters]: ...
    @staticmethod
    def getAvailableCountries() -> java.util.List[java.lang.String]: ...
    @staticmethod
    def getParameters(string: typing.Union[java.lang.String, str]) -> FiscalParameters: ...
    @staticmethod
    def getParametersOrDefault(string: typing.Union[java.lang.String, str], fiscalParameters: FiscalParameters) -> FiscalParameters: ...
    @staticmethod
    def getRegisteredCount() -> int: ...
    @staticmethod
    def getSummaryTable() -> java.lang.String: ...
    @staticmethod
    def isRegistered(string: typing.Union[java.lang.String, str]) -> bool: ...
    @staticmethod
    def loadFromJson(inputStream: java.io.InputStream) -> int: ...
    @staticmethod
    def register(fiscalParameters: FiscalParameters) -> None: ...
    @staticmethod
    def reload() -> bool: ...

class GenericTaxModel(TaxModel):
    def __init__(self, fiscalParameters: FiscalParameters): ...
    def calculateDepreciation(self, double: float, int: int) -> float: ...
    def calculateEffectiveTaxRate(self, double: float, double2: float, double3: float, double4: float) -> float: ...
    def calculateProfitSharing(self, double: float, double2: float) -> typing.MutableSequence[float]: ...
    def calculateRoyalty(self, double: float) -> float: ...
    def calculateStateParticipation(self, double: float) -> float: ...
    def calculateTax(self, double: float, double2: float, double3: float, double4: float) -> TaxModel.TaxResult: ...
    def calculateUplift(self, double: float, int: int) -> float: ...
    @staticmethod
    def forCountry(string: typing.Union[java.lang.String, str]) -> 'GenericTaxModel': ...
    def getCorporateTaxLossCarryForward(self) -> float: ...
    def getCountryCode(self) -> java.lang.String: ...
    def getCountryName(self) -> java.lang.String: ...
    def getLossCarryForward(self) -> float: ...
    def getParameters(self) -> FiscalParameters: ...
    def getResourceTaxLossCarryForward(self) -> float: ...
    def getTotalMarginalTaxRate(self) -> float: ...
    def reset(self) -> None: ...
    def setCorporateTaxLossCarryForward(self, double: float) -> None: ...
    def setResourceTaxLossCarryForward(self, double: float) -> None: ...
    def toString(self) -> java.lang.String: ...

class NorwegianTaxModel(TaxModel):
    DEFAULT_CORPORATE_TAX_RATE: typing.ClassVar[float] = ...
    DEFAULT_PETROLEUM_TAX_RATE: typing.ClassVar[float] = ...
    TOTAL_MARGINAL_RATE: typing.ClassVar[float] = ...
    DEFAULT_UPLIFT_RATE: typing.ClassVar[float] = ...
    DEFAULT_UPLIFT_YEARS: typing.ClassVar[int] = ...
    TOTAL_UPLIFT_PERCENTAGE: typing.ClassVar[float] = ...
    DEFAULT_DEPRECIATION_YEARS: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    def calculateDepreciation(self, double: float, int: int) -> float: ...
    def calculateEffectiveTaxRate(self, double: float, double2: float, double3: float, double4: float) -> float: ...
    def calculateGovernmentTake(self, double: float, double2: float, double3: float, double4: float) -> float: ...
    def calculateRoyalty(self, double: float) -> float: ...
    def calculateTax(self, double: float, double2: float, double3: float, double4: float) -> TaxModel.TaxResult: ...
    def calculateUplift(self, double: float, int: int) -> float: ...
    @staticmethod
    def createTaxModel() -> TaxModel: ...
    def getCorporateTaxLossCarryForward(self) -> float: ...
    def getCorporateTaxRate(self) -> float: ...
    def getCountryCode(self) -> java.lang.String: ...
    def getCountryName(self) -> java.lang.String: ...
    def getDepreciationYears(self) -> int: ...
    @staticmethod
    def getFiscalParameters() -> FiscalParameters: ...
    def getLossCarryForward(self) -> float: ...
    def getParameters(self) -> FiscalParameters: ...
    def getPetroleumTaxLossCarryForward(self) -> float: ...
    def getPetroleumTaxRate(self) -> float: ...
    def getTotalMarginalRate(self) -> float: ...
    def getTotalMarginalTaxRate(self) -> float: ...
    def getUpliftRate(self) -> float: ...
    def getUpliftYears(self) -> int: ...
    def reset(self) -> None: ...
    def resetLossCarryForward(self) -> None: ...
    def setCorporateTaxRate(self, double: float) -> None: ...
    def setDepreciationYears(self, int: int) -> None: ...
    def setPetroleumTaxRate(self, double: float) -> None: ...
    def setUpliftRate(self, double: float) -> None: ...
    def setUpliftYears(self, int: int) -> None: ...
    class TaxResult(java.io.Serializable):
        def __init__(self, double: float, double2: float, double3: float, double4: float, double5: float, double6: float, double7: float, double8: float, double9: float, double10: float): ...
        def getAfterTaxIncome(self) -> float: ...
        def getCorporateTax(self) -> float: ...
        def getCorporateTaxBase(self) -> float: ...
        def getDepreciation(self) -> float: ...
        def getEffectiveTaxRate(self) -> float: ...
        def getGrossRevenue(self) -> float: ...
        def getOpex(self) -> float: ...
        def getPetroleumTax(self) -> float: ...
        def getPetroleumTaxBase(self) -> float: ...
        def getTotalTax(self) -> float: ...
        def getUplift(self) -> float: ...
        def toString(self) -> java.lang.String: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.neqsim.process.fielddevelopment.economics")``.

    CashFlowEngine: typing.Type[CashFlowEngine]
    FiscalParameters: typing.Type[FiscalParameters]
    GenericTaxModel: typing.Type[GenericTaxModel]
    NorwegianTaxModel: typing.Type[NorwegianTaxModel]
    PortfolioOptimizer: typing.Type[PortfolioOptimizer]
    ProductionProfileGenerator: typing.Type[ProductionProfileGenerator]
    SensitivityAnalyzer: typing.Type[SensitivityAnalyzer]
    TaxModel: typing.Type[TaxModel]
    TaxModelRegistry: typing.Type[TaxModelRegistry]
