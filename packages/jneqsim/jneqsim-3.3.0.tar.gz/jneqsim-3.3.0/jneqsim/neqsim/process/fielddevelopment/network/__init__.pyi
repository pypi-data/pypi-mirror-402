
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jpype
import jneqsim.neqsim.process.equipment.reservoir
import jneqsim.neqsim.process.equipment.stream
import jneqsim.neqsim.thermo.system
import typing



class MultiphaseFlowIntegrator(java.io.Serializable):
    def __init__(self): ...
    def calculateHydraulics(self, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, double: float) -> 'MultiphaseFlowIntegrator.PipelineResult': ...
    def calculateHydraulicsCurve(self, systemInterface: jneqsim.neqsim.thermo.system.SystemInterface, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> java.util.List['MultiphaseFlowIntegrator.PipelineResult']: ...
    def getPipelineDiameterM(self) -> float: ...
    def getPipelineLengthKm(self) -> float: ...
    def setElevationChange(self, double: float) -> None: ...
    def setErosionalConstant(self, double: float) -> None: ...
    def setMinArrivalPressure(self, double: float) -> None: ...
    def setNumberOfSegments(self, int: int) -> None: ...
    def setOverallHeatTransferCoeff(self, double: float) -> None: ...
    def setPipelineDiameter(self, double: float) -> None: ...
    def setPipelineLength(self, double: float) -> None: ...
    def setPipelineRoughness(self, double: float) -> None: ...
    def setSeabedTemperature(self, double: float) -> None: ...
    def sizePipeline(self, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, double: float, double2: float) -> float: ...
    class FlowRegime(java.lang.Enum['MultiphaseFlowIntegrator.FlowRegime']):
        STRATIFIED_SMOOTH: typing.ClassVar['MultiphaseFlowIntegrator.FlowRegime'] = ...
        STRATIFIED_WAVY: typing.ClassVar['MultiphaseFlowIntegrator.FlowRegime'] = ...
        INTERMITTENT: typing.ClassVar['MultiphaseFlowIntegrator.FlowRegime'] = ...
        ANNULAR: typing.ClassVar['MultiphaseFlowIntegrator.FlowRegime'] = ...
        DISPERSED_BUBBLE: typing.ClassVar['MultiphaseFlowIntegrator.FlowRegime'] = ...
        UNKNOWN: typing.ClassVar['MultiphaseFlowIntegrator.FlowRegime'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'MultiphaseFlowIntegrator.FlowRegime': ...
        @staticmethod
        def values() -> typing.MutableSequence['MultiphaseFlowIntegrator.FlowRegime']: ...
    class PipelineResult(java.io.Serializable):
        def __init__(self): ...
        def generateReport(self) -> java.lang.String: ...
        def getArrivalPressureBar(self) -> float: ...
        def getArrivalTemperatureC(self) -> float: ...
        def getErosionalVelocityMs(self) -> float: ...
        def getErosionalVelocityRatio(self) -> float: ...
        def getFlowRegime(self) -> 'MultiphaseFlowIntegrator.FlowRegime': ...
        def getGasVelocityMs(self) -> float: ...
        def getInfeasibilityReason(self) -> java.lang.String: ...
        def getInletPressureBar(self) -> float: ...
        def getInletTemperatureC(self) -> float: ...
        def getLiquidHoldup(self) -> float: ...
        def getLiquidVelocityMs(self) -> float: ...
        def getMixtureVelocityMs(self) -> float: ...
        def getPressureDropBar(self) -> float: ...
        def getSlugFrequencyPerMin(self) -> float: ...
        def isFeasible(self) -> bool: ...
        def setArrivalPressureBar(self, double: float) -> None: ...
        def setArrivalTemperatureC(self, double: float) -> None: ...
        def setErosionalVelocityMs(self, double: float) -> None: ...
        def setErosionalVelocityRatio(self, double: float) -> None: ...
        def setFeasible(self, boolean: bool) -> None: ...
        def setFlowRegime(self, flowRegime: 'MultiphaseFlowIntegrator.FlowRegime') -> None: ...
        def setGasVelocityMs(self, double: float) -> None: ...
        def setInfeasibilityReason(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setInletPressureBar(self, double: float) -> None: ...
        def setInletTemperatureC(self, double: float) -> None: ...
        def setLiquidHoldup(self, double: float) -> None: ...
        def setLiquidVelocityMs(self, double: float) -> None: ...
        def setMixtureVelocityMs(self, double: float) -> None: ...
        def setPressureDropBar(self, double: float) -> None: ...
        def setSlugFrequencyPerMin(self, double: float) -> None: ...

class NetworkResult(java.io.Serializable):
    networkName: java.lang.String = ...
    solutionMode: 'NetworkSolver.SolutionMode' = ...
    manifoldPressure: float = ...
    totalRate: float = ...
    wellRates: java.util.Map = ...
    wellheadPressures: java.util.Map = ...
    flowlinePressureDrops: java.util.Map = ...
    wellEnabled: java.util.Map = ...
    converged: bool = ...
    iterations: int = ...
    residual: float = ...
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    def getFlowlinePressureDrop(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getProducingWellCount(self) -> int: ...
    def getSummaryTable(self) -> java.lang.String: ...
    def getTotalRate(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getWellRate(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> float: ...
    def getWellheadPressure(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def isWellEnabled(self, string: typing.Union[java.lang.String, str]) -> bool: ...
    def toString(self) -> java.lang.String: ...

class NetworkSolver(java.io.Serializable):
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def addWell(self, wellSystem: jneqsim.neqsim.process.equipment.reservoir.WellSystem, double: float) -> 'NetworkSolver': ...
    @typing.overload
    def addWell(self, wellSystem: jneqsim.neqsim.process.equipment.reservoir.WellSystem, double: float, double2: float) -> 'NetworkSolver': ...
    def getCombinedStream(self) -> jneqsim.neqsim.process.equipment.stream.StreamInterface: ...
    def getEnabledWellCount(self) -> int: ...
    def getName(self) -> java.lang.String: ...
    def getWellCount(self) -> int: ...
    def isSolved(self) -> bool: ...
    def setChokeOpening(self, string: typing.Union[java.lang.String, str], double: float) -> 'NetworkSolver': ...
    def setManifoldPressure(self, double: float, string: typing.Union[java.lang.String, str]) -> 'NetworkSolver': ...
    def setMaxTotalRate(self, double: float, string: typing.Union[java.lang.String, str]) -> 'NetworkSolver': ...
    def setReferenceFluid(self, systemInterface: jneqsim.neqsim.thermo.system.SystemInterface) -> 'NetworkSolver': ...
    def setSolutionMode(self, solutionMode: 'NetworkSolver.SolutionMode') -> 'NetworkSolver': ...
    def setSolverParameters(self, double: float, int: int, double2: float) -> 'NetworkSolver': ...
    def setTargetTotalRate(self, double: float, string: typing.Union[java.lang.String, str]) -> 'NetworkSolver': ...
    def setWellEnabled(self, string: typing.Union[java.lang.String, str], boolean: bool) -> 'NetworkSolver': ...
    def solve(self) -> NetworkResult: ...
    class SolutionMode(java.lang.Enum['NetworkSolver.SolutionMode']):
        FIXED_MANIFOLD_PRESSURE: typing.ClassVar['NetworkSolver.SolutionMode'] = ...
        FIXED_TOTAL_RATE: typing.ClassVar['NetworkSolver.SolutionMode'] = ...
        OPTIMIZE_ALLOCATION: typing.ClassVar['NetworkSolver.SolutionMode'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'NetworkSolver.SolutionMode': ...
        @staticmethod
        def values() -> typing.MutableSequence['NetworkSolver.SolutionMode']: ...
    class WellNode(java.io.Serializable): ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.neqsim.process.fielddevelopment.network")``.

    MultiphaseFlowIntegrator: typing.Type[MultiphaseFlowIntegrator]
    NetworkResult: typing.Type[NetworkResult]
    NetworkSolver: typing.Type[NetworkSolver]
