
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jneqsim.neqsim.process.equipment
import jneqsim.neqsim.process.equipment.separator
import jneqsim.neqsim.process.equipment.stream
import typing



class Hydrocyclone(jneqsim.neqsim.process.equipment.separator.Separator):
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str], streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface): ...
    def getD50Microns(self) -> float: ...
    def getEfficiencyForDropletSize(self, double: float) -> float: ...
    def getOilRemovalEfficiency(self) -> float: ...
    def getOutletOilMgL(self) -> float: ...
    def getPressureDropBar(self) -> float: ...
    def getRejectRatio(self) -> float: ...
    @typing.overload
    def run(self) -> None: ...
    @typing.overload
    def run(self, uUID: java.util.UUID) -> None: ...
    def setD50Microns(self, double: float) -> None: ...
    def setInletOilConcentration(self, double: float) -> None: ...
    def setOilRemovalEfficiency(self, double: float) -> None: ...
    def setPressureDropBar(self, double: float) -> None: ...
    def setRejectRatio(self, double: float) -> None: ...

class ProducedWaterTreatmentTrain(jneqsim.neqsim.process.equipment.ProcessEquipmentBaseClass):
    NCS_OIW_LIMIT_MGL: typing.ClassVar[float] = ...
    OSPAR_OIW_LIMIT_MGL: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str], streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface): ...
    def addStage(self, waterTreatmentStage: 'ProducedWaterTreatmentTrain.WaterTreatmentStage') -> None: ...
    def clearStages(self) -> None: ...
    def generateReport(self) -> java.lang.String: ...
    def getAnnualOilDischargeTonnes(self, double: float) -> float: ...
    def getInletStream(self) -> jneqsim.neqsim.process.equipment.stream.StreamInterface: ...
    def getOilInWaterMgL(self) -> float: ...
    def getOilInWaterPpm(self) -> float: ...
    def getOverallEfficiency(self) -> float: ...
    def getRecoveredOilM3h(self) -> float: ...
    def getRecoveredOilStream(self) -> jneqsim.neqsim.process.equipment.stream.StreamInterface: ...
    def getStages(self) -> java.util.List['ProducedWaterTreatmentTrain.WaterTreatmentStage']: ...
    def getTreatedWaterStream(self) -> jneqsim.neqsim.process.equipment.stream.StreamInterface: ...
    def isCompliantWith(self, double: float) -> bool: ...
    def isDischargeCompliant(self) -> bool: ...
    @typing.overload
    def run(self) -> None: ...
    @typing.overload
    def run(self, uUID: java.util.UUID) -> None: ...
    def setInletOilConcentration(self, double: float) -> None: ...
    def setInletStream(self, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface) -> None: ...
    def setStageEfficiency(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    def setWaterFlowRate(self, double: float) -> None: ...
    class StageType(java.lang.Enum['ProducedWaterTreatmentTrain.StageType']):
        HYDROCYCLONE: typing.ClassVar['ProducedWaterTreatmentTrain.StageType'] = ...
        FLOTATION: typing.ClassVar['ProducedWaterTreatmentTrain.StageType'] = ...
        SKIM_TANK: typing.ClassVar['ProducedWaterTreatmentTrain.StageType'] = ...
        COALESCER: typing.ClassVar['ProducedWaterTreatmentTrain.StageType'] = ...
        FILTER: typing.ClassVar['ProducedWaterTreatmentTrain.StageType'] = ...
        MEMBRANE: typing.ClassVar['ProducedWaterTreatmentTrain.StageType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProducedWaterTreatmentTrain.StageType': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProducedWaterTreatmentTrain.StageType']: ...
    class WaterTreatmentStage(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], stageType: 'ProducedWaterTreatmentTrain.StageType', double: float): ...
        def getEfficiency(self) -> float: ...
        def getInletOIW(self) -> float: ...
        def getName(self) -> java.lang.String: ...
        def getOutletOIW(self) -> float: ...
        def getRecoveredOilM3h(self) -> float: ...
        def getType(self) -> 'ProducedWaterTreatmentTrain.StageType': ...
        def setEfficiency(self, double: float) -> None: ...
        def setInletOIW(self, double: float) -> None: ...
        def setOutletOIW(self, double: float) -> None: ...
        def setRecoveredOilM3h(self, double: float) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.neqsim.process.equipment.watertreatment")``.

    Hydrocyclone: typing.Type[Hydrocyclone]
    ProducedWaterTreatmentTrain: typing.Type[ProducedWaterTreatmentTrain]
