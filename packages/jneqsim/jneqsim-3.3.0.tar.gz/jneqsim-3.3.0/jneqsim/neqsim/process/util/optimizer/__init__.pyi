
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.nio.file
import java.time
import java.util
import java.util.function
import jpype
import jpype.protocol
import jneqsim.neqsim.process.equipment
import jneqsim.neqsim.process.equipment.capacity
import jneqsim.neqsim.process.equipment.compressor
import jneqsim.neqsim.process.equipment.separator
import jneqsim.neqsim.process.equipment.stream
import jneqsim.neqsim.process.equipment.util
import jneqsim.neqsim.process.processmodel
import typing



class BatchStudy(java.io.Serializable):
    @staticmethod
    def builder(processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> 'BatchStudy.Builder': ...
    def getTotalCases(self) -> int: ...
    def run(self) -> 'BatchStudy.BatchStudyResult': ...
    class BatchStudyResult(java.io.Serializable):
        def exportToCSV(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def exportToJSON(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def getAllResults(self) -> java.util.List['BatchStudy.CaseResult']: ...
        def getBestCase(self, string: typing.Union[java.lang.String, str]) -> 'BatchStudy.CaseResult': ...
        def getFailureCount(self) -> int: ...
        def getParetoFront(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> java.util.List['BatchStudy.CaseResult']: ...
        def getSuccessCount(self) -> int: ...
        def getSuccessfulResults(self) -> java.util.List['BatchStudy.CaseResult']: ...
        def getSummary(self) -> java.lang.String: ...
        def getTotalCases(self) -> int: ...
        def toJson(self) -> java.lang.String: ...
    class Builder:
        def addObjective(self, string: typing.Union[java.lang.String, str], objective: 'BatchStudy.Objective', function: typing.Union[java.util.function.Function[jneqsim.neqsim.process.processmodel.ProcessSystem, float], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]]) -> 'BatchStudy.Builder': ...
        def build(self) -> 'BatchStudy': ...
        def name(self, string: typing.Union[java.lang.String, str]) -> 'BatchStudy.Builder': ...
        def parallelism(self, int: int) -> 'BatchStudy.Builder': ...
        def stopOnFailure(self, boolean: bool) -> 'BatchStudy.Builder': ...
        @typing.overload
        def vary(self, string: typing.Union[java.lang.String, str], double: float, double2: float, int: int) -> 'BatchStudy.Builder': ...
        @typing.overload
        def vary(self, string: typing.Union[java.lang.String, str], *double: float) -> 'BatchStudy.Builder': ...
    class CaseResult(java.io.Serializable):
        parameters: 'BatchStudy.ParameterSet' = ...
        failed: bool = ...
        errorMessage: java.lang.String = ...
        objectiveValues: java.util.Map = ...
        runtime: java.time.Duration = ...
        def __init__(self, parameterSet: 'BatchStudy.ParameterSet', boolean: bool, string: typing.Union[java.lang.String, str]): ...
    class Objective(java.lang.Enum['BatchStudy.Objective']):
        MINIMIZE: typing.ClassVar['BatchStudy.Objective'] = ...
        MAXIMIZE: typing.ClassVar['BatchStudy.Objective'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'BatchStudy.Objective': ...
        @staticmethod
        def values() -> typing.MutableSequence['BatchStudy.Objective']: ...
    class ObjectiveDefinition(java.io.Serializable):
        name: java.lang.String = ...
        direction: 'BatchStudy.Objective' = ...
        def __init__(self, string: typing.Union[java.lang.String, str], objective: 'BatchStudy.Objective'): ...
    class ParameterSet(java.io.Serializable):
        caseId: java.lang.String = ...
        values: java.util.Map = ...
        def __init__(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]): ...
        def toString(self) -> java.lang.String: ...

class EclipseVFPExporter(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def exportCOMPDAT(self, string: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    def exportMultipleScenarios(self, list: java.util.List['EclipseVFPExporter.VFPScenario'], string: typing.Union[java.lang.String, str]) -> None: ...
    def exportVFPEXP(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportVFPINJ(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def exportVFPPROD(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def getALQs(self) -> typing.MutableSequence[float]: ...
    def getBHPTable(self) -> typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[float]]]]]: ...
    def getDatumDepth(self) -> float: ...
    def getFlowRateType(self) -> java.lang.String: ...
    def getFlowRates(self) -> typing.MutableSequence[float]: ...
    def getGORs(self) -> typing.MutableSequence[float]: ...
    def getTHPs(self) -> typing.MutableSequence[float]: ...
    def getTableNumber(self) -> int: ...
    def getTableTitle(self) -> java.lang.String: ...
    def getUnitSystem(self) -> java.lang.String: ...
    def getVFPINJString(self) -> java.lang.String: ...
    def getVFPPRODString(self) -> java.lang.String: ...
    def getWaterCuts(self) -> typing.MutableSequence[float]: ...
    def setALQs(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setBHPTable(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[float]]]]], jpype.JArray]) -> None: ...
    def setDatumDepth(self, double: float) -> None: ...
    def setFlowRateType(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setFlowRates(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setGORs(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setLiftCurveData(self, liftCurveData: 'ProcessOptimizationEngine.LiftCurveData') -> None: ...
    def setTHPs(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setTableNumber(self, int: int) -> None: ...
    def setTableTitle(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setUnitSystem(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setWaterCuts(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    class VFPScenario(java.io.Serializable):
        def __init__(self): ...
        def getBHPTable(self) -> typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[float]]]]]: ...
        def getDescription(self) -> java.lang.String: ...
        def getFlowRates(self) -> typing.MutableSequence[float]: ...
        def getGORs(self) -> typing.MutableSequence[float]: ...
        def getTHPs(self) -> typing.MutableSequence[float]: ...
        def getTableNumber(self) -> int: ...
        def getWaterCuts(self) -> typing.MutableSequence[float]: ...
        def setBHPTable(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[typing.MutableSequence[float]]]]], jpype.JArray]) -> None: ...
        def setDescription(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setFlowRates(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
        def setGORs(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
        def setTHPs(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
        def setTableNumber(self, int: int) -> None: ...
        def setWaterCuts(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...

class FlowRateOptimizationResult(java.io.Serializable):
    def __init__(self): ...
    def addConstraintViolation(self, constraintViolation: 'FlowRateOptimizationResult.ConstraintViolation') -> None: ...
    @staticmethod
    def error(string: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizationResult': ...
    def getComputationTimeMs(self) -> int: ...
    def getConstraintViolations(self) -> java.util.List['FlowRateOptimizationResult.ConstraintViolation']: ...
    def getConvergenceError(self) -> float: ...
    def getFlowRate(self) -> float: ...
    def getFlowRateUnit(self) -> java.lang.String: ...
    def getInfeasibilityReason(self) -> java.lang.String: ...
    def getInletPressure(self) -> float: ...
    def getIterationCount(self) -> int: ...
    def getOutletPressure(self) -> float: ...
    def getPressureUnit(self) -> java.lang.String: ...
    def getStatus(self) -> 'FlowRateOptimizationResult.Status': ...
    def getTargetInletPressure(self) -> float: ...
    def getTargetOutletPressure(self) -> float: ...
    def hasHardViolations(self) -> bool: ...
    @staticmethod
    def infeasibleConstraint(string: typing.Union[java.lang.String, str], list: java.util.List['FlowRateOptimizationResult.ConstraintViolation']) -> 'FlowRateOptimizationResult': ...
    @staticmethod
    def infeasiblePressure(string: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizationResult': ...
    def isFeasible(self) -> bool: ...
    @staticmethod
    def notConverged(int: int, double: float) -> 'FlowRateOptimizationResult': ...
    def setComputationTimeMs(self, long: int) -> None: ...
    def setConvergenceError(self, double: float) -> None: ...
    def setFlowRate(self, double: float) -> None: ...
    def setFlowRateUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setInfeasibilityReason(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setInletPressure(self, double: float) -> None: ...
    def setIterationCount(self, int: int) -> None: ...
    def setOutletPressure(self, double: float) -> None: ...
    def setPressureUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setStatus(self, status: 'FlowRateOptimizationResult.Status') -> None: ...
    def setTargetInletPressure(self, double: float) -> None: ...
    def setTargetOutletPressure(self, double: float) -> None: ...
    @staticmethod
    def success(double: float, string: typing.Union[java.lang.String, str], double2: float, double3: float, string2: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizationResult': ...
    def toString(self) -> java.lang.String: ...
    class ConstraintViolation(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, double2: float, string3: typing.Union[java.lang.String, str], boolean: bool): ...
        def getConstraintName(self) -> java.lang.String: ...
        def getCurrentValue(self) -> float: ...
        def getEquipmentName(self) -> java.lang.String: ...
        def getLimitValue(self) -> float: ...
        def getUnit(self) -> java.lang.String: ...
        def isHardViolation(self) -> bool: ...
        def toString(self) -> java.lang.String: ...
    class Status(java.lang.Enum['FlowRateOptimizationResult.Status']):
        OPTIMAL: typing.ClassVar['FlowRateOptimizationResult.Status'] = ...
        INFEASIBLE_PRESSURE: typing.ClassVar['FlowRateOptimizationResult.Status'] = ...
        INFEASIBLE_CONSTRAINT: typing.ClassVar['FlowRateOptimizationResult.Status'] = ...
        NOT_CONVERGED: typing.ClassVar['FlowRateOptimizationResult.Status'] = ...
        ERROR: typing.ClassVar['FlowRateOptimizationResult.Status'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizationResult.Status': ...
        @staticmethod
        def values() -> typing.MutableSequence['FlowRateOptimizationResult.Status']: ...

class FlowRateOptimizer(java.io.Serializable):
    @typing.overload
    def __init__(self, processModel: jneqsim.neqsim.process.processmodel.ProcessModel, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]): ...
    def calculateTotalCompressorPower(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def configureProcessCompressorCharts(self) -> None: ...
    def findFlowRate(self, double: float, double2: float, string: typing.Union[java.lang.String, str]) -> FlowRateOptimizationResult: ...
    def findInletPressure(self, double: float, string: typing.Union[java.lang.String, str], double2: float, string2: typing.Union[java.lang.String, str]) -> FlowRateOptimizationResult: ...
    def findMaxFlowRateAtPressureBoundaries(self, double: float, double2: float, string: typing.Union[java.lang.String, str], double3: float) -> 'FlowRateOptimizer.ProcessOperatingPoint': ...
    def findMaximumFeasibleFlowRate(self, double: float, string: typing.Union[java.lang.String, str], double2: float) -> 'FlowRateOptimizer.ProcessOperatingPoint': ...
    def findMinimumTotalPowerOperatingPoint(self, double: float, double2: float, string: typing.Union[java.lang.String, str], double3: float, double4: float, string2: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizer.ProcessOperatingPoint': ...
    def findProcessOperatingPoint(self, double: float, string: typing.Union[java.lang.String, str], double2: float, string2: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizer.ProcessOperatingPoint': ...
    def generateCapacityCurve(self, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray], string: typing.Union[java.lang.String, str], double3: float, string2: typing.Union[java.lang.String, str]) -> typing.MutableSequence['FlowRateOptimizer.ProcessOperatingPoint']: ...
    def generateProcessCapacityTable(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], string: typing.Union[java.lang.String, str], double3: float) -> 'FlowRateOptimizer.ProcessCapacityTable': ...
    def generateProcessLiftCurve(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], string: typing.Union[java.lang.String, str], doubleArray2: typing.Union[typing.List[float], jpype.JArray], string2: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizer.ProcessLiftCurveTable': ...
    def generateProcessPerformanceTable(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], string: typing.Union[java.lang.String, str], double2: float, string2: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizer.ProcessPerformanceTable': ...
    @typing.overload
    def generateProfessionalLiftCurves(self, double: float, double2: float, double3: float, double4: float, string: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizer.LiftCurveResult': ...
    @typing.overload
    def generateProfessionalLiftCurves(self, liftCurveConfiguration: 'FlowRateOptimizer.LiftCurveConfiguration') -> 'FlowRateOptimizer.LiftCurveResult': ...
    def getEquipmentUtilizationReport(self) -> java.util.Map[java.lang.String, 'FlowRateOptimizer.EquipmentUtilizationData']: ...
    def getInitialFlowGuess(self) -> float: ...
    def getMaxEquipmentUtilization(self) -> float: ...
    def getMaxEquipmentUtilizationLimit(self) -> float: ...
    def getMaxFlowRate(self) -> float: ...
    def getMaxIterations(self) -> int: ...
    def getMaxPowerLimit(self) -> float: ...
    def getMaxSpeedLimit(self) -> float: ...
    def getMaxTotalPowerLimit(self) -> float: ...
    def getMaxVelocity(self) -> float: ...
    def getMinFlowRate(self) -> float: ...
    def getMinSpeedLimit(self) -> float: ...
    def getMinSurgeMargin(self) -> float: ...
    def getMode(self) -> 'FlowRateOptimizer.Mode': ...
    def getNumberOfChartSpeeds(self) -> int: ...
    def getParallelThreads(self) -> int: ...
    def getProcessCompressors(self) -> java.util.List[jneqsim.neqsim.process.equipment.compressor.Compressor]: ...
    def getProcessSeparators(self) -> java.util.List[jneqsim.neqsim.process.equipment.separator.Separator]: ...
    def getProgressCallback(self) -> 'FlowRateOptimizer.ProgressCallback': ...
    def getSpeedMarginAboveDesign(self) -> float: ...
    def getTolerance(self) -> float: ...
    def isAutoConfigureProcessCompressors(self) -> bool: ...
    def isAutoGenerateCompressorChart(self) -> bool: ...
    def isCheckCapacityConstraints(self) -> bool: ...
    def isParallelEvaluationEnabled(self) -> bool: ...
    def isSolveSpeed(self) -> bool: ...
    def setAutoConfigureProcessCompressors(self, boolean: bool) -> None: ...
    def setAutoGenerateCompressorChart(self, boolean: bool) -> None: ...
    def setCheckCapacityConstraints(self, boolean: bool) -> None: ...
    def setEnableParallelEvaluation(self, boolean: bool) -> None: ...
    def setEnableProgressLogging(self, boolean: bool) -> None: ...
    def setInitialFlowGuess(self, double: float) -> None: ...
    def setMaxEquipmentUtilizationLimit(self, double: float) -> None: ...
    def setMaxFlowRate(self, double: float) -> None: ...
    def setMaxIterations(self, int: int) -> None: ...
    def setMaxPowerLimit(self, double: float) -> None: ...
    def setMaxSpeedLimit(self, double: float) -> None: ...
    def setMaxTotalPowerLimit(self, double: float) -> None: ...
    def setMaxVelocity(self, double: float) -> None: ...
    def setMinFlowRate(self, double: float) -> None: ...
    def setMinSpeedLimit(self, double: float) -> None: ...
    def setMinSurgeMargin(self, double: float) -> None: ...
    def setNumberOfChartSpeeds(self, int: int) -> None: ...
    def setParallelThreads(self, int: int) -> None: ...
    def setProgressCallback(self, progressCallback: typing.Union['FlowRateOptimizer.ProgressCallback', typing.Callable]) -> None: ...
    def setSolveSpeed(self, boolean: bool) -> None: ...
    def setSpeedMarginAboveDesign(self, double: float) -> None: ...
    def setTolerance(self, double: float) -> None: ...
    def validateConfiguration(self) -> java.util.List[java.lang.String]: ...
    def validateOrThrow(self) -> None: ...
    class CompressorOperatingPoint(java.io.Serializable):
        def __init__(self): ...
        def getFlowRate(self) -> float: ...
        def getFlowRateUnit(self) -> java.lang.String: ...
        def getInletPressure(self) -> float: ...
        def getOutletPressure(self) -> float: ...
        def getPolytropicEfficiency(self) -> float: ...
        def getPolytropicHead(self) -> float: ...
        def getPower(self) -> float: ...
        def getPressureRatio(self) -> float: ...
        def getPressureUnit(self) -> java.lang.String: ...
        def getSpeed(self) -> float: ...
        def getSurgeMargin(self) -> float: ...
        def isAtStoneWall(self) -> bool: ...
        def isFeasible(self) -> bool: ...
        def isInSurge(self) -> bool: ...
        def setAtStoneWall(self, boolean: bool) -> None: ...
        def setFeasible(self, boolean: bool) -> None: ...
        def setFlowRate(self, double: float) -> None: ...
        def setFlowRateUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setInSurge(self, boolean: bool) -> None: ...
        def setInletPressure(self, double: float) -> None: ...
        def setOutletPressure(self, double: float) -> None: ...
        def setPolytropicEfficiency(self, double: float) -> None: ...
        def setPolytropicHead(self, double: float) -> None: ...
        def setPower(self, double: float) -> None: ...
        def setPressureUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setSpeed(self, double: float) -> None: ...
        def setSurgeMargin(self, double: float) -> None: ...
        def toString(self) -> java.lang.String: ...
    class EquipmentUtilizationData(java.io.Serializable):
        def __init__(self): ...
        def getCapacity(self) -> float: ...
        def getDuty(self) -> float: ...
        def getEquipmentType(self) -> java.lang.String: ...
        def getName(self) -> java.lang.String: ...
        def getPower(self) -> float: ...
        def getSpeed(self) -> float: ...
        def getStonewallMargin(self) -> float: ...
        def getSurgeMargin(self) -> float: ...
        def getUtilization(self) -> float: ...
        def setCapacity(self, double: float) -> None: ...
        def setDuty(self, double: float) -> None: ...
        def setEquipmentType(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setPower(self, double: float) -> None: ...
        def setSpeed(self, double: float) -> None: ...
        def setStonewallMargin(self, double: float) -> None: ...
        def setSurgeMargin(self, double: float) -> None: ...
        def setUtilization(self, double: float) -> None: ...
        def toString(self) -> java.lang.String: ...
    class LiftCurveConfiguration(java.io.Serializable):
        def __init__(self): ...
        def getFlowRateUnit(self) -> java.lang.String: ...
        def getFlowRates(self) -> typing.MutableSequence[float]: ...
        def getInletPressures(self) -> typing.MutableSequence[float]: ...
        def getMaxPowerLimit(self) -> float: ...
        def getMaxSpeedLimit(self) -> float: ...
        def getMaxTotalPowerLimit(self) -> float: ...
        def getMaxUtilization(self) -> float: ...
        def getMinSpeedLimit(self) -> float: ...
        def getOutletPressures(self) -> typing.MutableSequence[float]: ...
        def getPressureUnit(self) -> java.lang.String: ...
        def getProgressCallback(self) -> 'FlowRateOptimizer.ProgressCallback': ...
        def getSurgeMargin(self) -> float: ...
        def isEnableProgressLogging(self) -> bool: ...
        def isGenerateCapacityTable(self) -> bool: ...
        def isGenerateLiftCurveTable(self) -> bool: ...
        def isGeneratePerformanceTable(self) -> bool: ...
        def withFlowRateRange(self, double: float, double2: float, int: int) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withFlowRateUnit(self, string: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withInletPressureRange(self, double: float, double2: float, int: int) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withMaxPowerLimit(self, double: float) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withMaxTotalPowerLimit(self, double: float) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withMaxUtilization(self, double: float) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withOutletPressureRange(self, double: float, double2: float, int: int) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withPressureUnit(self, string: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withProgressCallback(self, progressCallback: typing.Union['FlowRateOptimizer.ProgressCallback', typing.Callable]) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withProgressLogging(self, boolean: bool) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withSpeedLimits(self, double: float, double2: float) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withSurgeMargin(self, double: float) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
        def withTables(self, boolean: bool, boolean2: bool, boolean3: bool) -> 'FlowRateOptimizer.LiftCurveConfiguration': ...
    class LiftCurveResult(java.io.Serializable):
        def __init__(self): ...
        def addWarning(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def getCapacityTable(self) -> 'FlowRateOptimizer.ProcessCapacityTable': ...
        def getFeasibilityPercentage(self) -> float: ...
        def getFeasiblePoints(self) -> int: ...
        def getGenerationTimeMs(self) -> int: ...
        def getLiftCurveTable(self) -> 'FlowRateOptimizer.ProcessLiftCurveTable': ...
        def getPerformanceTable(self) -> 'FlowRateOptimizer.ProcessPerformanceTable': ...
        def getSummary(self) -> java.lang.String: ...
        def getTotalEvaluations(self) -> int: ...
        def getWarnings(self) -> java.util.List[java.lang.String]: ...
        def setCapacityTable(self, processCapacityTable: 'FlowRateOptimizer.ProcessCapacityTable') -> None: ...
        def setFeasiblePoints(self, int: int) -> None: ...
        def setGenerationTimeMs(self, long: int) -> None: ...
        def setLiftCurveTable(self, processLiftCurveTable: 'FlowRateOptimizer.ProcessLiftCurveTable') -> None: ...
        def setPerformanceTable(self, processPerformanceTable: 'FlowRateOptimizer.ProcessPerformanceTable') -> None: ...
        def setTotalEvaluations(self, int: int) -> None: ...
    class Mode(java.lang.Enum['FlowRateOptimizer.Mode']):
        PROCESS_SYSTEM: typing.ClassVar['FlowRateOptimizer.Mode'] = ...
        PROCESS_MODEL: typing.ClassVar['FlowRateOptimizer.Mode'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizer.Mode': ...
        @staticmethod
        def values() -> typing.MutableSequence['FlowRateOptimizer.Mode']: ...
    class ProcessCapacityTable(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], list: java.util.List[typing.Union[java.lang.String, str]]): ...
        def countFeasiblePoints(self) -> int: ...
        def findMaxFlowRatePoint(self) -> 'FlowRateOptimizer.ProcessOperatingPoint': ...
        def findMinimumPowerPoint(self) -> 'FlowRateOptimizer.ProcessOperatingPoint': ...
        def getCompressorNames(self) -> java.util.List[java.lang.String]: ...
        def getFlowRateUnit(self) -> java.lang.String: ...
        def getFlowRateValues(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getInletPressures(self) -> typing.MutableSequence[float]: ...
        def getMaxUtilization(self) -> float: ...
        def getMaxUtilizationValues(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getOperatingPoint(self, int: int, int2: int) -> 'FlowRateOptimizer.ProcessOperatingPoint': ...
        def getOutletPressures(self) -> typing.MutableSequence[float]: ...
        def getPressureUnit(self) -> java.lang.String: ...
        def getTableName(self) -> java.lang.String: ...
        def getTotalPowerValues(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def setFlowRateUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setMaxUtilization(self, double: float) -> None: ...
        def setOperatingPoint(self, int: int, int2: int, processOperatingPoint: 'FlowRateOptimizer.ProcessOperatingPoint') -> None: ...
        def setPressureUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setTableName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def toCsv(self) -> java.lang.String: ...
        def toEclipseFormat(self) -> java.lang.String: ...
        def toFormattedString(self) -> java.lang.String: ...
        def toJson(self) -> java.lang.String: ...
    class ProcessLiftCurveTable(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], list: java.util.List[typing.Union[java.lang.String, str]]): ...
        def findMinimumPowerPoint(self) -> 'FlowRateOptimizer.ProcessOperatingPoint': ...
        def getCompressorNames(self) -> java.util.List[java.lang.String]: ...
        def getFlowRateUnit(self) -> java.lang.String: ...
        def getFlowRates(self) -> typing.MutableSequence[float]: ...
        def getInletPressures(self) -> typing.MutableSequence[float]: ...
        def getMaxUtilizationValues(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getOperatingPoint(self, int: int, int2: int) -> 'FlowRateOptimizer.ProcessOperatingPoint': ...
        def getOutletPressureValues(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def getPressureUnit(self) -> java.lang.String: ...
        def getTableName(self) -> java.lang.String: ...
        def getTotalPowerValues(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
        def setFlowRateUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setOperatingPoint(self, int: int, int2: int, processOperatingPoint: 'FlowRateOptimizer.ProcessOperatingPoint') -> None: ...
        def setPressureUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setTableName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def toEclipseFormat(self) -> java.lang.String: ...
        def toFormattedString(self) -> java.lang.String: ...
        def toJson(self) -> java.lang.String: ...
    class ProcessOperatingPoint(java.io.Serializable):
        def __init__(self): ...
        def addCompressorOperatingPoint(self, string: typing.Union[java.lang.String, str], compressorOperatingPoint: 'FlowRateOptimizer.CompressorOperatingPoint') -> None: ...
        def getCompressorNames(self) -> java.util.List[java.lang.String]: ...
        def getCompressorOperatingPoint(self, string: typing.Union[java.lang.String, str]) -> 'FlowRateOptimizer.CompressorOperatingPoint': ...
        def getCompressorOperatingPoints(self) -> java.util.Map[java.lang.String, 'FlowRateOptimizer.CompressorOperatingPoint']: ...
        def getCompressorPower(self, string: typing.Union[java.lang.String, str]) -> float: ...
        def getConstraintViolations(self) -> java.util.List[FlowRateOptimizationResult.ConstraintViolation]: ...
        def getEquipmentData(self) -> java.util.Map[java.lang.String, 'FlowRateOptimizer.EquipmentUtilizationData']: ...
        def getFlowRate(self) -> float: ...
        def getFlowRateUnit(self) -> java.lang.String: ...
        def getInletPressure(self) -> float: ...
        def getMaxUtilization(self) -> float: ...
        def getOutletPressure(self) -> float: ...
        def getPressureRatio(self) -> float: ...
        def getPressureUnit(self) -> java.lang.String: ...
        def getTotalPower(self) -> float: ...
        def isFeasible(self) -> bool: ...
        def setConstraintViolations(self, list: java.util.List[FlowRateOptimizationResult.ConstraintViolation]) -> None: ...
        def setEquipmentData(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], 'FlowRateOptimizer.EquipmentUtilizationData'], typing.Mapping[typing.Union[java.lang.String, str], 'FlowRateOptimizer.EquipmentUtilizationData']]) -> None: ...
        def setFeasible(self, boolean: bool) -> None: ...
        def setFlowRate(self, double: float) -> None: ...
        def setFlowRateUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setInletPressure(self, double: float) -> None: ...
        def setMaxUtilization(self, double: float) -> None: ...
        def setOutletPressure(self, double: float) -> None: ...
        def setPressureUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setTotalPower(self, double: float) -> None: ...
        def toDetailedString(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...
    class ProcessPerformanceTable(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], doubleArray: typing.Union[typing.List[float], jpype.JArray], list: java.util.List[typing.Union[java.lang.String, str]]): ...
        def findMinimumPowerPoint(self) -> 'FlowRateOptimizer.ProcessOperatingPoint': ...
        def getFlowRateUnit(self) -> java.lang.String: ...
        def getFlowRates(self) -> typing.MutableSequence[float]: ...
        def getInletPressure(self) -> float: ...
        def getOperatingPoint(self, int: int) -> 'FlowRateOptimizer.ProcessOperatingPoint': ...
        def getOutletPressure(self, int: int) -> float: ...
        def getPressureUnit(self) -> java.lang.String: ...
        def getTableName(self) -> java.lang.String: ...
        def getTotalPower(self, int: int) -> float: ...
        def setFlowRateUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setInletPressure(self, double: float) -> None: ...
        def setOperatingPoint(self, int: int, processOperatingPoint: 'FlowRateOptimizer.ProcessOperatingPoint') -> None: ...
        def setPressureUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setTableName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def toFormattedString(self) -> java.lang.String: ...
    class ProgressCallback:
        def onProgress(self, int: int, int2: int, string: typing.Union[java.lang.String, str]) -> None: ...

class LiftCurveGenerator(java.io.Serializable):
    @typing.overload
    def __init__(self, processModel: jneqsim.neqsim.process.processmodel.ProcessModel, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]): ...
    def generateFlowRateTable(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'LiftCurveTable': ...
    def generateTable(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'LiftCurveTable': ...
    def generateTableAutoRange(self, int: int, int2: int, double: float, double2: float, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> 'LiftCurveTable': ...
    def getMaxVelocity(self) -> float: ...
    def getOptimizer(self) -> FlowRateOptimizer: ...
    def getTableName(self) -> java.lang.String: ...
    def isCheckConstraints(self) -> bool: ...
    def setCheckConstraints(self, boolean: bool) -> None: ...
    def setFlowRateLimits(self, double: float, double2: float) -> None: ...
    def setMaxVelocity(self, double: float) -> None: ...
    def setOptimizerParameters(self, int: int, double: float) -> None: ...
    def setTableName(self, string: typing.Union[java.lang.String, str]) -> None: ...

class LiftCurveTable(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    def countFeasiblePoints(self) -> int: ...
    def getBHP(self, int: int, int2: int) -> float: ...
    def getBhpValues(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getComments(self) -> java.lang.String: ...
    def getFeasibilityPercent(self) -> float: ...
    def getFlowRateUnit(self) -> java.lang.String: ...
    def getFlowRates(self) -> typing.MutableSequence[float]: ...
    def getPressureUnit(self) -> java.lang.String: ...
    def getRawDataWithHeaders(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getTableName(self) -> java.lang.String: ...
    def getThpValues(self) -> typing.MutableSequence[float]: ...
    def getTotalPoints(self) -> int: ...
    def interpolateBHP(self, double: float, double2: float) -> float: ...
    def setBHP(self, int: int, int2: int, double: float) -> None: ...
    def setBhpValues(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]) -> None: ...
    def setComments(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setFlowRateUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setFlowRates(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def setPressureUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setTableName(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setThpValues(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def toCSV(self) -> java.lang.String: ...
    def toEclipseFormat(self) -> java.lang.String: ...
    def toJson(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class MultiObjectiveOptimizer(java.io.Serializable):
    DEFAULT_WEIGHT_COMBINATIONS: typing.ClassVar[int] = ...
    DEFAULT_GRID_POINTS: typing.ClassVar[int] = ...
    def __init__(self): ...
    def includeInfeasible(self, boolean: bool) -> 'MultiObjectiveOptimizer': ...
    def onProgress(self, progressCallback: typing.Union['MultiObjectiveOptimizer.ProgressCallback', typing.Callable]) -> 'MultiObjectiveOptimizer': ...
    @typing.overload
    def optimizeEpsilonConstraint(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, objectiveFunction: 'ObjectiveFunction', list: java.util.List['ObjectiveFunction'], optimizationConfig: 'ProductionOptimizer.OptimizationConfig', int: int) -> 'ParetoFront': ...
    @typing.overload
    def optimizeEpsilonConstraint(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, objectiveFunction: 'ObjectiveFunction', list: java.util.List['ObjectiveFunction'], optimizationConfig: 'ProductionOptimizer.OptimizationConfig', int: int, list2: java.util.List['ProductionOptimizer.OptimizationConstraint']) -> 'ParetoFront': ...
    @typing.overload
    def optimizeWeightedSum(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, list: java.util.List['ObjectiveFunction'], optimizationConfig: 'ProductionOptimizer.OptimizationConfig', int: int) -> 'ParetoFront': ...
    @typing.overload
    def optimizeWeightedSum(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, list: java.util.List['ObjectiveFunction'], optimizationConfig: 'ProductionOptimizer.OptimizationConfig', int: int, list2: java.util.List['ProductionOptimizer.OptimizationConstraint']) -> 'ParetoFront': ...
    @typing.overload
    def sampleParetoFront(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, list: java.util.List['ObjectiveFunction'], optimizationConfig: 'ProductionOptimizer.OptimizationConfig', int: int) -> 'ParetoFront': ...
    @typing.overload
    def sampleParetoFront(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, list: java.util.List['ObjectiveFunction'], optimizationConfig: 'ProductionOptimizer.OptimizationConfig', int: int, list2: java.util.List['ProductionOptimizer.OptimizationConstraint']) -> 'ParetoFront': ...
    class MultiObjectiveResult(java.io.Serializable):
        def __init__(self, paretoFront: 'ParetoFront', list: java.util.List['ObjectiveFunction'], string: typing.Union[java.lang.String, str], long: int): ...
        def getComputationTimeMs(self) -> int: ...
        def getKneePoint(self) -> 'ParetoSolution': ...
        def getMethod(self) -> java.lang.String: ...
        def getNumSolutions(self) -> int: ...
        def getObjectives(self) -> java.util.List['ObjectiveFunction']: ...
        def getParetoFront(self) -> 'ParetoFront': ...
        def toString(self) -> java.lang.String: ...
    class ProgressCallback:
        def onProgress(self, int: int, int2: int, paretoSolution: 'ParetoSolution') -> None: ...

class ObjectiveFunction:
    @staticmethod
    def create(string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], direction: 'ObjectiveFunction.Direction', string2: typing.Union[java.lang.String, str]) -> 'ObjectiveFunction': ...
    def evaluate(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> float: ...
    def evaluateNormalized(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> float: ...
    def getDirection(self) -> 'ObjectiveFunction.Direction': ...
    def getName(self) -> java.lang.String: ...
    def getUnit(self) -> java.lang.String: ...
    class Direction(java.lang.Enum['ObjectiveFunction.Direction']):
        MAXIMIZE: typing.ClassVar['ObjectiveFunction.Direction'] = ...
        MINIMIZE: typing.ClassVar['ObjectiveFunction.Direction'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ObjectiveFunction.Direction': ...
        @staticmethod
        def values() -> typing.MutableSequence['ObjectiveFunction.Direction']: ...

class OptimizationResultBase(java.io.Serializable):
    def __init__(self): ...
    def addConstraintMargin(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    @typing.overload
    def addConstraintViolation(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, double2: float, string3: typing.Union[java.lang.String, str], boolean: bool) -> None: ...
    @typing.overload
    def addConstraintViolation(self, constraintViolation: 'OptimizationResultBase.ConstraintViolation') -> None: ...
    def addInitialValue(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    def addOptimalValue(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    def addSensitivity(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    def addShadowPrice(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    def getBottleneckConstraint(self) -> java.lang.String: ...
    def getBottleneckEquipment(self) -> java.lang.String: ...
    def getConstraintEvaluations(self) -> int: ...
    def getConstraintMargins(self) -> java.util.Map[java.lang.String, float]: ...
    def getConstraintViolations(self) -> java.util.List['OptimizationResultBase.ConstraintViolation']: ...
    def getElapsedTimeMillis(self) -> int: ...
    def getElapsedTimeSeconds(self) -> float: ...
    def getEndTimeMillis(self) -> int: ...
    def getErrorMessage(self) -> java.lang.String: ...
    def getFunctionEvaluations(self) -> int: ...
    def getInitialValues(self) -> java.util.Map[java.lang.String, float]: ...
    def getIterations(self) -> int: ...
    def getObjective(self) -> java.lang.String: ...
    def getObjectiveValue(self) -> float: ...
    def getOptimalValue(self) -> float: ...
    def getOptimalValues(self) -> java.util.Map[java.lang.String, float]: ...
    def getSensitivities(self) -> java.util.Map[java.lang.String, float]: ...
    def getShadowPrices(self) -> java.util.Map[java.lang.String, float]: ...
    def getStartTimeMillis(self) -> int: ...
    def getStatus(self) -> 'OptimizationResultBase.Status': ...
    def getSummary(self) -> java.lang.String: ...
    def hasHardViolations(self) -> bool: ...
    def hasViolations(self) -> bool: ...
    def incrementConstraintEvaluations(self) -> None: ...
    def incrementFunctionEvaluations(self) -> None: ...
    def incrementIterations(self) -> None: ...
    def isConverged(self) -> bool: ...
    def markEnd(self) -> None: ...
    def markStart(self) -> None: ...
    def setBottleneckConstraint(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setBottleneckEquipment(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setConstraintEvaluations(self, int: int) -> None: ...
    def setConstraintMargins(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> None: ...
    def setConstraintViolations(self, list: java.util.List['OptimizationResultBase.ConstraintViolation']) -> None: ...
    def setConverged(self, boolean: bool) -> None: ...
    def setErrorMessage(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setFunctionEvaluations(self, int: int) -> None: ...
    def setInitialValues(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> None: ...
    def setIterations(self, int: int) -> None: ...
    def setObjective(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setObjectiveValue(self, double: float) -> None: ...
    def setOptimalValue(self, double: float) -> None: ...
    def setOptimalValues(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> None: ...
    def setSensitivities(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> None: ...
    def setShadowPrices(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> None: ...
    def setStatus(self, status: 'OptimizationResultBase.Status') -> None: ...
    def toString(self) -> java.lang.String: ...
    class ConstraintViolation(java.io.Serializable):
        @typing.overload
        def __init__(self): ...
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, double2: float, string3: typing.Union[java.lang.String, str], boolean: bool): ...
        def getConstraintName(self) -> java.lang.String: ...
        def getCurrentValue(self) -> float: ...
        def getEquipmentName(self) -> java.lang.String: ...
        def getLimitValue(self) -> float: ...
        def getUnit(self) -> java.lang.String: ...
        def getViolationAmount(self) -> float: ...
        def getViolationPercent(self) -> float: ...
        def isHardConstraint(self) -> bool: ...
        def setConstraintName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setCurrentValue(self, double: float) -> None: ...
        def setEquipmentName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setHardConstraint(self, boolean: bool) -> None: ...
        def setLimitValue(self, double: float) -> None: ...
        def setUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def toString(self) -> java.lang.String: ...
    class Status(java.lang.Enum['OptimizationResultBase.Status']):
        CONVERGED: typing.ClassVar['OptimizationResultBase.Status'] = ...
        MAX_ITERATIONS_REACHED: typing.ClassVar['OptimizationResultBase.Status'] = ...
        INFEASIBLE: typing.ClassVar['OptimizationResultBase.Status'] = ...
        FAILED: typing.ClassVar['OptimizationResultBase.Status'] = ...
        CANCELLED: typing.ClassVar['OptimizationResultBase.Status'] = ...
        IN_PROGRESS: typing.ClassVar['OptimizationResultBase.Status'] = ...
        NOT_STARTED: typing.ClassVar['OptimizationResultBase.Status'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'OptimizationResultBase.Status': ...
        @staticmethod
        def values() -> typing.MutableSequence['OptimizationResultBase.Status']: ...

class ParetoFront(java.io.Serializable, java.lang.Iterable['ParetoSolution']):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    def add(self, paretoSolution: 'ParetoSolution') -> bool: ...
    def calculateHypervolume2D(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    def calculateSpacing(self) -> float: ...
    def clear(self) -> None: ...
    def findKneePoint(self) -> 'ParetoSolution': ...
    def findMaximum(self, int: int) -> 'ParetoSolution': ...
    def findMinimum(self, int: int) -> 'ParetoSolution': ...
    def getSolutions(self) -> java.util.List['ParetoSolution']: ...
    def getSolutionsSortedBy(self, int: int, boolean: bool) -> java.util.List['ParetoSolution']: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator['ParetoSolution']: ...
    def size(self) -> int: ...
    def toJson(self) -> java.lang.String: ...
    def toString(self) -> java.lang.String: ...

class ParetoSolution(java.io.Serializable, java.lang.Comparable['ParetoSolution']):
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], stringArray: typing.Union[typing.List[java.lang.String], jpype.JArray], stringArray2: typing.Union[typing.List[java.lang.String], jpype.JArray], map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], boolean: bool): ...
    def addMetadata(self, string: typing.Union[java.lang.String, str], object: typing.Any) -> None: ...
    def compareTo(self, paretoSolution: 'ParetoSolution') -> int: ...
    def crowdingDistance(self, paretoSolution: 'ParetoSolution', paretoSolution2: 'ParetoSolution', int: int, double: float) -> float: ...
    def distanceTo(self, paretoSolution: 'ParetoSolution') -> float: ...
    def dominates(self, paretoSolution: 'ParetoSolution') -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDecisionVariables(self) -> java.util.Map[java.lang.String, float]: ...
    def getMetadata(self, string: typing.Union[java.lang.String, str]) -> typing.Any: ...
    def getNumObjectives(self) -> int: ...
    def getObjectiveName(self, int: int) -> java.lang.String: ...
    def getObjectiveUnit(self, int: int) -> java.lang.String: ...
    def getObjectiveValues(self) -> typing.MutableSequence[float]: ...
    def getRawObjectiveValues(self) -> typing.MutableSequence[float]: ...
    def getRawValue(self, int: int) -> float: ...
    def getValue(self, int: int) -> float: ...
    def hashCode(self) -> int: ...
    def isFeasible(self) -> bool: ...
    def toString(self) -> java.lang.String: ...
    class Builder:
        def __init__(self): ...
        def build(self) -> 'ParetoSolution': ...
        def decisionVariable(self, string: typing.Union[java.lang.String, str], double: float) -> 'ParetoSolution.Builder': ...
        def decisionVariables(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> 'ParetoSolution.Builder': ...
        def feasible(self, boolean: bool) -> 'ParetoSolution.Builder': ...
        def objectives(self, list: java.util.List[ObjectiveFunction], doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> 'ParetoSolution.Builder': ...

class PressureBoundaryOptimizer(java.io.Serializable):
    @typing.overload
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, streamInterface2: jneqsim.neqsim.process.equipment.stream.StreamInterface): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, productionOptimizer: 'ProductionOptimizer', string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, productionOptimizer: 'ProductionOptimizer', streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, streamInterface2: jneqsim.neqsim.process.equipment.stream.StreamInterface): ...
    def calculateTotalPower(self) -> float: ...
    def configureCompressorCharts(self) -> None: ...
    def findMaxFlowRate(self, double: float, double2: float, string: typing.Union[java.lang.String, str]) -> 'ProductionOptimizer.OptimizationResult': ...
    def findMinimumPowerOperatingPoint(self, double: float, double2: float, string: typing.Union[java.lang.String, str], double3: float) -> 'ProductionOptimizer.OptimizationResult': ...
    def generateCapacityCurve(self, double: float, doubleArray: typing.Union[typing.List[float], jpype.JArray], string: typing.Union[java.lang.String, str]) -> typing.MutableSequence[float]: ...
    def generateLiftCurveTable(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], string: typing.Union[java.lang.String, str]) -> 'PressureBoundaryOptimizer.LiftCurveTable': ...
    def getCompressors(self) -> java.util.List[jneqsim.neqsim.process.equipment.compressor.Compressor]: ...
    def getProductionOptimizer(self) -> 'ProductionOptimizer': ...
    def setAutoConfigureCompressors(self, boolean: bool) -> None: ...
    def setMaxFlowRate(self, double: float) -> None: ...
    def setMaxIterations(self, int: int) -> None: ...
    def setMaxPowerLimit(self, double: float) -> None: ...
    def setMaxUtilization(self, double: float) -> None: ...
    def setMinFlowRate(self, double: float) -> None: ...
    def setMinSurgeMargin(self, double: float) -> None: ...
    def setPressureTolerance(self, double: float) -> None: ...
    def setProductionOptimizer(self, productionOptimizer: 'ProductionOptimizer') -> None: ...
    def setRateUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def setSpeedLimits(self, double: float, double2: float) -> None: ...
    def setTolerance(self, double: float) -> None: ...
    class LiftCurveTable(java.io.Serializable):
        def __init__(self, string: typing.Union[java.lang.String, str], doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray4: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], stringArray: typing.Union[typing.List[typing.MutableSequence[java.lang.String]], jpype.JArray], string3: typing.Union[java.lang.String, str], string4: typing.Union[java.lang.String, str]): ...
        def countFeasiblePoints(self) -> int: ...
        def getBottleneck(self, int: int, int2: int) -> java.lang.String: ...
        def getFlowRate(self, int: int, int2: int) -> float: ...
        def getInletPressures(self) -> typing.MutableSequence[float]: ...
        def getOutletPressures(self) -> typing.MutableSequence[float]: ...
        def getPower(self, int: int, int2: int) -> float: ...
        def getTableName(self) -> java.lang.String: ...
        def toEclipseFormat(self) -> java.lang.String: ...
        def toJson(self) -> java.lang.String: ...
        def toString(self) -> java.lang.String: ...

class ProcessConstraintEvaluator(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem): ...
    @typing.overload
    def calculateFlowSensitivities(self, double: float, string: typing.Union[java.lang.String, str]) -> java.util.Map[java.lang.String, float]: ...
    @typing.overload
    def calculateFlowSensitivities(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, double: float) -> java.util.Map[java.lang.String, float]: ...
    def clearCache(self) -> None: ...
    @typing.overload
    def estimateMaxFlow(self, double: float, string: typing.Union[java.lang.String, str]) -> float: ...
    @typing.overload
    def estimateMaxFlow(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, double: float) -> float: ...
    @typing.overload
    def evaluate(self) -> 'ProcessConstraintEvaluator.ConstraintEvaluationResult': ...
    @typing.overload
    def evaluate(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> 'ProcessConstraintEvaluator.ConstraintEvaluationResult': ...
    def getCacheTTLMillis(self) -> int: ...
    def getProcessSystem(self) -> jneqsim.neqsim.process.processmodel.ProcessSystem: ...
    def getSensitivityStepSize(self) -> float: ...
    def isCachingEnabled(self) -> bool: ...
    def setCacheTTLMillis(self, long: int) -> None: ...
    def setCachingEnabled(self, boolean: bool) -> None: ...
    def setProcessSystem(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> None: ...
    def setSensitivityStepSize(self, double: float) -> None: ...
    class CachedConstraints(java.io.Serializable):
        def __init__(self): ...
        def getCachedResults(self) -> java.util.Map[java.lang.String, float]: ...
        def getFlowRate(self) -> float: ...
        def getTimestamp(self) -> int: ...
        def getTtlMillis(self) -> int: ...
        def invalidate(self) -> None: ...
        def isExpired(self) -> bool: ...
        def isValid(self) -> bool: ...
        def setFlowRate(self, double: float) -> None: ...
        def setTimestamp(self, long: int) -> None: ...
        def setTtlMillis(self, long: int) -> None: ...
        def setValid(self, boolean: bool) -> None: ...
    class ConstraintEvaluationResult(java.io.Serializable):
        def __init__(self): ...
        def addEquipmentSummary(self, equipmentConstraintSummary: 'ProcessConstraintEvaluator.EquipmentConstraintSummary') -> None: ...
        def addNormalizedUtilization(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
        def getBottleneckConstraint(self) -> java.lang.String: ...
        def getBottleneckEquipment(self) -> java.lang.String: ...
        def getBottleneckMargin(self) -> float: ...
        def getBottleneckUtilization(self) -> float: ...
        def getEquipmentSummaries(self) -> java.util.Map[java.lang.String, 'ProcessConstraintEvaluator.EquipmentConstraintSummary']: ...
        def getNormalizedUtilizations(self) -> java.util.Map[java.lang.String, float]: ...
        def getOverallUtilization(self) -> float: ...
        def getTotalViolationCount(self) -> int: ...
        def isAllHardConstraintsSatisfied(self) -> bool: ...
        def isAllSoftConstraintsSatisfied(self) -> bool: ...
        def isFeasible(self) -> bool: ...
        def setAllHardConstraintsSatisfied(self, boolean: bool) -> None: ...
        def setAllSoftConstraintsSatisfied(self, boolean: bool) -> None: ...
        def setBottleneckConstraint(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setBottleneckEquipment(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setBottleneckUtilization(self, double: float) -> None: ...
        def setFeasible(self, boolean: bool) -> None: ...
        def setOverallUtilization(self, double: float) -> None: ...
        def setTotalViolationCount(self, int: int) -> None: ...
    class EquipmentConstraintSummary(java.io.Serializable):
        def __init__(self): ...
        def addConstraintDetail(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
        def getBottleneckConstraint(self) -> java.lang.String: ...
        def getConstraintCount(self) -> int: ...
        def getConstraintDetails(self) -> java.util.Map[java.lang.String, float]: ...
        def getEquipmentName(self) -> java.lang.String: ...
        def getEquipmentType(self) -> java.lang.String: ...
        def getMarginToLimit(self) -> float: ...
        def getUtilization(self) -> float: ...
        def getViolationCount(self) -> int: ...
        def isWithinLimits(self) -> bool: ...
        def setBottleneckConstraint(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setConstraintCount(self, int: int) -> None: ...
        def setEquipmentName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setEquipmentType(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setMarginToLimit(self, double: float) -> None: ...
        def setUtilization(self, double: float) -> None: ...
        def setViolationCount(self, int: int) -> None: ...
        def setWithinLimits(self, boolean: bool) -> None: ...

class ProcessOptimizationEngine(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, processModule: jneqsim.neqsim.process.processmodel.ProcessModule): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem): ...
    def analyzeSensitivity(self, double: float, double2: float, double3: float) -> 'ProcessOptimizationEngine.SensitivityResult': ...
    def bfgsSearch(self, double: float, double2: float, double3: float, double4: float, double5: float) -> float: ...
    def calculateFlowSensitivities(self, double: float, string: typing.Union[java.lang.String, str]) -> java.util.Map[java.lang.String, float]: ...
    def calculateShadowPrices(self, double: float, double2: float, double3: float) -> java.util.Map[java.lang.String, float]: ...
    def clearCache(self) -> None: ...
    def createFlowAdjuster(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str], string4: typing.Union[java.lang.String, str], double: float, string5: typing.Union[java.lang.String, str]) -> jneqsim.neqsim.process.equipment.util.Adjuster: ...
    def createFlowRateOptimizer(self) -> FlowRateOptimizer: ...
    def disableAdjusters(self) -> java.util.List[jneqsim.neqsim.process.equipment.util.Adjuster]: ...
    def enableAdjusters(self, list: java.util.List[jneqsim.neqsim.process.equipment.util.Adjuster]) -> None: ...
    def estimateMaximumFlow(self, double: float, string: typing.Union[java.lang.String, str]) -> float: ...
    def evaluateAllConstraints(self) -> 'ProcessOptimizationEngine.ConstraintReport': ...
    def evaluateConstraintsWithCache(self) -> ProcessConstraintEvaluator.ConstraintEvaluationResult: ...
    def findBottleneckEquipment(self) -> java.lang.String: ...
    def findMaximumThroughput(self, double: float, double2: float, double3: float, double4: float) -> 'ProcessOptimizationEngine.OptimizationResult': ...
    def findRequiredInletPressure(self, double: float, double2: float, double3: float, double4: float) -> 'ProcessOptimizationEngine.OptimizationResult': ...
    def generateComprehensiveLiftCurve(self, string: typing.Union[java.lang.String, str], doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float) -> FlowRateOptimizer: ...
    def generateLiftCurve(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[float], jpype.JArray], doubleArray3: typing.Union[typing.List[float], jpype.JArray], doubleArray4: typing.Union[typing.List[float], jpype.JArray]) -> 'ProcessOptimizationEngine.LiftCurveData': ...
    def getAdjusters(self) -> java.util.List[jneqsim.neqsim.process.equipment.util.Adjuster]: ...
    def getConstraintEvaluator(self) -> ProcessConstraintEvaluator: ...
    def getFeedStreamName(self) -> java.lang.String: ...
    def getMaxIterations(self) -> int: ...
    def getOutletFlowRate(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getOutletStreamName(self) -> java.lang.String: ...
    @typing.overload
    def getOutletTemperature(self) -> float: ...
    @typing.overload
    def getOutletTemperature(self, string: typing.Union[java.lang.String, str]) -> float: ...
    def getProcessSystem(self) -> jneqsim.neqsim.process.processmodel.ProcessSystem: ...
    def getSearchAlgorithm(self) -> 'ProcessOptimizationEngine.SearchAlgorithm': ...
    def getTolerance(self) -> float: ...
    def gradientDescentArmijoWolfeSearch(self, double: float, double2: float, double3: float) -> float: ...
    def gradientDescentSearch(self, double: float, double2: float, double3: float) -> float: ...
    def isEnforceConstraints(self) -> bool: ...
    def optimizeWithAdjusterTargets(self, double: float, double2: float, double3: float, double4: float) -> 'ProcessOptimizationEngine.OptimizationResult': ...
    def optimizeWithAdjustersDisabled(self, double: float, double2: float, double3: float, double4: float) -> 'ProcessOptimizationEngine.OptimizationResult': ...
    def setArmijoC1(self, double: float) -> None: ...
    def setBfgsGradientTolerance(self, double: float) -> None: ...
    def setEnforceConstraints(self, boolean: bool) -> None: ...
    def setFeedStreamName(self, string: typing.Union[java.lang.String, str]) -> 'ProcessOptimizationEngine': ...
    def setMaxIterations(self, int: int) -> None: ...
    def setMaxLineSearchIterations(self, int: int) -> None: ...
    def setOutletStreamName(self, string: typing.Union[java.lang.String, str]) -> 'ProcessOptimizationEngine': ...
    def setProcessSystem(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> None: ...
    def setSearchAlgorithm(self, searchAlgorithm: 'ProcessOptimizationEngine.SearchAlgorithm') -> None: ...
    def setTolerance(self, double: float) -> None: ...
    def setWolfeC2(self, double: float) -> None: ...
    class ConstraintReport(java.io.Serializable):
        def __init__(self): ...
        def addEquipmentStatus(self, equipmentConstraintStatus: 'ProcessOptimizationEngine.EquipmentConstraintStatus') -> None: ...
        def getBottleneck(self) -> 'ProcessOptimizationEngine.EquipmentConstraintStatus': ...
        def getEquipmentStatuses(self) -> java.util.List['ProcessOptimizationEngine.EquipmentConstraintStatus']: ...
    class EquipmentConstraintStatus(java.io.Serializable):
        def __init__(self): ...
        def getBottleneckConstraint(self) -> java.lang.String: ...
        def getConstraints(self) -> java.util.List[jneqsim.neqsim.process.equipment.capacity.CapacityConstraint]: ...
        def getEquipmentName(self) -> java.lang.String: ...
        def getEquipmentType(self) -> java.lang.String: ...
        def getUtilization(self) -> float: ...
        def isWithinLimits(self) -> bool: ...
        def setBottleneckConstraint(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setConstraints(self, list: java.util.List[jneqsim.neqsim.process.equipment.capacity.CapacityConstraint]) -> None: ...
        def setEquipmentName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setEquipmentType(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setUtilization(self, double: float) -> None: ...
        def setWithinLimits(self, boolean: bool) -> None: ...
    class LiftCurveData(java.io.Serializable):
        def __init__(self): ...
        def addPoint(self, liftCurvePoint: 'ProcessOptimizationEngine.LiftCurvePoint') -> None: ...
        def getPoints(self) -> java.util.List['ProcessOptimizationEngine.LiftCurvePoint']: ...
        def size(self) -> int: ...
    class LiftCurvePoint(java.io.Serializable):
        def __init__(self): ...
        def getGOR(self) -> float: ...
        def getInletPressure(self) -> float: ...
        def getMaxFlowRate(self) -> float: ...
        def getTemperature(self) -> float: ...
        def getWaterCut(self) -> float: ...
        def setGOR(self, double: float) -> None: ...
        def setInletPressure(self, double: float) -> None: ...
        def setMaxFlowRate(self, double: float) -> None: ...
        def setTemperature(self, double: float) -> None: ...
        def setWaterCut(self, double: float) -> None: ...
    class OptimizationResult(java.io.Serializable):
        def __init__(self): ...
        def getAvailableMargin(self) -> float: ...
        def getBottleneck(self) -> java.lang.String: ...
        def getConstraintViolations(self) -> java.util.List[java.lang.String]: ...
        def getErrorMessage(self) -> java.lang.String: ...
        def getInletPressure(self) -> float: ...
        def getObjective(self) -> java.lang.String: ...
        def getOptimalValue(self) -> float: ...
        def getOutletPressure(self) -> float: ...
        def getSensitivity(self) -> 'ProcessOptimizationEngine.SensitivityResult': ...
        def isConverged(self) -> bool: ...
        def isNearCapacity(self) -> bool: ...
        def setBottleneck(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setConstraintViolations(self, list: java.util.List[typing.Union[java.lang.String, str]]) -> None: ...
        def setConverged(self, boolean: bool) -> None: ...
        def setErrorMessage(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setInletPressure(self, double: float) -> None: ...
        def setObjective(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setOptimalValue(self, double: float) -> None: ...
        def setOutletPressure(self, double: float) -> None: ...
        def setSensitivity(self, sensitivityResult: 'ProcessOptimizationEngine.SensitivityResult') -> None: ...
    class SearchAlgorithm(java.lang.Enum['ProcessOptimizationEngine.SearchAlgorithm']):
        BINARY_SEARCH: typing.ClassVar['ProcessOptimizationEngine.SearchAlgorithm'] = ...
        GOLDEN_SECTION: typing.ClassVar['ProcessOptimizationEngine.SearchAlgorithm'] = ...
        NELDER_MEAD: typing.ClassVar['ProcessOptimizationEngine.SearchAlgorithm'] = ...
        PARTICLE_SWARM: typing.ClassVar['ProcessOptimizationEngine.SearchAlgorithm'] = ...
        GRADIENT_DESCENT: typing.ClassVar['ProcessOptimizationEngine.SearchAlgorithm'] = ...
        GRADIENT_DESCENT_ARMIJO_WOLFE: typing.ClassVar['ProcessOptimizationEngine.SearchAlgorithm'] = ...
        BFGS: typing.ClassVar['ProcessOptimizationEngine.SearchAlgorithm'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProcessOptimizationEngine.SearchAlgorithm': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProcessOptimizationEngine.SearchAlgorithm']: ...
    class SensitivityResult(java.io.Serializable):
        def __init__(self): ...
        def getBaseFlow(self) -> float: ...
        def getBottleneckEquipment(self) -> java.lang.String: ...
        def getConstraintMargins(self) -> java.util.Map[java.lang.String, float]: ...
        def getFlowBuffer(self) -> float: ...
        def getFlowGradient(self) -> float: ...
        def getTightestConstraint(self) -> java.lang.String: ...
        def getTightestMargin(self) -> float: ...
        def isAtCapacity(self) -> bool: ...
        def setBaseFlow(self, double: float) -> None: ...
        def setConstraintMargins(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> None: ...
        def setFlowBuffer(self, double: float) -> None: ...
        def setFlowGradient(self, double: float) -> None: ...
        def setTightestConstraint(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setTightestMargin(self, double: float) -> None: ...

class ProcessSimulationEvaluator(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem): ...
    def addConstraintEquality(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], double: float, double2: float) -> 'ProcessSimulationEvaluator': ...
    def addConstraintLowerBound(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], double: float) -> 'ProcessSimulationEvaluator': ...
    def addConstraintRange(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], double: float, double2: float) -> 'ProcessSimulationEvaluator': ...
    def addConstraintUpperBound(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], double: float) -> 'ProcessSimulationEvaluator': ...
    @typing.overload
    def addObjective(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]]) -> 'ProcessSimulationEvaluator': ...
    @typing.overload
    def addObjective(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], direction: 'ProcessSimulationEvaluator.ObjectiveDefinition.Direction') -> 'ProcessSimulationEvaluator': ...
    @typing.overload
    def addObjective(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], direction: 'ProcessSimulationEvaluator.ObjectiveDefinition.Direction', double: float) -> 'ProcessSimulationEvaluator': ...
    def addParameter(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double: float, double2: float, string3: typing.Union[java.lang.String, str]) -> 'ProcessSimulationEvaluator': ...
    def addParameterWithSetter(self, string: typing.Union[java.lang.String, str], biConsumer: typing.Union[java.util.function.BiConsumer[jneqsim.neqsim.process.processmodel.ProcessSystem, float], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem, float], None]], double: float, double2: float, string2: typing.Union[java.lang.String, str]) -> 'ProcessSimulationEvaluator': ...
    def estimateConstraintJacobian(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    @typing.overload
    def estimateGradient(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...
    @typing.overload
    def estimateGradient(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], int: int) -> typing.MutableSequence[float]: ...
    def evaluate(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> 'ProcessSimulationEvaluator.EvaluationResult': ...
    def evaluateObjective(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    def evaluatePenalizedObjective(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    def getBounds(self) -> typing.MutableSequence[typing.MutableSequence[float]]: ...
    def getConstraintCount(self) -> int: ...
    def getConstraintMargins(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> typing.MutableSequence[float]: ...
    def getConstraints(self) -> java.util.List['ProcessSimulationEvaluator.ConstraintDefinition']: ...
    def getEvaluationCount(self) -> int: ...
    def getFiniteDifferenceStep(self) -> float: ...
    def getInitialValues(self) -> typing.MutableSequence[float]: ...
    def getLastResult(self) -> 'ProcessSimulationEvaluator.EvaluationResult': ...
    def getLowerBounds(self) -> typing.MutableSequence[float]: ...
    def getObjectiveCount(self) -> int: ...
    def getObjectives(self) -> java.util.List['ProcessSimulationEvaluator.ObjectiveDefinition']: ...
    def getParameterCount(self) -> int: ...
    def getParameters(self) -> java.util.List['ProcessSimulationEvaluator.ParameterDefinition']: ...
    def getProblemDefinition(self) -> java.util.Map[java.lang.String, typing.Any]: ...
    def getProcessSystem(self) -> jneqsim.neqsim.process.processmodel.ProcessSystem: ...
    def getUpperBounds(self) -> typing.MutableSequence[float]: ...
    def isCloneForEvaluation(self) -> bool: ...
    def isFeasible(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> bool: ...
    def isUseRelativeStep(self) -> bool: ...
    def resetEvaluationCount(self) -> None: ...
    def setCloneForEvaluation(self, boolean: bool) -> None: ...
    def setFiniteDifferenceStep(self, double: float) -> None: ...
    def setProcessSystem(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> None: ...
    def setUseRelativeStep(self, boolean: bool) -> None: ...
    def toJson(self) -> java.lang.String: ...
    class ConstraintDefinition(java.io.Serializable):
        @typing.overload
        def __init__(self): ...
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], double: float): ...
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], double: float, double2: float): ...
        def evaluate(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> float: ...
        def getEqualityTolerance(self) -> float: ...
        def getEvaluator(self) -> java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem]: ...
        def getLowerBound(self) -> float: ...
        def getName(self) -> java.lang.String: ...
        def getPenaltyWeight(self) -> float: ...
        def getType(self) -> 'ProcessSimulationEvaluator.ConstraintDefinition.Type': ...
        def getUnit(self) -> java.lang.String: ...
        def getUpperBound(self) -> float: ...
        def isHard(self) -> bool: ...
        def isSatisfied(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> bool: ...
        def margin(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> float: ...
        def penalty(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> float: ...
        def setEqualityTolerance(self, double: float) -> None: ...
        def setEvaluator(self, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]]) -> None: ...
        def setHard(self, boolean: bool) -> None: ...
        def setLowerBound(self, double: float) -> None: ...
        def setName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setPenaltyWeight(self, double: float) -> None: ...
        def setType(self, type: 'ProcessSimulationEvaluator.ConstraintDefinition.Type') -> None: ...
        def setUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setUpperBound(self, double: float) -> None: ...
        class Type(java.lang.Enum['ProcessSimulationEvaluator.ConstraintDefinition.Type']):
            LOWER_BOUND: typing.ClassVar['ProcessSimulationEvaluator.ConstraintDefinition.Type'] = ...
            UPPER_BOUND: typing.ClassVar['ProcessSimulationEvaluator.ConstraintDefinition.Type'] = ...
            RANGE: typing.ClassVar['ProcessSimulationEvaluator.ConstraintDefinition.Type'] = ...
            EQUALITY: typing.ClassVar['ProcessSimulationEvaluator.ConstraintDefinition.Type'] = ...
            _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
            @typing.overload
            @staticmethod
            def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
            @typing.overload
            @staticmethod
            def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProcessSimulationEvaluator.ConstraintDefinition.Type': ...
            @staticmethod
            def values() -> typing.MutableSequence['ProcessSimulationEvaluator.ConstraintDefinition.Type']: ...
    class EvaluationResult(java.io.Serializable):
        def __init__(self): ...
        def addOutput(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
        def getAdditionalOutputs(self) -> java.util.Map[java.lang.String, float]: ...
        def getConstraintMargins(self) -> typing.MutableSequence[float]: ...
        def getConstraintValues(self) -> typing.MutableSequence[float]: ...
        def getErrorMessage(self) -> java.lang.String: ...
        def getEvaluationNumber(self) -> int: ...
        def getEvaluationTimeMs(self) -> int: ...
        def getObjective(self) -> float: ...
        def getObjectives(self) -> typing.MutableSequence[float]: ...
        def getObjectivesRaw(self) -> typing.MutableSequence[float]: ...
        def getParameters(self) -> typing.MutableSequence[float]: ...
        def getPenalizedObjective(self) -> float: ...
        def getPenaltySum(self) -> float: ...
        def getWeightedObjective(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
        def isFeasible(self) -> bool: ...
        def isSimulationConverged(self) -> bool: ...
        def setAdditionalOutputs(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]) -> None: ...
        def setConstraintMargins(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
        def setConstraintValues(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
        def setErrorMessage(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setEvaluationNumber(self, int: int) -> None: ...
        def setEvaluationTimeMs(self, long: int) -> None: ...
        def setFeasible(self, boolean: bool) -> None: ...
        def setObjectives(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
        def setObjectivesRaw(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
        def setParameters(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
        def setPenaltySum(self, double: float) -> None: ...
        def setSimulationConverged(self, boolean: bool) -> None: ...
    class ObjectiveDefinition(java.io.Serializable):
        @typing.overload
        def __init__(self): ...
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], direction: 'ProcessSimulationEvaluator.ObjectiveDefinition.Direction'): ...
        def evaluate(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> float: ...
        def evaluateRaw(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> float: ...
        def getDirection(self) -> 'ProcessSimulationEvaluator.ObjectiveDefinition.Direction': ...
        def getEvaluator(self) -> java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem]: ...
        def getName(self) -> java.lang.String: ...
        def getUnit(self) -> java.lang.String: ...
        def getWeight(self) -> float: ...
        def setDirection(self, direction: 'ProcessSimulationEvaluator.ObjectiveDefinition.Direction') -> None: ...
        def setEvaluator(self, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]]) -> None: ...
        def setName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setWeight(self, double: float) -> None: ...
        class Direction(java.lang.Enum['ProcessSimulationEvaluator.ObjectiveDefinition.Direction']):
            MINIMIZE: typing.ClassVar['ProcessSimulationEvaluator.ObjectiveDefinition.Direction'] = ...
            MAXIMIZE: typing.ClassVar['ProcessSimulationEvaluator.ObjectiveDefinition.Direction'] = ...
            _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
            @typing.overload
            @staticmethod
            def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
            @typing.overload
            @staticmethod
            def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProcessSimulationEvaluator.ObjectiveDefinition.Direction': ...
            @staticmethod
            def values() -> typing.MutableSequence['ProcessSimulationEvaluator.ObjectiveDefinition.Direction']: ...
    class ParameterDefinition(java.io.Serializable):
        @typing.overload
        def __init__(self): ...
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str], double: float, double2: float, string4: typing.Union[java.lang.String, str]): ...
        def clamp(self, double: float) -> float: ...
        def getEquipmentName(self) -> java.lang.String: ...
        def getInitialValue(self) -> float: ...
        def getLowerBound(self) -> float: ...
        def getName(self) -> java.lang.String: ...
        def getPropertyName(self) -> java.lang.String: ...
        def getSetter(self) -> java.util.function.BiConsumer[jneqsim.neqsim.process.processmodel.ProcessSystem, float]: ...
        def getUnit(self) -> java.lang.String: ...
        def getUpperBound(self) -> float: ...
        def isWithinBounds(self, double: float) -> bool: ...
        def setEquipmentName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setInitialValue(self, double: float) -> None: ...
        def setLowerBound(self, double: float) -> None: ...
        def setName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setPropertyName(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setSetter(self, biConsumer: typing.Union[java.util.function.BiConsumer[jneqsim.neqsim.process.processmodel.ProcessSystem, float], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem, float], None]]) -> None: ...
        def setUnit(self, string: typing.Union[java.lang.String, str]) -> None: ...
        def setUpperBound(self, double: float) -> None: ...

class ProductionOptimizationSpecLoader:
    @staticmethod
    def load(path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Mapping[typing.Union[java.lang.String, str], jneqsim.neqsim.process.processmodel.ProcessSystem]], map2: typing.Union[java.util.Map[typing.Union[java.lang.String, str], jneqsim.neqsim.process.equipment.stream.StreamInterface], typing.Mapping[typing.Union[java.lang.String, str], jneqsim.neqsim.process.equipment.stream.StreamInterface]], map3: typing.Union[java.util.Map[typing.Union[java.lang.String, str], typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]]], typing.Mapping[typing.Union[java.lang.String, str], typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]]]]) -> java.util.List['ProductionOptimizer.ScenarioRequest']: ...

class ProductionOptimizer:
    DEFAULT_UTILIZATION_LIMIT: typing.ClassVar[float] = ...
    def __init__(self): ...
    @staticmethod
    def buildUtilizationSeries(list: java.util.List['ProductionOptimizer.IterationRecord']) -> java.util.List['ProductionOptimizer.UtilizationSeries']: ...
    def compareScenarios(self, list: java.util.List['ProductionOptimizer.ScenarioRequest'], list2: java.util.List['ProductionOptimizer.ScenarioKpi']) -> 'ProductionOptimizer.ScenarioComparisonResult': ...
    @staticmethod
    def formatScenarioComparisonTable(scenarioComparisonResult: 'ProductionOptimizer.ScenarioComparisonResult', list: java.util.List['ProductionOptimizer.ScenarioKpi']) -> java.lang.String: ...
    @staticmethod
    def formatUtilizationTable(list: java.util.List['ProductionOptimizer.UtilizationRecord']) -> java.lang.String: ...
    @staticmethod
    def formatUtilizationTimeline(list: java.util.List['ProductionOptimizer.IterationRecord']) -> java.lang.String: ...
    @typing.overload
    def optimize(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, list: java.util.List['ProductionOptimizer.ManipulatedVariable'], optimizationConfig: 'ProductionOptimizer.OptimizationConfig', list2: java.util.List['ProductionOptimizer.OptimizationObjective'], list3: java.util.List['ProductionOptimizer.OptimizationConstraint']) -> 'ProductionOptimizer.OptimizationResult': ...
    @typing.overload
    def optimize(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, optimizationConfig: 'ProductionOptimizer.OptimizationConfig', list: java.util.List['ProductionOptimizer.OptimizationObjective'], list2: java.util.List['ProductionOptimizer.OptimizationConstraint']) -> 'ProductionOptimizer.OptimizationResult': ...
    @typing.overload
    def optimizePareto(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, list: java.util.List['ProductionOptimizer.ManipulatedVariable'], optimizationConfig: 'ProductionOptimizer.OptimizationConfig', list2: java.util.List['ProductionOptimizer.OptimizationObjective'], list3: java.util.List['ProductionOptimizer.OptimizationConstraint']) -> 'ProductionOptimizer.ParetoResult': ...
    @typing.overload
    def optimizePareto(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, optimizationConfig: 'ProductionOptimizer.OptimizationConfig', list: java.util.List['ProductionOptimizer.OptimizationObjective'], list2: java.util.List['ProductionOptimizer.OptimizationConstraint']) -> 'ProductionOptimizer.ParetoResult': ...
    def optimizeScenarios(self, list: java.util.List['ProductionOptimizer.ScenarioRequest']) -> java.util.List['ProductionOptimizer.ScenarioResult']: ...
    def optimizeThroughput(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, double: float, double2: float, string: typing.Union[java.lang.String, str], list: java.util.List['ProductionOptimizer.OptimizationConstraint']) -> 'ProductionOptimizer.OptimizationResult': ...
    @typing.overload
    def quickOptimize(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface) -> 'ProductionOptimizer.OptimizationSummary': ...
    @typing.overload
    def quickOptimize(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, string: typing.Union[java.lang.String, str], list: java.util.List['ProductionOptimizer.OptimizationConstraint']) -> 'ProductionOptimizer.OptimizationSummary': ...
    class ConstraintDirection(java.lang.Enum['ProductionOptimizer.ConstraintDirection']):
        LESS_THAN: typing.ClassVar['ProductionOptimizer.ConstraintDirection'] = ...
        GREATER_THAN: typing.ClassVar['ProductionOptimizer.ConstraintDirection'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProductionOptimizer.ConstraintDirection': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProductionOptimizer.ConstraintDirection']: ...
    class ConstraintSeverity(java.lang.Enum['ProductionOptimizer.ConstraintSeverity']):
        HARD: typing.ClassVar['ProductionOptimizer.ConstraintSeverity'] = ...
        SOFT: typing.ClassVar['ProductionOptimizer.ConstraintSeverity'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProductionOptimizer.ConstraintSeverity': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProductionOptimizer.ConstraintSeverity']: ...
    class ConstraintStatus:
        def __init__(self, string: typing.Union[java.lang.String, str], constraintSeverity: 'ProductionOptimizer.ConstraintSeverity', double: float, double2: float, string2: typing.Union[java.lang.String, str]): ...
        def getDescription(self) -> java.lang.String: ...
        def getMargin(self) -> float: ...
        def getName(self) -> java.lang.String: ...
        def getPenaltyWeight(self) -> float: ...
        def getSeverity(self) -> 'ProductionOptimizer.ConstraintSeverity': ...
        def violated(self) -> bool: ...
    class IterationRecord:
        def __init__(self, double: float, string: typing.Union[java.lang.String, str], map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], string2: typing.Union[java.lang.String, str], double2: float, boolean: bool, boolean2: bool, boolean3: bool, double3: float, list: java.util.List['ProductionOptimizer.UtilizationRecord']): ...
        def getBottleneckName(self) -> java.lang.String: ...
        def getBottleneckUtilization(self) -> float: ...
        def getDecisionVariables(self) -> java.util.Map[java.lang.String, float]: ...
        def getRate(self) -> float: ...
        def getRateUnit(self) -> java.lang.String: ...
        def getScore(self) -> float: ...
        def getUtilizations(self) -> java.util.List['ProductionOptimizer.UtilizationRecord']: ...
        def isFeasible(self) -> bool: ...
        def isHardConstraintsOk(self) -> bool: ...
        def isUtilizationWithinLimits(self) -> bool: ...
    class ManipulatedVariable:
        def __init__(self, string: typing.Union[java.lang.String, str], double: float, double2: float, string2: typing.Union[java.lang.String, str], biConsumer: typing.Union[java.util.function.BiConsumer[jneqsim.neqsim.process.processmodel.ProcessSystem, float], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem, float], None]]): ...
        def apply(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, double: float) -> None: ...
        def getLowerBound(self) -> float: ...
        def getName(self) -> java.lang.String: ...
        def getUnit(self) -> java.lang.String: ...
        def getUpperBound(self) -> float: ...
    class ObjectiveType(java.lang.Enum['ProductionOptimizer.ObjectiveType']):
        MAXIMIZE: typing.ClassVar['ProductionOptimizer.ObjectiveType'] = ...
        MINIMIZE: typing.ClassVar['ProductionOptimizer.ObjectiveType'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProductionOptimizer.ObjectiveType': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProductionOptimizer.ObjectiveType']: ...
    class OptimizationConfig:
        def __init__(self, double: float, double2: float): ...
        def capacityPercentile(self, double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
        def capacityRangeForName(self, string: typing.Union[java.lang.String, str], capacityRange: 'ProductionOptimizer.CapacityRange') -> 'ProductionOptimizer.OptimizationConfig': ...
        def capacityRangeForType(self, class_: typing.Type[typing.Any], capacityRange: 'ProductionOptimizer.CapacityRange') -> 'ProductionOptimizer.OptimizationConfig': ...
        def capacityRangeSpreadFraction(self, double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
        def capacityRuleForName(self, string: typing.Union[java.lang.String, str], capacityRule: 'ProductionOptimizer.CapacityRule') -> 'ProductionOptimizer.OptimizationConfig': ...
        def capacityRuleForType(self, class_: typing.Type[typing.Any], capacityRule: 'ProductionOptimizer.CapacityRule') -> 'ProductionOptimizer.OptimizationConfig': ...
        def capacityUncertaintyFraction(self, double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
        def cognitiveWeight(self, double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
        def columnFsFactorLimit(self, double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
        def defaultUtilizationLimit(self, double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
        def enableCaching(self, boolean: bool) -> 'ProductionOptimizer.OptimizationConfig': ...
        def equipmentConstraintRule(self, equipmentConstraintRule: 'ProductionOptimizer.EquipmentConstraintRule') -> 'ProductionOptimizer.OptimizationConfig': ...
        def getCapacityPercentile(self) -> float: ...
        def getCapacityRangeSpreadFraction(self) -> float: ...
        def getCapacityUncertaintyFraction(self) -> float: ...
        def getCognitiveWeight(self) -> float: ...
        def getColumnFsFactorLimit(self) -> float: ...
        def getInertiaWeight(self) -> float: ...
        def getLowerBound(self) -> float: ...
        def getMaxIterations(self) -> int: ...
        def getParallelThreads(self) -> int: ...
        def getParetoGridSize(self) -> int: ...
        def getRateUnit(self) -> java.lang.String: ...
        def getSocialWeight(self) -> float: ...
        def getSwarmSize(self) -> int: ...
        def getUpperBound(self) -> float: ...
        def getUtilizationMarginFraction(self) -> float: ...
        def inertiaWeight(self, double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
        def isParallelEvaluations(self) -> bool: ...
        def isRejectInvalidSimulations(self) -> bool: ...
        def maxIterations(self, int: int) -> 'ProductionOptimizer.OptimizationConfig': ...
        def parallelEvaluations(self, boolean: bool) -> 'ProductionOptimizer.OptimizationConfig': ...
        def parallelThreads(self, int: int) -> 'ProductionOptimizer.OptimizationConfig': ...
        def paretoGridSize(self, int: int) -> 'ProductionOptimizer.OptimizationConfig': ...
        def rateUnit(self, string: typing.Union[java.lang.String, str]) -> 'ProductionOptimizer.OptimizationConfig': ...
        def rejectInvalidSimulations(self, boolean: bool) -> 'ProductionOptimizer.OptimizationConfig': ...
        def searchMode(self, searchMode: 'ProductionOptimizer.SearchMode') -> 'ProductionOptimizer.OptimizationConfig': ...
        def socialWeight(self, double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
        def swarmSize(self, int: int) -> 'ProductionOptimizer.OptimizationConfig': ...
        def tolerance(self, double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
        def utilizationLimitForName(self, string: typing.Union[java.lang.String, str], double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
        def utilizationLimitForType(self, class_: typing.Type[typing.Any], double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
        def utilizationMarginFraction(self, double: float) -> 'ProductionOptimizer.OptimizationConfig': ...
    class OptimizationConstraint:
        def __init__(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], double: float, constraintDirection: 'ProductionOptimizer.ConstraintDirection', constraintSeverity: 'ProductionOptimizer.ConstraintSeverity', double2: float, string2: typing.Union[java.lang.String, str]): ...
        def getDescription(self) -> java.lang.String: ...
        def getName(self) -> java.lang.String: ...
        def getPenaltyWeight(self) -> float: ...
        def getSeverity(self) -> 'ProductionOptimizer.ConstraintSeverity': ...
        @staticmethod
        def greaterThan(string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], double: float, constraintSeverity: 'ProductionOptimizer.ConstraintSeverity', double2: float, string2: typing.Union[java.lang.String, str]) -> 'ProductionOptimizer.OptimizationConstraint': ...
        def isSatisfied(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> bool: ...
        @staticmethod
        def lessThan(string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], double: float, constraintSeverity: 'ProductionOptimizer.ConstraintSeverity', double2: float, string2: typing.Union[java.lang.String, str]) -> 'ProductionOptimizer.OptimizationConstraint': ...
        def margin(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> float: ...
    class OptimizationObjective:
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], double: float): ...
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[jneqsim.neqsim.process.processmodel.ProcessSystem], typing.Callable[[jneqsim.neqsim.process.processmodel.ProcessSystem], float]], double: float, objectiveType: 'ProductionOptimizer.ObjectiveType'): ...
        def evaluate(self, processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem) -> float: ...
        def getName(self) -> java.lang.String: ...
        def getType(self) -> 'ProductionOptimizer.ObjectiveType': ...
        def getWeight(self) -> float: ...
    class OptimizationResult:
        def __init__(self, double: float, string: typing.Union[java.lang.String, str], map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], processEquipmentInterface: jneqsim.neqsim.process.equipment.ProcessEquipmentInterface, double2: float, list: java.util.List['ProductionOptimizer.UtilizationRecord'], map2: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], list2: java.util.List['ProductionOptimizer.ConstraintStatus'], boolean: bool, double3: float, int: int, list3: java.util.List['ProductionOptimizer.IterationRecord']): ...
        def getBottleneck(self) -> jneqsim.neqsim.process.equipment.ProcessEquipmentInterface: ...
        def getBottleneckUtilization(self) -> float: ...
        def getConstraintStatuses(self) -> java.util.List['ProductionOptimizer.ConstraintStatus']: ...
        def getDecisionVariables(self) -> java.util.Map[java.lang.String, float]: ...
        def getIterationHistory(self) -> java.util.List['ProductionOptimizer.IterationRecord']: ...
        def getIterations(self) -> int: ...
        def getObjectiveValues(self) -> java.util.Map[java.lang.String, float]: ...
        def getOptimalRate(self) -> float: ...
        def getRateUnit(self) -> java.lang.String: ...
        def getScore(self) -> float: ...
        def getUtilizationRecords(self) -> java.util.List['ProductionOptimizer.UtilizationRecord']: ...
        def isFeasible(self) -> bool: ...
    class OptimizationSummary:
        def __init__(self, double: float, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], double2: float, double3: float, double4: float, boolean: bool, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], list: java.util.List['ProductionOptimizer.UtilizationRecord'], list2: java.util.List['ProductionOptimizer.ConstraintStatus']): ...
        def getConstraints(self) -> java.util.List['ProductionOptimizer.ConstraintStatus']: ...
        def getDecisionVariables(self) -> java.util.Map[java.lang.String, float]: ...
        def getLimitingEquipment(self) -> java.lang.String: ...
        def getMaxRate(self) -> float: ...
        def getRateUnit(self) -> java.lang.String: ...
        def getUtilization(self) -> float: ...
        def getUtilizationLimit(self) -> float: ...
        def getUtilizationMargin(self) -> float: ...
        def getUtilizations(self) -> java.util.List['ProductionOptimizer.UtilizationRecord']: ...
        def isFeasible(self) -> bool: ...
    class ParetoPoint:
        def __init__(self, map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], map2: typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]], doubleArray: typing.Union[typing.List[float], jpype.JArray], boolean: bool, optimizationResult: 'ProductionOptimizer.OptimizationResult'): ...
        def dominates(self, paretoPoint: 'ProductionOptimizer.ParetoPoint', map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], 'ProductionOptimizer.ObjectiveType'], typing.Mapping[typing.Union[java.lang.String, str], 'ProductionOptimizer.ObjectiveType']]) -> bool: ...
        def getDecisionVariables(self) -> java.util.Map[java.lang.String, float]: ...
        def getFullResult(self) -> 'ProductionOptimizer.OptimizationResult': ...
        def getObjectiveValues(self) -> java.util.Map[java.lang.String, float]: ...
        def getWeights(self) -> typing.MutableSequence[float]: ...
        def isFeasible(self) -> bool: ...
    class ParetoResult:
        def __init__(self, list: java.util.List['ProductionOptimizer.ParetoPoint'], list2: java.util.List['ProductionOptimizer.ParetoPoint'], list3: java.util.List[typing.Union[java.lang.String, str]], map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], 'ProductionOptimizer.ObjectiveType'], typing.Mapping[typing.Union[java.lang.String, str], 'ProductionOptimizer.ObjectiveType']], int: int): ...
        def getAllPoints(self) -> java.util.List['ProductionOptimizer.ParetoPoint']: ...
        def getNadirPoint(self) -> java.util.Map[java.lang.String, float]: ...
        def getObjectiveNames(self) -> java.util.List[java.lang.String]: ...
        def getObjectiveTypes(self) -> java.util.Map[java.lang.String, 'ProductionOptimizer.ObjectiveType']: ...
        def getParetoFront(self) -> java.util.List['ProductionOptimizer.ParetoPoint']: ...
        def getParetoFrontSize(self) -> int: ...
        def getTotalIterations(self) -> int: ...
        def getUtopiaPoint(self) -> java.util.Map[java.lang.String, float]: ...
        def toMarkdownTable(self) -> java.lang.String: ...
    class ScenarioComparisonResult:
        def __init__(self, string: typing.Union[java.lang.String, str], list: java.util.List['ProductionOptimizer.ScenarioResult'], map: typing.Union[java.util.Map[typing.Union[java.lang.String, str], typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]], typing.Mapping[typing.Union[java.lang.String, str], typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]]], map2: typing.Union[java.util.Map[typing.Union[java.lang.String, str], typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]], typing.Mapping[typing.Union[java.lang.String, str], typing.Union[java.util.Map[typing.Union[java.lang.String, str], float], typing.Mapping[typing.Union[java.lang.String, str], float]]]]): ...
        def getBaselineScenario(self) -> java.lang.String: ...
        def getKpiDeltas(self) -> java.util.Map[java.lang.String, java.util.Map[java.lang.String, float]]: ...
        def getKpiValues(self) -> java.util.Map[java.lang.String, java.util.Map[java.lang.String, float]]: ...
        def getScenarioResults(self) -> java.util.List['ProductionOptimizer.ScenarioResult']: ...
    class ScenarioKpi:
        def __init__(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction['ProductionOptimizer.OptimizationResult'], typing.Callable[['ProductionOptimizer.OptimizationResult'], float]]): ...
        def evaluate(self, optimizationResult: 'ProductionOptimizer.OptimizationResult') -> float: ...
        def getName(self) -> java.lang.String: ...
        def getUnit(self) -> java.lang.String: ...
        @staticmethod
        def objectiveValue(string: typing.Union[java.lang.String, str]) -> 'ProductionOptimizer.ScenarioKpi': ...
        @staticmethod
        def optimalRate(string: typing.Union[java.lang.String, str]) -> 'ProductionOptimizer.ScenarioKpi': ...
        @staticmethod
        def score() -> 'ProductionOptimizer.ScenarioKpi': ...
    class ScenarioRequest:
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str], processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, list: java.util.List['ProductionOptimizer.ManipulatedVariable'], optimizationConfig: 'ProductionOptimizer.OptimizationConfig', list2: java.util.List['ProductionOptimizer.OptimizationObjective'], list3: java.util.List['ProductionOptimizer.OptimizationConstraint']): ...
        @typing.overload
        def __init__(self, string: typing.Union[java.lang.String, str], processSystem: jneqsim.neqsim.process.processmodel.ProcessSystem, streamInterface: jneqsim.neqsim.process.equipment.stream.StreamInterface, optimizationConfig: 'ProductionOptimizer.OptimizationConfig', list: java.util.List['ProductionOptimizer.OptimizationObjective'], list2: java.util.List['ProductionOptimizer.OptimizationConstraint']): ...
        def getConfig(self) -> 'ProductionOptimizer.OptimizationConfig': ...
        def getConstraints(self) -> java.util.List['ProductionOptimizer.OptimizationConstraint']: ...
        def getFeedStream(self) -> jneqsim.neqsim.process.equipment.stream.StreamInterface: ...
        def getName(self) -> java.lang.String: ...
        def getObjectives(self) -> java.util.List['ProductionOptimizer.OptimizationObjective']: ...
        def getProcess(self) -> jneqsim.neqsim.process.processmodel.ProcessSystem: ...
        def getVariables(self) -> java.util.List['ProductionOptimizer.ManipulatedVariable']: ...
    class ScenarioResult:
        def __init__(self, string: typing.Union[java.lang.String, str], optimizationResult: 'ProductionOptimizer.OptimizationResult'): ...
        def getName(self) -> java.lang.String: ...
        def getResult(self) -> 'ProductionOptimizer.OptimizationResult': ...
    class SearchMode(java.lang.Enum['ProductionOptimizer.SearchMode']):
        BINARY_FEASIBILITY: typing.ClassVar['ProductionOptimizer.SearchMode'] = ...
        GOLDEN_SECTION_SCORE: typing.ClassVar['ProductionOptimizer.SearchMode'] = ...
        NELDER_MEAD_SCORE: typing.ClassVar['ProductionOptimizer.SearchMode'] = ...
        PARTICLE_SWARM_SCORE: typing.ClassVar['ProductionOptimizer.SearchMode'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: typing.Union[java.lang.String, str]) -> 'ProductionOptimizer.SearchMode': ...
        @staticmethod
        def values() -> typing.MutableSequence['ProductionOptimizer.SearchMode']: ...
    class UtilizationRecord:
        def __init__(self, string: typing.Union[java.lang.String, str], double: float, double2: float, double3: float, double4: float): ...
        def getCapacityDuty(self) -> float: ...
        def getCapacityMax(self) -> float: ...
        def getEquipmentName(self) -> java.lang.String: ...
        def getUtilization(self) -> float: ...
        def getUtilizationLimit(self) -> float: ...
    class UtilizationSeries:
        def __init__(self, string: typing.Union[java.lang.String, str], list: java.util.List[float], list2: java.util.List[bool], double: float): ...
        def getBottleneckFlags(self) -> java.util.List[bool]: ...
        def getEquipmentName(self) -> java.lang.String: ...
        def getUtilizationLimit(self) -> float: ...
        def getUtilizations(self) -> java.util.List[float]: ...
    class CapacityRange: ...
    class CapacityRule: ...
    class EquipmentConstraintRule: ...

class StandardObjective(java.lang.Enum['StandardObjective'], ObjectiveFunction):
    MAXIMIZE_THROUGHPUT: typing.ClassVar['StandardObjective'] = ...
    MINIMIZE_POWER: typing.ClassVar['StandardObjective'] = ...
    MINIMIZE_HEATING_DUTY: typing.ClassVar['StandardObjective'] = ...
    MINIMIZE_COOLING_DUTY: typing.ClassVar['StandardObjective'] = ...
    MINIMIZE_TOTAL_ENERGY: typing.ClassVar['StandardObjective'] = ...
    MAXIMIZE_SPECIFIC_PRODUCTION: typing.ClassVar['StandardObjective'] = ...
    MAXIMIZE_LIQUID_RECOVERY: typing.ClassVar['StandardObjective'] = ...
    @staticmethod
    def maximizeManifoldThroughput(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def maximizePumpEfficiency(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def maximizePumpNPSHMargin(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def maximizeStreamFlow(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizeCompressorPower(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizeFIV_FRMS(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizeFIV_LOF(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizeManifoldBranchLOF(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizeManifoldHeaderFRMS(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizeManifoldHeaderLOF(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizeManifoldImbalance(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizeManifoldPressureDrop(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizeManifoldVelocityRatio(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizePipelineVibration(string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str], string3: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizePumpPower(string: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    @staticmethod
    def minimizeStreamFlow(string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> ObjectiveFunction: ...
    _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_0__T], string: typing.Union[java.lang.String, str]) -> _valueOf_0__T: ...
    @typing.overload
    @staticmethod
    def valueOf(string: typing.Union[java.lang.String, str]) -> 'StandardObjective': ...
    @staticmethod
    def values() -> typing.MutableSequence['StandardObjective']: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("jneqsim.neqsim.process.util.optimizer")``.

    BatchStudy: typing.Type[BatchStudy]
    EclipseVFPExporter: typing.Type[EclipseVFPExporter]
    FlowRateOptimizationResult: typing.Type[FlowRateOptimizationResult]
    FlowRateOptimizer: typing.Type[FlowRateOptimizer]
    LiftCurveGenerator: typing.Type[LiftCurveGenerator]
    LiftCurveTable: typing.Type[LiftCurveTable]
    MultiObjectiveOptimizer: typing.Type[MultiObjectiveOptimizer]
    ObjectiveFunction: typing.Type[ObjectiveFunction]
    OptimizationResultBase: typing.Type[OptimizationResultBase]
    ParetoFront: typing.Type[ParetoFront]
    ParetoSolution: typing.Type[ParetoSolution]
    PressureBoundaryOptimizer: typing.Type[PressureBoundaryOptimizer]
    ProcessConstraintEvaluator: typing.Type[ProcessConstraintEvaluator]
    ProcessOptimizationEngine: typing.Type[ProcessOptimizationEngine]
    ProcessSimulationEvaluator: typing.Type[ProcessSimulationEvaluator]
    ProductionOptimizationSpecLoader: typing.Type[ProductionOptimizationSpecLoader]
    ProductionOptimizer: typing.Type[ProductionOptimizer]
    StandardObjective: typing.Type[StandardObjective]
