# coding: utf-8

"""
    FINBOURNE Horizon API

    FINBOURNE Technology  # noqa: E501

    Contact: info@finbourne.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Dict, Optional, Any, Union, TYPE_CHECKING
from typing_extensions import Annotated
from pydantic.v1 import BaseModel, StrictStr, StrictInt, StrictBool, StrictFloat, StrictBytes, Field, validator, ValidationError, conlist, constr
from datetime import datetime
from finbourne_horizon.models.j_schema_type import JSchemaType

class JSchema(BaseModel):
    """
    JSchema
    """
    schema_version:  Optional[StrictStr] = Field(None,alias="schemaVersion") 
    valid: Optional[StrictBool] = None
    reference:  Optional[StrictStr] = Field(None,alias="reference") 
    ref: Optional[JSchema] = None
    recursive_reference:  Optional[StrictStr] = Field(None,alias="recursiveReference") 
    recursive_anchor: Optional[StrictBool] = Field(default=None, alias="recursiveAnchor")
    id:  Optional[StrictStr] = Field(None,alias="id") 
    anchor:  Optional[StrictStr] = Field(None,alias="anchor") 
    type: Optional[JSchemaType] = None
    default: Optional[Any] = None
    properties: Dict[str, JSchema]
    items: List[JSchema]
    items_position_validation: StrictBool = Field(alias="itemsPositionValidation")
    required: List[StrictStr]
    all_of: List[JSchema] = Field(alias="allOf")
    any_of: List[JSchema] = Field(alias="anyOf")
    one_of: List[JSchema] = Field(alias="oneOf")
    var_if: Optional[JSchema] = Field(default=None, alias="if")
    then: Optional[JSchema] = None
    var_else: Optional[JSchema] = Field(default=None, alias="else")
    var_not: Optional[JSchema] = Field(default=None, alias="not")
    contains: Optional[JSchema] = None
    property_names: Optional[JSchema] = Field(default=None, alias="propertyNames")
    enum: List[Any]
    const: Optional[Any] = None
    unique_items: StrictBool = Field(alias="uniqueItems")
    minimum_length: Optional[StrictInt] = Field(default=None, alias="minimumLength")
    maximum_length: Optional[StrictInt] = Field(default=None, alias="maximumLength")
    exclusive_minimum: StrictBool = Field(alias="exclusiveMinimum")
    exclusive_maximum: StrictBool = Field(alias="exclusiveMaximum")
    minimum_items: Optional[StrictInt] = Field(default=None, alias="minimumItems")
    maximum_items: Optional[StrictInt] = Field(default=None, alias="maximumItems")
    minimum_properties: Optional[StrictInt] = Field(default=None, alias="minimumProperties")
    maximum_properties: Optional[StrictInt] = Field(default=None, alias="maximumProperties")
    minimum_contains: Optional[StrictInt] = Field(default=None, alias="minimumContains")
    maximum_contains: Optional[StrictInt] = Field(default=None, alias="maximumContains")
    content_encoding:  Optional[StrictStr] = Field(None,alias="contentEncoding") 
    content_media_type:  Optional[StrictStr] = Field(None,alias="contentMediaType") 
    write_only: Optional[StrictBool] = Field(default=None, alias="writeOnly")
    read_only: Optional[StrictBool] = Field(default=None, alias="readOnly")
    extension_data: Dict[str, Any] = Field(alias="extensionData")
    title:  Optional[StrictStr] = Field(None,alias="title") 
    description:  Optional[StrictStr] = Field(None,alias="description") 
    multiple_of: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="multipleOf")
    pattern:  Optional[StrictStr] = Field(None,alias="pattern") 
    dependencies: Dict[str, Any]
    dependent_required: Dict[str, List[StrictStr]] = Field(alias="dependentRequired")
    dependent_schemas: Dict[str, JSchema] = Field(alias="dependentSchemas")
    pattern_properties: Dict[str, JSchema] = Field(alias="patternProperties")
    additional_properties: Optional[JSchema] = Field(default=None, alias="additionalProperties")
    allow_additional_properties: StrictBool = Field(alias="allowAdditionalProperties")
    allow_additional_properties_specified: StrictBool = Field(alias="allowAdditionalPropertiesSpecified")
    unevaluated_properties: Optional[JSchema] = Field(default=None, alias="unevaluatedProperties")
    allow_unevaluated_properties: Optional[StrictBool] = Field(default=None, alias="allowUnevaluatedProperties")
    additional_items: Optional[JSchema] = Field(default=None, alias="additionalItems")
    allow_additional_items: StrictBool = Field(alias="allowAdditionalItems")
    allow_additional_items_specified: StrictBool = Field(alias="allowAdditionalItemsSpecified")
    unevaluated_items: Optional[JSchema] = Field(default=None, alias="unevaluatedItems")
    allow_unevaluated_items: Optional[StrictBool] = Field(default=None, alias="allowUnevaluatedItems")
    format:  Optional[StrictStr] = Field(None,alias="format") 
    validators: List[Dict[str, Any]]
    __properties = ["schemaVersion", "valid", "reference", "ref", "recursiveReference", "recursiveAnchor", "id", "anchor", "type", "default", "properties", "items", "itemsPositionValidation", "required", "allOf", "anyOf", "oneOf", "if", "then", "else", "not", "contains", "propertyNames", "enum", "const", "uniqueItems", "minimumLength", "maximumLength", "exclusiveMinimum", "exclusiveMaximum", "minimumItems", "maximumItems", "minimumProperties", "maximumProperties", "minimumContains", "maximumContains", "contentEncoding", "contentMediaType", "writeOnly", "readOnly", "extensionData", "title", "description", "multipleOf", "pattern", "dependencies", "dependentRequired", "dependentSchemas", "patternProperties", "additionalProperties", "allowAdditionalProperties", "allowAdditionalPropertiesSpecified", "unevaluatedProperties", "allowUnevaluatedProperties", "additionalItems", "allowAdditionalItems", "allowAdditionalItemsSpecified", "unevaluatedItems", "allowUnevaluatedItems", "format", "validators"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def __str__(self):
        """For `print` and `pprint`"""
        return pprint.pformat(self.dict(by_alias=False))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> JSchema:
        """Create an instance of JSchema from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "properties",
                            "items",
                            "required",
                            "all_of",
                            "any_of",
                            "one_of",
                            "enum",
                            "extension_data",
                            "dependencies",
                            "dependent_required",
                            "dependent_schemas",
                            "pattern_properties",
                            "validators",
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of ref
        if self.ref:
            _dict['ref'] = self.ref.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in properties (dict)
        _field_dict = {}
        if self.properties:
            for _key in self.properties:
                if self.properties[_key]:
                    _field_dict[_key] = self.properties[_key].to_dict()
            _dict['properties'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each item in items (list)
        _items = []
        if self.items:
            for _item in self.items:
                if _item:
                    _items.append(_item.to_dict())
            _dict['items'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in all_of (list)
        _items = []
        if self.all_of:
            for _item in self.all_of:
                if _item:
                    _items.append(_item.to_dict())
            _dict['allOf'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in any_of (list)
        _items = []
        if self.any_of:
            for _item in self.any_of:
                if _item:
                    _items.append(_item.to_dict())
            _dict['anyOf'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in one_of (list)
        _items = []
        if self.one_of:
            for _item in self.one_of:
                if _item:
                    _items.append(_item.to_dict())
            _dict['oneOf'] = _items
        # override the default output from pydantic by calling `to_dict()` of var_if
        if self.var_if:
            _dict['if'] = self.var_if.to_dict()
        # override the default output from pydantic by calling `to_dict()` of then
        if self.then:
            _dict['then'] = self.then.to_dict()
        # override the default output from pydantic by calling `to_dict()` of var_else
        if self.var_else:
            _dict['else'] = self.var_else.to_dict()
        # override the default output from pydantic by calling `to_dict()` of var_not
        if self.var_not:
            _dict['not'] = self.var_not.to_dict()
        # override the default output from pydantic by calling `to_dict()` of contains
        if self.contains:
            _dict['contains'] = self.contains.to_dict()
        # override the default output from pydantic by calling `to_dict()` of property_names
        if self.property_names:
            _dict['propertyNames'] = self.property_names.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in dependent_required (dict of array)
        _field_dict_of_array = {}
        if self.dependent_required:
            for _key in self.dependent_required:
                if self.dependent_required[_key]:
                    _field_dict_of_array[_key] = [
                        _item.to_dict() for _item in self.dependent_required[_key]
                    ]
            _dict['dependentRequired'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of each value in dependent_schemas (dict)
        _field_dict = {}
        if self.dependent_schemas:
            for _key in self.dependent_schemas:
                if self.dependent_schemas[_key]:
                    _field_dict[_key] = self.dependent_schemas[_key].to_dict()
            _dict['dependentSchemas'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in pattern_properties (dict)
        _field_dict = {}
        if self.pattern_properties:
            for _key in self.pattern_properties:
                if self.pattern_properties[_key]:
                    _field_dict[_key] = self.pattern_properties[_key].to_dict()
            _dict['patternProperties'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of additional_properties
        if self.additional_properties:
            _dict['additionalProperties'] = self.additional_properties.to_dict()
        # override the default output from pydantic by calling `to_dict()` of unevaluated_properties
        if self.unevaluated_properties:
            _dict['unevaluatedProperties'] = self.unevaluated_properties.to_dict()
        # override the default output from pydantic by calling `to_dict()` of additional_items
        if self.additional_items:
            _dict['additionalItems'] = self.additional_items.to_dict()
        # override the default output from pydantic by calling `to_dict()` of unevaluated_items
        if self.unevaluated_items:
            _dict['unevaluatedItems'] = self.unevaluated_items.to_dict()
        # set to None if schema_version (nullable) is None
        # and __fields_set__ contains the field
        if self.schema_version is None and "schema_version" in self.__fields_set__:
            _dict['schemaVersion'] = None

        # set to None if valid (nullable) is None
        # and __fields_set__ contains the field
        if self.valid is None and "valid" in self.__fields_set__:
            _dict['valid'] = None

        # set to None if reference (nullable) is None
        # and __fields_set__ contains the field
        if self.reference is None and "reference" in self.__fields_set__:
            _dict['reference'] = None

        # set to None if recursive_reference (nullable) is None
        # and __fields_set__ contains the field
        if self.recursive_reference is None and "recursive_reference" in self.__fields_set__:
            _dict['recursiveReference'] = None

        # set to None if recursive_anchor (nullable) is None
        # and __fields_set__ contains the field
        if self.recursive_anchor is None and "recursive_anchor" in self.__fields_set__:
            _dict['recursiveAnchor'] = None

        # set to None if id (nullable) is None
        # and __fields_set__ contains the field
        if self.id is None and "id" in self.__fields_set__:
            _dict['id'] = None

        # set to None if anchor (nullable) is None
        # and __fields_set__ contains the field
        if self.anchor is None and "anchor" in self.__fields_set__:
            _dict['anchor'] = None

        # set to None if default (nullable) is None
        # and __fields_set__ contains the field
        if self.default is None and "default" in self.__fields_set__:
            _dict['default'] = None

        # set to None if const (nullable) is None
        # and __fields_set__ contains the field
        if self.const is None and "const" in self.__fields_set__:
            _dict['const'] = None

        # set to None if minimum_length (nullable) is None
        # and __fields_set__ contains the field
        if self.minimum_length is None and "minimum_length" in self.__fields_set__:
            _dict['minimumLength'] = None

        # set to None if maximum_length (nullable) is None
        # and __fields_set__ contains the field
        if self.maximum_length is None and "maximum_length" in self.__fields_set__:
            _dict['maximumLength'] = None

        # set to None if minimum_items (nullable) is None
        # and __fields_set__ contains the field
        if self.minimum_items is None and "minimum_items" in self.__fields_set__:
            _dict['minimumItems'] = None

        # set to None if maximum_items (nullable) is None
        # and __fields_set__ contains the field
        if self.maximum_items is None and "maximum_items" in self.__fields_set__:
            _dict['maximumItems'] = None

        # set to None if minimum_properties (nullable) is None
        # and __fields_set__ contains the field
        if self.minimum_properties is None and "minimum_properties" in self.__fields_set__:
            _dict['minimumProperties'] = None

        # set to None if maximum_properties (nullable) is None
        # and __fields_set__ contains the field
        if self.maximum_properties is None and "maximum_properties" in self.__fields_set__:
            _dict['maximumProperties'] = None

        # set to None if minimum_contains (nullable) is None
        # and __fields_set__ contains the field
        if self.minimum_contains is None and "minimum_contains" in self.__fields_set__:
            _dict['minimumContains'] = None

        # set to None if maximum_contains (nullable) is None
        # and __fields_set__ contains the field
        if self.maximum_contains is None and "maximum_contains" in self.__fields_set__:
            _dict['maximumContains'] = None

        # set to None if content_encoding (nullable) is None
        # and __fields_set__ contains the field
        if self.content_encoding is None and "content_encoding" in self.__fields_set__:
            _dict['contentEncoding'] = None

        # set to None if content_media_type (nullable) is None
        # and __fields_set__ contains the field
        if self.content_media_type is None and "content_media_type" in self.__fields_set__:
            _dict['contentMediaType'] = None

        # set to None if write_only (nullable) is None
        # and __fields_set__ contains the field
        if self.write_only is None and "write_only" in self.__fields_set__:
            _dict['writeOnly'] = None

        # set to None if read_only (nullable) is None
        # and __fields_set__ contains the field
        if self.read_only is None and "read_only" in self.__fields_set__:
            _dict['readOnly'] = None

        # set to None if title (nullable) is None
        # and __fields_set__ contains the field
        if self.title is None and "title" in self.__fields_set__:
            _dict['title'] = None

        # set to None if description (nullable) is None
        # and __fields_set__ contains the field
        if self.description is None and "description" in self.__fields_set__:
            _dict['description'] = None

        # set to None if multiple_of (nullable) is None
        # and __fields_set__ contains the field
        if self.multiple_of is None and "multiple_of" in self.__fields_set__:
            _dict['multipleOf'] = None

        # set to None if pattern (nullable) is None
        # and __fields_set__ contains the field
        if self.pattern is None and "pattern" in self.__fields_set__:
            _dict['pattern'] = None

        # set to None if allow_unevaluated_properties (nullable) is None
        # and __fields_set__ contains the field
        if self.allow_unevaluated_properties is None and "allow_unevaluated_properties" in self.__fields_set__:
            _dict['allowUnevaluatedProperties'] = None

        # set to None if allow_unevaluated_items (nullable) is None
        # and __fields_set__ contains the field
        if self.allow_unevaluated_items is None and "allow_unevaluated_items" in self.__fields_set__:
            _dict['allowUnevaluatedItems'] = None

        # set to None if format (nullable) is None
        # and __fields_set__ contains the field
        if self.format is None and "format" in self.__fields_set__:
            _dict['format'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> JSchema:
        """Create an instance of JSchema from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return JSchema.parse_obj(obj)

        _obj = JSchema.parse_obj({
            "schema_version": obj.get("schemaVersion"),
            "valid": obj.get("valid"),
            "reference": obj.get("reference"),
            "ref": JSchema.from_dict(obj.get("ref")) if obj.get("ref") is not None else None,
            "recursive_reference": obj.get("recursiveReference"),
            "recursive_anchor": obj.get("recursiveAnchor"),
            "id": obj.get("id"),
            "anchor": obj.get("anchor"),
            "type": obj.get("type"),
            "default": obj.get("default"),
            "properties": dict(
                (_k, JSchema.from_dict(_v))
                for _k, _v in obj.get("properties").items()
            )
            if obj.get("properties") is not None
            else None,
            "items": [JSchema.from_dict(_item) for _item in obj.get("items")] if obj.get("items") is not None else None,
            "items_position_validation": obj.get("itemsPositionValidation"),
            "required": obj.get("required"),
            "all_of": [JSchema.from_dict(_item) for _item in obj.get("allOf")] if obj.get("allOf") is not None else None,
            "any_of": [JSchema.from_dict(_item) for _item in obj.get("anyOf")] if obj.get("anyOf") is not None else None,
            "one_of": [JSchema.from_dict(_item) for _item in obj.get("oneOf")] if obj.get("oneOf") is not None else None,
            "var_if": JSchema.from_dict(obj.get("if")) if obj.get("if") is not None else None,
            "then": JSchema.from_dict(obj.get("then")) if obj.get("then") is not None else None,
            "var_else": JSchema.from_dict(obj.get("else")) if obj.get("else") is not None else None,
            "var_not": JSchema.from_dict(obj.get("not")) if obj.get("not") is not None else None,
            "contains": JSchema.from_dict(obj.get("contains")) if obj.get("contains") is not None else None,
            "property_names": JSchema.from_dict(obj.get("propertyNames")) if obj.get("propertyNames") is not None else None,
            "enum": obj.get("enum"),
            "const": obj.get("const"),
            "unique_items": obj.get("uniqueItems"),
            "minimum_length": obj.get("minimumLength"),
            "maximum_length": obj.get("maximumLength"),
            "exclusive_minimum": obj.get("exclusiveMinimum"),
            "exclusive_maximum": obj.get("exclusiveMaximum"),
            "minimum_items": obj.get("minimumItems"),
            "maximum_items": obj.get("maximumItems"),
            "minimum_properties": obj.get("minimumProperties"),
            "maximum_properties": obj.get("maximumProperties"),
            "minimum_contains": obj.get("minimumContains"),
            "maximum_contains": obj.get("maximumContains"),
            "content_encoding": obj.get("contentEncoding"),
            "content_media_type": obj.get("contentMediaType"),
            "write_only": obj.get("writeOnly"),
            "read_only": obj.get("readOnly"),
            "extension_data": obj.get("extensionData"),
            "title": obj.get("title"),
            "description": obj.get("description"),
            "multiple_of": obj.get("multipleOf"),
            "pattern": obj.get("pattern"),
            "dependencies": obj.get("dependencies"),
            "dependent_required": obj.get("dependentRequired"),
            "dependent_schemas": dict(
                (_k, JSchema.from_dict(_v))
                for _k, _v in obj.get("dependentSchemas").items()
            )
            if obj.get("dependentSchemas") is not None
            else None,
            "pattern_properties": dict(
                (_k, JSchema.from_dict(_v))
                for _k, _v in obj.get("patternProperties").items()
            )
            if obj.get("patternProperties") is not None
            else None,
            "additional_properties": JSchema.from_dict(obj.get("additionalProperties")) if obj.get("additionalProperties") is not None else None,
            "allow_additional_properties": obj.get("allowAdditionalProperties"),
            "allow_additional_properties_specified": obj.get("allowAdditionalPropertiesSpecified"),
            "unevaluated_properties": JSchema.from_dict(obj.get("unevaluatedProperties")) if obj.get("unevaluatedProperties") is not None else None,
            "allow_unevaluated_properties": obj.get("allowUnevaluatedProperties"),
            "additional_items": JSchema.from_dict(obj.get("additionalItems")) if obj.get("additionalItems") is not None else None,
            "allow_additional_items": obj.get("allowAdditionalItems"),
            "allow_additional_items_specified": obj.get("allowAdditionalItemsSpecified"),
            "unevaluated_items": JSchema.from_dict(obj.get("unevaluatedItems")) if obj.get("unevaluatedItems") is not None else None,
            "allow_unevaluated_items": obj.get("allowUnevaluatedItems"),
            "format": obj.get("format"),
            "validators": obj.get("validators")
        })
        return _obj

JSchema.update_forward_refs()
