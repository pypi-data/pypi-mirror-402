# coding: utf-8

"""
ME TT DataPortal Data Portal API

ME TT DataPortal Data Portal APIs to fetch Gut Microbes Genomes / Genes information.

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from mett_dataportal_sdk.models.amr_schema import AMRSchema
from mett_dataportal_sdk.models.dbx_ref_schema import DBXRefSchema
from typing import Set
from typing_extensions import Self


class GeneResponseSchema(BaseModel):
    """
    GeneResponseSchema
    """  # noqa: E501

    locus_tag: Optional[StrictStr] = None
    gene_name: Optional[StrictStr] = None
    alias: Optional[List[StrictStr]] = None
    product: Optional[StrictStr] = None
    product_source: Optional[StrictStr] = None
    start_position: Optional[StrictInt] = None
    end_position: Optional[StrictInt] = None
    seq_id: Optional[StrictStr] = None
    isolate_name: Optional[StrictStr] = None
    species_scientific_name: Optional[StrictStr] = None
    species_acronym: Optional[StrictStr] = None
    uniprot_id: Optional[StrictStr] = None
    essentiality: Optional[StrictStr] = None
    cog_funcats: Optional[List[StrictStr]] = None
    cog_id: Optional[List[StrictStr]] = None
    kegg: Optional[List[StrictStr]] = None
    pfam: Optional[List[StrictStr]] = None
    interpro: Optional[List[StrictStr]] = None
    ec_number: Optional[StrictStr] = None
    dbxref: Optional[List[DBXRefSchema]] = None
    eggnog: Optional[StrictStr] = None
    inference: Optional[StrictStr] = None
    ontology_terms: Optional[List[Dict[str, Any]]] = None
    uf_ontology_terms: Optional[List[StrictStr]] = None
    uf_prot_rec_fullname: Optional[StrictStr] = None
    uf_keyword: Optional[List[StrictStr]] = None
    uf_gene_name: Optional[StrictStr] = None
    amr: Optional[List[AMRSchema]] = None
    has_amr_info: Optional[StrictBool] = None
    has_proteomics: Optional[StrictBool] = None
    has_fitness: Optional[StrictBool] = None
    has_mutant_growth: Optional[StrictBool] = None
    has_reactions: Optional[StrictBool] = None
    feature_type: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = [
        "locus_tag",
        "gene_name",
        "alias",
        "product",
        "product_source",
        "start_position",
        "end_position",
        "seq_id",
        "isolate_name",
        "species_scientific_name",
        "species_acronym",
        "uniprot_id",
        "essentiality",
        "cog_funcats",
        "cog_id",
        "kegg",
        "pfam",
        "interpro",
        "ec_number",
        "dbxref",
        "eggnog",
        "inference",
        "ontology_terms",
        "uf_ontology_terms",
        "uf_prot_rec_fullname",
        "uf_keyword",
        "uf_gene_name",
        "amr",
        "has_amr_info",
        "has_proteomics",
        "has_fitness",
        "has_mutant_growth",
        "has_reactions",
        "feature_type",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GeneResponseSchema from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in dbxref (list)
        _items = []
        if self.dbxref:
            for _item_dbxref in self.dbxref:
                if _item_dbxref:
                    _items.append(_item_dbxref.to_dict())
            _dict["dbxref"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in amr (list)
        _items = []
        if self.amr:
            for _item_amr in self.amr:
                if _item_amr:
                    _items.append(_item_amr.to_dict())
            _dict["amr"] = _items
        # set to None if locus_tag (nullable) is None
        # and model_fields_set contains the field
        if self.locus_tag is None and "locus_tag" in self.model_fields_set:
            _dict["locus_tag"] = None

        # set to None if gene_name (nullable) is None
        # and model_fields_set contains the field
        if self.gene_name is None and "gene_name" in self.model_fields_set:
            _dict["gene_name"] = None

        # set to None if alias (nullable) is None
        # and model_fields_set contains the field
        if self.alias is None and "alias" in self.model_fields_set:
            _dict["alias"] = None

        # set to None if product (nullable) is None
        # and model_fields_set contains the field
        if self.product is None and "product" in self.model_fields_set:
            _dict["product"] = None

        # set to None if product_source (nullable) is None
        # and model_fields_set contains the field
        if self.product_source is None and "product_source" in self.model_fields_set:
            _dict["product_source"] = None

        # set to None if start_position (nullable) is None
        # and model_fields_set contains the field
        if self.start_position is None and "start_position" in self.model_fields_set:
            _dict["start_position"] = None

        # set to None if end_position (nullable) is None
        # and model_fields_set contains the field
        if self.end_position is None and "end_position" in self.model_fields_set:
            _dict["end_position"] = None

        # set to None if seq_id (nullable) is None
        # and model_fields_set contains the field
        if self.seq_id is None and "seq_id" in self.model_fields_set:
            _dict["seq_id"] = None

        # set to None if isolate_name (nullable) is None
        # and model_fields_set contains the field
        if self.isolate_name is None and "isolate_name" in self.model_fields_set:
            _dict["isolate_name"] = None

        # set to None if species_scientific_name (nullable) is None
        # and model_fields_set contains the field
        if (
            self.species_scientific_name is None
            and "species_scientific_name" in self.model_fields_set
        ):
            _dict["species_scientific_name"] = None

        # set to None if species_acronym (nullable) is None
        # and model_fields_set contains the field
        if self.species_acronym is None and "species_acronym" in self.model_fields_set:
            _dict["species_acronym"] = None

        # set to None if uniprot_id (nullable) is None
        # and model_fields_set contains the field
        if self.uniprot_id is None and "uniprot_id" in self.model_fields_set:
            _dict["uniprot_id"] = None

        # set to None if essentiality (nullable) is None
        # and model_fields_set contains the field
        if self.essentiality is None and "essentiality" in self.model_fields_set:
            _dict["essentiality"] = None

        # set to None if cog_funcats (nullable) is None
        # and model_fields_set contains the field
        if self.cog_funcats is None and "cog_funcats" in self.model_fields_set:
            _dict["cog_funcats"] = None

        # set to None if cog_id (nullable) is None
        # and model_fields_set contains the field
        if self.cog_id is None and "cog_id" in self.model_fields_set:
            _dict["cog_id"] = None

        # set to None if kegg (nullable) is None
        # and model_fields_set contains the field
        if self.kegg is None and "kegg" in self.model_fields_set:
            _dict["kegg"] = None

        # set to None if pfam (nullable) is None
        # and model_fields_set contains the field
        if self.pfam is None and "pfam" in self.model_fields_set:
            _dict["pfam"] = None

        # set to None if interpro (nullable) is None
        # and model_fields_set contains the field
        if self.interpro is None and "interpro" in self.model_fields_set:
            _dict["interpro"] = None

        # set to None if ec_number (nullable) is None
        # and model_fields_set contains the field
        if self.ec_number is None and "ec_number" in self.model_fields_set:
            _dict["ec_number"] = None

        # set to None if dbxref (nullable) is None
        # and model_fields_set contains the field
        if self.dbxref is None and "dbxref" in self.model_fields_set:
            _dict["dbxref"] = None

        # set to None if eggnog (nullable) is None
        # and model_fields_set contains the field
        if self.eggnog is None and "eggnog" in self.model_fields_set:
            _dict["eggnog"] = None

        # set to None if inference (nullable) is None
        # and model_fields_set contains the field
        if self.inference is None and "inference" in self.model_fields_set:
            _dict["inference"] = None

        # set to None if ontology_terms (nullable) is None
        # and model_fields_set contains the field
        if self.ontology_terms is None and "ontology_terms" in self.model_fields_set:
            _dict["ontology_terms"] = None

        # set to None if uf_ontology_terms (nullable) is None
        # and model_fields_set contains the field
        if (
            self.uf_ontology_terms is None
            and "uf_ontology_terms" in self.model_fields_set
        ):
            _dict["uf_ontology_terms"] = None

        # set to None if uf_prot_rec_fullname (nullable) is None
        # and model_fields_set contains the field
        if (
            self.uf_prot_rec_fullname is None
            and "uf_prot_rec_fullname" in self.model_fields_set
        ):
            _dict["uf_prot_rec_fullname"] = None

        # set to None if uf_keyword (nullable) is None
        # and model_fields_set contains the field
        if self.uf_keyword is None and "uf_keyword" in self.model_fields_set:
            _dict["uf_keyword"] = None

        # set to None if uf_gene_name (nullable) is None
        # and model_fields_set contains the field
        if self.uf_gene_name is None and "uf_gene_name" in self.model_fields_set:
            _dict["uf_gene_name"] = None

        # set to None if amr (nullable) is None
        # and model_fields_set contains the field
        if self.amr is None and "amr" in self.model_fields_set:
            _dict["amr"] = None

        # set to None if has_amr_info (nullable) is None
        # and model_fields_set contains the field
        if self.has_amr_info is None and "has_amr_info" in self.model_fields_set:
            _dict["has_amr_info"] = None

        # set to None if has_proteomics (nullable) is None
        # and model_fields_set contains the field
        if self.has_proteomics is None and "has_proteomics" in self.model_fields_set:
            _dict["has_proteomics"] = None

        # set to None if has_fitness (nullable) is None
        # and model_fields_set contains the field
        if self.has_fitness is None and "has_fitness" in self.model_fields_set:
            _dict["has_fitness"] = None

        # set to None if has_mutant_growth (nullable) is None
        # and model_fields_set contains the field
        if (
            self.has_mutant_growth is None
            and "has_mutant_growth" in self.model_fields_set
        ):
            _dict["has_mutant_growth"] = None

        # set to None if has_reactions (nullable) is None
        # and model_fields_set contains the field
        if self.has_reactions is None and "has_reactions" in self.model_fields_set:
            _dict["has_reactions"] = None

        # set to None if feature_type (nullable) is None
        # and model_fields_set contains the field
        if self.feature_type is None and "feature_type" in self.model_fields_set:
            _dict["feature_type"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GeneResponseSchema from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "locus_tag": obj.get("locus_tag"),
                "gene_name": obj.get("gene_name"),
                "alias": obj.get("alias"),
                "product": obj.get("product"),
                "product_source": obj.get("product_source"),
                "start_position": obj.get("start_position"),
                "end_position": obj.get("end_position"),
                "seq_id": obj.get("seq_id"),
                "isolate_name": obj.get("isolate_name"),
                "species_scientific_name": obj.get("species_scientific_name"),
                "species_acronym": obj.get("species_acronym"),
                "uniprot_id": obj.get("uniprot_id"),
                "essentiality": obj.get("essentiality"),
                "cog_funcats": obj.get("cog_funcats"),
                "cog_id": obj.get("cog_id"),
                "kegg": obj.get("kegg"),
                "pfam": obj.get("pfam"),
                "interpro": obj.get("interpro"),
                "ec_number": obj.get("ec_number"),
                "dbxref": [DBXRefSchema.from_dict(_item) for _item in obj["dbxref"]]
                if obj.get("dbxref") is not None
                else None,
                "eggnog": obj.get("eggnog"),
                "inference": obj.get("inference"),
                "ontology_terms": obj.get("ontology_terms"),
                "uf_ontology_terms": obj.get("uf_ontology_terms"),
                "uf_prot_rec_fullname": obj.get("uf_prot_rec_fullname"),
                "uf_keyword": obj.get("uf_keyword"),
                "uf_gene_name": obj.get("uf_gene_name"),
                "amr": [AMRSchema.from_dict(_item) for _item in obj["amr"]]
                if obj.get("amr") is not None
                else None,
                "has_amr_info": obj.get("has_amr_info"),
                "has_proteomics": obj.get("has_proteomics"),
                "has_fitness": obj.get("has_fitness"),
                "has_mutant_growth": obj.get("has_mutant_growth"),
                "has_reactions": obj.get("has_reactions"),
                "feature_type": obj.get("feature_type"),
            }
        )
        return _obj
