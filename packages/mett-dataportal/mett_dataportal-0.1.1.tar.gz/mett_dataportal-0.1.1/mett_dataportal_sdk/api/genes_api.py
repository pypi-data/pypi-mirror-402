# coding: utf-8

"""
ME TT DataPortal Data Portal API

ME TT DataPortal Data Portal APIs to fetch Gut Microbes Genomes / Genes information.

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import StrictBool
from mett_dataportal_sdk.models.gene_paginated_response_schema import (
    GenePaginatedResponseSchema,
)
from mett_dataportal_sdk.models.success_response_schema import SuccessResponseSchema

from mett_dataportal_sdk.api_client import ApiClient, RequestSerialized
from mett_dataportal_sdk.api_response import ApiResponse
from mett_dataportal_sdk.rest import RESTResponseType


class GenesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def dataportal_api_core_gene_endpoints_get_all_genes(
        self,
        page: Annotated[
            Optional[StrictInt], Field(description="Page number to retrieve.")
        ] = None,
        per_page: Annotated[
            Optional[StrictInt],
            Field(description="Number of genes to return per page."),
        ] = None,
        sort_field: Annotated[
            Optional[StrictStr], Field(description="Field to sort results by.")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr], Field(description="Sort order: 'asc' or 'desc'.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GenePaginatedResponseSchema:
        """Get all genes

        Retrieves a paginated list of all genes across all available genomes. Supports optional sorting by 'isolate_name', 'gene_name', 'alias', 'seq_id', 'locus_tag' and 'product'. Useful for browsing the full gene catalog without applying filters.

        :param page: Page number to retrieve.
        :type page: int
        :param per_page: Number of genes to return per page.
        :type per_page: int
        :param sort_field: Field to sort results by.
        :type sort_field: str
        :param sort_order: Sort order: 'asc' or 'desc'.
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_core_gene_endpoints_get_all_genes_serialize(
            page=page,
            per_page=per_page,
            sort_field=sort_field,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GenePaginatedResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_core_gene_endpoints_get_all_genes_with_http_info(
        self,
        page: Annotated[
            Optional[StrictInt], Field(description="Page number to retrieve.")
        ] = None,
        per_page: Annotated[
            Optional[StrictInt],
            Field(description="Number of genes to return per page."),
        ] = None,
        sort_field: Annotated[
            Optional[StrictStr], Field(description="Field to sort results by.")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr], Field(description="Sort order: 'asc' or 'desc'.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GenePaginatedResponseSchema]:
        """Get all genes

        Retrieves a paginated list of all genes across all available genomes. Supports optional sorting by 'isolate_name', 'gene_name', 'alias', 'seq_id', 'locus_tag' and 'product'. Useful for browsing the full gene catalog without applying filters.

        :param page: Page number to retrieve.
        :type page: int
        :param per_page: Number of genes to return per page.
        :type per_page: int
        :param sort_field: Field to sort results by.
        :type sort_field: str
        :param sort_order: Sort order: 'asc' or 'desc'.
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_core_gene_endpoints_get_all_genes_serialize(
            page=page,
            per_page=per_page,
            sort_field=sort_field,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GenePaginatedResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_core_gene_endpoints_get_all_genes_without_preload_content(
        self,
        page: Annotated[
            Optional[StrictInt], Field(description="Page number to retrieve.")
        ] = None,
        per_page: Annotated[
            Optional[StrictInt],
            Field(description="Number of genes to return per page."),
        ] = None,
        sort_field: Annotated[
            Optional[StrictStr], Field(description="Field to sort results by.")
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr], Field(description="Sort order: 'asc' or 'desc'.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all genes

        Retrieves a paginated list of all genes across all available genomes. Supports optional sorting by 'isolate_name', 'gene_name', 'alias', 'seq_id', 'locus_tag' and 'product'. Useful for browsing the full gene catalog without applying filters.

        :param page: Page number to retrieve.
        :type page: int
        :param per_page: Number of genes to return per page.
        :type per_page: int
        :param sort_field: Field to sort results by.
        :type sort_field: str
        :param sort_order: Sort order: 'asc' or 'desc'.
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_core_gene_endpoints_get_all_genes_serialize(
            page=page,
            per_page=per_page,
            sort_field=sort_field,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GenePaginatedResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_core_gene_endpoints_get_all_genes_serialize(
        self,
        page,
        per_page,
        sort_field,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if sort_field is not None:
            _query_params.append(("sort_field", sort_field))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def dataportal_api_core_gene_endpoints_get_gene_by_locus_tag(
        self,
        locus_tag: Annotated[
            StrictStr,
            Field(
                description="Unique locus tag identifier for the gene (e.g., 'ABC_123')."
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SuccessResponseSchema:
        """Get gene by locus tag

        Retrieves detailed information for a specific gene using its unique locus tag. Returns metadata and functional annotation associated with the gene. This endpoint is useful for direct lookups when the locus tag is already known.

        :param locus_tag: Unique locus tag identifier for the gene (e.g., 'ABC_123'). (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = (
            self._dataportal_api_core_gene_endpoints_get_gene_by_locus_tag_serialize(
                locus_tag=locus_tag,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_core_gene_endpoints_get_gene_by_locus_tag_with_http_info(
        self,
        locus_tag: Annotated[
            StrictStr,
            Field(
                description="Unique locus tag identifier for the gene (e.g., 'ABC_123')."
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SuccessResponseSchema]:
        """Get gene by locus tag

        Retrieves detailed information for a specific gene using its unique locus tag. Returns metadata and functional annotation associated with the gene. This endpoint is useful for direct lookups when the locus tag is already known.

        :param locus_tag: Unique locus tag identifier for the gene (e.g., 'ABC_123'). (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = (
            self._dataportal_api_core_gene_endpoints_get_gene_by_locus_tag_serialize(
                locus_tag=locus_tag,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_core_gene_endpoints_get_gene_by_locus_tag_without_preload_content(
        self,
        locus_tag: Annotated[
            StrictStr,
            Field(
                description="Unique locus tag identifier for the gene (e.g., 'ABC_123')."
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get gene by locus tag

        Retrieves detailed information for a specific gene using its unique locus tag. Returns metadata and functional annotation associated with the gene. This endpoint is useful for direct lookups when the locus tag is already known.

        :param locus_tag: Unique locus tag identifier for the gene (e.g., 'ABC_123'). (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = (
            self._dataportal_api_core_gene_endpoints_get_gene_by_locus_tag_serialize(
                locus_tag=locus_tag,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_core_gene_endpoints_get_gene_by_locus_tag_serialize(
        self,
        locus_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if locus_tag is not None:
            _path_params["locus_tag"] = locus_tag
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/{locus_tag}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def dataportal_api_core_gene_endpoints_search_genes_by_multiple_genomes_and_species_and_string(
        self,
        isolates: Annotated[
            Optional[StrictStr],
            Field(description="Comma-separated list of isolate names to filter."),
        ] = None,
        species_acronym: Annotated[
            Optional[StrictStr],
            Field(description="Species acronym to filter (e.g., 'BU', 'PV')."),
        ] = None,
        locus_tag: Annotated[
            Optional[StrictStr],
            Field(
                description="Exact locus tag to search for (takes precedence over query if provided)."
            ),
        ] = None,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="Free-text search string for gene names, locus tags, or annotations."
            ),
        ] = None,
        filter: Annotated[
            Optional[StrictStr],
            Field(
                description="Additional gene filter, e.g., 'pfam:PF07715;interpro:IPR012910'."
            ),
        ] = None,
        filter_operators: Annotated[
            Optional[StrictStr],
            Field(
                description="Logical operators for filters, e.g., 'pfam:AND;interpro:OR'."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="Page number for pagination (1-based)."),
        ] = None,
        per_page: Annotated[
            Optional[StrictInt],
            Field(description="Number of genes to return per page."),
        ] = None,
        sort_field: Annotated[
            Optional[StrictStr],
            Field(
                description="Field to sort results by, e.g., 'gene_name', 'isolate_name'."
            ),
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr], Field(description="Sort order: 'asc' or 'desc'.")
        ] = None,
        seq_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Sequence ID (contig/chromosome) to filter genes by coordinate range."
            ),
        ] = None,
        start_position: Annotated[
            Optional[StrictInt],
            Field(description="Start position for coordinate range filtering."),
        ] = None,
        end_position: Annotated[
            Optional[StrictInt],
            Field(description="End position for coordinate range filtering."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GenePaginatedResponseSchema:
        """Advanced gene search across genomes and species


        :param isolates: Comma-separated list of isolate names to filter.
        :type isolates: str
        :param species_acronym: Species acronym to filter (e.g., 'BU', 'PV').
        :type species_acronym: str
        :param locus_tag: Exact locus tag to search for (takes precedence over query if provided).
        :type locus_tag: str
        :param query: Free-text search string for gene names, locus tags, or annotations.
        :type query: str
        :param filter: Additional gene filter, e.g., 'pfam:PF07715;interpro:IPR012910'.
        :type filter: str
        :param filter_operators: Logical operators for filters, e.g., 'pfam:AND;interpro:OR'.
        :type filter_operators: str
        :param page: Page number for pagination (1-based).
        :type page: int
        :param per_page: Number of genes to return per page.
        :type per_page: int
        :param sort_field: Field to sort results by, e.g., 'gene_name', 'isolate_name'.
        :type sort_field: str
        :param sort_order: Sort order: 'asc' or 'desc'.
        :type sort_order: str
        :param seq_id: Sequence ID (contig/chromosome) to filter genes by coordinate range.
        :type seq_id: str
        :param start_position: Start position for coordinate range filtering.
        :type start_position: int
        :param end_position: End position for coordinate range filtering.
        :type end_position: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_core_gene_endpoints_search_genes_by_multiple_genomes_and_species_and_string_serialize(
            isolates=isolates,
            species_acronym=species_acronym,
            locus_tag=locus_tag,
            query=query,
            filter=filter,
            filter_operators=filter_operators,
            page=page,
            per_page=per_page,
            sort_field=sort_field,
            sort_order=sort_order,
            seq_id=seq_id,
            start_position=start_position,
            end_position=end_position,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GenePaginatedResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_core_gene_endpoints_search_genes_by_multiple_genomes_and_species_and_string_with_http_info(
        self,
        isolates: Annotated[
            Optional[StrictStr],
            Field(description="Comma-separated list of isolate names to filter."),
        ] = None,
        species_acronym: Annotated[
            Optional[StrictStr],
            Field(description="Species acronym to filter (e.g., 'BU', 'PV')."),
        ] = None,
        locus_tag: Annotated[
            Optional[StrictStr],
            Field(
                description="Exact locus tag to search for (takes precedence over query if provided)."
            ),
        ] = None,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="Free-text search string for gene names, locus tags, or annotations."
            ),
        ] = None,
        filter: Annotated[
            Optional[StrictStr],
            Field(
                description="Additional gene filter, e.g., 'pfam:PF07715;interpro:IPR012910'."
            ),
        ] = None,
        filter_operators: Annotated[
            Optional[StrictStr],
            Field(
                description="Logical operators for filters, e.g., 'pfam:AND;interpro:OR'."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="Page number for pagination (1-based)."),
        ] = None,
        per_page: Annotated[
            Optional[StrictInt],
            Field(description="Number of genes to return per page."),
        ] = None,
        sort_field: Annotated[
            Optional[StrictStr],
            Field(
                description="Field to sort results by, e.g., 'gene_name', 'isolate_name'."
            ),
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr], Field(description="Sort order: 'asc' or 'desc'.")
        ] = None,
        seq_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Sequence ID (contig/chromosome) to filter genes by coordinate range."
            ),
        ] = None,
        start_position: Annotated[
            Optional[StrictInt],
            Field(description="Start position for coordinate range filtering."),
        ] = None,
        end_position: Annotated[
            Optional[StrictInt],
            Field(description="End position for coordinate range filtering."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GenePaginatedResponseSchema]:
        """Advanced gene search across genomes and species


        :param isolates: Comma-separated list of isolate names to filter.
        :type isolates: str
        :param species_acronym: Species acronym to filter (e.g., 'BU', 'PV').
        :type species_acronym: str
        :param locus_tag: Exact locus tag to search for (takes precedence over query if provided).
        :type locus_tag: str
        :param query: Free-text search string for gene names, locus tags, or annotations.
        :type query: str
        :param filter: Additional gene filter, e.g., 'pfam:PF07715;interpro:IPR012910'.
        :type filter: str
        :param filter_operators: Logical operators for filters, e.g., 'pfam:AND;interpro:OR'.
        :type filter_operators: str
        :param page: Page number for pagination (1-based).
        :type page: int
        :param per_page: Number of genes to return per page.
        :type per_page: int
        :param sort_field: Field to sort results by, e.g., 'gene_name', 'isolate_name'.
        :type sort_field: str
        :param sort_order: Sort order: 'asc' or 'desc'.
        :type sort_order: str
        :param seq_id: Sequence ID (contig/chromosome) to filter genes by coordinate range.
        :type seq_id: str
        :param start_position: Start position for coordinate range filtering.
        :type start_position: int
        :param end_position: End position for coordinate range filtering.
        :type end_position: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_core_gene_endpoints_search_genes_by_multiple_genomes_and_species_and_string_serialize(
            isolates=isolates,
            species_acronym=species_acronym,
            locus_tag=locus_tag,
            query=query,
            filter=filter,
            filter_operators=filter_operators,
            page=page,
            per_page=per_page,
            sort_field=sort_field,
            sort_order=sort_order,
            seq_id=seq_id,
            start_position=start_position,
            end_position=end_position,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GenePaginatedResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_core_gene_endpoints_search_genes_by_multiple_genomes_and_species_and_string_without_preload_content(
        self,
        isolates: Annotated[
            Optional[StrictStr],
            Field(description="Comma-separated list of isolate names to filter."),
        ] = None,
        species_acronym: Annotated[
            Optional[StrictStr],
            Field(description="Species acronym to filter (e.g., 'BU', 'PV')."),
        ] = None,
        locus_tag: Annotated[
            Optional[StrictStr],
            Field(
                description="Exact locus tag to search for (takes precedence over query if provided)."
            ),
        ] = None,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="Free-text search string for gene names, locus tags, or annotations."
            ),
        ] = None,
        filter: Annotated[
            Optional[StrictStr],
            Field(
                description="Additional gene filter, e.g., 'pfam:PF07715;interpro:IPR012910'."
            ),
        ] = None,
        filter_operators: Annotated[
            Optional[StrictStr],
            Field(
                description="Logical operators for filters, e.g., 'pfam:AND;interpro:OR'."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="Page number for pagination (1-based)."),
        ] = None,
        per_page: Annotated[
            Optional[StrictInt],
            Field(description="Number of genes to return per page."),
        ] = None,
        sort_field: Annotated[
            Optional[StrictStr],
            Field(
                description="Field to sort results by, e.g., 'gene_name', 'isolate_name'."
            ),
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr], Field(description="Sort order: 'asc' or 'desc'.")
        ] = None,
        seq_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Sequence ID (contig/chromosome) to filter genes by coordinate range."
            ),
        ] = None,
        start_position: Annotated[
            Optional[StrictInt],
            Field(description="Start position for coordinate range filtering."),
        ] = None,
        end_position: Annotated[
            Optional[StrictInt],
            Field(description="End position for coordinate range filtering."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Advanced gene search across genomes and species


        :param isolates: Comma-separated list of isolate names to filter.
        :type isolates: str
        :param species_acronym: Species acronym to filter (e.g., 'BU', 'PV').
        :type species_acronym: str
        :param locus_tag: Exact locus tag to search for (takes precedence over query if provided).
        :type locus_tag: str
        :param query: Free-text search string for gene names, locus tags, or annotations.
        :type query: str
        :param filter: Additional gene filter, e.g., 'pfam:PF07715;interpro:IPR012910'.
        :type filter: str
        :param filter_operators: Logical operators for filters, e.g., 'pfam:AND;interpro:OR'.
        :type filter_operators: str
        :param page: Page number for pagination (1-based).
        :type page: int
        :param per_page: Number of genes to return per page.
        :type per_page: int
        :param sort_field: Field to sort results by, e.g., 'gene_name', 'isolate_name'.
        :type sort_field: str
        :param sort_order: Sort order: 'asc' or 'desc'.
        :type sort_order: str
        :param seq_id: Sequence ID (contig/chromosome) to filter genes by coordinate range.
        :type seq_id: str
        :param start_position: Start position for coordinate range filtering.
        :type start_position: int
        :param end_position: End position for coordinate range filtering.
        :type end_position: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_core_gene_endpoints_search_genes_by_multiple_genomes_and_species_and_string_serialize(
            isolates=isolates,
            species_acronym=species_acronym,
            locus_tag=locus_tag,
            query=query,
            filter=filter,
            filter_operators=filter_operators,
            page=page,
            per_page=per_page,
            sort_field=sort_field,
            sort_order=sort_order,
            seq_id=seq_id,
            start_position=start_position,
            end_position=end_position,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GenePaginatedResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_core_gene_endpoints_search_genes_by_multiple_genomes_and_species_and_string_serialize(
        self,
        isolates,
        species_acronym,
        locus_tag,
        query,
        filter,
        filter_operators,
        page,
        per_page,
        sort_field,
        sort_order,
        seq_id,
        start_position,
        end_position,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if isolates is not None:
            _query_params.append(("isolates", isolates))

        if species_acronym is not None:
            _query_params.append(("species_acronym", species_acronym))

        if locus_tag is not None:
            _query_params.append(("locus_tag", locus_tag))

        if query is not None:
            _query_params.append(("query", query))

        if filter is not None:
            _query_params.append(("filter", filter))

        if filter_operators is not None:
            _query_params.append(("filter_operators", filter_operators))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if sort_field is not None:
            _query_params.append(("sort_field", sort_field))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        if seq_id is not None:
            _query_params.append(("seq_id", seq_id))

        if start_position is not None:
            _query_params.append(("start_position", start_position))

        if end_position is not None:
            _query_params.append(("end_position", end_position))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/search/advanced",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def dataportal_api_core_gene_endpoints_search_genes_by_string(
        self,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="Free-text search term to match against gene names or locus tags."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="Page number for pagination (1-based)."),
        ] = None,
        per_page: Annotated[
            Optional[StrictInt],
            Field(description="Number of genes to return per page."),
        ] = None,
        sort_field: Annotated[
            Optional[StrictStr],
            Field(
                description="Field to sort results by (e.g., 'gene_name', 'isolate_name')."
            ),
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr], Field(description="Sort order: 'asc' or 'desc'.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GenePaginatedResponseSchema:
        """Search genes by query string


        :param query: Free-text search term to match against gene names or locus tags.
        :type query: str
        :param page: Page number for pagination (1-based).
        :type page: int
        :param per_page: Number of genes to return per page.
        :type per_page: int
        :param sort_field: Field to sort results by (e.g., 'gene_name', 'isolate_name').
        :type sort_field: str
        :param sort_order: Sort order: 'asc' or 'desc'.
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = (
            self._dataportal_api_core_gene_endpoints_search_genes_by_string_serialize(
                query=query,
                page=page,
                per_page=per_page,
                sort_field=sort_field,
                sort_order=sort_order,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GenePaginatedResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_core_gene_endpoints_search_genes_by_string_with_http_info(
        self,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="Free-text search term to match against gene names or locus tags."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="Page number for pagination (1-based)."),
        ] = None,
        per_page: Annotated[
            Optional[StrictInt],
            Field(description="Number of genes to return per page."),
        ] = None,
        sort_field: Annotated[
            Optional[StrictStr],
            Field(
                description="Field to sort results by (e.g., 'gene_name', 'isolate_name')."
            ),
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr], Field(description="Sort order: 'asc' or 'desc'.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GenePaginatedResponseSchema]:
        """Search genes by query string


        :param query: Free-text search term to match against gene names or locus tags.
        :type query: str
        :param page: Page number for pagination (1-based).
        :type page: int
        :param per_page: Number of genes to return per page.
        :type per_page: int
        :param sort_field: Field to sort results by (e.g., 'gene_name', 'isolate_name').
        :type sort_field: str
        :param sort_order: Sort order: 'asc' or 'desc'.
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = (
            self._dataportal_api_core_gene_endpoints_search_genes_by_string_serialize(
                query=query,
                page=page,
                per_page=per_page,
                sort_field=sort_field,
                sort_order=sort_order,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GenePaginatedResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_core_gene_endpoints_search_genes_by_string_without_preload_content(
        self,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="Free-text search term to match against gene names or locus tags."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(description="Page number for pagination (1-based)."),
        ] = None,
        per_page: Annotated[
            Optional[StrictInt],
            Field(description="Number of genes to return per page."),
        ] = None,
        sort_field: Annotated[
            Optional[StrictStr],
            Field(
                description="Field to sort results by (e.g., 'gene_name', 'isolate_name')."
            ),
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr], Field(description="Sort order: 'asc' or 'desc'.")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search genes by query string


        :param query: Free-text search term to match against gene names or locus tags.
        :type query: str
        :param page: Page number for pagination (1-based).
        :type page: int
        :param per_page: Number of genes to return per page.
        :type per_page: int
        :param sort_field: Field to sort results by (e.g., 'gene_name', 'isolate_name').
        :type sort_field: str
        :param sort_order: Sort order: 'asc' or 'desc'.
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = (
            self._dataportal_api_core_gene_endpoints_search_genes_by_string_serialize(
                query=query,
                page=page,
                per_page=per_page,
                sort_field=sort_field,
                sort_order=sort_order,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GenePaginatedResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_core_gene_endpoints_search_genes_by_string_serialize(
        self,
        query,
        page,
        per_page,
        sort_field,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            _query_params.append(("query", query))

        if page is not None:
            _query_params.append(("page", page))

        if per_page is not None:
            _query_params.append(("per_page", per_page))

        if sort_field is not None:
            _query_params.append(("sort_field", sort_field))

        if sort_order is not None:
            _query_params.append(("sort_order", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/search",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def dataportal_api_experimental_essentiality_endpoints_get_essentiality_by_gene(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SuccessResponseSchema:
        """Get essentiality data for a gene

        Retrieves essentiality data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with essentiality data including TnSeq metrics, essentiality calls, and experimental conditions.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_essentiality_endpoints_get_essentiality_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_experimental_essentiality_endpoints_get_essentiality_by_gene_with_http_info(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SuccessResponseSchema]:
        """Get essentiality data for a gene

        Retrieves essentiality data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with essentiality data including TnSeq metrics, essentiality calls, and experimental conditions.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_essentiality_endpoints_get_essentiality_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_experimental_essentiality_endpoints_get_essentiality_by_gene_without_preload_content(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get essentiality data for a gene

        Retrieves essentiality data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with essentiality data including TnSeq metrics, essentiality calls, and experimental conditions.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_essentiality_endpoints_get_essentiality_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_experimental_essentiality_endpoints_get_essentiality_by_gene_serialize(
        self,
        locus_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if locus_tag is not None:
            _path_params["locus_tag"] = locus_tag
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = ["RoleBasedJWTAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/{locus_tag}/essentiality",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def dataportal_api_experimental_fitness_endpoints_get_fitness_by_gene(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SuccessResponseSchema:
        """Get fitness data for a gene

        Retrieves fitness data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with fitness data including log fold change, FDR, and experimental conditions.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_fitness_endpoints_get_fitness_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_experimental_fitness_endpoints_get_fitness_by_gene_with_http_info(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SuccessResponseSchema]:
        """Get fitness data for a gene

        Retrieves fitness data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with fitness data including log fold change, FDR, and experimental conditions.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_fitness_endpoints_get_fitness_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_experimental_fitness_endpoints_get_fitness_by_gene_without_preload_content(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get fitness data for a gene

        Retrieves fitness data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with fitness data including log fold change, FDR, and experimental conditions.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_fitness_endpoints_get_fitness_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_experimental_fitness_endpoints_get_fitness_by_gene_serialize(
        self,
        locus_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if locus_tag is not None:
            _path_params["locus_tag"] = locus_tag
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = ["RoleBasedJWTAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/{locus_tag}/fitness",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def dataportal_api_experimental_mutant_growth_endpoints_get_mutant_growth_by_gene(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SuccessResponseSchema:
        """Get mutant growth data for a gene

        Retrieves mutant growth data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with mutant growth data including doubling times, biological replicates, and experimental conditions.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_mutant_growth_endpoints_get_mutant_growth_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_experimental_mutant_growth_endpoints_get_mutant_growth_by_gene_with_http_info(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SuccessResponseSchema]:
        """Get mutant growth data for a gene

        Retrieves mutant growth data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with mutant growth data including doubling times, biological replicates, and experimental conditions.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_mutant_growth_endpoints_get_mutant_growth_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_experimental_mutant_growth_endpoints_get_mutant_growth_by_gene_without_preload_content(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get mutant growth data for a gene

        Retrieves mutant growth data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with mutant growth data including doubling times, biological replicates, and experimental conditions.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_mutant_growth_endpoints_get_mutant_growth_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_experimental_mutant_growth_endpoints_get_mutant_growth_by_gene_serialize(
        self,
        locus_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if locus_tag is not None:
            _path_params["locus_tag"] = locus_tag
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = ["RoleBasedJWTAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/{locus_tag}/mutant-growth",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def dataportal_api_experimental_proteomics_endpoints_get_proteomics_by_gene(
        self,
        locus_tag: Annotated[
            StrictStr,
            Field(
                description="Gene locus tag or UniProt ID (e.g., 'BU_ATCC8492_00001')"
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SuccessResponseSchema:
        """Get proteomics evidence for a gene

        Retrieves proteomics evidence data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with all proteomics evidence entries including coverage, unique peptides, unique intensity, and evidence flag.

        :param locus_tag: Gene locus tag or UniProt ID (e.g., 'BU_ATCC8492_00001') (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_proteomics_endpoints_get_proteomics_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_experimental_proteomics_endpoints_get_proteomics_by_gene_with_http_info(
        self,
        locus_tag: Annotated[
            StrictStr,
            Field(
                description="Gene locus tag or UniProt ID (e.g., 'BU_ATCC8492_00001')"
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SuccessResponseSchema]:
        """Get proteomics evidence for a gene

        Retrieves proteomics evidence data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with all proteomics evidence entries including coverage, unique peptides, unique intensity, and evidence flag.

        :param locus_tag: Gene locus tag or UniProt ID (e.g., 'BU_ATCC8492_00001') (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_proteomics_endpoints_get_proteomics_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_experimental_proteomics_endpoints_get_proteomics_by_gene_without_preload_content(
        self,
        locus_tag: Annotated[
            StrictStr,
            Field(
                description="Gene locus tag or UniProt ID (e.g., 'BU_ATCC8492_00001')"
            ),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get proteomics evidence for a gene

        Retrieves proteomics evidence data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with all proteomics evidence entries including coverage, unique peptides, unique intensity, and evidence flag.

        :param locus_tag: Gene locus tag or UniProt ID (e.g., 'BU_ATCC8492_00001') (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_proteomics_endpoints_get_proteomics_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_experimental_proteomics_endpoints_get_proteomics_by_gene_serialize(
        self,
        locus_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if locus_tag is not None:
            _path_params["locus_tag"] = locus_tag
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = ["RoleBasedJWTAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/{locus_tag}/proteomics",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def dataportal_api_experimental_reactions_endpoints_get_reactions_by_gene(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SuccessResponseSchema:
        """Get reactions data for a gene

        Retrieves metabolic reactions data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with reaction identifiers, GPR rules, and metabolites.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_reactions_endpoints_get_reactions_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_experimental_reactions_endpoints_get_reactions_by_gene_with_http_info(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SuccessResponseSchema]:
        """Get reactions data for a gene

        Retrieves metabolic reactions data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with reaction identifiers, GPR rules, and metabolites.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_reactions_endpoints_get_reactions_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_experimental_reactions_endpoints_get_reactions_by_gene_without_preload_content(
        self,
        locus_tag: Annotated[
            StrictStr, Field(description="Gene locus tag or UniProt ID")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get reactions data for a gene

        Retrieves metabolic reactions data for a specific gene using its locus tag or UniProt ID. Returns basic gene information along with reaction identifiers, GPR rules, and metabolites.

        :param locus_tag: Gene locus tag or UniProt ID (required)
        :type locus_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_experimental_reactions_endpoints_get_reactions_by_gene_serialize(
            locus_tag=locus_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_experimental_reactions_endpoints_get_reactions_by_gene_serialize(
        self,
        locus_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if locus_tag is not None:
            _path_params["locus_tag"] = locus_tag
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = ["RoleBasedJWTAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/{locus_tag}/reactions",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def dataportal_api_interactions_fitness_correlation_endpoints_get_gene_correlations(
        self,
        locus_tag: StrictStr,
        species_acronym: Optional[StrictStr] = None,
        min_correlation: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Minimum absolute correlation value"),
        ] = None,
        max_results: Annotated[
            Optional[StrictInt],
            Field(description="Maximum number of results to return"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get correlations for a gene

        Get all genes correlated with a specific gene, ordered by correlation strength

        :param locus_tag: (required)
        :type locus_tag: str
        :param species_acronym:
        :type species_acronym: str
        :param min_correlation: Minimum absolute correlation value
        :type min_correlation: float
        :param max_results: Maximum number of results to return
        :type max_results: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_interactions_fitness_correlation_endpoints_get_gene_correlations_serialize(
            locus_tag=locus_tag,
            species_acronym=species_acronym,
            min_correlation=min_correlation,
            max_results=max_results,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_interactions_fitness_correlation_endpoints_get_gene_correlations_with_http_info(
        self,
        locus_tag: StrictStr,
        species_acronym: Optional[StrictStr] = None,
        min_correlation: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Minimum absolute correlation value"),
        ] = None,
        max_results: Annotated[
            Optional[StrictInt],
            Field(description="Maximum number of results to return"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get correlations for a gene

        Get all genes correlated with a specific gene, ordered by correlation strength

        :param locus_tag: (required)
        :type locus_tag: str
        :param species_acronym:
        :type species_acronym: str
        :param min_correlation: Minimum absolute correlation value
        :type min_correlation: float
        :param max_results: Maximum number of results to return
        :type max_results: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_interactions_fitness_correlation_endpoints_get_gene_correlations_serialize(
            locus_tag=locus_tag,
            species_acronym=species_acronym,
            min_correlation=min_correlation,
            max_results=max_results,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_interactions_fitness_correlation_endpoints_get_gene_correlations_without_preload_content(
        self,
        locus_tag: StrictStr,
        species_acronym: Optional[StrictStr] = None,
        min_correlation: Annotated[
            Optional[Union[StrictFloat, StrictInt]],
            Field(description="Minimum absolute correlation value"),
        ] = None,
        max_results: Annotated[
            Optional[StrictInt],
            Field(description="Maximum number of results to return"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get correlations for a gene

        Get all genes correlated with a specific gene, ordered by correlation strength

        :param locus_tag: (required)
        :type locus_tag: str
        :param species_acronym:
        :type species_acronym: str
        :param min_correlation: Minimum absolute correlation value
        :type min_correlation: float
        :param max_results: Maximum number of results to return
        :type max_results: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_interactions_fitness_correlation_endpoints_get_gene_correlations_serialize(
            locus_tag=locus_tag,
            species_acronym=species_acronym,
            min_correlation=min_correlation,
            max_results=max_results,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_interactions_fitness_correlation_endpoints_get_gene_correlations_serialize(
        self,
        locus_tag,
        species_acronym,
        min_correlation,
        max_results,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if locus_tag is not None:
            _path_params["locus_tag"] = locus_tag
        # process the query parameters
        if species_acronym is not None:
            _query_params.append(("species_acronym", species_acronym))

        if min_correlation is not None:
            _query_params.append(("min_correlation", min_correlation))

        if max_results is not None:
            _query_params.append(("max_results", max_results))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = ["RoleBasedJWTAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/{locus_tag}/correlations",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def dataportal_api_interactions_operon_endpoints_get_gene_operons(
        self,
        locus_tag: StrictStr,
        species_acronym: Annotated[
            Optional[StrictStr], Field(description="Filter by species")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SuccessResponseSchema:
        """Get operons containing a gene

        Get all operons that contain a specific gene

        :param locus_tag: (required)
        :type locus_tag: str
        :param species_acronym: Filter by species
        :type species_acronym: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_interactions_operon_endpoints_get_gene_operons_serialize(
            locus_tag=locus_tag,
            species_acronym=species_acronym,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_interactions_operon_endpoints_get_gene_operons_with_http_info(
        self,
        locus_tag: StrictStr,
        species_acronym: Annotated[
            Optional[StrictStr], Field(description="Filter by species")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SuccessResponseSchema]:
        """Get operons containing a gene

        Get all operons that contain a specific gene

        :param locus_tag: (required)
        :type locus_tag: str
        :param species_acronym: Filter by species
        :type species_acronym: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_interactions_operon_endpoints_get_gene_operons_serialize(
            locus_tag=locus_tag,
            species_acronym=species_acronym,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_interactions_operon_endpoints_get_gene_operons_without_preload_content(
        self,
        locus_tag: StrictStr,
        species_acronym: Annotated[
            Optional[StrictStr], Field(description="Filter by species")
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get operons containing a gene

        Get all operons that contain a specific gene

        :param locus_tag: (required)
        :type locus_tag: str
        :param species_acronym: Filter by species
        :type species_acronym: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_interactions_operon_endpoints_get_gene_operons_serialize(
            locus_tag=locus_tag,
            species_acronym=species_acronym,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_interactions_operon_endpoints_get_gene_operons_serialize(
        self,
        locus_tag,
        species_acronym,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if locus_tag is not None:
            _path_params["locus_tag"] = locus_tag
        # process the query parameters
        if species_acronym is not None:
            _query_params.append(("species_acronym", species_acronym))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = ["RoleBasedJWTAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/{locus_tag}/operons",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def dataportal_api_interactions_ortholog_endpoints_get_gene_orthologs(
        self,
        locus_tag: StrictStr,
        species_acronym: Annotated[
            Optional[StrictStr], Field(description="Filter by target species")
        ] = None,
        orthology_type: Annotated[
            Optional[StrictStr],
            Field(description="Filter by orthology type (1:1, many:1, etc.)"),
        ] = None,
        one_to_one_only: Annotated[
            Optional[StrictBool], Field(description="Return only one-to-one orthologs")
        ] = None,
        cross_species_only: Annotated[
            Optional[StrictBool],
            Field(description="Return only cross-species orthologs"),
        ] = None,
        max_results: Annotated[
            Optional[Annotated[int, Field(le=100000, strict=True)]],
            Field(description="Maximum number of results to return"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SuccessResponseSchema:
        """Get orthologs for a gene

        Get all orthologous genes for a specific gene across species

        :param locus_tag: (required)
        :type locus_tag: str
        :param species_acronym: Filter by target species
        :type species_acronym: str
        :param orthology_type: Filter by orthology type (1:1, many:1, etc.)
        :type orthology_type: str
        :param one_to_one_only: Return only one-to-one orthologs
        :type one_to_one_only: bool
        :param cross_species_only: Return only cross-species orthologs
        :type cross_species_only: bool
        :param max_results: Maximum number of results to return
        :type max_results: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_interactions_ortholog_endpoints_get_gene_orthologs_serialize(
            locus_tag=locus_tag,
            species_acronym=species_acronym,
            orthology_type=orthology_type,
            one_to_one_only=one_to_one_only,
            cross_species_only=cross_species_only,
            max_results=max_results,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def dataportal_api_interactions_ortholog_endpoints_get_gene_orthologs_with_http_info(
        self,
        locus_tag: StrictStr,
        species_acronym: Annotated[
            Optional[StrictStr], Field(description="Filter by target species")
        ] = None,
        orthology_type: Annotated[
            Optional[StrictStr],
            Field(description="Filter by orthology type (1:1, many:1, etc.)"),
        ] = None,
        one_to_one_only: Annotated[
            Optional[StrictBool], Field(description="Return only one-to-one orthologs")
        ] = None,
        cross_species_only: Annotated[
            Optional[StrictBool],
            Field(description="Return only cross-species orthologs"),
        ] = None,
        max_results: Annotated[
            Optional[Annotated[int, Field(le=100000, strict=True)]],
            Field(description="Maximum number of results to return"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SuccessResponseSchema]:
        """Get orthologs for a gene

        Get all orthologous genes for a specific gene across species

        :param locus_tag: (required)
        :type locus_tag: str
        :param species_acronym: Filter by target species
        :type species_acronym: str
        :param orthology_type: Filter by orthology type (1:1, many:1, etc.)
        :type orthology_type: str
        :param one_to_one_only: Return only one-to-one orthologs
        :type one_to_one_only: bool
        :param cross_species_only: Return only cross-species orthologs
        :type cross_species_only: bool
        :param max_results: Maximum number of results to return
        :type max_results: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_interactions_ortholog_endpoints_get_gene_orthologs_serialize(
            locus_tag=locus_tag,
            species_acronym=species_acronym,
            orthology_type=orthology_type,
            one_to_one_only=one_to_one_only,
            cross_species_only=cross_species_only,
            max_results=max_results,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def dataportal_api_interactions_ortholog_endpoints_get_gene_orthologs_without_preload_content(
        self,
        locus_tag: StrictStr,
        species_acronym: Annotated[
            Optional[StrictStr], Field(description="Filter by target species")
        ] = None,
        orthology_type: Annotated[
            Optional[StrictStr],
            Field(description="Filter by orthology type (1:1, many:1, etc.)"),
        ] = None,
        one_to_one_only: Annotated[
            Optional[StrictBool], Field(description="Return only one-to-one orthologs")
        ] = None,
        cross_species_only: Annotated[
            Optional[StrictBool],
            Field(description="Return only cross-species orthologs"),
        ] = None,
        max_results: Annotated[
            Optional[Annotated[int, Field(le=100000, strict=True)]],
            Field(description="Maximum number of results to return"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get orthologs for a gene

        Get all orthologous genes for a specific gene across species

        :param locus_tag: (required)
        :type locus_tag: str
        :param species_acronym: Filter by target species
        :type species_acronym: str
        :param orthology_type: Filter by orthology type (1:1, many:1, etc.)
        :type orthology_type: str
        :param one_to_one_only: Return only one-to-one orthologs
        :type one_to_one_only: bool
        :param cross_species_only: Return only cross-species orthologs
        :type cross_species_only: bool
        :param max_results: Maximum number of results to return
        :type max_results: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._dataportal_api_interactions_ortholog_endpoints_get_gene_orthologs_serialize(
            locus_tag=locus_tag,
            species_acronym=species_acronym,
            orthology_type=orthology_type,
            one_to_one_only=one_to_one_only,
            cross_species_only=cross_species_only,
            max_results=max_results,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "SuccessResponseSchema",
        }
        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _dataportal_api_interactions_ortholog_endpoints_get_gene_orthologs_serialize(
        self,
        locus_tag,
        species_acronym,
        orthology_type,
        one_to_one_only,
        cross_species_only,
        max_results,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:
        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if locus_tag is not None:
            _path_params["locus_tag"] = locus_tag
        # process the query parameters
        if species_acronym is not None:
            _query_params.append(("species_acronym", species_acronym))

        if orthology_type is not None:
            _query_params.append(("orthology_type", orthology_type))

        if one_to_one_only is not None:
            _query_params.append(("one_to_one_only", one_to_one_only))

        if cross_species_only is not None:
            _query_params.append(("cross_species_only", cross_species_only))

        if max_results is not None:
            _query_params.append(("max_results", max_results))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = ["RoleBasedJWTAuth"]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/genes/{locus_tag}/orthologs",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
